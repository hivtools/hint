/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/axios */ \"./node_modules/axios/lib/axios.js\");\n\n//# sourceURL=webpack:///./node_modules/axios/index.js?");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nvar settle = __webpack_require__(/*! ./../core/settle */ \"./node_modules/axios/lib/core/settle.js\");\n\nvar buildURL = __webpack_require__(/*! ./../helpers/buildURL */ \"./node_modules/axios/lib/helpers/buildURL.js\");\n\nvar parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ \"./node_modules/axios/lib/helpers/parseHeaders.js\");\n\nvar isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ \"./node_modules/axios/lib/helpers/isURLSameOrigin.js\");\n\nvar createError = __webpack_require__(/*! ../core/createError */ \"./node_modules/axios/lib/core/createError.js\");\n\nvar btoa = typeof window !== 'undefined' && window.btoa && window.btoa.bind(window) || __webpack_require__(/*! ./../helpers/btoa */ \"./node_modules/axios/lib/helpers/btoa.js\");\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n    var loadEvent = 'onreadystatechange';\n    var xDomain = false; // For IE 8/9 CORS support\n    // Only supports POST and GET calls and doesn't returns the response headers.\n    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.\n\n    if ( true && typeof window !== 'undefined' && window.XDomainRequest && !('withCredentials' in request) && !isURLSameOrigin(config.url)) {\n      request = new window.XDomainRequest();\n      loadEvent = 'onload';\n      xDomain = true;\n\n      request.onprogress = function handleProgress() {};\n\n      request.ontimeout = function handleTimeout() {};\n    } // HTTP basic authentication\n\n\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true); // Set the request timeout in MS\n\n    request.timeout = config.timeout; // Listen for ready state\n\n    request[loadEvent] = function handleLoad() {\n      if (!request || request.readyState !== 4 && !xDomain) {\n        return;\n      } // The request errored out and we didn't get a response, this will be\n      // handled by onerror instead\n      // With one exception: request that using file: protocol, most browsers\n      // will return status as 0 even though it's a successful request\n\n\n      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n        return;\n      } // Prepare the response\n\n\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        // IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201)\n        status: request.status === 1223 ? 204 : request.status,\n        statusText: request.status === 1223 ? 'No Content' : request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n      settle(resolve, reject, response); // Clean up request\n\n      request = null;\n    }; // Handle low level network errors\n\n\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request)); // Clean up request\n\n      request = null;\n    }; // Handle timeout\n\n\n    request.ontimeout = function handleTimeout() {\n      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', request)); // Clean up request\n\n      request = null;\n    }; // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n\n\n    if (utils.isStandardBrowserEnv()) {\n      var cookies = __webpack_require__(/*! ./../helpers/cookies */ \"./node_modules/axios/lib/helpers/cookies.js\"); // Add xsrf header\n\n\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    } // Add headers to the request\n\n\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    } // Add withCredentials to request if needed\n\n\n    if (config.withCredentials) {\n      request.withCredentials = true;\n    } // Add responseType to request if needed\n\n\n    if (config.responseType) {\n      try {\n        request.responseType = config.responseType;\n      } catch (e) {\n        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.\n        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.\n        if (config.responseType !== 'json') {\n          throw e;\n        }\n      }\n    } // Handle progress if needed\n\n\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    } // Not all browsers support upload events\n\n\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel); // Clean up request\n\n        request = null;\n      });\n    }\n\n    if (requestData === undefined) {\n      requestData = null;\n    } // Send the request\n\n\n    request.send(requestData);\n  });\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/adapters/xhr.js?");

/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/axios/lib/utils.js\");\n\nvar bind = __webpack_require__(/*! ./helpers/bind */ \"./node_modules/axios/lib/helpers/bind.js\");\n\nvar Axios = __webpack_require__(/*! ./core/Axios */ \"./node_modules/axios/lib/core/Axios.js\");\n\nvar defaults = __webpack_require__(/*! ./defaults */ \"./node_modules/axios/lib/defaults.js\");\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\n\n\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context); // Copy axios.prototype to instance\n\n  utils.extend(instance, Axios.prototype, context); // Copy context to instance\n\n  utils.extend(instance, context);\n  return instance;\n} // Create the default instance to be exported\n\n\nvar axios = createInstance(defaults); // Expose Axios class to allow class inheritance\n\naxios.Axios = Axios; // Factory for creating new instances\n\naxios.create = function create(instanceConfig) {\n  return createInstance(utils.merge(defaults, instanceConfig));\n}; // Expose Cancel & CancelToken\n\n\naxios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ \"./node_modules/axios/lib/cancel/Cancel.js\");\naxios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ \"./node_modules/axios/lib/cancel/CancelToken.js\");\naxios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ \"./node_modules/axios/lib/cancel/isCancel.js\"); // Expose all/spread\n\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\n\naxios.spread = __webpack_require__(/*! ./helpers/spread */ \"./node_modules/axios/lib/helpers/spread.js\");\nmodule.exports = axios; // Allow use of default import syntax in TypeScript\n\nmodule.exports[\"default\"] = axios;\n\n//# sourceURL=webpack:///./node_modules/axios/lib/axios.js?");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\n\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\nmodule.exports = Cancel;\n\n//# sourceURL=webpack:///./node_modules/axios/lib/cancel/Cancel.js?");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Cancel = __webpack_require__(/*! ./Cancel */ \"./node_modules/axios/lib/cancel/Cancel.js\");\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\n\n\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\n\n\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\n\n\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n\n//# sourceURL=webpack:///./node_modules/axios/lib/cancel/CancelToken.js?");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/cancel/isCancel.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar defaults = __webpack_require__(/*! ./../defaults */ \"./node_modules/axios/lib/defaults.js\");\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nvar InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ \"./node_modules/axios/lib/core/InterceptorManager.js\");\n\nvar dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ \"./node_modules/axios/lib/core/dispatchRequest.js\");\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\n\n\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\n\n\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = utils.merge({\n      url: arguments[0]\n    }, arguments[1]);\n  }\n\n  config = utils.merge(defaults, {\n    method: 'get'\n  }, this.defaults, config);\n  config.method = config.method.toLowerCase(); // Hook up interceptors middleware\n\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n}; // Provide aliases for supported request methods\n\n\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function (url, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url\n    }));\n  };\n});\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function (url, data, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\nmodule.exports = Axios;\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/Axios.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\n\n\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\n\n\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\n\n\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/InterceptorManager.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar enhanceError = __webpack_require__(/*! ./enhanceError */ \"./node_modules/axios/lib/core/enhanceError.js\");\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\n\n\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/createError.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nvar transformData = __webpack_require__(/*! ./transformData */ \"./node_modules/axios/lib/core/transformData.js\");\n\nvar isCancel = __webpack_require__(/*! ../cancel/isCancel */ \"./node_modules/axios/lib/cancel/isCancel.js\");\n\nvar defaults = __webpack_require__(/*! ../defaults */ \"./node_modules/axios/lib/defaults.js\");\n\nvar isAbsoluteURL = __webpack_require__(/*! ./../helpers/isAbsoluteURL */ \"./node_modules/axios/lib/helpers/isAbsoluteURL.js\");\n\nvar combineURLs = __webpack_require__(/*! ./../helpers/combineURLs */ \"./node_modules/axios/lib/helpers/combineURLs.js\");\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\n\n\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\n\n\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config); // Support baseURL config\n\n  if (config.baseURL && !isAbsoluteURL(config.url)) {\n    config.url = combineURLs(config.baseURL, config.url);\n  } // Ensure headers exist\n\n\n  config.headers = config.headers || {}; // Transform request data\n\n  config.data = transformData(config.data, config.headers, config.transformRequest); // Flatten headers\n\n  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers || {});\n  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {\n    delete config.headers[method];\n  });\n  var adapter = config.adapter || defaults.adapter;\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config); // Transform response data\n\n    response.data = transformData(response.data, response.headers, config.transformResponse);\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config); // Transform response data\n\n      if (reason && reason.response) {\n        reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/dispatchRequest.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\n\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n\n  if (code) {\n    error.code = code;\n  }\n\n  error.request = request;\n  error.response = response;\n  return error;\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/enhanceError.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar createError = __webpack_require__(/*! ./createError */ \"./node_modules/axios/lib/core/createError.js\");\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\n\n\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus; // Note: status is not exposed by XDomainRequest\n\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/settle.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\n\n\nmodule.exports = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n  return data;\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/transformData.js?");

/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/axios/lib/utils.js\");\n\nvar normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ \"./node_modules/axios/lib/helpers/normalizeHeaderName.js\");\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = __webpack_require__(/*! ./adapters/xhr */ \"./node_modules/axios/lib/adapters/xhr.js\");\n  } else if (typeof process !== 'undefined') {\n    // For node use HTTP adapter\n    adapter = __webpack_require__(/*! ./adapters/http */ \"./node_modules/axios/lib/adapters/xhr.js\");\n  }\n\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Content-Type');\n\n    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {\n      return data;\n    }\n\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n\n    if (utils.isObject(data)) {\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return JSON.stringify(data);\n    }\n\n    return data;\n  }],\n  transformResponse: [function transformResponse(data) {\n    /*eslint no-param-reassign:0*/\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (e) {\n        /* Ignore */\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n  maxContentLength: -1,\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\nmodule.exports = defaults;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/axios/lib/defaults.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    return fn.apply(thisArg, args);\n  };\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/bind.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/btoa.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/btoa.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js\n\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfunction E() {\n  this.message = 'String contains an invalid character';\n}\n\nE.prototype = new Error();\nE.prototype.code = 5;\nE.prototype.name = 'InvalidCharacterError';\n\nfunction btoa(input) {\n  var str = String(input);\n  var output = '';\n\n  for ( // initialize result and counter\n  var block, charCode, idx = 0, map = chars; // if the next str index does not exist:\n  //   change the mapping table to \"=\"\n  //   check if d has no fractional digits\n  str.charAt(idx | 0) || (map = '=', idx % 1); // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n  output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {\n    charCode = str.charCodeAt(idx += 3 / 4);\n\n    if (charCode > 0xFF) {\n      throw new E();\n    }\n\n    block = block << 8 | charCode;\n  }\n\n  return output;\n}\n\nmodule.exports = btoa;\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/btoa.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nfunction encode(val) {\n  return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');\n}\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\n\n\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/buildURL.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\n\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '') : baseURL;\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/combineURLs.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie\nfunction standardBrowserEnv() {\n  return {\n    write: function write(name, value, expires, path, domain, secure) {\n      var cookie = [];\n      cookie.push(name + '=' + encodeURIComponent(value));\n\n      if (utils.isNumber(expires)) {\n        cookie.push('expires=' + new Date(expires).toGMTString());\n      }\n\n      if (utils.isString(path)) {\n        cookie.push('path=' + path);\n      }\n\n      if (utils.isString(domain)) {\n        cookie.push('domain=' + domain);\n      }\n\n      if (secure === true) {\n        cookie.push('secure');\n      }\n\n      document.cookie = cookie.join('; ');\n    },\n    read: function read(name) {\n      var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n      return match ? decodeURIComponent(match[3]) : null;\n    },\n    remove: function remove(name) {\n      this.write(name, '', Date.now() - 86400000);\n    }\n  };\n}() : // Non standard browser env (web workers, react-native) lack needed support.\nfunction nonStandardBrowserEnv() {\n  return {\n    write: function write() {},\n    read: function read() {\n      return null;\n    },\n    remove: function remove() {}\n  };\n}();\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/cookies.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\n\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/isAbsoluteURL.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test\n// whether the request URL is of the same origin as current location.\nfunction standardBrowserEnv() {\n  var msie = /(msie|trident)/i.test(navigator.userAgent);\n  var urlParsingNode = document.createElement('a');\n  var originURL;\n  /**\n  * Parse a URL to discover it's components\n  *\n  * @param {String} url The URL to be parsed\n  * @returns {Object}\n  */\n\n  function resolveURL(url) {\n    var href = url;\n\n    if (msie) {\n      // IE needs attribute set twice to normalize properties\n      urlParsingNode.setAttribute('href', href);\n      href = urlParsingNode.href;\n    }\n\n    urlParsingNode.setAttribute('href', href); // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n\n    return {\n      href: urlParsingNode.href,\n      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n      host: urlParsingNode.host,\n      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n      hostname: urlParsingNode.hostname,\n      port: urlParsingNode.port,\n      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname\n    };\n  }\n\n  originURL = resolveURL(window.location.href);\n  /**\n  * Determine if a URL shares the same origin as the current location\n  *\n  * @param {String} requestURL The URL to test\n  * @returns {boolean} True if URL shares the same origin, otherwise false\n  */\n\n  return function isURLSameOrigin(requestURL) {\n    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;\n    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;\n  };\n}() : // Non standard browser envs (web workers, react-native) lack needed support.\nfunction nonStandardBrowserEnv() {\n  return function isURLSameOrigin() {\n    return true;\n  };\n}();\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/isURLSameOrigin.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/normalizeHeaderName.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\"); // Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\n\n\nvar ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\n\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) {\n    return parsed;\n  }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n  return parsed;\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/parseHeaders.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\n\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/spread.js?");

/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar bind = __webpack_require__(/*! ./helpers/bind */ \"./node_modules/axios/lib/helpers/bind.js\");\n\nvar isBuffer = __webpack_require__(/*! is-buffer */ \"./node_modules/is-buffer/index.js\");\n/*global toString:true*/\n// utils is a library of generic helper functions non-specific to axios\n\n\nvar toString = Object.prototype.toString;\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\n\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\n\n\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\n\n\nfunction isFormData(val) {\n  return typeof FormData !== 'undefined' && val instanceof FormData;\n}\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\n\n\nfunction isArrayBufferView(val) {\n  var result;\n\n  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = val && val.buffer && val.buffer instanceof ArrayBuffer;\n  }\n\n  return result;\n}\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\n\n\nfunction isString(val) {\n  return typeof val === 'string';\n}\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\n\n\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\n\n\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\n\n\nfunction isObject(val) {\n  return val !== null && _typeof(val) === 'object';\n}\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\n\n\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\n\n\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\n\n\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\n\n\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\n\n\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\n\n\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\n\n\nfunction trim(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n}\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n */\n\n\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    return false;\n  }\n\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\n\n\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  } // Force an array if not already something iterable\n\n\n  if (_typeof(obj) !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\n\n\nfunction merge()\n/* obj1, obj2, obj3, ... */\n{\n  var result = {};\n\n  function assignValue(val, key) {\n    if (_typeof(result[key]) === 'object' && _typeof(val) === 'object') {\n      result[key] = merge(result[key], val);\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n\n  return result;\n}\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\n\n\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim\n};\n\n//# sourceURL=webpack:///./node_modules/axios/lib/utils.js?");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?!./node_modules/ify-loader/index.js!./node_modules/vue-loader/lib/index.js?!./src/js/components/inputs.vue?vue&type=script&lang=js&":
/*!***********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib??ref--1!./node_modules/ify-loader!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/inputs.vue?vue&type=script&lang=js& ***!
  \***********************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'model-inputs',\n  data: function data() {\n    return {\n      error: \"\",\n      a: 20,\n      b: 3,\n      time: 1,\n      poll: 100,\n      valid: false\n    };\n  },\n  methods: {\n    validate: function validate(e) {\n      var _this = this;\n\n      e.preventDefault();\n      var inputs = {\n        \"parameters\": this.$data,\n        \"csv_data\": [\"a,b\", \"1,2\", \"2,3\", \"3,4\"]\n      };\n      var jsonString = \"modelJson=\" + JSON.stringify(inputs);\n      axios__WEBPACK_IMPORTED_MODULE_0___default.a.post(\"/validate\", jsonString).then(function (result) {\n        if (result.data.success) {\n          _this.$emit('validated', jsonString);\n\n          _this.error = \"\";\n          _this.valid = true;\n        } else {\n          _this.error = result.data.error;\n          _this.valid = false;\n        }\n      })[\"catch\"](function () {\n        _this.error = \"Error validating inputs\";\n        _this.valid = false;\n      });\n    }\n  }\n});\n\n//# sourceURL=webpack:///./src/js/components/inputs.vue?./node_modules/babel-loader/lib??ref--1!./node_modules/ify-loader!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?!./node_modules/ify-loader/index.js!./node_modules/vue-loader/lib/index.js?!./src/js/components/plotly.vue?vue&type=script&lang=js&":
/*!***********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib??ref--1!./node_modules/ify-loader!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/plotly.vue?vue&type=script&lang=js& ***!
  \***********************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var plotly_js_dist_plotly_basic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! plotly.js/dist/plotly-basic */ \"./node_modules/plotly.js/dist/plotly-basic.js\");\n/* harmony import */ var plotly_js_dist_plotly_basic__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(plotly_js_dist_plotly_basic__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/debounce */ \"./node_modules/lodash/debounce.js\");\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lodash_defaults__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/defaults */ \"./node_modules/lodash/defaults.js\");\n/* harmony import */ var lodash_defaults__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_defaults__WEBPACK_IMPORTED_MODULE_2__);\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n//\n//\n//\n//\n\n\n\nvar events = ['click', 'hover', 'unhover', 'selecting', 'selected', 'restyle', 'relayout', 'autosize', 'deselect', 'doubleclick', 'redraw', 'animated', 'afterplot'];\nvar functions = ['restyle', 'relayout', 'update', 'addTraces', 'deleteTraces', 'moveTraces', 'extendTraces', 'prependTraces', 'purge'];\nvar methods = functions.reduce(function (all, funcName) {\n  all[funcName] = function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return plotly_js_dist_plotly_basic__WEBPACK_IMPORTED_MODULE_0___default.a[funcName].apply(plotly_js_dist_plotly_basic__WEBPACK_IMPORTED_MODULE_0___default.a, [this.$refs.container].concat(args));\n  };\n\n  return all;\n}, {});\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  props: {\n    autoResize: Boolean,\n    watchShallow: false,\n    options: {\n      type: Object\n    },\n    data: {\n      type: Array\n    },\n    layout: {\n      type: Object\n    }\n  },\n  data: function data() {\n    return {\n      internalLayout: _objectSpread({}, this.layout, {\n        datarevision: 1\n      })\n    };\n  },\n  mounted: function mounted() {\n    var _this = this;\n\n    this.react();\n    this.initEvents();\n    this.$watch('data', function () {\n      _this.internalLayout.datarevision++;\n\n      _this.react();\n    }, {\n      deep: !this.watchShallow\n    });\n    this.$watch('options', this.react, {\n      deep: !this.watchShallow\n    });\n    this.$watch('layout', this.relayout, {\n      deep: !this.watchShallow\n    });\n  },\n  beforeDestroy: function beforeDestroy() {\n    var _this2 = this;\n\n    window.removeEventListener('resize', this.__resizeListener);\n\n    this.__generalListeners.forEach(function (obj) {\n      return _this2.$refs.container.removeAllListeners(obj.fullName);\n    });\n\n    plotly_js_dist_plotly_basic__WEBPACK_IMPORTED_MODULE_0___default.a.purge(this.$refs.container);\n  },\n  methods: _objectSpread({\n    initEvents: function initEvents() {\n      var _this3 = this;\n\n      if (this.autoResize) {\n        this.__resizeListener = function () {\n          _this3.internalLayout.datarevision++;\n          lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default()(_this3.react, 200);\n        };\n\n        window.addEventListener('resize', this.__resizeListener);\n      }\n\n      this.__generalListeners = events.map(function (eventName) {\n        return {\n          fullName: 'plotly_' + eventName,\n          handler: function handler() {\n            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              args[_key2] = arguments[_key2];\n            }\n\n            _this3.$emit.apply(_this3, [eventName].concat(args));\n          }\n        };\n      });\n\n      this.__generalListeners.forEach(function (obj) {\n        _this3.$refs.container.on(obj.fullName, obj.handler);\n      });\n    }\n  }, methods, {\n    toImage: function toImage(options) {\n      var el = this.$refs.container;\n      var opts = lodash_defaults__WEBPACK_IMPORTED_MODULE_2___default()(options, {\n        format: 'png',\n        width: el.clientWidth,\n        height: el.clientHeight\n      });\n      return plotly_js_dist_plotly_basic__WEBPACK_IMPORTED_MODULE_0___default.a.toImage(this.$refs.container, opts);\n    },\n    downloadImage: function downloadImage(options) {\n      var el = this.$refs.container;\n      var opts = lodash_defaults__WEBPACK_IMPORTED_MODULE_2___default()(options, {\n        format: 'png',\n        width: el.clientWidth,\n        height: el.clientHeight,\n        filename: (el.layout.title || 'plot') + ' - ' + new Date().toISOString()\n      });\n      return plotly_js_dist_plotly_basic__WEBPACK_IMPORTED_MODULE_0___default.a.downloadImage(this.$refs.container, opts);\n    },\n    plot: function plot() {\n      return plotly_js_dist_plotly_basic__WEBPACK_IMPORTED_MODULE_0___default.a.plot(this.$refs.container, this.data, this.internalLayout, this.getOptions());\n    },\n    getOptions: function getOptions() {\n      var el = this.$refs.container;\n      var opts = this.options; // if width/height is not specified for toImageButton, default to el.clientWidth/clientHeight\n\n      if (!opts) opts = {};\n      if (!opts.toImageButtonOptions) opts.toImageButtonOptions = {};\n      if (!opts.toImageButtonOptions.width) opts.toImageButtonOptions.width = el.clientWidth;\n      if (!opts.toImageButtonOptions.height) opts.toImageButtonOptions.height = el.clientHeight;\n      return opts;\n    },\n    newPlot: function newPlot() {\n      return plotly_js_dist_plotly_basic__WEBPACK_IMPORTED_MODULE_0___default.a.newPlot(this.$refs.container, this.data, this.internalLayout, this.getOptions());\n    },\n    react: function react() {\n      return plotly_js_dist_plotly_basic__WEBPACK_IMPORTED_MODULE_0___default.a.react(this.$refs.container, this.data, this.internalLayout, this.getOptions());\n    }\n  })\n});\n\n//# sourceURL=webpack:///./src/js/components/plotly.vue?./node_modules/babel-loader/lib??ref--1!./node_modules/ify-loader!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?!./node_modules/ify-loader/index.js!./node_modules/vue-loader/lib/index.js?!./src/js/components/results.vue?vue&type=script&lang=js&":
/*!************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib??ref--1!./node_modules/ify-loader!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/results.vue?vue&type=script&lang=js& ***!
  \************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _plotly_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plotly.vue */ \"./src/js/components/plotly.vue\");\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'results',\n  props: ['runId', 'finished', 'success'],\n  components: {\n    VuePlotly: _plotly_vue__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n  },\n  data: function data() {\n    return {\n      fitted: {},\n      simulation: []\n    };\n  },\n  methods: {\n    getResult: function getResult() {\n      var _this = this;\n\n      axios__WEBPACK_IMPORTED_MODULE_0___default.a.get(\"/result/\".concat(this.runId)).then(function (result) {\n        _this.fitted = result.data.fitted;\n        _this.simulation = result.data.simulation;\n      })[\"catch\"](function () {\n        _this.error = \"Error querying result\";\n      });\n    }\n  },\n  watch: {\n    finished: function finished(newVal) {\n      if (newVal && this.success) {\n        this.getResult();\n      }\n    },\n    success: function success(newVal) {\n      if (newVal && this.finished) {\n        this.getResult();\n      }\n    }\n  }\n});\n\n//# sourceURL=webpack:///./src/js/components/results.vue?./node_modules/babel-loader/lib??ref--1!./node_modules/ify-loader!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?!./node_modules/ify-loader/index.js!./node_modules/vue-loader/lib/index.js?!./src/js/components/runner.vue?vue&type=script&lang=js&":
/*!***********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib??ref--1!./node_modules/ify-loader!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/runner.vue?vue&type=script&lang=js& ***!
  \***********************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'runner',\n  props: ['running', 'inputs'],\n  data: function data() {\n    return {\n      error: \"\"\n    };\n  },\n  methods: {\n    run: function run() {\n      var _this = this;\n\n      axios__WEBPACK_IMPORTED_MODULE_0___default.a.post(\"/run\", this.inputs).then(function (result) {\n        if (result.data.error) {\n          _this.error = result.data.error;\n        } else {\n          _this.$emit('queued', result.data);\n        }\n      })[\"catch\"](function () {\n        _this.error = \"Error queuing model run\";\n      });\n    }\n  }\n});\n\n//# sourceURL=webpack:///./src/js/components/runner.vue?./node_modules/babel-loader/lib??ref--1!./node_modules/ify-loader!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?!./node_modules/ify-loader/index.js!./node_modules/vue-loader/lib/index.js?!./src/js/components/status.vue?vue&type=script&lang=js&":
/*!***********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib??ref--1!./node_modules/ify-loader!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/status.vue?vue&type=script&lang=js& ***!
  \***********************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _polling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./polling */ \"./src/js/components/polling.js\");\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'status',\n  props: ['runId'],\n  data: function data() {\n    return {\n      interval: null,\n      error: \"\"\n    };\n  },\n  methods: {\n    pollStatus: function pollStatus() {\n      var _this = this;\n\n      axios__WEBPACK_IMPORTED_MODULE_0___default.a.get(\"/status/\".concat(this.runId)).then(function (result) {\n        if (result.data.done) {\n          Object(_polling__WEBPACK_IMPORTED_MODULE_1__[\"stop\"])(_this.interval);\n          _this.interval = null;\n\n          _this.$emit('finished', result.data.success);\n\n          if (!result.data.success) {\n            _this.error = \"Model run failed\";\n          }\n        }\n      })[\"catch\"](function () {\n        _this.error = \"Error querying run status\";\n      });\n    }\n  },\n  watch: {\n    runId: function runId(newVal) {\n      if (newVal) {\n        this.error = \"\";\n        this.pollStatus();\n        this.interval = Object(_polling__WEBPACK_IMPORTED_MODULE_1__[\"start\"])(this.pollStatus.bind(this));\n      }\n    }\n  }\n});\n\n//# sourceURL=webpack:///./src/js/components/status.vue?./node_modules/babel-loader/lib??ref--1!./node_modules/ify-loader!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/bootstrap/js/dist/tab.js":
/*!***********************************************!*\
  !*** ./node_modules/bootstrap/js/dist/tab.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n  * Bootstrap tab.js v4.3.1 (https://getbootstrap.com/)\n  * Copyright 2011-2019 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n  */\n(function (global, factory) {\n  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory(__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\"), __webpack_require__(/*! ./util.js */ \"./node_modules/bootstrap/js/dist/util.js\")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\"), __webpack_require__(/*! ./util.js */ \"./node_modules/bootstrap/js/dist/util.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);\n})(this, function ($, Util) {\n  'use strict';\n\n  $ = $ && $.hasOwnProperty('default') ? $['default'] : $;\n  Util = Util && Util.hasOwnProperty('default') ? Util['default'] : Util;\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n\n  var NAME = 'tab';\n  var VERSION = '4.3.1';\n  var DATA_KEY = 'bs.tab';\n  var EVENT_KEY = \".\" + DATA_KEY;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var Event = {\n    HIDE: \"hide\" + EVENT_KEY,\n    HIDDEN: \"hidden\" + EVENT_KEY,\n    SHOW: \"show\" + EVENT_KEY,\n    SHOWN: \"shown\" + EVENT_KEY,\n    CLICK_DATA_API: \"click\" + EVENT_KEY + DATA_API_KEY\n  };\n  var ClassName = {\n    DROPDOWN_MENU: 'dropdown-menu',\n    ACTIVE: 'active',\n    DISABLED: 'disabled',\n    FADE: 'fade',\n    SHOW: 'show'\n  };\n  var Selector = {\n    DROPDOWN: '.dropdown',\n    NAV_LIST_GROUP: '.nav, .list-group',\n    ACTIVE: '.active',\n    ACTIVE_UL: '> li > .active',\n    DATA_TOGGLE: '[data-toggle=\"tab\"], [data-toggle=\"pill\"], [data-toggle=\"list\"]',\n    DROPDOWN_TOGGLE: '.dropdown-toggle',\n    DROPDOWN_ACTIVE_CHILD: '> .dropdown-menu .active'\n    /**\n     * ------------------------------------------------------------------------\n     * Class Definition\n     * ------------------------------------------------------------------------\n     */\n\n  };\n\n  var Tab =\n  /*#__PURE__*/\n  function () {\n    function Tab(element) {\n      this._element = element;\n    } // Getters\n\n\n    var _proto = Tab.prototype; // Public\n\n    _proto.show = function show() {\n      var _this = this;\n\n      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $(this._element).hasClass(ClassName.ACTIVE) || $(this._element).hasClass(ClassName.DISABLED)) {\n        return;\n      }\n\n      var target;\n      var previous;\n      var listElement = $(this._element).closest(Selector.NAV_LIST_GROUP)[0];\n      var selector = Util.getSelectorFromElement(this._element);\n\n      if (listElement) {\n        var itemSelector = listElement.nodeName === 'UL' || listElement.nodeName === 'OL' ? Selector.ACTIVE_UL : Selector.ACTIVE;\n        previous = $.makeArray($(listElement).find(itemSelector));\n        previous = previous[previous.length - 1];\n      }\n\n      var hideEvent = $.Event(Event.HIDE, {\n        relatedTarget: this._element\n      });\n      var showEvent = $.Event(Event.SHOW, {\n        relatedTarget: previous\n      });\n\n      if (previous) {\n        $(previous).trigger(hideEvent);\n      }\n\n      $(this._element).trigger(showEvent);\n\n      if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      if (selector) {\n        target = document.querySelector(selector);\n      }\n\n      this._activate(this._element, listElement);\n\n      var complete = function complete() {\n        var hiddenEvent = $.Event(Event.HIDDEN, {\n          relatedTarget: _this._element\n        });\n        var shownEvent = $.Event(Event.SHOWN, {\n          relatedTarget: previous\n        });\n        $(previous).trigger(hiddenEvent);\n        $(_this._element).trigger(shownEvent);\n      };\n\n      if (target) {\n        this._activate(target, target.parentNode, complete);\n      } else {\n        complete();\n      }\n    };\n\n    _proto.dispose = function dispose() {\n      $.removeData(this._element, DATA_KEY);\n      this._element = null;\n    } // Private\n    ;\n\n    _proto._activate = function _activate(element, container, callback) {\n      var _this2 = this;\n\n      var activeElements = container && (container.nodeName === 'UL' || container.nodeName === 'OL') ? $(container).find(Selector.ACTIVE_UL) : $(container).children(Selector.ACTIVE);\n      var active = activeElements[0];\n      var isTransitioning = callback && active && $(active).hasClass(ClassName.FADE);\n\n      var complete = function complete() {\n        return _this2._transitionComplete(element, active, callback);\n      };\n\n      if (active && isTransitioning) {\n        var transitionDuration = Util.getTransitionDurationFromElement(active);\n        $(active).removeClass(ClassName.SHOW).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n    };\n\n    _proto._transitionComplete = function _transitionComplete(element, active, callback) {\n      if (active) {\n        $(active).removeClass(ClassName.ACTIVE);\n        var dropdownChild = $(active.parentNode).find(Selector.DROPDOWN_ACTIVE_CHILD)[0];\n\n        if (dropdownChild) {\n          $(dropdownChild).removeClass(ClassName.ACTIVE);\n        }\n\n        if (active.getAttribute('role') === 'tab') {\n          active.setAttribute('aria-selected', false);\n        }\n      }\n\n      $(element).addClass(ClassName.ACTIVE);\n\n      if (element.getAttribute('role') === 'tab') {\n        element.setAttribute('aria-selected', true);\n      }\n\n      Util.reflow(element);\n\n      if (element.classList.contains(ClassName.FADE)) {\n        element.classList.add(ClassName.SHOW);\n      }\n\n      if (element.parentNode && $(element.parentNode).hasClass(ClassName.DROPDOWN_MENU)) {\n        var dropdownElement = $(element).closest(Selector.DROPDOWN)[0];\n\n        if (dropdownElement) {\n          var dropdownToggleList = [].slice.call(dropdownElement.querySelectorAll(Selector.DROPDOWN_TOGGLE));\n          $(dropdownToggleList).addClass(ClassName.ACTIVE);\n        }\n\n        element.setAttribute('aria-expanded', true);\n      }\n\n      if (callback) {\n        callback();\n      }\n    } // Static\n    ;\n\n    Tab._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $this = $(this);\n        var data = $this.data(DATA_KEY);\n\n        if (!data) {\n          data = new Tab(this);\n          $this.data(DATA_KEY, data);\n        }\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Tab, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION;\n      }\n    }]);\n\n    return Tab;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n\n  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {\n    event.preventDefault();\n\n    Tab._jQueryInterface.call($(this), 'show');\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $.fn[NAME] = Tab._jQueryInterface;\n  $.fn[NAME].Constructor = Tab;\n\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Tab._jQueryInterface;\n  };\n\n  return Tab;\n});\n\n//# sourceURL=webpack:///./node_modules/bootstrap/js/dist/tab.js?");

/***/ }),

/***/ "./node_modules/bootstrap/js/dist/util.js":
/*!************************************************!*\
  !*** ./node_modules/bootstrap/js/dist/util.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n  * Bootstrap util.js v4.3.1 (https://getbootstrap.com/)\n  * Copyright 2011-2019 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n  */\n(function (global, factory) {\n  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory(__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);\n})(this, function ($) {\n  'use strict';\n\n  $ = $ && $.hasOwnProperty('default') ? $['default'] : $;\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v4.3.1): util.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n\n  /**\n   * ------------------------------------------------------------------------\n   * Private TransitionEnd Helpers\n   * ------------------------------------------------------------------------\n   */\n\n  var TRANSITION_END = 'transitionend';\n  var MAX_UID = 1000000;\n  var MILLISECONDS_MULTIPLIER = 1000; // Shoutout AngusCroll (https://goo.gl/pxwQGp)\n\n  function toType(obj) {\n    return {}.toString.call(obj).match(/\\s([a-z]+)/i)[1].toLowerCase();\n  }\n\n  function getSpecialTransitionEndEvent() {\n    return {\n      bindType: TRANSITION_END,\n      delegateType: TRANSITION_END,\n      handle: function handle(event) {\n        if ($(event.target).is(this)) {\n          return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params\n        }\n\n        return undefined; // eslint-disable-line no-undefined\n      }\n    };\n  }\n\n  function transitionEndEmulator(duration) {\n    var _this = this;\n\n    var called = false;\n    $(this).one(Util.TRANSITION_END, function () {\n      called = true;\n    });\n    setTimeout(function () {\n      if (!called) {\n        Util.triggerTransitionEnd(_this);\n      }\n    }, duration);\n    return this;\n  }\n\n  function setTransitionEndSupport() {\n    $.fn.emulateTransitionEnd = transitionEndEmulator;\n    $.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();\n  }\n  /**\n   * --------------------------------------------------------------------------\n   * Public Util Api\n   * --------------------------------------------------------------------------\n   */\n\n\n  var Util = {\n    TRANSITION_END: 'bsTransitionEnd',\n    getUID: function getUID(prefix) {\n      do {\n        // eslint-disable-next-line no-bitwise\n        prefix += ~~(Math.random() * MAX_UID); // \"~~\" acts like a faster Math.floor() here\n      } while (document.getElementById(prefix));\n\n      return prefix;\n    },\n    getSelectorFromElement: function getSelectorFromElement(element) {\n      var selector = element.getAttribute('data-target');\n\n      if (!selector || selector === '#') {\n        var hrefAttr = element.getAttribute('href');\n        selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : '';\n      }\n\n      try {\n        return document.querySelector(selector) ? selector : null;\n      } catch (err) {\n        return null;\n      }\n    },\n    getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {\n      if (!element) {\n        return 0;\n      } // Get transition-duration of the element\n\n\n      var transitionDuration = $(element).css('transition-duration');\n      var transitionDelay = $(element).css('transition-delay');\n      var floatTransitionDuration = parseFloat(transitionDuration);\n      var floatTransitionDelay = parseFloat(transitionDelay); // Return 0 if element or transition duration is not found\n\n      if (!floatTransitionDuration && !floatTransitionDelay) {\n        return 0;\n      } // If multiple durations are defined, take the first\n\n\n      transitionDuration = transitionDuration.split(',')[0];\n      transitionDelay = transitionDelay.split(',')[0];\n      return (parseFloat(transitionDuration) + parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;\n    },\n    reflow: function reflow(element) {\n      return element.offsetHeight;\n    },\n    triggerTransitionEnd: function triggerTransitionEnd(element) {\n      $(element).trigger(TRANSITION_END);\n    },\n    // TODO: Remove in v5\n    supportsTransitionEnd: function supportsTransitionEnd() {\n      return Boolean(TRANSITION_END);\n    },\n    isElement: function isElement(obj) {\n      return (obj[0] || obj).nodeType;\n    },\n    typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {\n      for (var property in configTypes) {\n        if (Object.prototype.hasOwnProperty.call(configTypes, property)) {\n          var expectedTypes = configTypes[property];\n          var value = config[property];\n          var valueType = value && Util.isElement(value) ? 'element' : toType(value);\n\n          if (!new RegExp(expectedTypes).test(valueType)) {\n            throw new Error(componentName.toUpperCase() + \": \" + (\"Option \\\"\" + property + \"\\\" provided type \\\"\" + valueType + \"\\\" \") + (\"but expected type \\\"\" + expectedTypes + \"\\\".\"));\n          }\n        }\n      }\n    },\n    findShadowRoot: function findShadowRoot(element) {\n      if (!document.documentElement.attachShadow) {\n        return null;\n      } // Can find the shadow root otherwise it'll return the document\n\n\n      if (typeof element.getRootNode === 'function') {\n        var root = element.getRootNode();\n        return root instanceof ShadowRoot ? root : null;\n      }\n\n      if (element instanceof ShadowRoot) {\n        return element;\n      } // when we don't find a shadow root\n\n\n      if (!element.parentNode) {\n        return null;\n      }\n\n      return Util.findShadowRoot(element.parentNode);\n    }\n  };\n  setTransitionEndSupport();\n  return Util;\n});\n\n//# sourceURL=webpack:///./node_modules/bootstrap/js/dist/util.js?");

/***/ }),

/***/ "./node_modules/is-buffer/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-buffer/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);\n};\n\nfunction isBuffer(obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);\n} // For Node v0.10 support. Remove this eventually.\n\n\nfunction isSlowBuffer(obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));\n}\n\n//# sourceURL=webpack:///./node_modules/is-buffer/index.js?");

/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n * jQuery JavaScript Library v3.4.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2019-05-01T21:04Z\n */\n(function (global, factory) {\n  \"use strict\";\n\n  if (( false ? undefined : _typeof(module)) === \"object\" && _typeof(module.exports) === \"object\") {\n    // For CommonJS and CommonJS-like environments where a proper `window`\n    // is present, execute the factory and get jQuery.\n    // For environments that do not have a `window` with a `document`\n    // (such as Node.js), expose a factory as module.exports.\n    // This accentuates the need for the creation of a real `window`.\n    // e.g. var jQuery = require(\"jquery\")(window);\n    // See ticket #14549 for more info.\n    module.exports = global.document ? factory(global, true) : function (w) {\n      if (!w.document) {\n        throw new Error(\"jQuery requires a window with a document\");\n      }\n\n      return factory(w);\n    };\n  } else {\n    factory(global);\n  } // Pass this if window is not defined yet\n\n})(typeof window !== \"undefined\" ? window : this, function (window, noGlobal) {\n  // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n  // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n  // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n  // enough that all such attempts are guarded in a try block.\n  \"use strict\";\n\n  var arr = [];\n  var document = window.document;\n  var getProto = Object.getPrototypeOf;\n  var _slice = arr.slice;\n  var concat = arr.concat;\n  var push = arr.push;\n  var indexOf = arr.indexOf;\n  var class2type = {};\n  var toString = class2type.toString;\n  var hasOwn = class2type.hasOwnProperty;\n  var fnToString = hasOwn.toString;\n  var ObjectFunctionString = fnToString.call(Object);\n  var support = {};\n\n  var isFunction = function isFunction(obj) {\n    // Support: Chrome <=57, Firefox <=52\n    // In some browsers, typeof returns \"function\" for HTML <object> elements\n    // (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n    // We don't want to classify *any* DOM node as a function.\n    return typeof obj === \"function\" && typeof obj.nodeType !== \"number\";\n  };\n\n  var isWindow = function isWindow(obj) {\n    return obj != null && obj === obj.window;\n  };\n\n  var preservedScriptAttributes = {\n    type: true,\n    src: true,\n    nonce: true,\n    noModule: true\n  };\n\n  function DOMEval(code, node, doc) {\n    doc = doc || document;\n    var i,\n        val,\n        script = doc.createElement(\"script\");\n    script.text = code;\n\n    if (node) {\n      for (i in preservedScriptAttributes) {\n        // Support: Firefox 64+, Edge 18+\n        // Some browsers don't support the \"nonce\" property on scripts.\n        // On the other hand, just using `getAttribute` is not enough as\n        // the `nonce` attribute is reset to an empty string whenever it\n        // becomes browsing-context connected.\n        // See https://github.com/whatwg/html/issues/2369\n        // See https://html.spec.whatwg.org/#nonce-attributes\n        // The `node.getAttribute` check was added for the sake of\n        // `jQuery.globalEval` so that it can fake a nonce-containing node\n        // via an object.\n        val = node[i] || node.getAttribute && node.getAttribute(i);\n\n        if (val) {\n          script.setAttribute(i, val);\n        }\n      }\n    }\n\n    doc.head.appendChild(script).parentNode.removeChild(script);\n  }\n\n  function toType(obj) {\n    if (obj == null) {\n      return obj + \"\";\n    } // Support: Android <=2.3 only (functionish RegExp)\n\n\n    return _typeof(obj) === \"object\" || typeof obj === \"function\" ? class2type[toString.call(obj)] || \"object\" : _typeof(obj);\n  }\n  /* global Symbol */\n  // Defining this global in .eslintrc.json would create a danger of using the global\n  // unguarded in another place, it seems safer to define global only for this module\n\n\n  var version = \"3.4.1\",\n      // Define a local copy of jQuery\n  jQuery = function jQuery(selector, context) {\n    // The jQuery object is actually just the init constructor 'enhanced'\n    // Need init if jQuery is called (just allow error to be thrown if not included)\n    return new jQuery.fn.init(selector, context);\n  },\n      // Support: Android <=4.0 only\n  // Make sure we trim BOM and NBSP\n  rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\n  jQuery.fn = jQuery.prototype = {\n    // The current version of jQuery being used\n    jquery: version,\n    constructor: jQuery,\n    // The default length of a jQuery object is 0\n    length: 0,\n    toArray: function toArray() {\n      return _slice.call(this);\n    },\n    // Get the Nth element in the matched element set OR\n    // Get the whole matched element set as a clean array\n    get: function get(num) {\n      // Return all the elements in a clean array\n      if (num == null) {\n        return _slice.call(this);\n      } // Return just the one element from the set\n\n\n      return num < 0 ? this[num + this.length] : this[num];\n    },\n    // Take an array of elements and push it onto the stack\n    // (returning the new matched element set)\n    pushStack: function pushStack(elems) {\n      // Build a new jQuery matched element set\n      var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference)\n\n      ret.prevObject = this; // Return the newly-formed element set\n\n      return ret;\n    },\n    // Execute a callback for every element in the matched set.\n    each: function each(callback) {\n      return jQuery.each(this, callback);\n    },\n    map: function map(callback) {\n      return this.pushStack(jQuery.map(this, function (elem, i) {\n        return callback.call(elem, i, elem);\n      }));\n    },\n    slice: function slice() {\n      return this.pushStack(_slice.apply(this, arguments));\n    },\n    first: function first() {\n      return this.eq(0);\n    },\n    last: function last() {\n      return this.eq(-1);\n    },\n    eq: function eq(i) {\n      var len = this.length,\n          j = +i + (i < 0 ? len : 0);\n      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);\n    },\n    end: function end() {\n      return this.prevObject || this.constructor();\n    },\n    // For internal use only.\n    // Behaves like an Array's method, not like a jQuery method.\n    push: push,\n    sort: arr.sort,\n    splice: arr.splice\n  };\n\n  jQuery.extend = jQuery.fn.extend = function () {\n    var options,\n        name,\n        src,\n        copy,\n        copyIsArray,\n        clone,\n        target = arguments[0] || {},\n        i = 1,\n        length = arguments.length,\n        deep = false; // Handle a deep copy situation\n\n    if (typeof target === \"boolean\") {\n      deep = target; // Skip the boolean and the target\n\n      target = arguments[i] || {};\n      i++;\n    } // Handle case when target is a string or something (possible in deep copy)\n\n\n    if (_typeof(target) !== \"object\" && !isFunction(target)) {\n      target = {};\n    } // Extend jQuery itself if only one argument is passed\n\n\n    if (i === length) {\n      target = this;\n      i--;\n    }\n\n    for (; i < length; i++) {\n      // Only deal with non-null/undefined values\n      if ((options = arguments[i]) != null) {\n        // Extend the base object\n        for (name in options) {\n          copy = options[name]; // Prevent Object.prototype pollution\n          // Prevent never-ending loop\n\n          if (name === \"__proto__\" || target === copy) {\n            continue;\n          } // Recurse if we're merging plain objects or arrays\n\n\n          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {\n            src = target[name]; // Ensure proper type for the source value\n\n            if (copyIsArray && !Array.isArray(src)) {\n              clone = [];\n            } else if (!copyIsArray && !jQuery.isPlainObject(src)) {\n              clone = {};\n            } else {\n              clone = src;\n            }\n\n            copyIsArray = false; // Never move original objects, clone them\n\n            target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values\n          } else if (copy !== undefined) {\n            target[name] = copy;\n          }\n        }\n      }\n    } // Return the modified object\n\n\n    return target;\n  };\n\n  jQuery.extend({\n    // Unique for each copy of jQuery on the page\n    expando: \"jQuery\" + (version + Math.random()).replace(/\\D/g, \"\"),\n    // Assume jQuery is ready without the ready module\n    isReady: true,\n    error: function error(msg) {\n      throw new Error(msg);\n    },\n    noop: function noop() {},\n    isPlainObject: function isPlainObject(obj) {\n      var proto, Ctor; // Detect obvious negatives\n      // Use toString instead of jQuery.type to catch host objects\n\n      if (!obj || toString.call(obj) !== \"[object Object]\") {\n        return false;\n      }\n\n      proto = getProto(obj); // Objects with no prototype (e.g., `Object.create( null )`) are plain\n\n      if (!proto) {\n        return true;\n      } // Objects with prototype are plain iff they were constructed by a global Object function\n\n\n      Ctor = hasOwn.call(proto, \"constructor\") && proto.constructor;\n      return typeof Ctor === \"function\" && fnToString.call(Ctor) === ObjectFunctionString;\n    },\n    isEmptyObject: function isEmptyObject(obj) {\n      var name;\n\n      for (name in obj) {\n        return false;\n      }\n\n      return true;\n    },\n    // Evaluates a script in a global context\n    globalEval: function globalEval(code, options) {\n      DOMEval(code, {\n        nonce: options && options.nonce\n      });\n    },\n    each: function each(obj, callback) {\n      var length,\n          i = 0;\n\n      if (isArrayLike(obj)) {\n        length = obj.length;\n\n        for (; i < length; i++) {\n          if (callback.call(obj[i], i, obj[i]) === false) {\n            break;\n          }\n        }\n      } else {\n        for (i in obj) {\n          if (callback.call(obj[i], i, obj[i]) === false) {\n            break;\n          }\n        }\n      }\n\n      return obj;\n    },\n    // Support: Android <=4.0 only\n    trim: function trim(text) {\n      return text == null ? \"\" : (text + \"\").replace(rtrim, \"\");\n    },\n    // results is for internal usage only\n    makeArray: function makeArray(arr, results) {\n      var ret = results || [];\n\n      if (arr != null) {\n        if (isArrayLike(Object(arr))) {\n          jQuery.merge(ret, typeof arr === \"string\" ? [arr] : arr);\n        } else {\n          push.call(ret, arr);\n        }\n      }\n\n      return ret;\n    },\n    inArray: function inArray(elem, arr, i) {\n      return arr == null ? -1 : indexOf.call(arr, elem, i);\n    },\n    // Support: Android <=4.0 only, PhantomJS 1 only\n    // push.apply(_, arraylike) throws on ancient WebKit\n    merge: function merge(first, second) {\n      var len = +second.length,\n          j = 0,\n          i = first.length;\n\n      for (; j < len; j++) {\n        first[i++] = second[j];\n      }\n\n      first.length = i;\n      return first;\n    },\n    grep: function grep(elems, callback, invert) {\n      var callbackInverse,\n          matches = [],\n          i = 0,\n          length = elems.length,\n          callbackExpect = !invert; // Go through the array, only saving the items\n      // that pass the validator function\n\n      for (; i < length; i++) {\n        callbackInverse = !callback(elems[i], i);\n\n        if (callbackInverse !== callbackExpect) {\n          matches.push(elems[i]);\n        }\n      }\n\n      return matches;\n    },\n    // arg is for internal usage only\n    map: function map(elems, callback, arg) {\n      var length,\n          value,\n          i = 0,\n          ret = []; // Go through the array, translating each of the items to their new values\n\n      if (isArrayLike(elems)) {\n        length = elems.length;\n\n        for (; i < length; i++) {\n          value = callback(elems[i], i, arg);\n\n          if (value != null) {\n            ret.push(value);\n          }\n        } // Go through every key on the object,\n\n      } else {\n        for (i in elems) {\n          value = callback(elems[i], i, arg);\n\n          if (value != null) {\n            ret.push(value);\n          }\n        }\n      } // Flatten any nested arrays\n\n\n      return concat.apply([], ret);\n    },\n    // A global GUID counter for objects\n    guid: 1,\n    // jQuery.support is not used in Core but other projects attach their\n    // properties to it so it needs to exist.\n    support: support\n  });\n\n  if (typeof Symbol === \"function\") {\n    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];\n  } // Populate the class2type map\n\n\n  jQuery.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"), function (i, name) {\n    class2type[\"[object \" + name + \"]\"] = name.toLowerCase();\n  });\n\n  function isArrayLike(obj) {\n    // Support: real iOS 8.2 only (not reproducible in simulator)\n    // `in` check used to prevent JIT error (gh-2145)\n    // hasOwn isn't used here due to false negatives\n    // regarding Nodelist length in IE\n    var length = !!obj && \"length\" in obj && obj.length,\n        type = toType(obj);\n\n    if (isFunction(obj) || isWindow(obj)) {\n      return false;\n    }\n\n    return type === \"array\" || length === 0 || typeof length === \"number\" && length > 0 && length - 1 in obj;\n  }\n\n  var Sizzle =\n  /*!\n   * Sizzle CSS Selector Engine v2.3.4\n   * https://sizzlejs.com/\n   *\n   * Copyright JS Foundation and other contributors\n   * Released under the MIT license\n   * https://js.foundation/\n   *\n   * Date: 2019-04-08\n   */\n  function (window) {\n    var i,\n        support,\n        Expr,\n        getText,\n        isXML,\n        tokenize,\n        compile,\n        select,\n        outermostContext,\n        sortInput,\n        hasDuplicate,\n        // Local document vars\n    setDocument,\n        document,\n        docElem,\n        documentIsHTML,\n        rbuggyQSA,\n        rbuggyMatches,\n        matches,\n        contains,\n        // Instance-specific data\n    expando = \"sizzle\" + 1 * new Date(),\n        preferredDoc = window.document,\n        dirruns = 0,\n        done = 0,\n        classCache = createCache(),\n        tokenCache = createCache(),\n        compilerCache = createCache(),\n        nonnativeSelectorCache = createCache(),\n        sortOrder = function sortOrder(a, b) {\n      if (a === b) {\n        hasDuplicate = true;\n      }\n\n      return 0;\n    },\n        // Instance methods\n    hasOwn = {}.hasOwnProperty,\n        arr = [],\n        pop = arr.pop,\n        push_native = arr.push,\n        push = arr.push,\n        slice = arr.slice,\n        // Use a stripped-down indexOf as it's faster than native\n    // https://jsperf.com/thor-indexof-vs-for/5\n    indexOf = function indexOf(list, elem) {\n      var i = 0,\n          len = list.length;\n\n      for (; i < len; i++) {\n        if (list[i] === elem) {\n          return i;\n        }\n      }\n\n      return -1;\n    },\n        booleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n        // Regular expressions\n    // http://www.w3.org/TR/css3-selectors/#whitespace\n    whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n        // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n    identifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n    attributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace + // Operator (capture 2)\n    \"*([*^$|!~]?=)\" + whitespace + // \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n    \"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace + \"*\\\\]\",\n        pseudos = \":(\" + identifier + \")(?:\\\\((\" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n    // 1. quoted (capture 3; capture 4 or capture 5)\n    \"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" + // 2. simple (capture 6)\n    \"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" + // 3. anything else (capture 2)\n    \".*\" + \")\\\\)|)\",\n        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n    rwhitespace = new RegExp(whitespace + \"+\", \"g\"),\n        rtrim = new RegExp(\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\"),\n        rcomma = new RegExp(\"^\" + whitespace + \"*,\" + whitespace + \"*\"),\n        rcombinators = new RegExp(\"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\"),\n        rdescend = new RegExp(whitespace + \"|>\"),\n        rpseudo = new RegExp(pseudos),\n        ridentifier = new RegExp(\"^\" + identifier + \"$\"),\n        matchExpr = {\n      \"ID\": new RegExp(\"^#(\" + identifier + \")\"),\n      \"CLASS\": new RegExp(\"^\\\\.(\" + identifier + \")\"),\n      \"TAG\": new RegExp(\"^(\" + identifier + \"|[*])\"),\n      \"ATTR\": new RegExp(\"^\" + attributes),\n      \"PSEUDO\": new RegExp(\"^\" + pseudos),\n      \"CHILD\": new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\"),\n      \"bool\": new RegExp(\"^(?:\" + booleans + \")$\", \"i\"),\n      // For use in libraries implementing .is()\n      // We use this for POS matching in `select`\n      \"needsContext\": new RegExp(\"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\")\n    },\n        rhtml = /HTML$/i,\n        rinputs = /^(?:input|select|textarea|button)$/i,\n        rheader = /^h\\d$/i,\n        rnative = /^[^{]+\\{\\s*\\[native \\w/,\n        // Easily-parseable/retrievable ID or TAG or CLASS selectors\n    rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n        rsibling = /[+~]/,\n        // CSS escapes\n    // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n    runescape = new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\"),\n        funescape = function funescape(_, escaped, escapedWhitespace) {\n      var high = \"0x\" + escaped - 0x10000; // NaN means non-codepoint\n      // Support: Firefox<24\n      // Workaround erroneous numeric interpretation of +\"0x\"\n\n      return high !== high || escapedWhitespace ? escaped : high < 0 ? // BMP codepoint\n      String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)\n      String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n    },\n        // CSS string/identifier serialization\n    // https://drafts.csswg.org/cssom/#common-serializing-idioms\n    rcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n        fcssescape = function fcssescape(ch, asCodePoint) {\n      if (asCodePoint) {\n        // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n        if (ch === \"\\0\") {\n          return \"\\uFFFD\";\n        } // Control characters and (dependent upon position) numbers get escaped as code points\n\n\n        return ch.slice(0, -1) + \"\\\\\" + ch.charCodeAt(ch.length - 1).toString(16) + \" \";\n      } // Other potentially-special ASCII characters get backslash-escaped\n\n\n      return \"\\\\\" + ch;\n    },\n        // Used for iframes\n    // See setDocument()\n    // Removing the function wrapper causes a \"Permission Denied\"\n    // error in IE\n    unloadHandler = function unloadHandler() {\n      setDocument();\n    },\n        inDisabledFieldset = addCombinator(function (elem) {\n      return elem.disabled === true && elem.nodeName.toLowerCase() === \"fieldset\";\n    }, {\n      dir: \"parentNode\",\n      next: \"legend\"\n    }); // Optimize for push.apply( _, NodeList )\n\n\n    try {\n      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0\n      // Detect silently failing push.apply\n\n      arr[preferredDoc.childNodes.length].nodeType;\n    } catch (e) {\n      push = {\n        apply: arr.length ? // Leverage slice if possible\n        function (target, els) {\n          push_native.apply(target, slice.call(els));\n        } : // Support: IE<9\n        // Otherwise append directly\n        function (target, els) {\n          var j = target.length,\n              i = 0; // Can't trust NodeList.length\n\n          while (target[j++] = els[i++]) {}\n\n          target.length = j - 1;\n        }\n      };\n    }\n\n    function Sizzle(selector, context, results, seed) {\n      var m,\n          i,\n          elem,\n          nid,\n          match,\n          groups,\n          newSelector,\n          newContext = context && context.ownerDocument,\n          // nodeType defaults to 9, since context defaults to document\n      nodeType = context ? context.nodeType : 9;\n      results = results || []; // Return early from calls with invalid selector or context\n\n      if (typeof selector !== \"string\" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n        return results;\n      } // Try to shortcut find operations (as opposed to filters) in HTML documents\n\n\n      if (!seed) {\n        if ((context ? context.ownerDocument || context : preferredDoc) !== document) {\n          setDocument(context);\n        }\n\n        context = context || document;\n\n        if (documentIsHTML) {\n          // If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n          // (excepting DocumentFragment context, where the methods don't exist)\n          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {\n            // ID selector\n            if (m = match[1]) {\n              // Document context\n              if (nodeType === 9) {\n                if (elem = context.getElementById(m)) {\n                  // Support: IE, Opera, Webkit\n                  // TODO: identify versions\n                  // getElementById can match elements by name instead of ID\n                  if (elem.id === m) {\n                    results.push(elem);\n                    return results;\n                  }\n                } else {\n                  return results;\n                } // Element context\n\n              } else {\n                // Support: IE, Opera, Webkit\n                // TODO: identify versions\n                // getElementById can match elements by name instead of ID\n                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {\n                  results.push(elem);\n                  return results;\n                }\n              } // Type selector\n\n            } else if (match[2]) {\n              push.apply(results, context.getElementsByTagName(selector));\n              return results; // Class selector\n            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {\n              push.apply(results, context.getElementsByClassName(m));\n              return results;\n            }\n          } // Take advantage of querySelectorAll\n\n\n          if (support.qsa && !nonnativeSelectorCache[selector + \" \"] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && ( // Support: IE 8 only\n          // Exclude object elements\n          nodeType !== 1 || context.nodeName.toLowerCase() !== \"object\")) {\n            newSelector = selector;\n            newContext = context; // qSA considers elements outside a scoping root when evaluating child or\n            // descendant combinators, which is not what we want.\n            // In such cases, we work around the behavior by prefixing every selector in the\n            // list with an ID selector referencing the scope context.\n            // Thanks to Andrew Dupont for this technique.\n\n            if (nodeType === 1 && rdescend.test(selector)) {\n              // Capture the context ID, setting it first if necessary\n              if (nid = context.getAttribute(\"id\")) {\n                nid = nid.replace(rcssescape, fcssescape);\n              } else {\n                context.setAttribute(\"id\", nid = expando);\n              } // Prefix every selector in the list\n\n\n              groups = tokenize(selector);\n              i = groups.length;\n\n              while (i--) {\n                groups[i] = \"#\" + nid + \" \" + toSelector(groups[i]);\n              }\n\n              newSelector = groups.join(\",\"); // Expand context for sibling selectors\n\n              newContext = rsibling.test(selector) && testContext(context.parentNode) || context;\n            }\n\n            try {\n              push.apply(results, newContext.querySelectorAll(newSelector));\n              return results;\n            } catch (qsaError) {\n              nonnativeSelectorCache(selector, true);\n            } finally {\n              if (nid === expando) {\n                context.removeAttribute(\"id\");\n              }\n            }\n          }\n        }\n      } // All others\n\n\n      return select(selector.replace(rtrim, \"$1\"), context, results, seed);\n    }\n    /**\n     * Create key-value caches of limited size\n     * @returns {function(string, object)} Returns the Object data after storing it on itself with\n     *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n     *\tdeleting the oldest entry\n     */\n\n\n    function createCache() {\n      var keys = [];\n\n      function cache(key, value) {\n        // Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n        if (keys.push(key + \" \") > Expr.cacheLength) {\n          // Only keep the most recent entries\n          delete cache[keys.shift()];\n        }\n\n        return cache[key + \" \"] = value;\n      }\n\n      return cache;\n    }\n    /**\n     * Mark a function for special use by Sizzle\n     * @param {Function} fn The function to mark\n     */\n\n\n    function markFunction(fn) {\n      fn[expando] = true;\n      return fn;\n    }\n    /**\n     * Support testing using an element\n     * @param {Function} fn Passed the created element and returns a boolean result\n     */\n\n\n    function assert(fn) {\n      var el = document.createElement(\"fieldset\");\n\n      try {\n        return !!fn(el);\n      } catch (e) {\n        return false;\n      } finally {\n        // Remove from its parent by default\n        if (el.parentNode) {\n          el.parentNode.removeChild(el);\n        } // release memory in IE\n\n\n        el = null;\n      }\n    }\n    /**\n     * Adds the same handler for all of the specified attrs\n     * @param {String} attrs Pipe-separated list of attributes\n     * @param {Function} handler The method that will be applied\n     */\n\n\n    function addHandle(attrs, handler) {\n      var arr = attrs.split(\"|\"),\n          i = arr.length;\n\n      while (i--) {\n        Expr.attrHandle[arr[i]] = handler;\n      }\n    }\n    /**\n     * Checks document order of two siblings\n     * @param {Element} a\n     * @param {Element} b\n     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n     */\n\n\n    function siblingCheck(a, b) {\n      var cur = b && a,\n          diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex; // Use IE sourceIndex if available on both nodes\n\n      if (diff) {\n        return diff;\n      } // Check if b follows a\n\n\n      if (cur) {\n        while (cur = cur.nextSibling) {\n          if (cur === b) {\n            return -1;\n          }\n        }\n      }\n\n      return a ? 1 : -1;\n    }\n    /**\n     * Returns a function to use in pseudos for input types\n     * @param {String} type\n     */\n\n\n    function createInputPseudo(type) {\n      return function (elem) {\n        var name = elem.nodeName.toLowerCase();\n        return name === \"input\" && elem.type === type;\n      };\n    }\n    /**\n     * Returns a function to use in pseudos for buttons\n     * @param {String} type\n     */\n\n\n    function createButtonPseudo(type) {\n      return function (elem) {\n        var name = elem.nodeName.toLowerCase();\n        return (name === \"input\" || name === \"button\") && elem.type === type;\n      };\n    }\n    /**\n     * Returns a function to use in pseudos for :enabled/:disabled\n     * @param {Boolean} disabled true for :disabled; false for :enabled\n     */\n\n\n    function createDisabledPseudo(disabled) {\n      // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n      return function (elem) {\n        // Only certain elements can match :enabled or :disabled\n        // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n        // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n        if (\"form\" in elem) {\n          // Check for inherited disabledness on relevant non-disabled elements:\n          // * listed form-associated elements in a disabled fieldset\n          //   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n          //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n          // * option elements in a disabled optgroup\n          //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n          // All such elements have a \"form\" property.\n          if (elem.parentNode && elem.disabled === false) {\n            // Option elements defer to a parent optgroup if present\n            if (\"label\" in elem) {\n              if (\"label\" in elem.parentNode) {\n                return elem.parentNode.disabled === disabled;\n              } else {\n                return elem.disabled === disabled;\n              }\n            } // Support: IE 6 - 11\n            // Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\n\n            return elem.isDisabled === disabled || // Where there is no isDisabled, check manually\n\n            /* jshint -W018 */\n            elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;\n          }\n\n          return elem.disabled === disabled; // Try to winnow out elements that can't be disabled before trusting the disabled property.\n          // Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n          // even exist on them, let alone have a boolean value.\n        } else if (\"label\" in elem) {\n          return elem.disabled === disabled;\n        } // Remaining elements are neither :enabled nor :disabled\n\n\n        return false;\n      };\n    }\n    /**\n     * Returns a function to use in pseudos for positionals\n     * @param {Function} fn\n     */\n\n\n    function createPositionalPseudo(fn) {\n      return markFunction(function (argument) {\n        argument = +argument;\n        return markFunction(function (seed, matches) {\n          var j,\n              matchIndexes = fn([], seed.length, argument),\n              i = matchIndexes.length; // Match elements found at the specified indexes\n\n          while (i--) {\n            if (seed[j = matchIndexes[i]]) {\n              seed[j] = !(matches[j] = seed[j]);\n            }\n          }\n        });\n      });\n    }\n    /**\n     * Checks a node for validity as a Sizzle context\n     * @param {Element|Object=} context\n     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n     */\n\n\n    function testContext(context) {\n      return context && typeof context.getElementsByTagName !== \"undefined\" && context;\n    } // Expose support vars for convenience\n\n\n    support = Sizzle.support = {};\n    /**\n     * Detects XML nodes\n     * @param {Element|Object} elem An element or a document\n     * @returns {Boolean} True iff elem is a non-HTML XML node\n     */\n\n    isXML = Sizzle.isXML = function (elem) {\n      var namespace = elem.namespaceURI,\n          docElem = (elem.ownerDocument || elem).documentElement; // Support: IE <=8\n      // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes\n      // https://bugs.jquery.com/ticket/4833\n\n      return !rhtml.test(namespace || docElem && docElem.nodeName || \"HTML\");\n    };\n    /**\n     * Sets document-related variables once based on the current document\n     * @param {Element|Object} [doc] An element or document object to use to set the document\n     * @returns {Object} Returns the current document\n     */\n\n\n    setDocument = Sizzle.setDocument = function (node) {\n      var hasCompare,\n          subWindow,\n          doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected\n\n      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {\n        return document;\n      } // Update global variables\n\n\n      document = doc;\n      docElem = document.documentElement;\n      documentIsHTML = !isXML(document); // Support: IE 9-11, Edge\n      // Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\n      if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {\n        // Support: IE 11, Edge\n        if (subWindow.addEventListener) {\n          subWindow.addEventListener(\"unload\", unloadHandler, false); // Support: IE 9 - 10 only\n        } else if (subWindow.attachEvent) {\n          subWindow.attachEvent(\"onunload\", unloadHandler);\n        }\n      }\n      /* Attributes\n      ---------------------------------------------------------------------- */\n      // Support: IE<8\n      // Verify that getAttribute really returns attributes and not properties\n      // (excepting IE8 booleans)\n\n\n      support.attributes = assert(function (el) {\n        el.className = \"i\";\n        return !el.getAttribute(\"className\");\n      });\n      /* getElement(s)By*\n      ---------------------------------------------------------------------- */\n      // Check if getElementsByTagName(\"*\") returns only elements\n\n      support.getElementsByTagName = assert(function (el) {\n        el.appendChild(document.createComment(\"\"));\n        return !el.getElementsByTagName(\"*\").length;\n      }); // Support: IE<9\n\n      support.getElementsByClassName = rnative.test(document.getElementsByClassName); // Support: IE<10\n      // Check if getElementById returns elements by name\n      // The broken getElementById methods don't pick up programmatically-set names,\n      // so use a roundabout getElementsByName test\n\n      support.getById = assert(function (el) {\n        docElem.appendChild(el).id = expando;\n        return !document.getElementsByName || !document.getElementsByName(expando).length;\n      }); // ID filter and find\n\n      if (support.getById) {\n        Expr.filter[\"ID\"] = function (id) {\n          var attrId = id.replace(runescape, funescape);\n          return function (elem) {\n            return elem.getAttribute(\"id\") === attrId;\n          };\n        };\n\n        Expr.find[\"ID\"] = function (id, context) {\n          if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n            var elem = context.getElementById(id);\n            return elem ? [elem] : [];\n          }\n        };\n      } else {\n        Expr.filter[\"ID\"] = function (id) {\n          var attrId = id.replace(runescape, funescape);\n          return function (elem) {\n            var node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n            return node && node.value === attrId;\n          };\n        }; // Support: IE 6 - 7 only\n        // getElementById is not reliable as a find shortcut\n\n\n        Expr.find[\"ID\"] = function (id, context) {\n          if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n            var node,\n                i,\n                elems,\n                elem = context.getElementById(id);\n\n            if (elem) {\n              // Verify the id attribute\n              node = elem.getAttributeNode(\"id\");\n\n              if (node && node.value === id) {\n                return [elem];\n              } // Fall back on getElementsByName\n\n\n              elems = context.getElementsByName(id);\n              i = 0;\n\n              while (elem = elems[i++]) {\n                node = elem.getAttributeNode(\"id\");\n\n                if (node && node.value === id) {\n                  return [elem];\n                }\n              }\n            }\n\n            return [];\n          }\n        };\n      } // Tag\n\n\n      Expr.find[\"TAG\"] = support.getElementsByTagName ? function (tag, context) {\n        if (typeof context.getElementsByTagName !== \"undefined\") {\n          return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN\n        } else if (support.qsa) {\n          return context.querySelectorAll(tag);\n        }\n      } : function (tag, context) {\n        var elem,\n            tmp = [],\n            i = 0,\n            // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n        results = context.getElementsByTagName(tag); // Filter out possible comments\n\n        if (tag === \"*\") {\n          while (elem = results[i++]) {\n            if (elem.nodeType === 1) {\n              tmp.push(elem);\n            }\n          }\n\n          return tmp;\n        }\n\n        return results;\n      }; // Class\n\n      Expr.find[\"CLASS\"] = support.getElementsByClassName && function (className, context) {\n        if (typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML) {\n          return context.getElementsByClassName(className);\n        }\n      };\n      /* QSA/matchesSelector\n      ---------------------------------------------------------------------- */\n      // QSA and matchesSelector support\n      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\n\n      rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)\n      // We allow this because of a bug in IE8/9 that throws an error\n      // whenever `document.activeElement` is accessed on an iframe\n      // So, we allow :focus to pass through QSA all the time to avoid the IE error\n      // See https://bugs.jquery.com/ticket/13378\n\n      rbuggyQSA = [];\n\n      if (support.qsa = rnative.test(document.querySelectorAll)) {\n        // Build QSA regex\n        // Regex strategy adopted from Diego Perini\n        assert(function (el) {\n          // Select is set to empty string on purpose\n          // This is to test IE's treatment of not explicitly\n          // setting a boolean content attribute,\n          // since its presence should be enough\n          // https://bugs.jquery.com/ticket/12359\n          docElem.appendChild(el).innerHTML = \"<a id='\" + expando + \"'></a>\" + \"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" + \"<option selected=''></option></select>\"; // Support: IE8, Opera 11-12.16\n          // Nothing should be selected when empty strings follow ^= or $= or *=\n          // The test attribute must be unknown in Opera but \"safe\" for WinRT\n          // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\n          if (el.querySelectorAll(\"[msallowcapture^='']\").length) {\n            rbuggyQSA.push(\"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\");\n          } // Support: IE8\n          // Boolean attributes and \"value\" are not treated correctly\n\n\n          if (!el.querySelectorAll(\"[selected]\").length) {\n            rbuggyQSA.push(\"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\");\n          } // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\n\n          if (!el.querySelectorAll(\"[id~=\" + expando + \"-]\").length) {\n            rbuggyQSA.push(\"~=\");\n          } // Webkit/Opera - :checked should return selected option elements\n          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n          // IE8 throws error here and will not see later tests\n\n\n          if (!el.querySelectorAll(\":checked\").length) {\n            rbuggyQSA.push(\":checked\");\n          } // Support: Safari 8+, iOS 8+\n          // https://bugs.webkit.org/show_bug.cgi?id=136851\n          // In-page `selector#id sibling-combinator selector` fails\n\n\n          if (!el.querySelectorAll(\"a#\" + expando + \"+*\").length) {\n            rbuggyQSA.push(\".#.+[+~]\");\n          }\n        });\n        assert(function (el) {\n          el.innerHTML = \"<a href='' disabled='disabled'></a>\" + \"<select disabled='disabled'><option/></select>\"; // Support: Windows 8 Native Apps\n          // The type and name attributes are restricted during .innerHTML assignment\n\n          var input = document.createElement(\"input\");\n          input.setAttribute(\"type\", \"hidden\");\n          el.appendChild(input).setAttribute(\"name\", \"D\"); // Support: IE8\n          // Enforce case-sensitivity of name attribute\n\n          if (el.querySelectorAll(\"[name=d]\").length) {\n            rbuggyQSA.push(\"name\" + whitespace + \"*[*^$|!~]?=\");\n          } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n          // IE8 throws error here and will not see later tests\n\n\n          if (el.querySelectorAll(\":enabled\").length !== 2) {\n            rbuggyQSA.push(\":enabled\", \":disabled\");\n          } // Support: IE9-11+\n          // IE's :disabled selector does not pick up the children of disabled fieldsets\n\n\n          docElem.appendChild(el).disabled = true;\n\n          if (el.querySelectorAll(\":disabled\").length !== 2) {\n            rbuggyQSA.push(\":enabled\", \":disabled\");\n          } // Opera 10-11 does not throw on post-comma invalid pseudos\n\n\n          el.querySelectorAll(\"*,:x\");\n          rbuggyQSA.push(\",.*:\");\n        });\n      }\n\n      if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {\n        assert(function (el) {\n          // Check to see if it's possible to do matchesSelector\n          // on a disconnected node (IE 9)\n          support.disconnectedMatch = matches.call(el, \"*\"); // This should fail with an exception\n          // Gecko does not error, returns false instead\n\n          matches.call(el, \"[s!='']:x\");\n          rbuggyMatches.push(\"!=\", pseudos);\n        });\n      }\n\n      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join(\"|\"));\n      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join(\"|\"));\n      /* Contains\n      ---------------------------------------------------------------------- */\n\n      hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another\n      // Purposefully self-exclusive\n      // As in, an element does not contain itself\n\n      contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {\n        var adown = a.nodeType === 9 ? a.documentElement : a,\n            bup = b && b.parentNode;\n        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\n      } : function (a, b) {\n        if (b) {\n          while (b = b.parentNode) {\n            if (b === a) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n      };\n      /* Sorting\n      ---------------------------------------------------------------------- */\n      // Document order sorting\n\n      sortOrder = hasCompare ? function (a, b) {\n        // Flag for duplicate removal\n        if (a === b) {\n          hasDuplicate = true;\n          return 0;\n        } // Sort on method existence if only one input has compareDocumentPosition\n\n\n        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\n        if (compare) {\n          return compare;\n        } // Calculate position if both inputs belong to the same document\n\n\n        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected\n        1; // Disconnected nodes\n\n        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {\n          // Choose the first element that is related to our preferred document\n          if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {\n            return -1;\n          }\n\n          if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {\n            return 1;\n          } // Maintain original order\n\n\n          return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;\n        }\n\n        return compare & 4 ? -1 : 1;\n      } : function (a, b) {\n        // Exit early if the nodes are identical\n        if (a === b) {\n          hasDuplicate = true;\n          return 0;\n        }\n\n        var cur,\n            i = 0,\n            aup = a.parentNode,\n            bup = b.parentNode,\n            ap = [a],\n            bp = [b]; // Parentless nodes are either documents or disconnected\n\n        if (!aup || !bup) {\n          return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check\n        } else if (aup === bup) {\n          return siblingCheck(a, b);\n        } // Otherwise we need full lists of their ancestors for comparison\n\n\n        cur = a;\n\n        while (cur = cur.parentNode) {\n          ap.unshift(cur);\n        }\n\n        cur = b;\n\n        while (cur = cur.parentNode) {\n          bp.unshift(cur);\n        } // Walk down the tree looking for a discrepancy\n\n\n        while (ap[i] === bp[i]) {\n          i++;\n        }\n\n        return i ? // Do a sibling check if the nodes have a common ancestor\n        siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first\n        ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;\n      };\n      return document;\n    };\n\n    Sizzle.matches = function (expr, elements) {\n      return Sizzle(expr, null, null, elements);\n    };\n\n    Sizzle.matchesSelector = function (elem, expr) {\n      // Set document vars if needed\n      if ((elem.ownerDocument || elem) !== document) {\n        setDocument(elem);\n      }\n\n      if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + \" \"] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {\n        try {\n          var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes\n\n          if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document\n          // fragment in IE 9\n          elem.document && elem.document.nodeType !== 11) {\n            return ret;\n          }\n        } catch (e) {\n          nonnativeSelectorCache(expr, true);\n        }\n      }\n\n      return Sizzle(expr, document, null, [elem]).length > 0;\n    };\n\n    Sizzle.contains = function (context, elem) {\n      // Set document vars if needed\n      if ((context.ownerDocument || context) !== document) {\n        setDocument(context);\n      }\n\n      return contains(context, elem);\n    };\n\n    Sizzle.attr = function (elem, name) {\n      // Set document vars if needed\n      if ((elem.ownerDocument || elem) !== document) {\n        setDocument(elem);\n      }\n\n      var fn = Expr.attrHandle[name.toLowerCase()],\n          // Don't get fooled by Object.prototype properties (jQuery #13807)\n      val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;\n      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n    };\n\n    Sizzle.escape = function (sel) {\n      return (sel + \"\").replace(rcssescape, fcssescape);\n    };\n\n    Sizzle.error = function (msg) {\n      throw new Error(\"Syntax error, unrecognized expression: \" + msg);\n    };\n    /**\n     * Document sorting and removing duplicates\n     * @param {ArrayLike} results\n     */\n\n\n    Sizzle.uniqueSort = function (results) {\n      var elem,\n          duplicates = [],\n          j = 0,\n          i = 0; // Unless we *know* we can detect duplicates, assume their presence\n\n      hasDuplicate = !support.detectDuplicates;\n      sortInput = !support.sortStable && results.slice(0);\n      results.sort(sortOrder);\n\n      if (hasDuplicate) {\n        while (elem = results[i++]) {\n          if (elem === results[i]) {\n            j = duplicates.push(i);\n          }\n        }\n\n        while (j--) {\n          results.splice(duplicates[j], 1);\n        }\n      } // Clear input after sorting to release objects\n      // See https://github.com/jquery/sizzle/pull/225\n\n\n      sortInput = null;\n      return results;\n    };\n    /**\n     * Utility function for retrieving the text value of an array of DOM nodes\n     * @param {Array|Element} elem\n     */\n\n\n    getText = Sizzle.getText = function (elem) {\n      var node,\n          ret = \"\",\n          i = 0,\n          nodeType = elem.nodeType;\n\n      if (!nodeType) {\n        // If no nodeType, this is expected to be an array\n        while (node = elem[i++]) {\n          // Do not traverse comment nodes\n          ret += getText(node);\n        }\n      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\n        // Use textContent for elements\n        // innerText usage removed for consistency of new lines (jQuery #11153)\n        if (typeof elem.textContent === \"string\") {\n          return elem.textContent;\n        } else {\n          // Traverse its children\n          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n            ret += getText(elem);\n          }\n        }\n      } else if (nodeType === 3 || nodeType === 4) {\n        return elem.nodeValue;\n      } // Do not include comment or processing instruction nodes\n\n\n      return ret;\n    };\n\n    Expr = Sizzle.selectors = {\n      // Can be adjusted by the user\n      cacheLength: 50,\n      createPseudo: markFunction,\n      match: matchExpr,\n      attrHandle: {},\n      find: {},\n      relative: {\n        \">\": {\n          dir: \"parentNode\",\n          first: true\n        },\n        \" \": {\n          dir: \"parentNode\"\n        },\n        \"+\": {\n          dir: \"previousSibling\",\n          first: true\n        },\n        \"~\": {\n          dir: \"previousSibling\"\n        }\n      },\n      preFilter: {\n        \"ATTR\": function ATTR(match) {\n          match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted\n\n          match[3] = (match[3] || match[4] || match[5] || \"\").replace(runescape, funescape);\n\n          if (match[2] === \"~=\") {\n            match[3] = \" \" + match[3] + \" \";\n          }\n\n          return match.slice(0, 4);\n        },\n        \"CHILD\": function CHILD(match) {\n          /* matches from matchExpr[\"CHILD\"]\n          \t1 type (only|nth|...)\n          \t2 what (child|of-type)\n          \t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n          \t4 xn-component of xn+y argument ([+-]?\\d*n|)\n          \t5 sign of xn-component\n          \t6 x of xn-component\n          \t7 sign of y-component\n          \t8 y of y-component\n          */\n          match[1] = match[1].toLowerCase();\n\n          if (match[1].slice(0, 3) === \"nth\") {\n            // nth-* requires argument\n            if (!match[3]) {\n              Sizzle.error(match[0]);\n            } // numeric x and y parameters for Expr.filter.CHILD\n            // remember that false/true cast respectively to 0/1\n\n\n            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === \"even\" || match[3] === \"odd\"));\n            match[5] = +(match[7] + match[8] || match[3] === \"odd\"); // other types prohibit arguments\n          } else if (match[3]) {\n            Sizzle.error(match[0]);\n          }\n\n          return match;\n        },\n        \"PSEUDO\": function PSEUDO(match) {\n          var excess,\n              unquoted = !match[6] && match[2];\n\n          if (matchExpr[\"CHILD\"].test(match[0])) {\n            return null;\n          } // Accept quoted arguments as-is\n\n\n          if (match[3]) {\n            match[2] = match[4] || match[5] || \"\"; // Strip excess characters from unquoted arguments\n          } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)\n          excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis\n          excess = unquoted.indexOf(\")\", unquoted.length - excess) - unquoted.length)) {\n            // excess is a negative index\n            match[0] = match[0].slice(0, excess);\n            match[2] = unquoted.slice(0, excess);\n          } // Return only captures needed by the pseudo filter method (type and argument)\n\n\n          return match.slice(0, 3);\n        }\n      },\n      filter: {\n        \"TAG\": function TAG(nodeNameSelector) {\n          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();\n          return nodeNameSelector === \"*\" ? function () {\n            return true;\n          } : function (elem) {\n            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n          };\n        },\n        \"CLASS\": function CLASS(className) {\n          var pattern = classCache[className + \" \"];\n          return pattern || (pattern = new RegExp(\"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\")) && classCache(className, function (elem) {\n            return pattern.test(typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\");\n          });\n        },\n        \"ATTR\": function ATTR(name, operator, check) {\n          return function (elem) {\n            var result = Sizzle.attr(elem, name);\n\n            if (result == null) {\n              return operator === \"!=\";\n            }\n\n            if (!operator) {\n              return true;\n            }\n\n            result += \"\";\n            return operator === \"=\" ? result === check : operator === \"!=\" ? result !== check : operator === \"^=\" ? check && result.indexOf(check) === 0 : operator === \"*=\" ? check && result.indexOf(check) > -1 : operator === \"$=\" ? check && result.slice(-check.length) === check : operator === \"~=\" ? (\" \" + result.replace(rwhitespace, \" \") + \" \").indexOf(check) > -1 : operator === \"|=\" ? result === check || result.slice(0, check.length + 1) === check + \"-\" : false;\n          };\n        },\n        \"CHILD\": function CHILD(type, what, argument, first, last) {\n          var simple = type.slice(0, 3) !== \"nth\",\n              forward = type.slice(-4) !== \"last\",\n              ofType = what === \"of-type\";\n          return first === 1 && last === 0 ? // Shortcut for :nth-*(n)\n          function (elem) {\n            return !!elem.parentNode;\n          } : function (elem, context, xml) {\n            var cache,\n                uniqueCache,\n                outerCache,\n                node,\n                nodeIndex,\n                start,\n                dir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n                parent = elem.parentNode,\n                name = ofType && elem.nodeName.toLowerCase(),\n                useCache = !xml && !ofType,\n                diff = false;\n\n            if (parent) {\n              // :(first|last|only)-(child|of-type)\n              if (simple) {\n                while (dir) {\n                  node = elem;\n\n                  while (node = node[dir]) {\n                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {\n                      return false;\n                    }\n                  } // Reverse direction for :only-* (if we haven't yet done so)\n\n\n                  start = dir = type === \"only\" && !start && \"nextSibling\";\n                }\n\n                return true;\n              }\n\n              start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`\n\n              if (forward && useCache) {\n                // Seek `elem` from a previously-cached index\n                // ...in a gzip-friendly way\n                node = parent;\n                outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                // Defend against cloned attroperties (jQuery gh-1709)\n\n                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                cache = uniqueCache[type] || [];\n                nodeIndex = cache[0] === dirruns && cache[1];\n                diff = nodeIndex && cache[2];\n                node = nodeIndex && parent.childNodes[nodeIndex];\n\n                while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start\n                diff = nodeIndex = 0) || start.pop()) {\n                  // When found, cache indexes on `parent` and break\n                  if (node.nodeType === 1 && ++diff && node === elem) {\n                    uniqueCache[type] = [dirruns, nodeIndex, diff];\n                    break;\n                  }\n                }\n              } else {\n                // Use previously-cached element index if available\n                if (useCache) {\n                  // ...in a gzip-friendly way\n                  node = elem;\n                  outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                  // Defend against cloned attroperties (jQuery gh-1709)\n\n                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                  cache = uniqueCache[type] || [];\n                  nodeIndex = cache[0] === dirruns && cache[1];\n                  diff = nodeIndex;\n                } // xml :nth-child(...)\n                // or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\n\n                if (diff === false) {\n                  // Use the same loop as above to seek `elem` from the start\n                  while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {\n                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {\n                      // Cache the index of each encountered element\n                      if (useCache) {\n                        outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                        // Defend against cloned attroperties (jQuery gh-1709)\n\n                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                        uniqueCache[type] = [dirruns, diff];\n                      }\n\n                      if (node === elem) {\n                        break;\n                      }\n                    }\n                  }\n                }\n              } // Incorporate the offset, then check against cycle size\n\n\n              diff -= last;\n              return diff === first || diff % first === 0 && diff / first >= 0;\n            }\n          };\n        },\n        \"PSEUDO\": function PSEUDO(pseudo, argument) {\n          // pseudo-class names are case-insensitive\n          // http://www.w3.org/TR/selectors/#pseudo-classes\n          // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n          // Remember that setFilters inherits from pseudos\n          var args,\n              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error(\"unsupported pseudo: \" + pseudo); // The user may use createPseudo to indicate that\n          // arguments are needed to create the filter function\n          // just as Sizzle does\n\n          if (fn[expando]) {\n            return fn(argument);\n          } // But maintain support for old signatures\n\n\n          if (fn.length > 1) {\n            args = [pseudo, pseudo, \"\", argument];\n            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {\n              var idx,\n                  matched = fn(seed, argument),\n                  i = matched.length;\n\n              while (i--) {\n                idx = indexOf(seed, matched[i]);\n                seed[idx] = !(matches[idx] = matched[i]);\n              }\n            }) : function (elem) {\n              return fn(elem, 0, args);\n            };\n          }\n\n          return fn;\n        }\n      },\n      pseudos: {\n        // Potentially complex pseudos\n        \"not\": markFunction(function (selector) {\n          // Trim the selector passed to compile\n          // to avoid treating leading and trailing\n          // spaces as combinators\n          var input = [],\n              results = [],\n              matcher = compile(selector.replace(rtrim, \"$1\"));\n          return matcher[expando] ? markFunction(function (seed, matches, context, xml) {\n            var elem,\n                unmatched = matcher(seed, null, xml, []),\n                i = seed.length; // Match elements unmatched by `matcher`\n\n            while (i--) {\n              if (elem = unmatched[i]) {\n                seed[i] = !(matches[i] = elem);\n              }\n            }\n          }) : function (elem, context, xml) {\n            input[0] = elem;\n            matcher(input, null, xml, results); // Don't keep the element (issue #299)\n\n            input[0] = null;\n            return !results.pop();\n          };\n        }),\n        \"has\": markFunction(function (selector) {\n          return function (elem) {\n            return Sizzle(selector, elem).length > 0;\n          };\n        }),\n        \"contains\": markFunction(function (text) {\n          text = text.replace(runescape, funescape);\n          return function (elem) {\n            return (elem.textContent || getText(elem)).indexOf(text) > -1;\n          };\n        }),\n        // \"Whether an element is represented by a :lang() selector\n        // is based solely on the element's language value\n        // being equal to the identifier C,\n        // or beginning with the identifier C immediately followed by \"-\".\n        // The matching of C against the element's language value is performed case-insensitively.\n        // The identifier C does not have to be a valid language name.\"\n        // http://www.w3.org/TR/selectors/#lang-pseudo\n        \"lang\": markFunction(function (lang) {\n          // lang value must be a valid identifier\n          if (!ridentifier.test(lang || \"\")) {\n            Sizzle.error(\"unsupported lang: \" + lang);\n          }\n\n          lang = lang.replace(runescape, funescape).toLowerCase();\n          return function (elem) {\n            var elemLang;\n\n            do {\n              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) {\n                elemLang = elemLang.toLowerCase();\n                return elemLang === lang || elemLang.indexOf(lang + \"-\") === 0;\n              }\n            } while ((elem = elem.parentNode) && elem.nodeType === 1);\n\n            return false;\n          };\n        }),\n        // Miscellaneous\n        \"target\": function target(elem) {\n          var hash = window.location && window.location.hash;\n          return hash && hash.slice(1) === elem.id;\n        },\n        \"root\": function root(elem) {\n          return elem === docElem;\n        },\n        \"focus\": function focus(elem) {\n          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n        },\n        // Boolean properties\n        \"enabled\": createDisabledPseudo(false),\n        \"disabled\": createDisabledPseudo(true),\n        \"checked\": function checked(elem) {\n          // In CSS3, :checked should return both checked and selected elements\n          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n          var nodeName = elem.nodeName.toLowerCase();\n          return nodeName === \"input\" && !!elem.checked || nodeName === \"option\" && !!elem.selected;\n        },\n        \"selected\": function selected(elem) {\n          // Accessing this property makes selected-by-default\n          // options in Safari work properly\n          if (elem.parentNode) {\n            elem.parentNode.selectedIndex;\n          }\n\n          return elem.selected === true;\n        },\n        // Contents\n        \"empty\": function empty(elem) {\n          // http://www.w3.org/TR/selectors/#empty-pseudo\n          // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n          //   but not by others (comment: 8; processing instruction: 7; etc.)\n          // nodeType < 6 works because attributes (2) do not appear as children\n          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n            if (elem.nodeType < 6) {\n              return false;\n            }\n          }\n\n          return true;\n        },\n        \"parent\": function parent(elem) {\n          return !Expr.pseudos[\"empty\"](elem);\n        },\n        // Element/input types\n        \"header\": function header(elem) {\n          return rheader.test(elem.nodeName);\n        },\n        \"input\": function input(elem) {\n          return rinputs.test(elem.nodeName);\n        },\n        \"button\": function button(elem) {\n          var name = elem.nodeName.toLowerCase();\n          return name === \"input\" && elem.type === \"button\" || name === \"button\";\n        },\n        \"text\": function text(elem) {\n          var attr;\n          return elem.nodeName.toLowerCase() === \"input\" && elem.type === \"text\" && ( // Support: IE<8\n          // New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n          (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\");\n        },\n        // Position-in-collection\n        \"first\": createPositionalPseudo(function () {\n          return [0];\n        }),\n        \"last\": createPositionalPseudo(function (matchIndexes, length) {\n          return [length - 1];\n        }),\n        \"eq\": createPositionalPseudo(function (matchIndexes, length, argument) {\n          return [argument < 0 ? argument + length : argument];\n        }),\n        \"even\": createPositionalPseudo(function (matchIndexes, length) {\n          var i = 0;\n\n          for (; i < length; i += 2) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        }),\n        \"odd\": createPositionalPseudo(function (matchIndexes, length) {\n          var i = 1;\n\n          for (; i < length; i += 2) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        }),\n        \"lt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n          var i = argument < 0 ? argument + length : argument > length ? length : argument;\n\n          for (; --i >= 0;) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        }),\n        \"gt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n          var i = argument < 0 ? argument + length : argument;\n\n          for (; ++i < length;) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        })\n      }\n    };\n    Expr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"]; // Add button/input type pseudos\n\n    for (i in {\n      radio: true,\n      checkbox: true,\n      file: true,\n      password: true,\n      image: true\n    }) {\n      Expr.pseudos[i] = createInputPseudo(i);\n    }\n\n    for (i in {\n      submit: true,\n      reset: true\n    }) {\n      Expr.pseudos[i] = createButtonPseudo(i);\n    } // Easy API for creating new setFilters\n\n\n    function setFilters() {}\n\n    setFilters.prototype = Expr.filters = Expr.pseudos;\n    Expr.setFilters = new setFilters();\n\n    tokenize = Sizzle.tokenize = function (selector, parseOnly) {\n      var matched,\n          match,\n          tokens,\n          type,\n          soFar,\n          groups,\n          preFilters,\n          cached = tokenCache[selector + \" \"];\n\n      if (cached) {\n        return parseOnly ? 0 : cached.slice(0);\n      }\n\n      soFar = selector;\n      groups = [];\n      preFilters = Expr.preFilter;\n\n      while (soFar) {\n        // Comma and first run\n        if (!matched || (match = rcomma.exec(soFar))) {\n          if (match) {\n            // Don't consume trailing commas as valid\n            soFar = soFar.slice(match[0].length) || soFar;\n          }\n\n          groups.push(tokens = []);\n        }\n\n        matched = false; // Combinators\n\n        if (match = rcombinators.exec(soFar)) {\n          matched = match.shift();\n          tokens.push({\n            value: matched,\n            // Cast descendant combinators to space\n            type: match[0].replace(rtrim, \" \")\n          });\n          soFar = soFar.slice(matched.length);\n        } // Filters\n\n\n        for (type in Expr.filter) {\n          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\n            matched = match.shift();\n            tokens.push({\n              value: matched,\n              type: type,\n              matches: match\n            });\n            soFar = soFar.slice(matched.length);\n          }\n        }\n\n        if (!matched) {\n          break;\n        }\n      } // Return the length of the invalid excess\n      // if we're just parsing\n      // Otherwise, throw an error or return tokens\n\n\n      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens\n      tokenCache(selector, groups).slice(0);\n    };\n\n    function toSelector(tokens) {\n      var i = 0,\n          len = tokens.length,\n          selector = \"\";\n\n      for (; i < len; i++) {\n        selector += tokens[i].value;\n      }\n\n      return selector;\n    }\n\n    function addCombinator(matcher, combinator, base) {\n      var dir = combinator.dir,\n          skip = combinator.next,\n          key = skip || dir,\n          checkNonElements = base && key === \"parentNode\",\n          doneName = done++;\n      return combinator.first ? // Check against closest ancestor/preceding element\n      function (elem, context, xml) {\n        while (elem = elem[dir]) {\n          if (elem.nodeType === 1 || checkNonElements) {\n            return matcher(elem, context, xml);\n          }\n        }\n\n        return false;\n      } : // Check against all ancestor/preceding elements\n      function (elem, context, xml) {\n        var oldCache,\n            uniqueCache,\n            outerCache,\n            newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\n        if (xml) {\n          while (elem = elem[dir]) {\n            if (elem.nodeType === 1 || checkNonElements) {\n              if (matcher(elem, context, xml)) {\n                return true;\n              }\n            }\n          }\n        } else {\n          while (elem = elem[dir]) {\n            if (elem.nodeType === 1 || checkNonElements) {\n              outerCache = elem[expando] || (elem[expando] = {}); // Support: IE <9 only\n              // Defend against cloned attroperties (jQuery gh-1709)\n\n              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});\n\n              if (skip && skip === elem.nodeName.toLowerCase()) {\n                elem = elem[dir] || elem;\n              } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {\n                // Assign to newCache so results back-propagate to previous elements\n                return newCache[2] = oldCache[2];\n              } else {\n                // Reuse newcache so results back-propagate to previous elements\n                uniqueCache[key] = newCache; // A match means we're done; a fail means we have to keep checking\n\n                if (newCache[2] = matcher(elem, context, xml)) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n\n        return false;\n      };\n    }\n\n    function elementMatcher(matchers) {\n      return matchers.length > 1 ? function (elem, context, xml) {\n        var i = matchers.length;\n\n        while (i--) {\n          if (!matchers[i](elem, context, xml)) {\n            return false;\n          }\n        }\n\n        return true;\n      } : matchers[0];\n    }\n\n    function multipleContexts(selector, contexts, results) {\n      var i = 0,\n          len = contexts.length;\n\n      for (; i < len; i++) {\n        Sizzle(selector, contexts[i], results);\n      }\n\n      return results;\n    }\n\n    function condense(unmatched, map, filter, context, xml) {\n      var elem,\n          newUnmatched = [],\n          i = 0,\n          len = unmatched.length,\n          mapped = map != null;\n\n      for (; i < len; i++) {\n        if (elem = unmatched[i]) {\n          if (!filter || filter(elem, context, xml)) {\n            newUnmatched.push(elem);\n\n            if (mapped) {\n              map.push(i);\n            }\n          }\n        }\n      }\n\n      return newUnmatched;\n    }\n\n    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\n      if (postFilter && !postFilter[expando]) {\n        postFilter = setMatcher(postFilter);\n      }\n\n      if (postFinder && !postFinder[expando]) {\n        postFinder = setMatcher(postFinder, postSelector);\n      }\n\n      return markFunction(function (seed, results, context, xml) {\n        var temp,\n            i,\n            elem,\n            preMap = [],\n            postMap = [],\n            preexisting = results.length,\n            // Get initial elements from seed or context\n        elems = seed || multipleContexts(selector || \"*\", context.nodeType ? [context] : context, []),\n            // Prefilter to get matcher input, preserving a map for seed-results synchronization\n        matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,\n            matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n        postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary\n        [] : // ...otherwise use results directly\n        results : matcherIn; // Find primary matches\n\n        if (matcher) {\n          matcher(matcherIn, matcherOut, context, xml);\n        } // Apply postFilter\n\n\n        if (postFilter) {\n          temp = condense(matcherOut, postMap);\n          postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn\n\n          i = temp.length;\n\n          while (i--) {\n            if (elem = temp[i]) {\n              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\n            }\n          }\n        }\n\n        if (seed) {\n          if (postFinder || preFilter) {\n            if (postFinder) {\n              // Get the final matcherOut by condensing this intermediate into postFinder contexts\n              temp = [];\n              i = matcherOut.length;\n\n              while (i--) {\n                if (elem = matcherOut[i]) {\n                  // Restore matcherIn since elem is not yet a final match\n                  temp.push(matcherIn[i] = elem);\n                }\n              }\n\n              postFinder(null, matcherOut = [], temp, xml);\n            } // Move matched elements from seed to results to keep them synchronized\n\n\n            i = matcherOut.length;\n\n            while (i--) {\n              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {\n                seed[temp] = !(results[temp] = elem);\n              }\n            }\n          } // Add elements to results, through postFinder if defined\n\n        } else {\n          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);\n\n          if (postFinder) {\n            postFinder(null, results, matcherOut, xml);\n          } else {\n            push.apply(results, matcherOut);\n          }\n        }\n      });\n    }\n\n    function matcherFromTokens(tokens) {\n      var checkContext,\n          matcher,\n          j,\n          len = tokens.length,\n          leadingRelative = Expr.relative[tokens[0].type],\n          implicitRelative = leadingRelative || Expr.relative[\" \"],\n          i = leadingRelative ? 1 : 0,\n          // The foundational matcher ensures that elements are reachable from top-level context(s)\n      matchContext = addCombinator(function (elem) {\n        return elem === checkContext;\n      }, implicitRelative, true),\n          matchAnyContext = addCombinator(function (elem) {\n        return indexOf(checkContext, elem) > -1;\n      }, implicitRelative, true),\n          matchers = [function (elem, context, xml) {\n        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)\n\n        checkContext = null;\n        return ret;\n      }];\n\n      for (; i < len; i++) {\n        if (matcher = Expr.relative[tokens[i].type]) {\n          matchers = [addCombinator(elementMatcher(matchers), matcher)];\n        } else {\n          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher\n\n          if (matcher[expando]) {\n            // Find the next relative operator (if any) for proper handling\n            j = ++i;\n\n            for (; j < len; j++) {\n              if (Expr.relative[tokens[j].type]) {\n                break;\n              }\n            }\n\n            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`\n            tokens.slice(0, i - 1).concat({\n              value: tokens[i - 2].type === \" \" ? \"*\" : \"\"\n            })).replace(rtrim, \"$1\"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));\n          }\n\n          matchers.push(matcher);\n        }\n      }\n\n      return elementMatcher(matchers);\n    }\n\n    function matcherFromGroupMatchers(elementMatchers, setMatchers) {\n      var bySet = setMatchers.length > 0,\n          byElement = elementMatchers.length > 0,\n          superMatcher = function superMatcher(seed, context, xml, results, outermost) {\n        var elem,\n            j,\n            matcher,\n            matchedCount = 0,\n            i = \"0\",\n            unmatched = seed && [],\n            setMatched = [],\n            contextBackup = outermostContext,\n            // We must always have either seed elements or outermost context\n        elems = seed || byElement && Expr.find[\"TAG\"](\"*\", outermost),\n            // Use integer dirruns iff this is the outermost matcher\n        dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,\n            len = elems.length;\n\n        if (outermost) {\n          outermostContext = context === document || context || outermost;\n        } // Add elements passing elementMatchers directly to results\n        // Support: IE<9, Safari\n        // Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\n\n        for (; i !== len && (elem = elems[i]) != null; i++) {\n          if (byElement && elem) {\n            j = 0;\n\n            if (!context && elem.ownerDocument !== document) {\n              setDocument(elem);\n              xml = !documentIsHTML;\n            }\n\n            while (matcher = elementMatchers[j++]) {\n              if (matcher(elem, context || document, xml)) {\n                results.push(elem);\n                break;\n              }\n            }\n\n            if (outermost) {\n              dirruns = dirrunsUnique;\n            }\n          } // Track unmatched elements for set filters\n\n\n          if (bySet) {\n            // They will have gone through all possible matchers\n            if (elem = !matcher && elem) {\n              matchedCount--;\n            } // Lengthen the array for every element, matched or not\n\n\n            if (seed) {\n              unmatched.push(elem);\n            }\n          }\n        } // `i` is now the count of elements visited above, and adding it to `matchedCount`\n        // makes the latter nonnegative.\n\n\n        matchedCount += i; // Apply set filters to unmatched elements\n        // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n        // equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n        // no element matchers and no seed.\n        // Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n        // case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n        // numerically zero.\n\n        if (bySet && i !== matchedCount) {\n          j = 0;\n\n          while (matcher = setMatchers[j++]) {\n            matcher(unmatched, setMatched, context, xml);\n          }\n\n          if (seed) {\n            // Reintegrate element matches to eliminate the need for sorting\n            if (matchedCount > 0) {\n              while (i--) {\n                if (!(unmatched[i] || setMatched[i])) {\n                  setMatched[i] = pop.call(results);\n                }\n              }\n            } // Discard index placeholder values to get only actual matches\n\n\n            setMatched = condense(setMatched);\n          } // Add matches to results\n\n\n          push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting\n\n          if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\n            Sizzle.uniqueSort(results);\n          }\n        } // Override manipulation of globals by nested matchers\n\n\n        if (outermost) {\n          dirruns = dirrunsUnique;\n          outermostContext = contextBackup;\n        }\n\n        return unmatched;\n      };\n\n      return bySet ? markFunction(superMatcher) : superMatcher;\n    }\n\n    compile = Sizzle.compile = function (selector, match\n    /* Internal Use Only */\n    ) {\n      var i,\n          setMatchers = [],\n          elementMatchers = [],\n          cached = compilerCache[selector + \" \"];\n\n      if (!cached) {\n        // Generate a function of recursive functions that can be used to check each element\n        if (!match) {\n          match = tokenize(selector);\n        }\n\n        i = match.length;\n\n        while (i--) {\n          cached = matcherFromTokens(match[i]);\n\n          if (cached[expando]) {\n            setMatchers.push(cached);\n          } else {\n            elementMatchers.push(cached);\n          }\n        } // Cache the compiled function\n\n\n        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization\n\n        cached.selector = selector;\n      }\n\n      return cached;\n    };\n    /**\n     * A low-level selection function that works with Sizzle's compiled\n     *  selector functions\n     * @param {String|Function} selector A selector or a pre-compiled\n     *  selector function built with Sizzle.compile\n     * @param {Element} context\n     * @param {Array} [results]\n     * @param {Array} [seed] A set of elements to match against\n     */\n\n\n    select = Sizzle.select = function (selector, context, results, seed) {\n      var i,\n          tokens,\n          token,\n          type,\n          find,\n          compiled = typeof selector === \"function\" && selector,\n          match = !seed && tokenize(selector = compiled.selector || selector);\n      results = results || []; // Try to minimize operations if there is only one selector in the list and no seed\n      // (the latter of which guarantees us context)\n\n      if (match.length === 1) {\n        // Reduce context if the leading compound selector is an ID\n        tokens = match[0] = match[0].slice(0);\n\n        if (tokens.length > 2 && (token = tokens[0]).type === \"ID\" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {\n          context = (Expr.find[\"ID\"](token.matches[0].replace(runescape, funescape), context) || [])[0];\n\n          if (!context) {\n            return results; // Precompiled matchers will still verify ancestry, so step up a level\n          } else if (compiled) {\n            context = context.parentNode;\n          }\n\n          selector = selector.slice(tokens.shift().value.length);\n        } // Fetch a seed set for right-to-left matching\n\n\n        i = matchExpr[\"needsContext\"].test(selector) ? 0 : tokens.length;\n\n        while (i--) {\n          token = tokens[i]; // Abort if we hit a combinator\n\n          if (Expr.relative[type = token.type]) {\n            break;\n          }\n\n          if (find = Expr.find[type]) {\n            // Search, expanding context for leading sibling combinators\n            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {\n              // If seed is empty or no tokens remain, we can return early\n              tokens.splice(i, 1);\n              selector = seed.length && toSelector(tokens);\n\n              if (!selector) {\n                push.apply(results, seed);\n                return results;\n              }\n\n              break;\n            }\n          }\n        }\n      } // Compile and execute a filtering function if one is not provided\n      // Provide `match` to avoid retokenization if we modified the selector above\n\n\n      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);\n      return results;\n    }; // One-time assignments\n    // Sort stability\n\n\n    support.sortStable = expando.split(\"\").sort(sortOrder).join(\"\") === expando; // Support: Chrome 14-35+\n    // Always assume duplicates if they aren't passed to the comparison function\n\n    support.detectDuplicates = !!hasDuplicate; // Initialize against the default document\n\n    setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n    // Detached nodes confoundingly follow *each other*\n\n    support.sortDetached = assert(function (el) {\n      // Should return 1, but returns 4 (following)\n      return el.compareDocumentPosition(document.createElement(\"fieldset\")) & 1;\n    }); // Support: IE<8\n    // Prevent attribute/property \"interpolation\"\n    // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\n    if (!assert(function (el) {\n      el.innerHTML = \"<a href='#'></a>\";\n      return el.firstChild.getAttribute(\"href\") === \"#\";\n    })) {\n      addHandle(\"type|href|height|width\", function (elem, name, isXML) {\n        if (!isXML) {\n          return elem.getAttribute(name, name.toLowerCase() === \"type\" ? 1 : 2);\n        }\n      });\n    } // Support: IE<9\n    // Use defaultValue in place of getAttribute(\"value\")\n\n\n    if (!support.attributes || !assert(function (el) {\n      el.innerHTML = \"<input/>\";\n      el.firstChild.setAttribute(\"value\", \"\");\n      return el.firstChild.getAttribute(\"value\") === \"\";\n    })) {\n      addHandle(\"value\", function (elem, name, isXML) {\n        if (!isXML && elem.nodeName.toLowerCase() === \"input\") {\n          return elem.defaultValue;\n        }\n      });\n    } // Support: IE<9\n    // Use getAttributeNode to fetch booleans when getAttribute lies\n\n\n    if (!assert(function (el) {\n      return el.getAttribute(\"disabled\") == null;\n    })) {\n      addHandle(booleans, function (elem, name, isXML) {\n        var val;\n\n        if (!isXML) {\n          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n        }\n      });\n    }\n\n    return Sizzle;\n  }(window);\n\n  jQuery.find = Sizzle;\n  jQuery.expr = Sizzle.selectors; // Deprecated\n\n  jQuery.expr[\":\"] = jQuery.expr.pseudos;\n  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\n  jQuery.text = Sizzle.getText;\n  jQuery.isXMLDoc = Sizzle.isXML;\n  jQuery.contains = Sizzle.contains;\n  jQuery.escapeSelector = Sizzle.escape;\n\n  var dir = function dir(elem, _dir, until) {\n    var matched = [],\n        truncate = until !== undefined;\n\n    while ((elem = elem[_dir]) && elem.nodeType !== 9) {\n      if (elem.nodeType === 1) {\n        if (truncate && jQuery(elem).is(until)) {\n          break;\n        }\n\n        matched.push(elem);\n      }\n    }\n\n    return matched;\n  };\n\n  var _siblings = function siblings(n, elem) {\n    var matched = [];\n\n    for (; n; n = n.nextSibling) {\n      if (n.nodeType === 1 && n !== elem) {\n        matched.push(n);\n      }\n    }\n\n    return matched;\n  };\n\n  var rneedsContext = jQuery.expr.match.needsContext;\n\n  function nodeName(elem, name) {\n    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n  }\n\n  ;\n  var rsingleTag = /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i; // Implement the identical functionality for filter and not\n\n  function winnow(elements, qualifier, not) {\n    if (isFunction(qualifier)) {\n      return jQuery.grep(elements, function (elem, i) {\n        return !!qualifier.call(elem, i, elem) !== not;\n      });\n    } // Single element\n\n\n    if (qualifier.nodeType) {\n      return jQuery.grep(elements, function (elem) {\n        return elem === qualifier !== not;\n      });\n    } // Arraylike of elements (jQuery, arguments, Array)\n\n\n    if (typeof qualifier !== \"string\") {\n      return jQuery.grep(elements, function (elem) {\n        return indexOf.call(qualifier, elem) > -1 !== not;\n      });\n    } // Filtered directly for both simple and complex selectors\n\n\n    return jQuery.filter(qualifier, elements, not);\n  }\n\n  jQuery.filter = function (expr, elems, not) {\n    var elem = elems[0];\n\n    if (not) {\n      expr = \":not(\" + expr + \")\";\n    }\n\n    if (elems.length === 1 && elem.nodeType === 1) {\n      return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];\n    }\n\n    return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {\n      return elem.nodeType === 1;\n    }));\n  };\n\n  jQuery.fn.extend({\n    find: function find(selector) {\n      var i,\n          ret,\n          len = this.length,\n          self = this;\n\n      if (typeof selector !== \"string\") {\n        return this.pushStack(jQuery(selector).filter(function () {\n          for (i = 0; i < len; i++) {\n            if (jQuery.contains(self[i], this)) {\n              return true;\n            }\n          }\n        }));\n      }\n\n      ret = this.pushStack([]);\n\n      for (i = 0; i < len; i++) {\n        jQuery.find(selector, self[i], ret);\n      }\n\n      return len > 1 ? jQuery.uniqueSort(ret) : ret;\n    },\n    filter: function filter(selector) {\n      return this.pushStack(winnow(this, selector || [], false));\n    },\n    not: function not(selector) {\n      return this.pushStack(winnow(this, selector || [], true));\n    },\n    is: function is(selector) {\n      return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set\n      // so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n      typeof selector === \"string\" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;\n    }\n  }); // Initialize a jQuery object\n  // A central reference to the root jQuery(document)\n\n  var rootjQuery,\n      // A simple way to check for HTML strings\n  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n  // Strict HTML recognition (#11290: must start with <)\n  // Shortcut simple #id case for speed\n  rquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n      init = jQuery.fn.init = function (selector, context, root) {\n    var match, elem; // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\n    if (!selector) {\n      return this;\n    } // Method init() accepts an alternate rootjQuery\n    // so migrate can support jQuery.sub (gh-2101)\n\n\n    root = root || rootjQuery; // Handle HTML strings\n\n    if (typeof selector === \"string\") {\n      if (selector[0] === \"<\" && selector[selector.length - 1] === \">\" && selector.length >= 3) {\n        // Assume that strings that start and end with <> are HTML and skip the regex check\n        match = [null, selector, null];\n      } else {\n        match = rquickExpr.exec(selector);\n      } // Match html or make sure no context is specified for #id\n\n\n      if (match && (match[1] || !context)) {\n        // HANDLE: $(html) -> $(array)\n        if (match[1]) {\n          context = context instanceof jQuery ? context[0] : context; // Option to run scripts is true for back-compat\n          // Intentionally let the error be thrown if parseHTML is not present\n\n          jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true)); // HANDLE: $(html, props)\n\n          if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {\n            for (match in context) {\n              // Properties of context are called as methods if possible\n              if (isFunction(this[match])) {\n                this[match](context[match]); // ...and otherwise set as attributes\n              } else {\n                this.attr(match, context[match]);\n              }\n            }\n          }\n\n          return this; // HANDLE: $(#id)\n        } else {\n          elem = document.getElementById(match[2]);\n\n          if (elem) {\n            // Inject the element directly into the jQuery object\n            this[0] = elem;\n            this.length = 1;\n          }\n\n          return this;\n        } // HANDLE: $(expr, $(...))\n\n      } else if (!context || context.jquery) {\n        return (context || root).find(selector); // HANDLE: $(expr, context)\n        // (which is just equivalent to: $(context).find(expr)\n      } else {\n        return this.constructor(context).find(selector);\n      } // HANDLE: $(DOMElement)\n\n    } else if (selector.nodeType) {\n      this[0] = selector;\n      this.length = 1;\n      return this; // HANDLE: $(function)\n      // Shortcut for document ready\n    } else if (isFunction(selector)) {\n      return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present\n      selector(jQuery);\n    }\n\n    return jQuery.makeArray(selector, this);\n  }; // Give the init function the jQuery prototype for later instantiation\n\n\n  init.prototype = jQuery.fn; // Initialize central reference\n\n  rootjQuery = jQuery(document);\n  var rparentsprev = /^(?:parents|prev(?:Until|All))/,\n      // Methods guaranteed to produce a unique set when starting from a unique set\n  guaranteedUnique = {\n    children: true,\n    contents: true,\n    next: true,\n    prev: true\n  };\n  jQuery.fn.extend({\n    has: function has(target) {\n      var targets = jQuery(target, this),\n          l = targets.length;\n      return this.filter(function () {\n        var i = 0;\n\n        for (; i < l; i++) {\n          if (jQuery.contains(this, targets[i])) {\n            return true;\n          }\n        }\n      });\n    },\n    closest: function closest(selectors, context) {\n      var cur,\n          i = 0,\n          l = this.length,\n          matched = [],\n          targets = typeof selectors !== \"string\" && jQuery(selectors); // Positional selectors never match, since there's no _selection_ context\n\n      if (!rneedsContext.test(selectors)) {\n        for (; i < l; i++) {\n          for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {\n            // Always skip document fragments\n            if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to Sizzle\n            cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {\n              matched.push(cur);\n              break;\n            }\n          }\n        }\n      }\n\n      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);\n    },\n    // Determine the position of an element within the set\n    index: function index(elem) {\n      // No argument, return index in parent\n      if (!elem) {\n        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\n      } // Index in selector\n\n\n      if (typeof elem === \"string\") {\n        return indexOf.call(jQuery(elem), this[0]);\n      } // Locate the position of the desired element\n\n\n      return indexOf.call(this, // If it receives a jQuery object, the first element is used\n      elem.jquery ? elem[0] : elem);\n    },\n    add: function add(selector, context) {\n      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));\n    },\n    addBack: function addBack(selector) {\n      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));\n    }\n  });\n\n  function sibling(cur, dir) {\n    while ((cur = cur[dir]) && cur.nodeType !== 1) {}\n\n    return cur;\n  }\n\n  jQuery.each({\n    parent: function parent(elem) {\n      var parent = elem.parentNode;\n      return parent && parent.nodeType !== 11 ? parent : null;\n    },\n    parents: function parents(elem) {\n      return dir(elem, \"parentNode\");\n    },\n    parentsUntil: function parentsUntil(elem, i, until) {\n      return dir(elem, \"parentNode\", until);\n    },\n    next: function next(elem) {\n      return sibling(elem, \"nextSibling\");\n    },\n    prev: function prev(elem) {\n      return sibling(elem, \"previousSibling\");\n    },\n    nextAll: function nextAll(elem) {\n      return dir(elem, \"nextSibling\");\n    },\n    prevAll: function prevAll(elem) {\n      return dir(elem, \"previousSibling\");\n    },\n    nextUntil: function nextUntil(elem, i, until) {\n      return dir(elem, \"nextSibling\", until);\n    },\n    prevUntil: function prevUntil(elem, i, until) {\n      return dir(elem, \"previousSibling\", until);\n    },\n    siblings: function siblings(elem) {\n      return _siblings((elem.parentNode || {}).firstChild, elem);\n    },\n    children: function children(elem) {\n      return _siblings(elem.firstChild);\n    },\n    contents: function contents(elem) {\n      if (typeof elem.contentDocument !== \"undefined\") {\n        return elem.contentDocument;\n      } // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n      // Treat the template element as a regular one in browsers that\n      // don't support it.\n\n\n      if (nodeName(elem, \"template\")) {\n        elem = elem.content || elem;\n      }\n\n      return jQuery.merge([], elem.childNodes);\n    }\n  }, function (name, fn) {\n    jQuery.fn[name] = function (until, selector) {\n      var matched = jQuery.map(this, fn, until);\n\n      if (name.slice(-5) !== \"Until\") {\n        selector = until;\n      }\n\n      if (selector && typeof selector === \"string\") {\n        matched = jQuery.filter(selector, matched);\n      }\n\n      if (this.length > 1) {\n        // Remove duplicates\n        if (!guaranteedUnique[name]) {\n          jQuery.uniqueSort(matched);\n        } // Reverse order for parents* and prev-derivatives\n\n\n        if (rparentsprev.test(name)) {\n          matched.reverse();\n        }\n      }\n\n      return this.pushStack(matched);\n    };\n  });\n  var rnothtmlwhite = /[^\\x20\\t\\r\\n\\f]+/g; // Convert String-formatted options into Object-formatted ones\n\n  function createOptions(options) {\n    var object = {};\n    jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {\n      object[flag] = true;\n    });\n    return object;\n  }\n  /*\n   * Create a callback list using the following parameters:\n   *\n   *\toptions: an optional list of space-separated options that will change how\n   *\t\t\tthe callback list behaves or a more traditional option object\n   *\n   * By default a callback list will act like an event callback list and can be\n   * \"fired\" multiple times.\n   *\n   * Possible options:\n   *\n   *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n   *\n   *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n   *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n   *\t\t\t\t\tvalues (like a Deferred)\n   *\n   *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n   *\n   *\tstopOnFalse:\tinterrupt callings when a callback returns false\n   *\n   */\n\n\n  jQuery.Callbacks = function (options) {\n    // Convert options from String-formatted to Object-formatted if needed\n    // (we check in cache first)\n    options = typeof options === \"string\" ? createOptions(options) : jQuery.extend({}, options);\n\n    var // Flag to know if list is currently firing\n    firing,\n        // Last fire value for non-forgettable lists\n    memory,\n        // Flag to know if list was already fired\n    _fired,\n        // Flag to prevent firing\n    _locked,\n        // Actual callback list\n    list = [],\n        // Queue of execution data for repeatable lists\n    queue = [],\n        // Index of currently firing callback (modified by add/remove as needed)\n    firingIndex = -1,\n        // Fire callbacks\n    fire = function fire() {\n      // Enforce single-firing\n      _locked = _locked || options.once; // Execute callbacks for all pending executions,\n      // respecting firingIndex overrides and runtime changes\n\n      _fired = firing = true;\n\n      for (; queue.length; firingIndex = -1) {\n        memory = queue.shift();\n\n        while (++firingIndex < list.length) {\n          // Run callback and check for early termination\n          if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {\n            // Jump to end and forget the data so .add doesn't re-fire\n            firingIndex = list.length;\n            memory = false;\n          }\n        }\n      } // Forget the data if we're done with it\n\n\n      if (!options.memory) {\n        memory = false;\n      }\n\n      firing = false; // Clean up if we're done firing for good\n\n      if (_locked) {\n        // Keep an empty list if we have data for future add calls\n        if (memory) {\n          list = []; // Otherwise, this object is spent\n        } else {\n          list = \"\";\n        }\n      }\n    },\n        // Actual Callbacks object\n    self = {\n      // Add a callback or a collection of callbacks to the list\n      add: function add() {\n        if (list) {\n          // If we have memory from a past run, we should fire after adding\n          if (memory && !firing) {\n            firingIndex = list.length - 1;\n            queue.push(memory);\n          }\n\n          (function add(args) {\n            jQuery.each(args, function (_, arg) {\n              if (isFunction(arg)) {\n                if (!options.unique || !self.has(arg)) {\n                  list.push(arg);\n                }\n              } else if (arg && arg.length && toType(arg) !== \"string\") {\n                // Inspect recursively\n                add(arg);\n              }\n            });\n          })(arguments);\n\n          if (memory && !firing) {\n            fire();\n          }\n        }\n\n        return this;\n      },\n      // Remove a callback from the list\n      remove: function remove() {\n        jQuery.each(arguments, function (_, arg) {\n          var index;\n\n          while ((index = jQuery.inArray(arg, list, index)) > -1) {\n            list.splice(index, 1); // Handle firing indexes\n\n            if (index <= firingIndex) {\n              firingIndex--;\n            }\n          }\n        });\n        return this;\n      },\n      // Check if a given callback is in the list.\n      // If no argument is given, return whether or not list has callbacks attached.\n      has: function has(fn) {\n        return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;\n      },\n      // Remove all callbacks from the list\n      empty: function empty() {\n        if (list) {\n          list = [];\n        }\n\n        return this;\n      },\n      // Disable .fire and .add\n      // Abort any current/pending executions\n      // Clear all callbacks and values\n      disable: function disable() {\n        _locked = queue = [];\n        list = memory = \"\";\n        return this;\n      },\n      disabled: function disabled() {\n        return !list;\n      },\n      // Disable .fire\n      // Also disable .add unless we have memory (since it would have no effect)\n      // Abort any pending executions\n      lock: function lock() {\n        _locked = queue = [];\n\n        if (!memory && !firing) {\n          list = memory = \"\";\n        }\n\n        return this;\n      },\n      locked: function locked() {\n        return !!_locked;\n      },\n      // Call all callbacks with the given context and arguments\n      fireWith: function fireWith(context, args) {\n        if (!_locked) {\n          args = args || [];\n          args = [context, args.slice ? args.slice() : args];\n          queue.push(args);\n\n          if (!firing) {\n            fire();\n          }\n        }\n\n        return this;\n      },\n      // Call all the callbacks with the given arguments\n      fire: function fire() {\n        self.fireWith(this, arguments);\n        return this;\n      },\n      // To know if the callbacks have already been called at least once\n      fired: function fired() {\n        return !!_fired;\n      }\n    };\n\n    return self;\n  };\n\n  function Identity(v) {\n    return v;\n  }\n\n  function Thrower(ex) {\n    throw ex;\n  }\n\n  function adoptValue(value, resolve, reject, noValue) {\n    var method;\n\n    try {\n      // Check for promise aspect first to privilege synchronous behavior\n      if (value && isFunction(method = value.promise)) {\n        method.call(value).done(resolve).fail(reject); // Other thenables\n      } else if (value && isFunction(method = value.then)) {\n        method.call(value, resolve, reject); // Other non-thenables\n      } else {\n        // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n        // * false: [ value ].slice( 0 ) => resolve( value )\n        // * true: [ value ].slice( 1 ) => resolve()\n        resolve.apply(undefined, [value].slice(noValue));\n      } // For Promises/A+, convert exceptions into rejections\n      // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n      // Deferred#then to conditionally suppress rejection.\n\n    } catch (value) {\n      // Support: Android 4.0 only\n      // Strict mode functions invoked without .call/.apply get global-object context\n      reject.apply(undefined, [value]);\n    }\n  }\n\n  jQuery.extend({\n    Deferred: function Deferred(func) {\n      var tuples = [// action, add listener, callbacks,\n      // ... .then handlers, argument index, [final state]\n      [\"notify\", \"progress\", jQuery.Callbacks(\"memory\"), jQuery.Callbacks(\"memory\"), 2], [\"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), jQuery.Callbacks(\"once memory\"), 0, \"resolved\"], [\"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), jQuery.Callbacks(\"once memory\"), 1, \"rejected\"]],\n          _state = \"pending\",\n          _promise = {\n        state: function state() {\n          return _state;\n        },\n        always: function always() {\n          deferred.done(arguments).fail(arguments);\n          return this;\n        },\n        \"catch\": function _catch(fn) {\n          return _promise.then(null, fn);\n        },\n        // Keep pipe for back-compat\n        pipe: function pipe()\n        /* fnDone, fnFail, fnProgress */\n        {\n          var fns = arguments;\n          return jQuery.Deferred(function (newDefer) {\n            jQuery.each(tuples, function (i, tuple) {\n              // Map tuples (progress, done, fail) to arguments (done, fail, progress)\n              var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]]; // deferred.progress(function() { bind to newDefer or newDefer.notify })\n              // deferred.done(function() { bind to newDefer or newDefer.resolve })\n              // deferred.fail(function() { bind to newDefer or newDefer.reject })\n\n              deferred[tuple[1]](function () {\n                var returned = fn && fn.apply(this, arguments);\n\n                if (returned && isFunction(returned.promise)) {\n                  returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);\n                } else {\n                  newDefer[tuple[0] + \"With\"](this, fn ? [returned] : arguments);\n                }\n              });\n            });\n            fns = null;\n          }).promise();\n        },\n        then: function then(onFulfilled, onRejected, onProgress) {\n          var maxDepth = 0;\n\n          function resolve(depth, deferred, handler, special) {\n            return function () {\n              var that = this,\n                  args = arguments,\n                  mightThrow = function mightThrow() {\n                var returned, then; // Support: Promises/A+ section 2.3.3.3.3\n                // https://promisesaplus.com/#point-59\n                // Ignore double-resolution attempts\n\n                if (depth < maxDepth) {\n                  return;\n                }\n\n                returned = handler.apply(that, args); // Support: Promises/A+ section 2.3.1\n                // https://promisesaplus.com/#point-48\n\n                if (returned === deferred.promise()) {\n                  throw new TypeError(\"Thenable self-resolution\");\n                } // Support: Promises/A+ sections 2.3.3.1, 3.5\n                // https://promisesaplus.com/#point-54\n                // https://promisesaplus.com/#point-75\n                // Retrieve `then` only once\n\n\n                then = returned && ( // Support: Promises/A+ section 2.3.4\n                // https://promisesaplus.com/#point-64\n                // Only check objects and functions for thenability\n                _typeof(returned) === \"object\" || typeof returned === \"function\") && returned.then; // Handle a returned thenable\n\n                if (isFunction(then)) {\n                  // Special processors (notify) just wait for resolution\n                  if (special) {\n                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)); // Normal processors (resolve) also hook into progress\n                  } else {\n                    // ...and disregard older resolution values\n                    maxDepth++;\n                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));\n                  } // Handle all other returned values\n\n                } else {\n                  // Only substitute handlers pass on context\n                  // and multiple values (non-spec behavior)\n                  if (handler !== Identity) {\n                    that = undefined;\n                    args = [returned];\n                  } // Process the value(s)\n                  // Default process is resolve\n\n\n                  (special || deferred.resolveWith)(that, args);\n                }\n              },\n                  // Only normal processors (resolve) catch and reject exceptions\n              process = special ? mightThrow : function () {\n                try {\n                  mightThrow();\n                } catch (e) {\n                  if (jQuery.Deferred.exceptionHook) {\n                    jQuery.Deferred.exceptionHook(e, process.stackTrace);\n                  } // Support: Promises/A+ section 2.3.3.3.4.1\n                  // https://promisesaplus.com/#point-61\n                  // Ignore post-resolution exceptions\n\n\n                  if (depth + 1 >= maxDepth) {\n                    // Only substitute handlers pass on context\n                    // and multiple values (non-spec behavior)\n                    if (handler !== Thrower) {\n                      that = undefined;\n                      args = [e];\n                    }\n\n                    deferred.rejectWith(that, args);\n                  }\n                }\n              }; // Support: Promises/A+ section 2.3.3.3.1\n              // https://promisesaplus.com/#point-57\n              // Re-resolve promises immediately to dodge false rejection from\n              // subsequent errors\n\n\n              if (depth) {\n                process();\n              } else {\n                // Call an optional hook to record the stack, in case of exception\n                // since it's otherwise lost when execution goes async\n                if (jQuery.Deferred.getStackHook) {\n                  process.stackTrace = jQuery.Deferred.getStackHook();\n                }\n\n                window.setTimeout(process);\n              }\n            };\n          }\n\n          return jQuery.Deferred(function (newDefer) {\n            // progress_handlers.add( ... )\n            tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)); // fulfilled_handlers.add( ... )\n\n            tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity)); // rejected_handlers.add( ... )\n\n            tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));\n          }).promise();\n        },\n        // Get a promise for this deferred\n        // If obj is provided, the promise aspect is added to the object\n        promise: function promise(obj) {\n          return obj != null ? jQuery.extend(obj, _promise) : _promise;\n        }\n      },\n          deferred = {}; // Add list-specific methods\n\n      jQuery.each(tuples, function (i, tuple) {\n        var list = tuple[2],\n            stateString = tuple[5]; // promise.progress = list.add\n        // promise.done = list.add\n        // promise.fail = list.add\n\n        _promise[tuple[1]] = list.add; // Handle state\n\n        if (stateString) {\n          list.add(function () {\n            // state = \"resolved\" (i.e., fulfilled)\n            // state = \"rejected\"\n            _state = stateString;\n          }, // rejected_callbacks.disable\n          // fulfilled_callbacks.disable\n          tuples[3 - i][2].disable, // rejected_handlers.disable\n          // fulfilled_handlers.disable\n          tuples[3 - i][3].disable, // progress_callbacks.lock\n          tuples[0][2].lock, // progress_handlers.lock\n          tuples[0][3].lock);\n        } // progress_handlers.fire\n        // fulfilled_handlers.fire\n        // rejected_handlers.fire\n\n\n        list.add(tuple[3].fire); // deferred.notify = function() { deferred.notifyWith(...) }\n        // deferred.resolve = function() { deferred.resolveWith(...) }\n        // deferred.reject = function() { deferred.rejectWith(...) }\n\n        deferred[tuple[0]] = function () {\n          deferred[tuple[0] + \"With\"](this === deferred ? undefined : this, arguments);\n          return this;\n        }; // deferred.notifyWith = list.fireWith\n        // deferred.resolveWith = list.fireWith\n        // deferred.rejectWith = list.fireWith\n\n\n        deferred[tuple[0] + \"With\"] = list.fireWith;\n      }); // Make the deferred a promise\n\n      _promise.promise(deferred); // Call given func if any\n\n\n      if (func) {\n        func.call(deferred, deferred);\n      } // All done!\n\n\n      return deferred;\n    },\n    // Deferred helper\n    when: function when(singleValue) {\n      var // count of uncompleted subordinates\n      remaining = arguments.length,\n          // count of unprocessed arguments\n      i = remaining,\n          // subordinate fulfillment data\n      resolveContexts = Array(i),\n          resolveValues = _slice.call(arguments),\n          // the master Deferred\n      master = jQuery.Deferred(),\n          // subordinate callback factory\n      updateFunc = function updateFunc(i) {\n        return function (value) {\n          resolveContexts[i] = this;\n          resolveValues[i] = arguments.length > 1 ? _slice.call(arguments) : value;\n\n          if (! --remaining) {\n            master.resolveWith(resolveContexts, resolveValues);\n          }\n        };\n      }; // Single- and empty arguments are adopted like Promise.resolve\n\n\n      if (remaining <= 1) {\n        adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining); // Use .then() to unwrap secondary thenables (cf. gh-3000)\n\n        if (master.state() === \"pending\" || isFunction(resolveValues[i] && resolveValues[i].then)) {\n          return master.then();\n        }\n      } // Multiple arguments are aggregated like Promise.all array elements\n\n\n      while (i--) {\n        adoptValue(resolveValues[i], updateFunc(i), master.reject);\n      }\n\n      return master.promise();\n    }\n  }); // These usually indicate a programmer mistake during development,\n  // warn about them ASAP rather than swallowing them by default.\n\n  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\n  jQuery.Deferred.exceptionHook = function (error, stack) {\n    // Support: IE 8 - 9 only\n    // Console exists when dev tools are open, which can happen at any time\n    if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {\n      window.console.warn(\"jQuery.Deferred exception: \" + error.message, error.stack, stack);\n    }\n  };\n\n  jQuery.readyException = function (error) {\n    window.setTimeout(function () {\n      throw error;\n    });\n  }; // The deferred used on DOM ready\n\n\n  var readyList = jQuery.Deferred();\n\n  jQuery.fn.ready = function (fn) {\n    readyList.then(fn) // Wrap jQuery.readyException in a function so that the lookup\n    // happens at the time of error handling instead of callback\n    // registration.\n    [\"catch\"](function (error) {\n      jQuery.readyException(error);\n    });\n    return this;\n  };\n\n  jQuery.extend({\n    // Is the DOM ready to be used? Set to true once it occurs.\n    isReady: false,\n    // A counter to track how many items to wait for before\n    // the ready event fires. See #6781\n    readyWait: 1,\n    // Handle when the DOM is ready\n    ready: function ready(wait) {\n      // Abort if there are pending holds or we're already ready\n      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {\n        return;\n      } // Remember that the DOM is ready\n\n\n      jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be\n\n      if (wait !== true && --jQuery.readyWait > 0) {\n        return;\n      } // If there are functions bound, to execute\n\n\n      readyList.resolveWith(document, [jQuery]);\n    }\n  });\n  jQuery.ready.then = readyList.then; // The ready event handler and self cleanup method\n\n  function completed() {\n    document.removeEventListener(\"DOMContentLoaded\", completed);\n    window.removeEventListener(\"load\", completed);\n    jQuery.ready();\n  } // Catch cases where $(document).ready() is called\n  // after the browser event has already occurred.\n  // Support: IE <=9 - 10 only\n  // Older IE sometimes signals \"interactive\" too soon\n\n\n  if (document.readyState === \"complete\" || document.readyState !== \"loading\" && !document.documentElement.doScroll) {\n    // Handle it asynchronously to allow scripts the opportunity to delay ready\n    window.setTimeout(jQuery.ready);\n  } else {\n    // Use the handy event callback\n    document.addEventListener(\"DOMContentLoaded\", completed); // A fallback to window.onload, that will always work\n\n    window.addEventListener(\"load\", completed);\n  } // Multifunctional method to get and set values of a collection\n  // The value/s can optionally be executed if it's a function\n\n\n  var access = function access(elems, fn, key, value, chainable, emptyGet, raw) {\n    var i = 0,\n        len = elems.length,\n        bulk = key == null; // Sets many values\n\n    if (toType(key) === \"object\") {\n      chainable = true;\n\n      for (i in key) {\n        access(elems, fn, i, key[i], true, emptyGet, raw);\n      } // Sets one value\n\n    } else if (value !== undefined) {\n      chainable = true;\n\n      if (!isFunction(value)) {\n        raw = true;\n      }\n\n      if (bulk) {\n        // Bulk operations run against the entire set\n        if (raw) {\n          fn.call(elems, value);\n          fn = null; // ...except when executing function values\n        } else {\n          bulk = fn;\n\n          fn = function fn(elem, key, value) {\n            return bulk.call(jQuery(elem), value);\n          };\n        }\n      }\n\n      if (fn) {\n        for (; i < len; i++) {\n          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));\n        }\n      }\n    }\n\n    if (chainable) {\n      return elems;\n    } // Gets\n\n\n    if (bulk) {\n      return fn.call(elems);\n    }\n\n    return len ? fn(elems[0], key) : emptyGet;\n  }; // Matches dashed string for camelizing\n\n\n  var rmsPrefix = /^-ms-/,\n      rdashAlpha = /-([a-z])/g; // Used by camelCase as callback to replace()\n\n  function fcamelCase(all, letter) {\n    return letter.toUpperCase();\n  } // Convert dashed to camelCase; used by the css and data modules\n  // Support: IE <=9 - 11, Edge 12 - 15\n  // Microsoft forgot to hump their vendor prefix (#9572)\n\n\n  function camelCase(string) {\n    return string.replace(rmsPrefix, \"ms-\").replace(rdashAlpha, fcamelCase);\n  }\n\n  var acceptData = function acceptData(owner) {\n    // Accepts only:\n    //  - Node\n    //    - Node.ELEMENT_NODE\n    //    - Node.DOCUMENT_NODE\n    //  - Object\n    //    - Any\n    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;\n  };\n\n  function Data() {\n    this.expando = jQuery.expando + Data.uid++;\n  }\n\n  Data.uid = 1;\n  Data.prototype = {\n    cache: function cache(owner) {\n      // Check if the owner object already has a cache\n      var value = owner[this.expando]; // If not, create one\n\n      if (!value) {\n        value = {}; // We can accept data for non-element nodes in modern browsers,\n        // but we should not, see #8335.\n        // Always return an empty object.\n\n        if (acceptData(owner)) {\n          // If it is a node unlikely to be stringify-ed or looped over\n          // use plain assignment\n          if (owner.nodeType) {\n            owner[this.expando] = value; // Otherwise secure it in a non-enumerable property\n            // configurable must be true to allow the property to be\n            // deleted when data is removed\n          } else {\n            Object.defineProperty(owner, this.expando, {\n              value: value,\n              configurable: true\n            });\n          }\n        }\n      }\n\n      return value;\n    },\n    set: function set(owner, data, value) {\n      var prop,\n          cache = this.cache(owner); // Handle: [ owner, key, value ] args\n      // Always use camelCase key (gh-2257)\n\n      if (typeof data === \"string\") {\n        cache[camelCase(data)] = value; // Handle: [ owner, { properties } ] args\n      } else {\n        // Copy the properties one-by-one to the cache object\n        for (prop in data) {\n          cache[camelCase(prop)] = data[prop];\n        }\n      }\n\n      return cache;\n    },\n    get: function get(owner, key) {\n      return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)\n      owner[this.expando] && owner[this.expando][camelCase(key)];\n    },\n    access: function access(owner, key, value) {\n      // In cases where either:\n      //\n      //   1. No key was specified\n      //   2. A string key was specified, but no value provided\n      //\n      // Take the \"read\" path and allow the get method to determine\n      // which value to return, respectively either:\n      //\n      //   1. The entire cache object\n      //   2. The data stored at the key\n      //\n      if (key === undefined || key && typeof key === \"string\" && value === undefined) {\n        return this.get(owner, key);\n      } // When the key is not a string, or both a key and value\n      // are specified, set or extend (existing objects) with either:\n      //\n      //   1. An object of properties\n      //   2. A key and value\n      //\n\n\n      this.set(owner, key, value); // Since the \"set\" path can have two possible entry points\n      // return the expected data based on which path was taken[*]\n\n      return value !== undefined ? value : key;\n    },\n    remove: function remove(owner, key) {\n      var i,\n          cache = owner[this.expando];\n\n      if (cache === undefined) {\n        return;\n      }\n\n      if (key !== undefined) {\n        // Support array or space separated string of keys\n        if (Array.isArray(key)) {\n          // If key is an array of keys...\n          // We always set camelCase keys, so remove that.\n          key = key.map(camelCase);\n        } else {\n          key = camelCase(key); // If a key with the spaces exists, use it.\n          // Otherwise, create an array by matching non-whitespace\n\n          key = key in cache ? [key] : key.match(rnothtmlwhite) || [];\n        }\n\n        i = key.length;\n\n        while (i--) {\n          delete cache[key[i]];\n        }\n      } // Remove the expando if there's no more data\n\n\n      if (key === undefined || jQuery.isEmptyObject(cache)) {\n        // Support: Chrome <=35 - 45\n        // Webkit & Blink performance suffers when deleting properties\n        // from DOM nodes, so set to undefined instead\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n        if (owner.nodeType) {\n          owner[this.expando] = undefined;\n        } else {\n          delete owner[this.expando];\n        }\n      }\n    },\n    hasData: function hasData(owner) {\n      var cache = owner[this.expando];\n      return cache !== undefined && !jQuery.isEmptyObject(cache);\n    }\n  };\n  var dataPriv = new Data();\n  var dataUser = new Data(); //\tImplementation Summary\n  //\n  //\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n  //\t2. Improve the module's maintainability by reducing the storage\n  //\t\tpaths to a single mechanism.\n  //\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n  //\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n  //\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n  //\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\n  var rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n      rmultiDash = /[A-Z]/g;\n\n  function getData(data) {\n    if (data === \"true\") {\n      return true;\n    }\n\n    if (data === \"false\") {\n      return false;\n    }\n\n    if (data === \"null\") {\n      return null;\n    } // Only convert to a number if it doesn't change the string\n\n\n    if (data === +data + \"\") {\n      return +data;\n    }\n\n    if (rbrace.test(data)) {\n      return JSON.parse(data);\n    }\n\n    return data;\n  }\n\n  function dataAttr(elem, key, data) {\n    var name; // If nothing was found internally, try to fetch any\n    // data from the HTML5 data-* attribute\n\n    if (data === undefined && elem.nodeType === 1) {\n      name = \"data-\" + key.replace(rmultiDash, \"-$&\").toLowerCase();\n      data = elem.getAttribute(name);\n\n      if (typeof data === \"string\") {\n        try {\n          data = getData(data);\n        } catch (e) {} // Make sure we set the data so it isn't changed later\n\n\n        dataUser.set(elem, key, data);\n      } else {\n        data = undefined;\n      }\n    }\n\n    return data;\n  }\n\n  jQuery.extend({\n    hasData: function hasData(elem) {\n      return dataUser.hasData(elem) || dataPriv.hasData(elem);\n    },\n    data: function data(elem, name, _data) {\n      return dataUser.access(elem, name, _data);\n    },\n    removeData: function removeData(elem, name) {\n      dataUser.remove(elem, name);\n    },\n    // TODO: Now that all calls to _data and _removeData have been replaced\n    // with direct calls to dataPriv methods, these can be deprecated.\n    _data: function _data(elem, name, data) {\n      return dataPriv.access(elem, name, data);\n    },\n    _removeData: function _removeData(elem, name) {\n      dataPriv.remove(elem, name);\n    }\n  });\n  jQuery.fn.extend({\n    data: function data(key, value) {\n      var i,\n          name,\n          data,\n          elem = this[0],\n          attrs = elem && elem.attributes; // Gets all values\n\n      if (key === undefined) {\n        if (this.length) {\n          data = dataUser.get(elem);\n\n          if (elem.nodeType === 1 && !dataPriv.get(elem, \"hasDataAttrs\")) {\n            i = attrs.length;\n\n            while (i--) {\n              // Support: IE 11 only\n              // The attrs elements can be null (#14894)\n              if (attrs[i]) {\n                name = attrs[i].name;\n\n                if (name.indexOf(\"data-\") === 0) {\n                  name = camelCase(name.slice(5));\n                  dataAttr(elem, name, data[name]);\n                }\n              }\n            }\n\n            dataPriv.set(elem, \"hasDataAttrs\", true);\n          }\n        }\n\n        return data;\n      } // Sets multiple values\n\n\n      if (_typeof(key) === \"object\") {\n        return this.each(function () {\n          dataUser.set(this, key);\n        });\n      }\n\n      return access(this, function (value) {\n        var data; // The calling jQuery object (element matches) is not empty\n        // (and therefore has an element appears at this[ 0 ]) and the\n        // `value` parameter was not undefined. An empty jQuery object\n        // will result in `undefined` for elem = this[ 0 ] which will\n        // throw an exception if an attempt to read a data cache is made.\n\n        if (elem && value === undefined) {\n          // Attempt to get data from the cache\n          // The key will always be camelCased in Data\n          data = dataUser.get(elem, key);\n\n          if (data !== undefined) {\n            return data;\n          } // Attempt to \"discover\" the data in\n          // HTML5 custom data-* attrs\n\n\n          data = dataAttr(elem, key);\n\n          if (data !== undefined) {\n            return data;\n          } // We tried really hard, but the data doesn't exist.\n\n\n          return;\n        } // Set the data...\n\n\n        this.each(function () {\n          // We always store the camelCased key\n          dataUser.set(this, key, value);\n        });\n      }, null, value, arguments.length > 1, null, true);\n    },\n    removeData: function removeData(key) {\n      return this.each(function () {\n        dataUser.remove(this, key);\n      });\n    }\n  });\n  jQuery.extend({\n    queue: function queue(elem, type, data) {\n      var queue;\n\n      if (elem) {\n        type = (type || \"fx\") + \"queue\";\n        queue = dataPriv.get(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup\n\n        if (data) {\n          if (!queue || Array.isArray(data)) {\n            queue = dataPriv.access(elem, type, jQuery.makeArray(data));\n          } else {\n            queue.push(data);\n          }\n        }\n\n        return queue || [];\n      }\n    },\n    dequeue: function dequeue(elem, type) {\n      type = type || \"fx\";\n\n      var queue = jQuery.queue(elem, type),\n          startLength = queue.length,\n          fn = queue.shift(),\n          hooks = jQuery._queueHooks(elem, type),\n          next = function next() {\n        jQuery.dequeue(elem, type);\n      }; // If the fx queue is dequeued, always remove the progress sentinel\n\n\n      if (fn === \"inprogress\") {\n        fn = queue.shift();\n        startLength--;\n      }\n\n      if (fn) {\n        // Add a progress sentinel to prevent the fx queue from being\n        // automatically dequeued\n        if (type === \"fx\") {\n          queue.unshift(\"inprogress\");\n        } // Clear up the last queue stop function\n\n\n        delete hooks.stop;\n        fn.call(elem, next, hooks);\n      }\n\n      if (!startLength && hooks) {\n        hooks.empty.fire();\n      }\n    },\n    // Not public - generate a queueHooks object, or return the current one\n    _queueHooks: function _queueHooks(elem, type) {\n      var key = type + \"queueHooks\";\n      return dataPriv.get(elem, key) || dataPriv.access(elem, key, {\n        empty: jQuery.Callbacks(\"once memory\").add(function () {\n          dataPriv.remove(elem, [type + \"queue\", key]);\n        })\n      });\n    }\n  });\n  jQuery.fn.extend({\n    queue: function queue(type, data) {\n      var setter = 2;\n\n      if (typeof type !== \"string\") {\n        data = type;\n        type = \"fx\";\n        setter--;\n      }\n\n      if (arguments.length < setter) {\n        return jQuery.queue(this[0], type);\n      }\n\n      return data === undefined ? this : this.each(function () {\n        var queue = jQuery.queue(this, type, data); // Ensure a hooks for this queue\n\n        jQuery._queueHooks(this, type);\n\n        if (type === \"fx\" && queue[0] !== \"inprogress\") {\n          jQuery.dequeue(this, type);\n        }\n      });\n    },\n    dequeue: function dequeue(type) {\n      return this.each(function () {\n        jQuery.dequeue(this, type);\n      });\n    },\n    clearQueue: function clearQueue(type) {\n      return this.queue(type || \"fx\", []);\n    },\n    // Get a promise resolved when queues of a certain type\n    // are emptied (fx is the type by default)\n    promise: function promise(type, obj) {\n      var tmp,\n          count = 1,\n          defer = jQuery.Deferred(),\n          elements = this,\n          i = this.length,\n          resolve = function resolve() {\n        if (! --count) {\n          defer.resolveWith(elements, [elements]);\n        }\n      };\n\n      if (typeof type !== \"string\") {\n        obj = type;\n        type = undefined;\n      }\n\n      type = type || \"fx\";\n\n      while (i--) {\n        tmp = dataPriv.get(elements[i], type + \"queueHooks\");\n\n        if (tmp && tmp.empty) {\n          count++;\n          tmp.empty.add(resolve);\n        }\n      }\n\n      resolve();\n      return defer.promise(obj);\n    }\n  });\n  var pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\n  var rcssNum = new RegExp(\"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\");\n  var cssExpand = [\"Top\", \"Right\", \"Bottom\", \"Left\"];\n  var documentElement = document.documentElement;\n\n  var isAttached = function isAttached(elem) {\n    return jQuery.contains(elem.ownerDocument, elem);\n  },\n      composed = {\n    composed: true\n  }; // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only\n  // Check attachment across shadow DOM boundaries when possible (gh-3504)\n  // Support: iOS 10.0-10.2 only\n  // Early iOS 10 versions support `attachShadow` but not `getRootNode`,\n  // leading to errors. We need to check for `getRootNode`.\n\n\n  if (documentElement.getRootNode) {\n    isAttached = function isAttached(elem) {\n      return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;\n    };\n  }\n\n  var isHiddenWithinTree = function isHiddenWithinTree(elem, el) {\n    // isHiddenWithinTree might be called from jQuery#filter function;\n    // in that case, element will be second argument\n    elem = el || elem; // Inline style trumps all\n\n    return elem.style.display === \"none\" || elem.style.display === \"\" && // Otherwise, check computed style\n    // Support: Firefox <=43 - 45\n    // Disconnected elements can have computed display: none, so first confirm that elem is\n    // in the document.\n    isAttached(elem) && jQuery.css(elem, \"display\") === \"none\";\n  };\n\n  var swap = function swap(elem, options, callback, args) {\n    var ret,\n        name,\n        old = {}; // Remember the old values, and insert the new ones\n\n    for (name in options) {\n      old[name] = elem.style[name];\n      elem.style[name] = options[name];\n    }\n\n    ret = callback.apply(elem, args || []); // Revert the old values\n\n    for (name in options) {\n      elem.style[name] = old[name];\n    }\n\n    return ret;\n  };\n\n  function adjustCSS(elem, prop, valueParts, tween) {\n    var adjusted,\n        scale,\n        maxIterations = 20,\n        currentValue = tween ? function () {\n      return tween.cur();\n    } : function () {\n      return jQuery.css(elem, prop, \"\");\n    },\n        initial = currentValue(),\n        unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? \"\" : \"px\"),\n        // Starting value computation is required for potential unit mismatches\n    initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== \"px\" && +initial) && rcssNum.exec(jQuery.css(elem, prop));\n\n    if (initialInUnit && initialInUnit[3] !== unit) {\n      // Support: Firefox <=54\n      // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n      initial = initial / 2; // Trust units reported by jQuery.css\n\n      unit = unit || initialInUnit[3]; // Iteratively approximate from a nonzero starting point\n\n      initialInUnit = +initial || 1;\n\n      while (maxIterations--) {\n        // Evaluate and update our best guess (doubling guesses that zero out).\n        // Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n        jQuery.style(elem, prop, initialInUnit + unit);\n\n        if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {\n          maxIterations = 0;\n        }\n\n        initialInUnit = initialInUnit / scale;\n      }\n\n      initialInUnit = initialInUnit * 2;\n      jQuery.style(elem, prop, initialInUnit + unit); // Make sure we update the tween properties later on\n\n      valueParts = valueParts || [];\n    }\n\n    if (valueParts) {\n      initialInUnit = +initialInUnit || +initial || 0; // Apply relative offset (+=/-=) if specified\n\n      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];\n\n      if (tween) {\n        tween.unit = unit;\n        tween.start = initialInUnit;\n        tween.end = adjusted;\n      }\n    }\n\n    return adjusted;\n  }\n\n  var defaultDisplayMap = {};\n\n  function getDefaultDisplay(elem) {\n    var temp,\n        doc = elem.ownerDocument,\n        nodeName = elem.nodeName,\n        display = defaultDisplayMap[nodeName];\n\n    if (display) {\n      return display;\n    }\n\n    temp = doc.body.appendChild(doc.createElement(nodeName));\n    display = jQuery.css(temp, \"display\");\n    temp.parentNode.removeChild(temp);\n\n    if (display === \"none\") {\n      display = \"block\";\n    }\n\n    defaultDisplayMap[nodeName] = display;\n    return display;\n  }\n\n  function showHide(elements, show) {\n    var display,\n        elem,\n        values = [],\n        index = 0,\n        length = elements.length; // Determine new display value for elements that need to change\n\n    for (; index < length; index++) {\n      elem = elements[index];\n\n      if (!elem.style) {\n        continue;\n      }\n\n      display = elem.style.display;\n\n      if (show) {\n        // Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n        // check is required in this first loop unless we have a nonempty display value (either\n        // inline or about-to-be-restored)\n        if (display === \"none\") {\n          values[index] = dataPriv.get(elem, \"display\") || null;\n\n          if (!values[index]) {\n            elem.style.display = \"\";\n          }\n        }\n\n        if (elem.style.display === \"\" && isHiddenWithinTree(elem)) {\n          values[index] = getDefaultDisplay(elem);\n        }\n      } else {\n        if (display !== \"none\") {\n          values[index] = \"none\"; // Remember what we're overwriting\n\n          dataPriv.set(elem, \"display\", display);\n        }\n      }\n    } // Set the display of the elements in a second loop to avoid constant reflow\n\n\n    for (index = 0; index < length; index++) {\n      if (values[index] != null) {\n        elements[index].style.display = values[index];\n      }\n    }\n\n    return elements;\n  }\n\n  jQuery.fn.extend({\n    show: function show() {\n      return showHide(this, true);\n    },\n    hide: function hide() {\n      return showHide(this);\n    },\n    toggle: function toggle(state) {\n      if (typeof state === \"boolean\") {\n        return state ? this.show() : this.hide();\n      }\n\n      return this.each(function () {\n        if (isHiddenWithinTree(this)) {\n          jQuery(this).show();\n        } else {\n          jQuery(this).hide();\n        }\n      });\n    }\n  });\n  var rcheckableType = /^(?:checkbox|radio)$/i;\n  var rtagName = /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i;\n  var rscriptType = /^$|^module$|\\/(?:java|ecma)script/i; // We have to close these tags to support XHTML (#13200)\n\n  var wrapMap = {\n    // Support: IE <=9 only\n    option: [1, \"<select multiple='multiple'>\", \"</select>\"],\n    // XHTML parsers do not magically insert elements in the\n    // same way that tag soup parsers do. So we cannot shorten\n    // this by omitting <tbody> or other required elements.\n    thead: [1, \"<table>\", \"</table>\"],\n    col: [2, \"<table><colgroup>\", \"</colgroup></table>\"],\n    tr: [2, \"<table><tbody>\", \"</tbody></table>\"],\n    td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"],\n    _default: [0, \"\", \"\"]\n  }; // Support: IE <=9 only\n\n  wrapMap.optgroup = wrapMap.option;\n  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n  wrapMap.th = wrapMap.td;\n\n  function getAll(context, tag) {\n    // Support: IE <=9 - 11 only\n    // Use typeof to avoid zero-argument method invocation on host objects (#15151)\n    var ret;\n\n    if (typeof context.getElementsByTagName !== \"undefined\") {\n      ret = context.getElementsByTagName(tag || \"*\");\n    } else if (typeof context.querySelectorAll !== \"undefined\") {\n      ret = context.querySelectorAll(tag || \"*\");\n    } else {\n      ret = [];\n    }\n\n    if (tag === undefined || tag && nodeName(context, tag)) {\n      return jQuery.merge([context], ret);\n    }\n\n    return ret;\n  } // Mark scripts as having already been evaluated\n\n\n  function setGlobalEval(elems, refElements) {\n    var i = 0,\n        l = elems.length;\n\n    for (; i < l; i++) {\n      dataPriv.set(elems[i], \"globalEval\", !refElements || dataPriv.get(refElements[i], \"globalEval\"));\n    }\n  }\n\n  var rhtml = /<|&#?\\w+;/;\n\n  function buildFragment(elems, context, scripts, selection, ignored) {\n    var elem,\n        tmp,\n        tag,\n        wrap,\n        attached,\n        j,\n        fragment = context.createDocumentFragment(),\n        nodes = [],\n        i = 0,\n        l = elems.length;\n\n    for (; i < l; i++) {\n      elem = elems[i];\n\n      if (elem || elem === 0) {\n        // Add nodes directly\n        if (toType(elem) === \"object\") {\n          // Support: Android <=4.0 only, PhantomJS 1 only\n          // push.apply(_, arraylike) throws on ancient WebKit\n          jQuery.merge(nodes, elem.nodeType ? [elem] : elem); // Convert non-html into a text node\n        } else if (!rhtml.test(elem)) {\n          nodes.push(context.createTextNode(elem)); // Convert html into DOM nodes\n        } else {\n          tmp = tmp || fragment.appendChild(context.createElement(\"div\")); // Deserialize a standard representation\n\n          tag = (rtagName.exec(elem) || [\"\", \"\"])[1].toLowerCase();\n          wrap = wrapMap[tag] || wrapMap._default;\n          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]; // Descend through wrappers to the right content\n\n          j = wrap[0];\n\n          while (j--) {\n            tmp = tmp.lastChild;\n          } // Support: Android <=4.0 only, PhantomJS 1 only\n          // push.apply(_, arraylike) throws on ancient WebKit\n\n\n          jQuery.merge(nodes, tmp.childNodes); // Remember the top-level container\n\n          tmp = fragment.firstChild; // Ensure the created nodes are orphaned (#12392)\n\n          tmp.textContent = \"\";\n        }\n      }\n    } // Remove wrapper from fragment\n\n\n    fragment.textContent = \"\";\n    i = 0;\n\n    while (elem = nodes[i++]) {\n      // Skip elements already in the context collection (trac-4087)\n      if (selection && jQuery.inArray(elem, selection) > -1) {\n        if (ignored) {\n          ignored.push(elem);\n        }\n\n        continue;\n      }\n\n      attached = isAttached(elem); // Append to fragment\n\n      tmp = getAll(fragment.appendChild(elem), \"script\"); // Preserve script evaluation history\n\n      if (attached) {\n        setGlobalEval(tmp);\n      } // Capture executables\n\n\n      if (scripts) {\n        j = 0;\n\n        while (elem = tmp[j++]) {\n          if (rscriptType.test(elem.type || \"\")) {\n            scripts.push(elem);\n          }\n        }\n      }\n    }\n\n    return fragment;\n  }\n\n  (function () {\n    var fragment = document.createDocumentFragment(),\n        div = fragment.appendChild(document.createElement(\"div\")),\n        input = document.createElement(\"input\"); // Support: Android 4.0 - 4.3 only\n    // Check state lost if the name is set (#11217)\n    // Support: Windows Web Apps (WWA)\n    // `name` and `type` must use .setAttribute for WWA (#14901)\n\n    input.setAttribute(\"type\", \"radio\");\n    input.setAttribute(\"checked\", \"checked\");\n    input.setAttribute(\"name\", \"t\");\n    div.appendChild(input); // Support: Android <=4.1 only\n    // Older WebKit doesn't clone checked state correctly in fragments\n\n    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked; // Support: IE <=11 only\n    // Make sure textarea (and checkbox) defaultValue is properly cloned\n\n    div.innerHTML = \"<textarea>x</textarea>\";\n    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;\n  })();\n\n  var rkeyEvent = /^key/,\n      rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n      rtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\n  function returnTrue() {\n    return true;\n  }\n\n  function returnFalse() {\n    return false;\n  } // Support: IE <=9 - 11+\n  // focus() and blur() are asynchronous, except when they are no-op.\n  // So expect focus to be synchronous when the element is already active,\n  // and blur to be synchronous when the element is not already active.\n  // (focus and blur are always synchronous in other supported browsers,\n  // this just defines when we can count on it).\n\n\n  function expectSync(elem, type) {\n    return elem === safeActiveElement() === (type === \"focus\");\n  } // Support: IE <=9 only\n  // Accessing document.activeElement can throw unexpectedly\n  // https://bugs.jquery.com/ticket/13393\n\n\n  function safeActiveElement() {\n    try {\n      return document.activeElement;\n    } catch (err) {}\n  }\n\n  function _on(elem, types, selector, data, fn, one) {\n    var origFn, type; // Types can be a map of types/handlers\n\n    if (_typeof(types) === \"object\") {\n      // ( types-Object, selector, data )\n      if (typeof selector !== \"string\") {\n        // ( types-Object, data )\n        data = data || selector;\n        selector = undefined;\n      }\n\n      for (type in types) {\n        _on(elem, type, selector, data, types[type], one);\n      }\n\n      return elem;\n    }\n\n    if (data == null && fn == null) {\n      // ( types, fn )\n      fn = selector;\n      data = selector = undefined;\n    } else if (fn == null) {\n      if (typeof selector === \"string\") {\n        // ( types, selector, fn )\n        fn = data;\n        data = undefined;\n      } else {\n        // ( types, data, fn )\n        fn = data;\n        data = selector;\n        selector = undefined;\n      }\n    }\n\n    if (fn === false) {\n      fn = returnFalse;\n    } else if (!fn) {\n      return elem;\n    }\n\n    if (one === 1) {\n      origFn = fn;\n\n      fn = function fn(event) {\n        // Can use an empty set, since event contains the info\n        jQuery().off(event);\n        return origFn.apply(this, arguments);\n      }; // Use same guid so caller can remove using origFn\n\n\n      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);\n    }\n\n    return elem.each(function () {\n      jQuery.event.add(this, types, fn, data, selector);\n    });\n  }\n  /*\n   * Helper functions for managing events -- not part of the public interface.\n   * Props to Dean Edwards' addEvent library for many of the ideas.\n   */\n\n\n  jQuery.event = {\n    global: {},\n    add: function add(elem, types, handler, data, selector) {\n      var handleObjIn,\n          eventHandle,\n          tmp,\n          events,\n          t,\n          handleObj,\n          special,\n          handlers,\n          type,\n          namespaces,\n          origType,\n          elemData = dataPriv.get(elem); // Don't attach events to noData or text/comment nodes (but allow plain objects)\n\n      if (!elemData) {\n        return;\n      } // Caller can pass in an object of custom data in lieu of the handler\n\n\n      if (handler.handler) {\n        handleObjIn = handler;\n        handler = handleObjIn.handler;\n        selector = handleObjIn.selector;\n      } // Ensure that invalid selectors throw exceptions at attach time\n      // Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\n\n      if (selector) {\n        jQuery.find.matchesSelector(documentElement, selector);\n      } // Make sure that the handler has a unique ID, used to find/remove it later\n\n\n      if (!handler.guid) {\n        handler.guid = jQuery.guid++;\n      } // Init the element's event structure and main handler, if this is the first\n\n\n      if (!(events = elemData.events)) {\n        events = elemData.events = {};\n      }\n\n      if (!(eventHandle = elemData.handle)) {\n        eventHandle = elemData.handle = function (e) {\n          // Discard the second event of a jQuery.event.trigger() and\n          // when an event is called after a page has unloaded\n          return typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;\n        };\n      } // Handle multiple events separated by a space\n\n\n      types = (types || \"\").match(rnothtmlwhite) || [\"\"];\n      t = types.length;\n\n      while (t--) {\n        tmp = rtypenamespace.exec(types[t]) || [];\n        type = origType = tmp[1];\n        namespaces = (tmp[2] || \"\").split(\".\").sort(); // There *must* be a type, no attaching namespace-only handlers\n\n        if (!type) {\n          continue;\n        } // If event changes its type, use the special event handlers for the changed type\n\n\n        special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type\n\n        type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type\n\n        special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers\n\n        handleObj = jQuery.extend({\n          type: type,\n          origType: origType,\n          data: data,\n          handler: handler,\n          guid: handler.guid,\n          selector: selector,\n          needsContext: selector && jQuery.expr.match.needsContext.test(selector),\n          namespace: namespaces.join(\".\")\n        }, handleObjIn); // Init the event handler queue if we're the first\n\n        if (!(handlers = events[type])) {\n          handlers = events[type] = [];\n          handlers.delegateCount = 0; // Only use addEventListener if the special events handler returns false\n\n          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {\n            if (elem.addEventListener) {\n              elem.addEventListener(type, eventHandle);\n            }\n          }\n        }\n\n        if (special.add) {\n          special.add.call(elem, handleObj);\n\n          if (!handleObj.handler.guid) {\n            handleObj.handler.guid = handler.guid;\n          }\n        } // Add to the element's handler list, delegates in front\n\n\n        if (selector) {\n          handlers.splice(handlers.delegateCount++, 0, handleObj);\n        } else {\n          handlers.push(handleObj);\n        } // Keep track of which events have ever been used, for event optimization\n\n\n        jQuery.event.global[type] = true;\n      }\n    },\n    // Detach an event or set of events from an element\n    remove: function remove(elem, types, handler, selector, mappedTypes) {\n      var j,\n          origCount,\n          tmp,\n          events,\n          t,\n          handleObj,\n          special,\n          handlers,\n          type,\n          namespaces,\n          origType,\n          elemData = dataPriv.hasData(elem) && dataPriv.get(elem);\n\n      if (!elemData || !(events = elemData.events)) {\n        return;\n      } // Once for each type.namespace in types; type may be omitted\n\n\n      types = (types || \"\").match(rnothtmlwhite) || [\"\"];\n      t = types.length;\n\n      while (t--) {\n        tmp = rtypenamespace.exec(types[t]) || [];\n        type = origType = tmp[1];\n        namespaces = (tmp[2] || \"\").split(\".\").sort(); // Unbind all events (on this namespace, if provided) for the element\n\n        if (!type) {\n          for (type in events) {\n            jQuery.event.remove(elem, type + types[t], handler, selector, true);\n          }\n\n          continue;\n        }\n\n        special = jQuery.event.special[type] || {};\n        type = (selector ? special.delegateType : special.bindType) || type;\n        handlers = events[type] || [];\n        tmp = tmp[2] && new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\"); // Remove matching events\n\n        origCount = j = handlers.length;\n\n        while (j--) {\n          handleObj = handlers[j];\n\n          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector)) {\n            handlers.splice(j, 1);\n\n            if (handleObj.selector) {\n              handlers.delegateCount--;\n            }\n\n            if (special.remove) {\n              special.remove.call(elem, handleObj);\n            }\n          }\n        } // Remove generic event handler if we removed something and no more handlers exist\n        // (avoids potential for endless recursion during removal of special event handlers)\n\n\n        if (origCount && !handlers.length) {\n          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {\n            jQuery.removeEvent(elem, type, elemData.handle);\n          }\n\n          delete events[type];\n        }\n      } // Remove data and the expando if it's no longer used\n\n\n      if (jQuery.isEmptyObject(events)) {\n        dataPriv.remove(elem, \"handle events\");\n      }\n    },\n    dispatch: function dispatch(nativeEvent) {\n      // Make a writable jQuery.Event from the native event object\n      var event = jQuery.event.fix(nativeEvent);\n      var i,\n          j,\n          ret,\n          matched,\n          handleObj,\n          handlerQueue,\n          args = new Array(arguments.length),\n          handlers = (dataPriv.get(this, \"events\") || {})[event.type] || [],\n          special = jQuery.event.special[event.type] || {}; // Use the fix-ed jQuery.Event rather than the (read-only) native event\n\n      args[0] = event;\n\n      for (i = 1; i < arguments.length; i++) {\n        args[i] = arguments[i];\n      }\n\n      event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired\n\n      if (special.preDispatch && special.preDispatch.call(this, event) === false) {\n        return;\n      } // Determine handlers\n\n\n      handlerQueue = jQuery.event.handlers.call(this, event, handlers); // Run delegates first; they may want to stop propagation beneath us\n\n      i = 0;\n\n      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\n        event.currentTarget = matched.elem;\n        j = 0;\n\n        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {\n          // If the event is namespaced, then each handler is only invoked if it is\n          // specially universal or its namespaces are a superset of the event's.\n          if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {\n            event.handleObj = handleObj;\n            event.data = handleObj.data;\n            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);\n\n            if (ret !== undefined) {\n              if ((event.result = ret) === false) {\n                event.preventDefault();\n                event.stopPropagation();\n              }\n            }\n          }\n        }\n      } // Call the postDispatch hook for the mapped type\n\n\n      if (special.postDispatch) {\n        special.postDispatch.call(this, event);\n      }\n\n      return event.result;\n    },\n    handlers: function handlers(event, _handlers) {\n      var i,\n          handleObj,\n          sel,\n          matchedHandlers,\n          matchedSelectors,\n          handlerQueue = [],\n          delegateCount = _handlers.delegateCount,\n          cur = event.target; // Find delegate handlers\n\n      if (delegateCount && // Support: IE <=9\n      // Black-hole SVG <use> instance trees (trac-13180)\n      cur.nodeType && // Support: Firefox <=42\n      // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n      // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n      // Support: IE 11 only\n      // ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n      !(event.type === \"click\" && event.button >= 1)) {\n        for (; cur !== this; cur = cur.parentNode || this) {\n          // Don't check non-elements (#13208)\n          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n          if (cur.nodeType === 1 && !(event.type === \"click\" && cur.disabled === true)) {\n            matchedHandlers = [];\n            matchedSelectors = {};\n\n            for (i = 0; i < delegateCount; i++) {\n              handleObj = _handlers[i]; // Don't conflict with Object.prototype properties (#13203)\n\n              sel = handleObj.selector + \" \";\n\n              if (matchedSelectors[sel] === undefined) {\n                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;\n              }\n\n              if (matchedSelectors[sel]) {\n                matchedHandlers.push(handleObj);\n              }\n            }\n\n            if (matchedHandlers.length) {\n              handlerQueue.push({\n                elem: cur,\n                handlers: matchedHandlers\n              });\n            }\n          }\n        }\n      } // Add the remaining (directly-bound) handlers\n\n\n      cur = this;\n\n      if (delegateCount < _handlers.length) {\n        handlerQueue.push({\n          elem: cur,\n          handlers: _handlers.slice(delegateCount)\n        });\n      }\n\n      return handlerQueue;\n    },\n    addProp: function addProp(name, hook) {\n      Object.defineProperty(jQuery.Event.prototype, name, {\n        enumerable: true,\n        configurable: true,\n        get: isFunction(hook) ? function () {\n          if (this.originalEvent) {\n            return hook(this.originalEvent);\n          }\n        } : function () {\n          if (this.originalEvent) {\n            return this.originalEvent[name];\n          }\n        },\n        set: function set(value) {\n          Object.defineProperty(this, name, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: value\n          });\n        }\n      });\n    },\n    fix: function fix(originalEvent) {\n      return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);\n    },\n    special: {\n      load: {\n        // Prevent triggered image.load events from bubbling to window.load\n        noBubble: true\n      },\n      click: {\n        // Utilize native event to ensure correct state for checkable inputs\n        setup: function setup(data) {\n          // For mutual compressibility with _default, replace `this` access with a local var.\n          // `|| data` is dead code meant only to preserve the variable through minification.\n          var el = this || data; // Claim the first handler\n\n          if (rcheckableType.test(el.type) && el.click && nodeName(el, \"input\")) {\n            // dataPriv.set( el, \"click\", ... )\n            leverageNative(el, \"click\", returnTrue);\n          } // Return false to allow normal processing in the caller\n\n\n          return false;\n        },\n        trigger: function trigger(data) {\n          // For mutual compressibility with _default, replace `this` access with a local var.\n          // `|| data` is dead code meant only to preserve the variable through minification.\n          var el = this || data; // Force setup before triggering a click\n\n          if (rcheckableType.test(el.type) && el.click && nodeName(el, \"input\")) {\n            leverageNative(el, \"click\");\n          } // Return non-false to allow normal event-path propagation\n\n\n          return true;\n        },\n        // For cross-browser consistency, suppress native .click() on links\n        // Also prevent it if we're currently inside a leveraged native-event stack\n        _default: function _default(event) {\n          var target = event.target;\n          return rcheckableType.test(target.type) && target.click && nodeName(target, \"input\") && dataPriv.get(target, \"click\") || nodeName(target, \"a\");\n        }\n      },\n      beforeunload: {\n        postDispatch: function postDispatch(event) {\n          // Support: Firefox 20+\n          // Firefox doesn't alert if the returnValue field is not set.\n          if (event.result !== undefined && event.originalEvent) {\n            event.originalEvent.returnValue = event.result;\n          }\n        }\n      }\n    }\n  }; // Ensure the presence of an event listener that handles manually-triggered\n  // synthetic events by interrupting progress until reinvoked in response to\n  // *native* events that it fires directly, ensuring that state changes have\n  // already occurred before other listeners are invoked.\n\n  function leverageNative(el, type, expectSync) {\n    // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add\n    if (!expectSync) {\n      if (dataPriv.get(el, type) === undefined) {\n        jQuery.event.add(el, type, returnTrue);\n      }\n\n      return;\n    } // Register the controller as a special universal handler for all event namespaces\n\n\n    dataPriv.set(el, type, false);\n    jQuery.event.add(el, type, {\n      namespace: false,\n      handler: function handler(event) {\n        var notAsync,\n            result,\n            saved = dataPriv.get(this, type);\n\n        if (event.isTrigger & 1 && this[type]) {\n          // Interrupt processing of the outer synthetic .trigger()ed event\n          // Saved data should be false in such cases, but might be a leftover capture object\n          // from an async native handler (gh-4350)\n          if (!saved.length) {\n            // Store arguments for use when handling the inner native event\n            // There will always be at least one argument (an event object), so this array\n            // will not be confused with a leftover capture object.\n            saved = _slice.call(arguments);\n            dataPriv.set(this, type, saved); // Trigger the native event and capture its result\n            // Support: IE <=9 - 11+\n            // focus() and blur() are asynchronous\n\n            notAsync = expectSync(this, type);\n            this[type]();\n            result = dataPriv.get(this, type);\n\n            if (saved !== result || notAsync) {\n              dataPriv.set(this, type, false);\n            } else {\n              result = {};\n            }\n\n            if (saved !== result) {\n              // Cancel the outer synthetic event\n              event.stopImmediatePropagation();\n              event.preventDefault();\n              return result.value;\n            } // If this is an inner synthetic event for an event with a bubbling surrogate\n            // (focus or blur), assume that the surrogate already propagated from triggering the\n            // native event and prevent that from happening again here.\n            // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the\n            // bubbling surrogate propagates *after* the non-bubbling base), but that seems\n            // less bad than duplication.\n\n          } else if ((jQuery.event.special[type] || {}).delegateType) {\n            event.stopPropagation();\n          } // If this is a native event triggered above, everything is now in order\n          // Fire an inner synthetic event with the original arguments\n\n        } else if (saved.length) {\n          // ...and capture the result\n          dataPriv.set(this, type, {\n            value: jQuery.event.trigger( // Support: IE <=9 - 11+\n            // Extend with the prototype to reset the above stopImmediatePropagation()\n            jQuery.extend(saved[0], jQuery.Event.prototype), saved.slice(1), this)\n          }); // Abort handling of the native event\n\n          event.stopImmediatePropagation();\n        }\n      }\n    });\n  }\n\n  jQuery.removeEvent = function (elem, type, handle) {\n    // This \"if\" is needed for plain objects\n    if (elem.removeEventListener) {\n      elem.removeEventListener(type, handle);\n    }\n  };\n\n  jQuery.Event = function (src, props) {\n    // Allow instantiation without the 'new' keyword\n    if (!(this instanceof jQuery.Event)) {\n      return new jQuery.Event(src, props);\n    } // Event object\n\n\n    if (src && src.type) {\n      this.originalEvent = src;\n      this.type = src.type; // Events bubbling up the document may have been marked as prevented\n      // by a handler lower down the tree; reflect the correct value.\n\n      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only\n      src.returnValue === false ? returnTrue : returnFalse; // Create target properties\n      // Support: Safari <=6 - 7 only\n      // Target should not be a text node (#504, #13143)\n\n      this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;\n      this.currentTarget = src.currentTarget;\n      this.relatedTarget = src.relatedTarget; // Event type\n    } else {\n      this.type = src;\n    } // Put explicitly provided properties onto the event object\n\n\n    if (props) {\n      jQuery.extend(this, props);\n    } // Create a timestamp if incoming event doesn't have one\n\n\n    this.timeStamp = src && src.timeStamp || Date.now(); // Mark it as fixed\n\n    this[jQuery.expando] = true;\n  }; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n  // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\n\n  jQuery.Event.prototype = {\n    constructor: jQuery.Event,\n    isDefaultPrevented: returnFalse,\n    isPropagationStopped: returnFalse,\n    isImmediatePropagationStopped: returnFalse,\n    isSimulated: false,\n    preventDefault: function preventDefault() {\n      var e = this.originalEvent;\n      this.isDefaultPrevented = returnTrue;\n\n      if (e && !this.isSimulated) {\n        e.preventDefault();\n      }\n    },\n    stopPropagation: function stopPropagation() {\n      var e = this.originalEvent;\n      this.isPropagationStopped = returnTrue;\n\n      if (e && !this.isSimulated) {\n        e.stopPropagation();\n      }\n    },\n    stopImmediatePropagation: function stopImmediatePropagation() {\n      var e = this.originalEvent;\n      this.isImmediatePropagationStopped = returnTrue;\n\n      if (e && !this.isSimulated) {\n        e.stopImmediatePropagation();\n      }\n\n      this.stopPropagation();\n    }\n  }; // Includes all common event props including KeyEvent and MouseEvent specific props\n\n  jQuery.each({\n    altKey: true,\n    bubbles: true,\n    cancelable: true,\n    changedTouches: true,\n    ctrlKey: true,\n    detail: true,\n    eventPhase: true,\n    metaKey: true,\n    pageX: true,\n    pageY: true,\n    shiftKey: true,\n    view: true,\n    \"char\": true,\n    code: true,\n    charCode: true,\n    key: true,\n    keyCode: true,\n    button: true,\n    buttons: true,\n    clientX: true,\n    clientY: true,\n    offsetX: true,\n    offsetY: true,\n    pointerId: true,\n    pointerType: true,\n    screenX: true,\n    screenY: true,\n    targetTouches: true,\n    toElement: true,\n    touches: true,\n    which: function which(event) {\n      var button = event.button; // Add which for key events\n\n      if (event.which == null && rkeyEvent.test(event.type)) {\n        return event.charCode != null ? event.charCode : event.keyCode;\n      } // Add which for click: 1 === left; 2 === middle; 3 === right\n\n\n      if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {\n        if (button & 1) {\n          return 1;\n        }\n\n        if (button & 2) {\n          return 3;\n        }\n\n        if (button & 4) {\n          return 2;\n        }\n\n        return 0;\n      }\n\n      return event.which;\n    }\n  }, jQuery.event.addProp);\n  jQuery.each({\n    focus: \"focusin\",\n    blur: \"focusout\"\n  }, function (type, delegateType) {\n    jQuery.event.special[type] = {\n      // Utilize native event if possible so blur/focus sequence is correct\n      setup: function setup() {\n        // Claim the first handler\n        // dataPriv.set( this, \"focus\", ... )\n        // dataPriv.set( this, \"blur\", ... )\n        leverageNative(this, type, expectSync); // Return false to allow normal processing in the caller\n\n        return false;\n      },\n      trigger: function trigger() {\n        // Force setup before trigger\n        leverageNative(this, type); // Return non-false to allow normal event-path propagation\n\n        return true;\n      },\n      delegateType: delegateType\n    };\n  }); // Create mouseenter/leave events using mouseover/out and event-time checks\n  // so that event delegation works in jQuery.\n  // Do the same for pointerenter/pointerleave and pointerover/pointerout\n  //\n  // Support: Safari 7 only\n  // Safari sends mouseenter too often; see:\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n  // for the description of the bug (it existed in older Chrome versions as well).\n\n  jQuery.each({\n    mouseenter: \"mouseover\",\n    mouseleave: \"mouseout\",\n    pointerenter: \"pointerover\",\n    pointerleave: \"pointerout\"\n  }, function (orig, fix) {\n    jQuery.event.special[orig] = {\n      delegateType: fix,\n      bindType: fix,\n      handle: function handle(event) {\n        var ret,\n            target = this,\n            related = event.relatedTarget,\n            handleObj = event.handleObj; // For mouseenter/leave call the handler if related is outside the target.\n        // NB: No relatedTarget if the mouse left/entered the browser window\n\n        if (!related || related !== target && !jQuery.contains(target, related)) {\n          event.type = handleObj.origType;\n          ret = handleObj.handler.apply(this, arguments);\n          event.type = fix;\n        }\n\n        return ret;\n      }\n    };\n  });\n  jQuery.fn.extend({\n    on: function on(types, selector, data, fn) {\n      return _on(this, types, selector, data, fn);\n    },\n    one: function one(types, selector, data, fn) {\n      return _on(this, types, selector, data, fn, 1);\n    },\n    off: function off(types, selector, fn) {\n      var handleObj, type;\n\n      if (types && types.preventDefault && types.handleObj) {\n        // ( event )  dispatched jQuery.Event\n        handleObj = types.handleObj;\n        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);\n        return this;\n      }\n\n      if (_typeof(types) === \"object\") {\n        // ( types-object [, selector] )\n        for (type in types) {\n          this.off(type, selector, types[type]);\n        }\n\n        return this;\n      }\n\n      if (selector === false || typeof selector === \"function\") {\n        // ( types [, fn] )\n        fn = selector;\n        selector = undefined;\n      }\n\n      if (fn === false) {\n        fn = returnFalse;\n      }\n\n      return this.each(function () {\n        jQuery.event.remove(this, types, fn, selector);\n      });\n    }\n  });\n  var\n  /* eslint-disable max-len */\n  // See https://github.com/eslint/eslint/issues/3229\n  rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\n  /* eslint-enable */\n  // Support: IE <=10 - 11, Edge 12 - 13 only\n  // In IE/Edge using regex groups here causes severe slowdowns.\n  // See https://connect.microsoft.com/IE/feedback/details/1736512/\n  rnoInnerhtml = /<script|<style|<link/i,\n      // checked=\"checked\" or checked\n  rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n      rcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g; // Prefer a tbody over its parent table for containing new rows\n\n  function manipulationTarget(elem, content) {\n    if (nodeName(elem, \"table\") && nodeName(content.nodeType !== 11 ? content : content.firstChild, \"tr\")) {\n      return jQuery(elem).children(\"tbody\")[0] || elem;\n    }\n\n    return elem;\n  } // Replace/restore the type attribute of script elements for safe DOM manipulation\n\n\n  function disableScript(elem) {\n    elem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\n    return elem;\n  }\n\n  function restoreScript(elem) {\n    if ((elem.type || \"\").slice(0, 5) === \"true/\") {\n      elem.type = elem.type.slice(5);\n    } else {\n      elem.removeAttribute(\"type\");\n    }\n\n    return elem;\n  }\n\n  function cloneCopyEvent(src, dest) {\n    var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n    if (dest.nodeType !== 1) {\n      return;\n    } // 1. Copy private data: events, handlers, etc.\n\n\n    if (dataPriv.hasData(src)) {\n      pdataOld = dataPriv.access(src);\n      pdataCur = dataPriv.set(dest, pdataOld);\n      events = pdataOld.events;\n\n      if (events) {\n        delete pdataCur.handle;\n        pdataCur.events = {};\n\n        for (type in events) {\n          for (i = 0, l = events[type].length; i < l; i++) {\n            jQuery.event.add(dest, type, events[type][i]);\n          }\n        }\n      }\n    } // 2. Copy user data\n\n\n    if (dataUser.hasData(src)) {\n      udataOld = dataUser.access(src);\n      udataCur = jQuery.extend({}, udataOld);\n      dataUser.set(dest, udataCur);\n    }\n  } // Fix IE bugs, see support tests\n\n\n  function fixInput(src, dest) {\n    var nodeName = dest.nodeName.toLowerCase(); // Fails to persist the checked state of a cloned checkbox or radio button.\n\n    if (nodeName === \"input\" && rcheckableType.test(src.type)) {\n      dest.checked = src.checked; // Fails to return the selected option to the default selected state when cloning options\n    } else if (nodeName === \"input\" || nodeName === \"textarea\") {\n      dest.defaultValue = src.defaultValue;\n    }\n  }\n\n  function domManip(collection, args, callback, ignored) {\n    // Flatten any nested arrays\n    args = concat.apply([], args);\n    var fragment,\n        first,\n        scripts,\n        hasScripts,\n        node,\n        doc,\n        i = 0,\n        l = collection.length,\n        iNoClone = l - 1,\n        value = args[0],\n        valueIsFunction = isFunction(value); // We can't cloneNode fragments that contain checked, in WebKit\n\n    if (valueIsFunction || l > 1 && typeof value === \"string\" && !support.checkClone && rchecked.test(value)) {\n      return collection.each(function (index) {\n        var self = collection.eq(index);\n\n        if (valueIsFunction) {\n          args[0] = value.call(this, index, self.html());\n        }\n\n        domManip(self, args, callback, ignored);\n      });\n    }\n\n    if (l) {\n      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);\n      first = fragment.firstChild;\n\n      if (fragment.childNodes.length === 1) {\n        fragment = first;\n      } // Require either new content or an interest in ignored elements to invoke the callback\n\n\n      if (first || ignored) {\n        scripts = jQuery.map(getAll(fragment, \"script\"), disableScript);\n        hasScripts = scripts.length; // Use the original fragment for the last item\n        // instead of the first because it can end up\n        // being emptied incorrectly in certain situations (#8070).\n\n        for (; i < l; i++) {\n          node = fragment;\n\n          if (i !== iNoClone) {\n            node = jQuery.clone(node, true, true); // Keep references to cloned scripts for later restoration\n\n            if (hasScripts) {\n              // Support: Android <=4.0 only, PhantomJS 1 only\n              // push.apply(_, arraylike) throws on ancient WebKit\n              jQuery.merge(scripts, getAll(node, \"script\"));\n            }\n          }\n\n          callback.call(collection[i], node, i);\n        }\n\n        if (hasScripts) {\n          doc = scripts[scripts.length - 1].ownerDocument; // Reenable scripts\n\n          jQuery.map(scripts, restoreScript); // Evaluate executable scripts on first document insertion\n\n          for (i = 0; i < hasScripts; i++) {\n            node = scripts[i];\n\n            if (rscriptType.test(node.type || \"\") && !dataPriv.access(node, \"globalEval\") && jQuery.contains(doc, node)) {\n              if (node.src && (node.type || \"\").toLowerCase() !== \"module\") {\n                // Optional AJAX dependency, but won't run scripts if not present\n                if (jQuery._evalUrl && !node.noModule) {\n                  jQuery._evalUrl(node.src, {\n                    nonce: node.nonce || node.getAttribute(\"nonce\")\n                  });\n                }\n              } else {\n                DOMEval(node.textContent.replace(rcleanScript, \"\"), node, doc);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return collection;\n  }\n\n  function _remove(elem, selector, keepData) {\n    var node,\n        nodes = selector ? jQuery.filter(selector, elem) : elem,\n        i = 0;\n\n    for (; (node = nodes[i]) != null; i++) {\n      if (!keepData && node.nodeType === 1) {\n        jQuery.cleanData(getAll(node));\n      }\n\n      if (node.parentNode) {\n        if (keepData && isAttached(node)) {\n          setGlobalEval(getAll(node, \"script\"));\n        }\n\n        node.parentNode.removeChild(node);\n      }\n    }\n\n    return elem;\n  }\n\n  jQuery.extend({\n    htmlPrefilter: function htmlPrefilter(html) {\n      return html.replace(rxhtmlTag, \"<$1></$2>\");\n    },\n    clone: function clone(elem, dataAndEvents, deepDataAndEvents) {\n      var i,\n          l,\n          srcElements,\n          destElements,\n          clone = elem.cloneNode(true),\n          inPage = isAttached(elem); // Fix IE cloning issues\n\n      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {\n        // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n        destElements = getAll(clone);\n        srcElements = getAll(elem);\n\n        for (i = 0, l = srcElements.length; i < l; i++) {\n          fixInput(srcElements[i], destElements[i]);\n        }\n      } // Copy the events from the original to the clone\n\n\n      if (dataAndEvents) {\n        if (deepDataAndEvents) {\n          srcElements = srcElements || getAll(elem);\n          destElements = destElements || getAll(clone);\n\n          for (i = 0, l = srcElements.length; i < l; i++) {\n            cloneCopyEvent(srcElements[i], destElements[i]);\n          }\n        } else {\n          cloneCopyEvent(elem, clone);\n        }\n      } // Preserve script evaluation history\n\n\n      destElements = getAll(clone, \"script\");\n\n      if (destElements.length > 0) {\n        setGlobalEval(destElements, !inPage && getAll(elem, \"script\"));\n      } // Return the cloned set\n\n\n      return clone;\n    },\n    cleanData: function cleanData(elems) {\n      var data,\n          elem,\n          type,\n          special = jQuery.event.special,\n          i = 0;\n\n      for (; (elem = elems[i]) !== undefined; i++) {\n        if (acceptData(elem)) {\n          if (data = elem[dataPriv.expando]) {\n            if (data.events) {\n              for (type in data.events) {\n                if (special[type]) {\n                  jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead\n                } else {\n                  jQuery.removeEvent(elem, type, data.handle);\n                }\n              }\n            } // Support: Chrome <=35 - 45+\n            // Assign undefined instead of using delete, see Data#remove\n\n\n            elem[dataPriv.expando] = undefined;\n          }\n\n          if (elem[dataUser.expando]) {\n            // Support: Chrome <=35 - 45+\n            // Assign undefined instead of using delete, see Data#remove\n            elem[dataUser.expando] = undefined;\n          }\n        }\n      }\n    }\n  });\n  jQuery.fn.extend({\n    detach: function detach(selector) {\n      return _remove(this, selector, true);\n    },\n    remove: function remove(selector) {\n      return _remove(this, selector);\n    },\n    text: function text(value) {\n      return access(this, function (value) {\n        return value === undefined ? jQuery.text(this) : this.empty().each(function () {\n          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n            this.textContent = value;\n          }\n        });\n      }, null, value, arguments.length);\n    },\n    append: function append() {\n      return domManip(this, arguments, function (elem) {\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n          var target = manipulationTarget(this, elem);\n          target.appendChild(elem);\n        }\n      });\n    },\n    prepend: function prepend() {\n      return domManip(this, arguments, function (elem) {\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n          var target = manipulationTarget(this, elem);\n          target.insertBefore(elem, target.firstChild);\n        }\n      });\n    },\n    before: function before() {\n      return domManip(this, arguments, function (elem) {\n        if (this.parentNode) {\n          this.parentNode.insertBefore(elem, this);\n        }\n      });\n    },\n    after: function after() {\n      return domManip(this, arguments, function (elem) {\n        if (this.parentNode) {\n          this.parentNode.insertBefore(elem, this.nextSibling);\n        }\n      });\n    },\n    empty: function empty() {\n      var elem,\n          i = 0;\n\n      for (; (elem = this[i]) != null; i++) {\n        if (elem.nodeType === 1) {\n          // Prevent memory leaks\n          jQuery.cleanData(getAll(elem, false)); // Remove any remaining nodes\n\n          elem.textContent = \"\";\n        }\n      }\n\n      return this;\n    },\n    clone: function clone(dataAndEvents, deepDataAndEvents) {\n      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n      return this.map(function () {\n        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);\n      });\n    },\n    html: function html(value) {\n      return access(this, function (value) {\n        var elem = this[0] || {},\n            i = 0,\n            l = this.length;\n\n        if (value === undefined && elem.nodeType === 1) {\n          return elem.innerHTML;\n        } // See if we can take a shortcut and just use innerHTML\n\n\n        if (typeof value === \"string\" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [\"\", \"\"])[1].toLowerCase()]) {\n          value = jQuery.htmlPrefilter(value);\n\n          try {\n            for (; i < l; i++) {\n              elem = this[i] || {}; // Remove element nodes and prevent memory leaks\n\n              if (elem.nodeType === 1) {\n                jQuery.cleanData(getAll(elem, false));\n                elem.innerHTML = value;\n              }\n            }\n\n            elem = 0; // If using innerHTML throws an exception, use the fallback method\n          } catch (e) {}\n        }\n\n        if (elem) {\n          this.empty().append(value);\n        }\n      }, null, value, arguments.length);\n    },\n    replaceWith: function replaceWith() {\n      var ignored = []; // Make the changes, replacing each non-ignored context element with the new content\n\n      return domManip(this, arguments, function (elem) {\n        var parent = this.parentNode;\n\n        if (jQuery.inArray(this, ignored) < 0) {\n          jQuery.cleanData(getAll(this));\n\n          if (parent) {\n            parent.replaceChild(elem, this);\n          }\n        } // Force callback invocation\n\n      }, ignored);\n    }\n  });\n  jQuery.each({\n    appendTo: \"append\",\n    prependTo: \"prepend\",\n    insertBefore: \"before\",\n    insertAfter: \"after\",\n    replaceAll: \"replaceWith\"\n  }, function (name, original) {\n    jQuery.fn[name] = function (selector) {\n      var elems,\n          ret = [],\n          insert = jQuery(selector),\n          last = insert.length - 1,\n          i = 0;\n\n      for (; i <= last; i++) {\n        elems = i === last ? this : this.clone(true);\n        jQuery(insert[i])[original](elems); // Support: Android <=4.0 only, PhantomJS 1 only\n        // .get() because push.apply(_, arraylike) throws on ancient WebKit\n\n        push.apply(ret, elems.get());\n      }\n\n      return this.pushStack(ret);\n    };\n  });\n  var rnumnonpx = new RegExp(\"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\");\n\n  var getStyles = function getStyles(elem) {\n    // Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n    // IE throws on elements created in popups\n    // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n    var view = elem.ownerDocument.defaultView;\n\n    if (!view || !view.opener) {\n      view = window;\n    }\n\n    return view.getComputedStyle(elem);\n  };\n\n  var rboxStyle = new RegExp(cssExpand.join(\"|\"), \"i\");\n\n  (function () {\n    // Executing both pixelPosition & boxSizingReliable tests require only one layout\n    // so they're executed at the same time to save the second computation.\n    function computeStyleTests() {\n      // This is a singleton, we need to execute it only once\n      if (!div) {\n        return;\n      }\n\n      container.style.cssText = \"position:absolute;left:-11111px;width:60px;\" + \"margin-top:1px;padding:0;border:0\";\n      div.style.cssText = \"position:relative;display:block;box-sizing:border-box;overflow:scroll;\" + \"margin:auto;border:1px;padding:1px;\" + \"width:60%;top:1%\";\n      documentElement.appendChild(container).appendChild(div);\n      var divStyle = window.getComputedStyle(div);\n      pixelPositionVal = divStyle.top !== \"1%\"; // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\n      reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12; // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n      // Some styles come back with percentage values, even though they shouldn't\n\n      div.style.right = \"60%\";\n      pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36; // Support: IE 9 - 11 only\n      // Detect misreporting of content dimensions for box-sizing:border-box elements\n\n      boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36; // Support: IE 9 only\n      // Detect overflow:scroll screwiness (gh-3699)\n      // Support: Chrome <=64\n      // Don't get tricked when zoom affects offsetWidth (gh-4029)\n\n      div.style.position = \"absolute\";\n      scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;\n      documentElement.removeChild(container); // Nullify the div so it wouldn't be stored in the memory and\n      // it will also be a sign that checks already performed\n\n      div = null;\n    }\n\n    function roundPixelMeasures(measure) {\n      return Math.round(parseFloat(measure));\n    }\n\n    var pixelPositionVal,\n        boxSizingReliableVal,\n        scrollboxSizeVal,\n        pixelBoxStylesVal,\n        reliableMarginLeftVal,\n        container = document.createElement(\"div\"),\n        div = document.createElement(\"div\"); // Finish early in limited (non-browser) environments\n\n    if (!div.style) {\n      return;\n    } // Support: IE <=9 - 11 only\n    // Style of cloned element affects source element cloned (#8908)\n\n\n    div.style.backgroundClip = \"content-box\";\n    div.cloneNode(true).style.backgroundClip = \"\";\n    support.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n    jQuery.extend(support, {\n      boxSizingReliable: function boxSizingReliable() {\n        computeStyleTests();\n        return boxSizingReliableVal;\n      },\n      pixelBoxStyles: function pixelBoxStyles() {\n        computeStyleTests();\n        return pixelBoxStylesVal;\n      },\n      pixelPosition: function pixelPosition() {\n        computeStyleTests();\n        return pixelPositionVal;\n      },\n      reliableMarginLeft: function reliableMarginLeft() {\n        computeStyleTests();\n        return reliableMarginLeftVal;\n      },\n      scrollboxSize: function scrollboxSize() {\n        computeStyleTests();\n        return scrollboxSizeVal;\n      }\n    });\n  })();\n\n  function curCSS(elem, name, computed) {\n    var width,\n        minWidth,\n        maxWidth,\n        ret,\n        // Support: Firefox 51+\n    // Retrieving style before computed somehow\n    // fixes an issue with getting wrong values\n    // on detached elements\n    style = elem.style;\n    computed = computed || getStyles(elem); // getPropertyValue is needed for:\n    //   .css('filter') (IE 9 only, #12537)\n    //   .css('--customProperty) (#3144)\n\n    if (computed) {\n      ret = computed.getPropertyValue(name) || computed[name];\n\n      if (ret === \"\" && !isAttached(elem)) {\n        ret = jQuery.style(elem, name);\n      } // A tribute to the \"awesome hack by Dean Edwards\"\n      // Android Browser returns percentage for some values,\n      // but width seems to be reliably pixels.\n      // This is against the CSSOM draft spec:\n      // https://drafts.csswg.org/cssom/#resolved-values\n\n\n      if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {\n        // Remember the original values\n        width = style.width;\n        minWidth = style.minWidth;\n        maxWidth = style.maxWidth; // Put in the new values to get a computed value out\n\n        style.minWidth = style.maxWidth = style.width = ret;\n        ret = computed.width; // Revert the changed values\n\n        style.width = width;\n        style.minWidth = minWidth;\n        style.maxWidth = maxWidth;\n      }\n    }\n\n    return ret !== undefined ? // Support: IE <=9 - 11 only\n    // IE returns zIndex value as an integer.\n    ret + \"\" : ret;\n  }\n\n  function addGetHookIf(conditionFn, hookFn) {\n    // Define the hook, we'll check on the first run if it's really needed.\n    return {\n      get: function get() {\n        if (conditionFn()) {\n          // Hook not needed (or it's not possible to use it due\n          // to missing dependency), remove it.\n          delete this.get;\n          return;\n        } // Hook needed; redefine it so that the support test is not executed again.\n\n\n        return (this.get = hookFn).apply(this, arguments);\n      }\n    };\n  }\n\n  var cssPrefixes = [\"Webkit\", \"Moz\", \"ms\"],\n      emptyStyle = document.createElement(\"div\").style,\n      vendorProps = {}; // Return a vendor-prefixed property or undefined\n\n  function vendorPropName(name) {\n    // Check for vendor prefixed names\n    var capName = name[0].toUpperCase() + name.slice(1),\n        i = cssPrefixes.length;\n\n    while (i--) {\n      name = cssPrefixes[i] + capName;\n\n      if (name in emptyStyle) {\n        return name;\n      }\n    }\n  } // Return a potentially-mapped jQuery.cssProps or vendor prefixed property\n\n\n  function finalPropName(name) {\n    var _final = jQuery.cssProps[name] || vendorProps[name];\n\n    if (_final) {\n      return _final;\n    }\n\n    if (name in emptyStyle) {\n      return name;\n    }\n\n    return vendorProps[name] = vendorPropName(name) || name;\n  }\n\n  var // Swappable if display is none or starts with table\n  // except \"table\", \"table-cell\", or \"table-caption\"\n  // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n  rdisplayswap = /^(none|table(?!-c[ea]).+)/,\n      rcustomProp = /^--/,\n      cssShow = {\n    position: \"absolute\",\n    visibility: \"hidden\",\n    display: \"block\"\n  },\n      cssNormalTransform = {\n    letterSpacing: \"0\",\n    fontWeight: \"400\"\n  };\n\n  function setPositiveNumber(elem, value, subtract) {\n    // Any relative (+/-) values have already been\n    // normalized at this point\n    var matches = rcssNum.exec(value);\n    return matches ? // Guard against undefined \"subtract\", e.g., when used as in cssHooks\n    Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || \"px\") : value;\n  }\n\n  function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {\n    var i = dimension === \"width\" ? 1 : 0,\n        extra = 0,\n        delta = 0; // Adjustment may not be necessary\n\n    if (box === (isBorderBox ? \"border\" : \"content\")) {\n      return 0;\n    }\n\n    for (; i < 4; i += 2) {\n      // Both box models exclude margin\n      if (box === \"margin\") {\n        delta += jQuery.css(elem, box + cssExpand[i], true, styles);\n      } // If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\n\n\n      if (!isBorderBox) {\n        // Add padding\n        delta += jQuery.css(elem, \"padding\" + cssExpand[i], true, styles); // For \"border\" or \"margin\", add border\n\n        if (box !== \"padding\") {\n          delta += jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles); // But still keep track of it otherwise\n        } else {\n          extra += jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n        } // If we get here with a border-box (content + padding + border), we're seeking \"content\" or\n        // \"padding\" or \"margin\"\n\n      } else {\n        // For \"content\", subtract padding\n        if (box === \"content\") {\n          delta -= jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\n        } // For \"content\" or \"padding\", subtract border\n\n\n        if (box !== \"margin\") {\n          delta -= jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n        }\n      }\n    } // Account for positive content-box scroll gutter when requested by providing computedVal\n\n\n    if (!isBorderBox && computedVal >= 0) {\n      // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n      // Assuming integer scroll gutter, subtract the rest and round down\n      delta += Math.max(0, Math.ceil(elem[\"offset\" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5 // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter\n      // Use an explicit zero to avoid NaN (gh-3964)\n      )) || 0;\n    }\n\n    return delta;\n  }\n\n  function getWidthOrHeight(elem, dimension, extra) {\n    // Start with computed style\n    var styles = getStyles(elem),\n        // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).\n    // Fake content-box until we know it's needed to know the true value.\n    boxSizingNeeded = !support.boxSizingReliable() || extra,\n        isBorderBox = boxSizingNeeded && jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\",\n        valueIsBorderBox = isBorderBox,\n        val = curCSS(elem, dimension, styles),\n        offsetProp = \"offset\" + dimension[0].toUpperCase() + dimension.slice(1); // Support: Firefox <=54\n    // Return a confounding non-pixel value or feign ignorance, as appropriate.\n\n    if (rnumnonpx.test(val)) {\n      if (!extra) {\n        return val;\n      }\n\n      val = \"auto\";\n    } // Fall back to offsetWidth/offsetHeight when value is \"auto\"\n    // This happens for inline elements with no explicit setting (gh-3571)\n    // Support: Android <=4.1 - 4.3 only\n    // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\n    // Support: IE 9-11 only\n    // Also use offsetWidth/offsetHeight for when box sizing is unreliable\n    // We use getClientRects() to check for hidden/disconnected.\n    // In those cases, the computed value can be trusted to be border-box\n\n\n    if ((!support.boxSizingReliable() && isBorderBox || val === \"auto\" || !parseFloat(val) && jQuery.css(elem, \"display\", false, styles) === \"inline\") && elem.getClientRects().length) {\n      isBorderBox = jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\"; // Where available, offsetWidth/offsetHeight approximate border box dimensions.\n      // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the\n      // retrieved value as a content box dimension.\n\n      valueIsBorderBox = offsetProp in elem;\n\n      if (valueIsBorderBox) {\n        val = elem[offsetProp];\n      }\n    } // Normalize \"\" and auto\n\n\n    val = parseFloat(val) || 0; // Adjust for the element's box model\n\n    return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? \"border\" : \"content\"), valueIsBorderBox, styles, // Provide the current computed size to request scroll gutter calculation (gh-3589)\n    val) + \"px\";\n  }\n\n  jQuery.extend({\n    // Add in style property hooks for overriding the default\n    // behavior of getting and setting a style property\n    cssHooks: {\n      opacity: {\n        get: function get(elem, computed) {\n          if (computed) {\n            // We should always get a number back from opacity\n            var ret = curCSS(elem, \"opacity\");\n            return ret === \"\" ? \"1\" : ret;\n          }\n        }\n      }\n    },\n    // Don't automatically add \"px\" to these possibly-unitless properties\n    cssNumber: {\n      \"animationIterationCount\": true,\n      \"columnCount\": true,\n      \"fillOpacity\": true,\n      \"flexGrow\": true,\n      \"flexShrink\": true,\n      \"fontWeight\": true,\n      \"gridArea\": true,\n      \"gridColumn\": true,\n      \"gridColumnEnd\": true,\n      \"gridColumnStart\": true,\n      \"gridRow\": true,\n      \"gridRowEnd\": true,\n      \"gridRowStart\": true,\n      \"lineHeight\": true,\n      \"opacity\": true,\n      \"order\": true,\n      \"orphans\": true,\n      \"widows\": true,\n      \"zIndex\": true,\n      \"zoom\": true\n    },\n    // Add in properties whose names you wish to fix before\n    // setting or getting the value\n    cssProps: {},\n    // Get and set the style property on a DOM Node\n    style: function style(elem, name, value, extra) {\n      // Don't set styles on text and comment nodes\n      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {\n        return;\n      } // Make sure that we're working with the right name\n\n\n      var ret,\n          type,\n          hooks,\n          origName = camelCase(name),\n          isCustomProp = rcustomProp.test(name),\n          style = elem.style; // Make sure that we're working with the right name. We don't\n      // want to query the value if it is a CSS custom property\n      // since they are user-defined.\n\n      if (!isCustomProp) {\n        name = finalPropName(origName);\n      } // Gets hook for the prefixed version, then unprefixed version\n\n\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // Check if we're setting a value\n\n      if (value !== undefined) {\n        type = _typeof(value); // Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\n        if (type === \"string\" && (ret = rcssNum.exec(value)) && ret[1]) {\n          value = adjustCSS(elem, name, ret); // Fixes bug #9237\n\n          type = \"number\";\n        } // Make sure that null and NaN values aren't set (#7116)\n\n\n        if (value == null || value !== value) {\n          return;\n        } // If a number was passed in, add the unit (except for certain CSS properties)\n        // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append\n        // \"px\" to a few hardcoded values.\n\n\n        if (type === \"number\" && !isCustomProp) {\n          value += ret && ret[3] || (jQuery.cssNumber[origName] ? \"\" : \"px\");\n        } // background-* props affect original clone's values\n\n\n        if (!support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0) {\n          style[name] = \"inherit\";\n        } // If a hook was provided, use that value, otherwise just set the specified value\n\n\n        if (!hooks || !(\"set\" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {\n          if (isCustomProp) {\n            style.setProperty(name, value);\n          } else {\n            style[name] = value;\n          }\n        }\n      } else {\n        // If a hook was provided get the non-computed value from there\n        if (hooks && \"get\" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {\n          return ret;\n        } // Otherwise just get the value from the style object\n\n\n        return style[name];\n      }\n    },\n    css: function css(elem, name, extra, styles) {\n      var val,\n          num,\n          hooks,\n          origName = camelCase(name),\n          isCustomProp = rcustomProp.test(name); // Make sure that we're working with the right name. We don't\n      // want to modify the value if it is a CSS custom property\n      // since they are user-defined.\n\n      if (!isCustomProp) {\n        name = finalPropName(origName);\n      } // Try prefixed name followed by the unprefixed name\n\n\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there\n\n      if (hooks && \"get\" in hooks) {\n        val = hooks.get(elem, true, extra);\n      } // Otherwise, if a way to get the computed value exists, use that\n\n\n      if (val === undefined) {\n        val = curCSS(elem, name, styles);\n      } // Convert \"normal\" to computed value\n\n\n      if (val === \"normal\" && name in cssNormalTransform) {\n        val = cssNormalTransform[name];\n      } // Make numeric if forced or a qualifier was provided and val looks numeric\n\n\n      if (extra === \"\" || extra) {\n        num = parseFloat(val);\n        return extra === true || isFinite(num) ? num || 0 : val;\n      }\n\n      return val;\n    }\n  });\n  jQuery.each([\"height\", \"width\"], function (i, dimension) {\n    jQuery.cssHooks[dimension] = {\n      get: function get(elem, computed, extra) {\n        if (computed) {\n          // Certain elements can have dimension info if we invisibly show them\n          // but it must have a current display style that would benefit\n          return rdisplayswap.test(jQuery.css(elem, \"display\")) && ( // Support: Safari 8+\n          // Table columns in Safari have non-zero offsetWidth & zero\n          // getBoundingClientRect().width unless display is changed.\n          // Support: IE <=11 only\n          // Running getBoundingClientRect on a disconnected node\n          // in IE throws an error.\n          !elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {\n            return getWidthOrHeight(elem, dimension, extra);\n          }) : getWidthOrHeight(elem, dimension, extra);\n        }\n      },\n      set: function set(elem, value, extra) {\n        var matches,\n            styles = getStyles(elem),\n            // Only read styles.position if the test has a chance to fail\n        // to avoid forcing a reflow.\n        scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === \"absolute\",\n            // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)\n        boxSizingNeeded = scrollboxSizeBuggy || extra,\n            isBorderBox = boxSizingNeeded && jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\",\n            subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0; // Account for unreliable border-box dimensions by comparing offset* to computed and\n        // faking a content-box to get border and padding (gh-3699)\n\n        if (isBorderBox && scrollboxSizeBuggy) {\n          subtract -= Math.ceil(elem[\"offset\" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, \"border\", false, styles) - 0.5);\n        } // Convert to pixels if value adjustment is needed\n\n\n        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || \"px\") !== \"px\") {\n          elem.style[dimension] = value;\n          value = jQuery.css(elem, dimension);\n        }\n\n        return setPositiveNumber(elem, value, subtract);\n      }\n    };\n  });\n  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {\n    if (computed) {\n      return (parseFloat(curCSS(elem, \"marginLeft\")) || elem.getBoundingClientRect().left - swap(elem, {\n        marginLeft: 0\n      }, function () {\n        return elem.getBoundingClientRect().left;\n      })) + \"px\";\n    }\n  }); // These hooks are used by animate to expand properties\n\n  jQuery.each({\n    margin: \"\",\n    padding: \"\",\n    border: \"Width\"\n  }, function (prefix, suffix) {\n    jQuery.cssHooks[prefix + suffix] = {\n      expand: function expand(value) {\n        var i = 0,\n            expanded = {},\n            // Assumes a single number if not a string\n        parts = typeof value === \"string\" ? value.split(\" \") : [value];\n\n        for (; i < 4; i++) {\n          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];\n        }\n\n        return expanded;\n      }\n    };\n\n    if (prefix !== \"margin\") {\n      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;\n    }\n  });\n  jQuery.fn.extend({\n    css: function css(name, value) {\n      return access(this, function (elem, name, value) {\n        var styles,\n            len,\n            map = {},\n            i = 0;\n\n        if (Array.isArray(name)) {\n          styles = getStyles(elem);\n          len = name.length;\n\n          for (; i < len; i++) {\n            map[name[i]] = jQuery.css(elem, name[i], false, styles);\n          }\n\n          return map;\n        }\n\n        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);\n      }, name, value, arguments.length > 1);\n    }\n  });\n\n  function Tween(elem, options, prop, end, easing) {\n    return new Tween.prototype.init(elem, options, prop, end, easing);\n  }\n\n  jQuery.Tween = Tween;\n  Tween.prototype = {\n    constructor: Tween,\n    init: function init(elem, options, prop, end, easing, unit) {\n      this.elem = elem;\n      this.prop = prop;\n      this.easing = easing || jQuery.easing._default;\n      this.options = options;\n      this.start = this.now = this.cur();\n      this.end = end;\n      this.unit = unit || (jQuery.cssNumber[prop] ? \"\" : \"px\");\n    },\n    cur: function cur() {\n      var hooks = Tween.propHooks[this.prop];\n      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);\n    },\n    run: function run(percent) {\n      var eased,\n          hooks = Tween.propHooks[this.prop];\n\n      if (this.options.duration) {\n        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);\n      } else {\n        this.pos = eased = percent;\n      }\n\n      this.now = (this.end - this.start) * eased + this.start;\n\n      if (this.options.step) {\n        this.options.step.call(this.elem, this.now, this);\n      }\n\n      if (hooks && hooks.set) {\n        hooks.set(this);\n      } else {\n        Tween.propHooks._default.set(this);\n      }\n\n      return this;\n    }\n  };\n  Tween.prototype.init.prototype = Tween.prototype;\n  Tween.propHooks = {\n    _default: {\n      get: function get(tween) {\n        var result; // Use a property on the element directly when it is not a DOM element,\n        // or when there is no matching style property that exists.\n\n        if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {\n          return tween.elem[tween.prop];\n        } // Passing an empty string as a 3rd parameter to .css will automatically\n        // attempt a parseFloat and fallback to a string if the parse fails.\n        // Simple values such as \"10px\" are parsed to Float;\n        // complex values such as \"rotate(1rad)\" are returned as-is.\n\n\n        result = jQuery.css(tween.elem, tween.prop, \"\"); // Empty strings, null, undefined and \"auto\" are converted to 0.\n\n        return !result || result === \"auto\" ? 0 : result;\n      },\n      set: function set(tween) {\n        // Use step hook for back compat.\n        // Use cssHook if its there.\n        // Use .style if available and use plain properties where available.\n        if (jQuery.fx.step[tween.prop]) {\n          jQuery.fx.step[tween.prop](tween);\n        } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {\n          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);\n        } else {\n          tween.elem[tween.prop] = tween.now;\n        }\n      }\n    }\n  }; // Support: IE <=9 only\n  // Panic based approach to setting things on disconnected nodes\n\n  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n    set: function set(tween) {\n      if (tween.elem.nodeType && tween.elem.parentNode) {\n        tween.elem[tween.prop] = tween.now;\n      }\n    }\n  };\n  jQuery.easing = {\n    linear: function linear(p) {\n      return p;\n    },\n    swing: function swing(p) {\n      return 0.5 - Math.cos(p * Math.PI) / 2;\n    },\n    _default: \"swing\"\n  };\n  jQuery.fx = Tween.prototype.init; // Back compat <1.8 extension point\n\n  jQuery.fx.step = {};\n  var fxNow,\n      inProgress,\n      rfxtypes = /^(?:toggle|show|hide)$/,\n      rrun = /queueHooks$/;\n\n  function schedule() {\n    if (inProgress) {\n      if (document.hidden === false && window.requestAnimationFrame) {\n        window.requestAnimationFrame(schedule);\n      } else {\n        window.setTimeout(schedule, jQuery.fx.interval);\n      }\n\n      jQuery.fx.tick();\n    }\n  } // Animations created synchronously will run synchronously\n\n\n  function createFxNow() {\n    window.setTimeout(function () {\n      fxNow = undefined;\n    });\n    return fxNow = Date.now();\n  } // Generate parameters to create a standard animation\n\n\n  function genFx(type, includeWidth) {\n    var which,\n        i = 0,\n        attrs = {\n      height: type\n    }; // If we include width, step value is 1 to do all cssExpand values,\n    // otherwise step value is 2 to skip over Left and Right\n\n    includeWidth = includeWidth ? 1 : 0;\n\n    for (; i < 4; i += 2 - includeWidth) {\n      which = cssExpand[i];\n      attrs[\"margin\" + which] = attrs[\"padding\" + which] = type;\n    }\n\n    if (includeWidth) {\n      attrs.opacity = attrs.width = type;\n    }\n\n    return attrs;\n  }\n\n  function createTween(value, prop, animation) {\n    var tween,\n        collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners[\"*\"]),\n        index = 0,\n        length = collection.length;\n\n    for (; index < length; index++) {\n      if (tween = collection[index].call(animation, prop, value)) {\n        // We're done with this property\n        return tween;\n      }\n    }\n  }\n\n  function defaultPrefilter(elem, props, opts) {\n    var prop,\n        value,\n        toggle,\n        hooks,\n        oldfire,\n        propTween,\n        restoreDisplay,\n        display,\n        isBox = \"width\" in props || \"height\" in props,\n        anim = this,\n        orig = {},\n        style = elem.style,\n        hidden = elem.nodeType && isHiddenWithinTree(elem),\n        dataShow = dataPriv.get(elem, \"fxshow\"); // Queue-skipping animations hijack the fx hooks\n\n    if (!opts.queue) {\n      hooks = jQuery._queueHooks(elem, \"fx\");\n\n      if (hooks.unqueued == null) {\n        hooks.unqueued = 0;\n        oldfire = hooks.empty.fire;\n\n        hooks.empty.fire = function () {\n          if (!hooks.unqueued) {\n            oldfire();\n          }\n        };\n      }\n\n      hooks.unqueued++;\n      anim.always(function () {\n        // Ensure the complete handler is called before this completes\n        anim.always(function () {\n          hooks.unqueued--;\n\n          if (!jQuery.queue(elem, \"fx\").length) {\n            hooks.empty.fire();\n          }\n        });\n      });\n    } // Detect show/hide animations\n\n\n    for (prop in props) {\n      value = props[prop];\n\n      if (rfxtypes.test(value)) {\n        delete props[prop];\n        toggle = toggle || value === \"toggle\";\n\n        if (value === (hidden ? \"hide\" : \"show\")) {\n          // Pretend to be hidden if this is a \"show\" and\n          // there is still data from a stopped show/hide\n          if (value === \"show\" && dataShow && dataShow[prop] !== undefined) {\n            hidden = true; // Ignore all other no-op show/hide data\n          } else {\n            continue;\n          }\n        }\n\n        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);\n      }\n    } // Bail out if this is a no-op like .hide().hide()\n\n\n    propTween = !jQuery.isEmptyObject(props);\n\n    if (!propTween && jQuery.isEmptyObject(orig)) {\n      return;\n    } // Restrict \"overflow\" and \"display\" styles during box animations\n\n\n    if (isBox && elem.nodeType === 1) {\n      // Support: IE <=9 - 11, Edge 12 - 15\n      // Record all 3 overflow attributes because IE does not infer the shorthand\n      // from identically-valued overflowX and overflowY and Edge just mirrors\n      // the overflowX value there.\n      opts.overflow = [style.overflow, style.overflowX, style.overflowY]; // Identify a display type, preferring old show/hide data over the CSS cascade\n\n      restoreDisplay = dataShow && dataShow.display;\n\n      if (restoreDisplay == null) {\n        restoreDisplay = dataPriv.get(elem, \"display\");\n      }\n\n      display = jQuery.css(elem, \"display\");\n\n      if (display === \"none\") {\n        if (restoreDisplay) {\n          display = restoreDisplay;\n        } else {\n          // Get nonempty value(s) by temporarily forcing visibility\n          showHide([elem], true);\n          restoreDisplay = elem.style.display || restoreDisplay;\n          display = jQuery.css(elem, \"display\");\n          showHide([elem]);\n        }\n      } // Animate inline elements as inline-block\n\n\n      if (display === \"inline\" || display === \"inline-block\" && restoreDisplay != null) {\n        if (jQuery.css(elem, \"float\") === \"none\") {\n          // Restore the original display value at the end of pure show/hide animations\n          if (!propTween) {\n            anim.done(function () {\n              style.display = restoreDisplay;\n            });\n\n            if (restoreDisplay == null) {\n              display = style.display;\n              restoreDisplay = display === \"none\" ? \"\" : display;\n            }\n          }\n\n          style.display = \"inline-block\";\n        }\n      }\n    }\n\n    if (opts.overflow) {\n      style.overflow = \"hidden\";\n      anim.always(function () {\n        style.overflow = opts.overflow[0];\n        style.overflowX = opts.overflow[1];\n        style.overflowY = opts.overflow[2];\n      });\n    } // Implement show/hide animations\n\n\n    propTween = false;\n\n    for (prop in orig) {\n      // General show/hide setup for this element animation\n      if (!propTween) {\n        if (dataShow) {\n          if (\"hidden\" in dataShow) {\n            hidden = dataShow.hidden;\n          }\n        } else {\n          dataShow = dataPriv.access(elem, \"fxshow\", {\n            display: restoreDisplay\n          });\n        } // Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\n\n        if (toggle) {\n          dataShow.hidden = !hidden;\n        } // Show elements before animating them\n\n\n        if (hidden) {\n          showHide([elem], true);\n        }\n        /* eslint-disable no-loop-func */\n\n\n        anim.done(function () {\n          /* eslint-enable no-loop-func */\n          // The final step of a \"hide\" animation is actually hiding the element\n          if (!hidden) {\n            showHide([elem]);\n          }\n\n          dataPriv.remove(elem, \"fxshow\");\n\n          for (prop in orig) {\n            jQuery.style(elem, prop, orig[prop]);\n          }\n        });\n      } // Per-property setup\n\n\n      propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);\n\n      if (!(prop in dataShow)) {\n        dataShow[prop] = propTween.start;\n\n        if (hidden) {\n          propTween.end = propTween.start;\n          propTween.start = 0;\n        }\n      }\n    }\n  }\n\n  function propFilter(props, specialEasing) {\n    var index, name, easing, value, hooks; // camelCase, specialEasing and expand cssHook pass\n\n    for (index in props) {\n      name = camelCase(index);\n      easing = specialEasing[name];\n      value = props[index];\n\n      if (Array.isArray(value)) {\n        easing = value[1];\n        value = props[index] = value[0];\n      }\n\n      if (index !== name) {\n        props[name] = value;\n        delete props[index];\n      }\n\n      hooks = jQuery.cssHooks[name];\n\n      if (hooks && \"expand\" in hooks) {\n        value = hooks.expand(value);\n        delete props[name]; // Not quite $.extend, this won't overwrite existing keys.\n        // Reusing 'index' because we have the correct \"name\"\n\n        for (index in value) {\n          if (!(index in props)) {\n            props[index] = value[index];\n            specialEasing[index] = easing;\n          }\n        }\n      } else {\n        specialEasing[name] = easing;\n      }\n    }\n  }\n\n  function Animation(elem, properties, options) {\n    var result,\n        stopped,\n        index = 0,\n        length = Animation.prefilters.length,\n        deferred = jQuery.Deferred().always(function () {\n      // Don't match elem in the :animated selector\n      delete tick.elem;\n    }),\n        tick = function tick() {\n      if (stopped) {\n        return false;\n      }\n\n      var currentTime = fxNow || createFxNow(),\n          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),\n          // Support: Android 2.3 only\n      // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n      temp = remaining / animation.duration || 0,\n          percent = 1 - temp,\n          index = 0,\n          length = animation.tweens.length;\n\n      for (; index < length; index++) {\n        animation.tweens[index].run(percent);\n      }\n\n      deferred.notifyWith(elem, [animation, percent, remaining]); // If there's more to do, yield\n\n      if (percent < 1 && length) {\n        return remaining;\n      } // If this was an empty animation, synthesize a final progress notification\n\n\n      if (!length) {\n        deferred.notifyWith(elem, [animation, 1, 0]);\n      } // Resolve the animation and report its conclusion\n\n\n      deferred.resolveWith(elem, [animation]);\n      return false;\n    },\n        animation = deferred.promise({\n      elem: elem,\n      props: jQuery.extend({}, properties),\n      opts: jQuery.extend(true, {\n        specialEasing: {},\n        easing: jQuery.easing._default\n      }, options),\n      originalProperties: properties,\n      originalOptions: options,\n      startTime: fxNow || createFxNow(),\n      duration: options.duration,\n      tweens: [],\n      createTween: function createTween(prop, end) {\n        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);\n        animation.tweens.push(tween);\n        return tween;\n      },\n      stop: function stop(gotoEnd) {\n        var index = 0,\n            // If we are going to the end, we want to run all the tweens\n        // otherwise we skip this part\n        length = gotoEnd ? animation.tweens.length : 0;\n\n        if (stopped) {\n          return this;\n        }\n\n        stopped = true;\n\n        for (; index < length; index++) {\n          animation.tweens[index].run(1);\n        } // Resolve when we played the last frame; otherwise, reject\n\n\n        if (gotoEnd) {\n          deferred.notifyWith(elem, [animation, 1, 0]);\n          deferred.resolveWith(elem, [animation, gotoEnd]);\n        } else {\n          deferred.rejectWith(elem, [animation, gotoEnd]);\n        }\n\n        return this;\n      }\n    }),\n        props = animation.props;\n\n    propFilter(props, animation.opts.specialEasing);\n\n    for (; index < length; index++) {\n      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);\n\n      if (result) {\n        if (isFunction(result.stop)) {\n          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);\n        }\n\n        return result;\n      }\n    }\n\n    jQuery.map(props, createTween, animation);\n\n    if (isFunction(animation.opts.start)) {\n      animation.opts.start.call(elem, animation);\n    } // Attach callbacks from options\n\n\n    animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);\n    jQuery.fx.timer(jQuery.extend(tick, {\n      elem: elem,\n      anim: animation,\n      queue: animation.opts.queue\n    }));\n    return animation;\n  }\n\n  jQuery.Animation = jQuery.extend(Animation, {\n    tweeners: {\n      \"*\": [function (prop, value) {\n        var tween = this.createTween(prop, value);\n        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);\n        return tween;\n      }]\n    },\n    tweener: function tweener(props, callback) {\n      if (isFunction(props)) {\n        callback = props;\n        props = [\"*\"];\n      } else {\n        props = props.match(rnothtmlwhite);\n      }\n\n      var prop,\n          index = 0,\n          length = props.length;\n\n      for (; index < length; index++) {\n        prop = props[index];\n        Animation.tweeners[prop] = Animation.tweeners[prop] || [];\n        Animation.tweeners[prop].unshift(callback);\n      }\n    },\n    prefilters: [defaultPrefilter],\n    prefilter: function prefilter(callback, prepend) {\n      if (prepend) {\n        Animation.prefilters.unshift(callback);\n      } else {\n        Animation.prefilters.push(callback);\n      }\n    }\n  });\n\n  jQuery.speed = function (speed, easing, fn) {\n    var opt = speed && _typeof(speed) === \"object\" ? jQuery.extend({}, speed) : {\n      complete: fn || !fn && easing || isFunction(speed) && speed,\n      duration: speed,\n      easing: fn && easing || easing && !isFunction(easing) && easing\n    }; // Go to the end state if fx are off\n\n    if (jQuery.fx.off) {\n      opt.duration = 0;\n    } else {\n      if (typeof opt.duration !== \"number\") {\n        if (opt.duration in jQuery.fx.speeds) {\n          opt.duration = jQuery.fx.speeds[opt.duration];\n        } else {\n          opt.duration = jQuery.fx.speeds._default;\n        }\n      }\n    } // Normalize opt.queue - true/undefined/null -> \"fx\"\n\n\n    if (opt.queue == null || opt.queue === true) {\n      opt.queue = \"fx\";\n    } // Queueing\n\n\n    opt.old = opt.complete;\n\n    opt.complete = function () {\n      if (isFunction(opt.old)) {\n        opt.old.call(this);\n      }\n\n      if (opt.queue) {\n        jQuery.dequeue(this, opt.queue);\n      }\n    };\n\n    return opt;\n  };\n\n  jQuery.fn.extend({\n    fadeTo: function fadeTo(speed, to, easing, callback) {\n      // Show any hidden elements after setting opacity to 0\n      return this.filter(isHiddenWithinTree).css(\"opacity\", 0).show() // Animate to the value specified\n      .end().animate({\n        opacity: to\n      }, speed, easing, callback);\n    },\n    animate: function animate(prop, speed, easing, callback) {\n      var empty = jQuery.isEmptyObject(prop),\n          optall = jQuery.speed(speed, easing, callback),\n          doAnimation = function doAnimation() {\n        // Operate on a copy of prop so per-property easing won't be lost\n        var anim = Animation(this, jQuery.extend({}, prop), optall); // Empty animations, or finishing resolves immediately\n\n        if (empty || dataPriv.get(this, \"finish\")) {\n          anim.stop(true);\n        }\n      };\n\n      doAnimation.finish = doAnimation;\n      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);\n    },\n    stop: function stop(type, clearQueue, gotoEnd) {\n      var stopQueue = function stopQueue(hooks) {\n        var stop = hooks.stop;\n        delete hooks.stop;\n        stop(gotoEnd);\n      };\n\n      if (typeof type !== \"string\") {\n        gotoEnd = clearQueue;\n        clearQueue = type;\n        type = undefined;\n      }\n\n      if (clearQueue && type !== false) {\n        this.queue(type || \"fx\", []);\n      }\n\n      return this.each(function () {\n        var dequeue = true,\n            index = type != null && type + \"queueHooks\",\n            timers = jQuery.timers,\n            data = dataPriv.get(this);\n\n        if (index) {\n          if (data[index] && data[index].stop) {\n            stopQueue(data[index]);\n          }\n        } else {\n          for (index in data) {\n            if (data[index] && data[index].stop && rrun.test(index)) {\n              stopQueue(data[index]);\n            }\n          }\n        }\n\n        for (index = timers.length; index--;) {\n          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {\n            timers[index].anim.stop(gotoEnd);\n            dequeue = false;\n            timers.splice(index, 1);\n          }\n        } // Start the next in the queue if the last step wasn't forced.\n        // Timers currently will call their complete callbacks, which\n        // will dequeue but only if they were gotoEnd.\n\n\n        if (dequeue || !gotoEnd) {\n          jQuery.dequeue(this, type);\n        }\n      });\n    },\n    finish: function finish(type) {\n      if (type !== false) {\n        type = type || \"fx\";\n      }\n\n      return this.each(function () {\n        var index,\n            data = dataPriv.get(this),\n            queue = data[type + \"queue\"],\n            hooks = data[type + \"queueHooks\"],\n            timers = jQuery.timers,\n            length = queue ? queue.length : 0; // Enable finishing flag on private data\n\n        data.finish = true; // Empty the queue first\n\n        jQuery.queue(this, type, []);\n\n        if (hooks && hooks.stop) {\n          hooks.stop.call(this, true);\n        } // Look for any active animations, and finish them\n\n\n        for (index = timers.length; index--;) {\n          if (timers[index].elem === this && timers[index].queue === type) {\n            timers[index].anim.stop(true);\n            timers.splice(index, 1);\n          }\n        } // Look for any animations in the old queue and finish them\n\n\n        for (index = 0; index < length; index++) {\n          if (queue[index] && queue[index].finish) {\n            queue[index].finish.call(this);\n          }\n        } // Turn off finishing flag\n\n\n        delete data.finish;\n      });\n    }\n  });\n  jQuery.each([\"toggle\", \"show\", \"hide\"], function (i, name) {\n    var cssFn = jQuery.fn[name];\n\n    jQuery.fn[name] = function (speed, easing, callback) {\n      return speed == null || typeof speed === \"boolean\" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);\n    };\n  }); // Generate shortcuts for custom animations\n\n  jQuery.each({\n    slideDown: genFx(\"show\"),\n    slideUp: genFx(\"hide\"),\n    slideToggle: genFx(\"toggle\"),\n    fadeIn: {\n      opacity: \"show\"\n    },\n    fadeOut: {\n      opacity: \"hide\"\n    },\n    fadeToggle: {\n      opacity: \"toggle\"\n    }\n  }, function (name, props) {\n    jQuery.fn[name] = function (speed, easing, callback) {\n      return this.animate(props, speed, easing, callback);\n    };\n  });\n  jQuery.timers = [];\n\n  jQuery.fx.tick = function () {\n    var timer,\n        i = 0,\n        timers = jQuery.timers;\n    fxNow = Date.now();\n\n    for (; i < timers.length; i++) {\n      timer = timers[i]; // Run the timer and safely remove it when done (allowing for external removal)\n\n      if (!timer() && timers[i] === timer) {\n        timers.splice(i--, 1);\n      }\n    }\n\n    if (!timers.length) {\n      jQuery.fx.stop();\n    }\n\n    fxNow = undefined;\n  };\n\n  jQuery.fx.timer = function (timer) {\n    jQuery.timers.push(timer);\n    jQuery.fx.start();\n  };\n\n  jQuery.fx.interval = 13;\n\n  jQuery.fx.start = function () {\n    if (inProgress) {\n      return;\n    }\n\n    inProgress = true;\n    schedule();\n  };\n\n  jQuery.fx.stop = function () {\n    inProgress = null;\n  };\n\n  jQuery.fx.speeds = {\n    slow: 600,\n    fast: 200,\n    // Default speed\n    _default: 400\n  }; // Based off of the plugin by Clint Helfers, with permission.\n  // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\n\n  jQuery.fn.delay = function (time, type) {\n    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;\n    type = type || \"fx\";\n    return this.queue(type, function (next, hooks) {\n      var timeout = window.setTimeout(next, time);\n\n      hooks.stop = function () {\n        window.clearTimeout(timeout);\n      };\n    });\n  };\n\n  (function () {\n    var input = document.createElement(\"input\"),\n        select = document.createElement(\"select\"),\n        opt = select.appendChild(document.createElement(\"option\"));\n    input.type = \"checkbox\"; // Support: Android <=4.3 only\n    // Default value for a checkbox should be \"on\"\n\n    support.checkOn = input.value !== \"\"; // Support: IE <=11 only\n    // Must access selectedIndex to make default options select\n\n    support.optSelected = opt.selected; // Support: IE <=11 only\n    // An input loses its value after becoming a radio\n\n    input = document.createElement(\"input\");\n    input.value = \"t\";\n    input.type = \"radio\";\n    support.radioValue = input.value === \"t\";\n  })();\n\n  var boolHook,\n      attrHandle = jQuery.expr.attrHandle;\n  jQuery.fn.extend({\n    attr: function attr(name, value) {\n      return access(this, jQuery.attr, name, value, arguments.length > 1);\n    },\n    removeAttr: function removeAttr(name) {\n      return this.each(function () {\n        jQuery.removeAttr(this, name);\n      });\n    }\n  });\n  jQuery.extend({\n    attr: function attr(elem, name, value) {\n      var ret,\n          hooks,\n          nType = elem.nodeType; // Don't get/set attributes on text, comment and attribute nodes\n\n      if (nType === 3 || nType === 8 || nType === 2) {\n        return;\n      } // Fallback to prop when attributes are not supported\n\n\n      if (typeof elem.getAttribute === \"undefined\") {\n        return jQuery.prop(elem, name, value);\n      } // Attribute hooks are determined by the lowercase version\n      // Grab necessary hook if one is defined\n\n\n      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n        hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);\n      }\n\n      if (value !== undefined) {\n        if (value === null) {\n          jQuery.removeAttr(elem, name);\n          return;\n        }\n\n        if (hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n          return ret;\n        }\n\n        elem.setAttribute(name, value + \"\");\n        return value;\n      }\n\n      if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n        return ret;\n      }\n\n      ret = jQuery.find.attr(elem, name); // Non-existent attributes return null, we normalize to undefined\n\n      return ret == null ? undefined : ret;\n    },\n    attrHooks: {\n      type: {\n        set: function set(elem, value) {\n          if (!support.radioValue && value === \"radio\" && nodeName(elem, \"input\")) {\n            var val = elem.value;\n            elem.setAttribute(\"type\", value);\n\n            if (val) {\n              elem.value = val;\n            }\n\n            return value;\n          }\n        }\n      }\n    },\n    removeAttr: function removeAttr(elem, value) {\n      var name,\n          i = 0,\n          // Attribute names can contain non-HTML whitespace characters\n      // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n      attrNames = value && value.match(rnothtmlwhite);\n\n      if (attrNames && elem.nodeType === 1) {\n        while (name = attrNames[i++]) {\n          elem.removeAttribute(name);\n        }\n      }\n    }\n  }); // Hooks for boolean attributes\n\n  boolHook = {\n    set: function set(elem, value, name) {\n      if (value === false) {\n        // Remove boolean attributes when set to false\n        jQuery.removeAttr(elem, name);\n      } else {\n        elem.setAttribute(name, name);\n      }\n\n      return name;\n    }\n  };\n  jQuery.each(jQuery.expr.match.bool.source.match(/\\w+/g), function (i, name) {\n    var getter = attrHandle[name] || jQuery.find.attr;\n\n    attrHandle[name] = function (elem, name, isXML) {\n      var ret,\n          handle,\n          lowercaseName = name.toLowerCase();\n\n      if (!isXML) {\n        // Avoid an infinite loop by temporarily removing this function from the getter\n        handle = attrHandle[lowercaseName];\n        attrHandle[lowercaseName] = ret;\n        ret = getter(elem, name, isXML) != null ? lowercaseName : null;\n        attrHandle[lowercaseName] = handle;\n      }\n\n      return ret;\n    };\n  });\n  var rfocusable = /^(?:input|select|textarea|button)$/i,\n      rclickable = /^(?:a|area)$/i;\n  jQuery.fn.extend({\n    prop: function prop(name, value) {\n      return access(this, jQuery.prop, name, value, arguments.length > 1);\n    },\n    removeProp: function removeProp(name) {\n      return this.each(function () {\n        delete this[jQuery.propFix[name] || name];\n      });\n    }\n  });\n  jQuery.extend({\n    prop: function prop(elem, name, value) {\n      var ret,\n          hooks,\n          nType = elem.nodeType; // Don't get/set properties on text, comment and attribute nodes\n\n      if (nType === 3 || nType === 8 || nType === 2) {\n        return;\n      }\n\n      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n        // Fix name and attach hooks\n        name = jQuery.propFix[name] || name;\n        hooks = jQuery.propHooks[name];\n      }\n\n      if (value !== undefined) {\n        if (hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n          return ret;\n        }\n\n        return elem[name] = value;\n      }\n\n      if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n        return ret;\n      }\n\n      return elem[name];\n    },\n    propHooks: {\n      tabIndex: {\n        get: function get(elem) {\n          // Support: IE <=9 - 11 only\n          // elem.tabIndex doesn't always return the\n          // correct value when it hasn't been explicitly set\n          // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n          // Use proper attribute retrieval(#12072)\n          var tabindex = jQuery.find.attr(elem, \"tabindex\");\n\n          if (tabindex) {\n            return parseInt(tabindex, 10);\n          }\n\n          if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {\n            return 0;\n          }\n\n          return -1;\n        }\n      }\n    },\n    propFix: {\n      \"for\": \"htmlFor\",\n      \"class\": \"className\"\n    }\n  }); // Support: IE <=11 only\n  // Accessing the selectedIndex property\n  // forces the browser to respect setting selected\n  // on the option\n  // The getter ensures a default option is selected\n  // when in an optgroup\n  // eslint rule \"no-unused-expressions\" is disabled for this code\n  // since it considers such accessions noop\n\n  if (!support.optSelected) {\n    jQuery.propHooks.selected = {\n      get: function get(elem) {\n        /* eslint no-unused-expressions: \"off\" */\n        var parent = elem.parentNode;\n\n        if (parent && parent.parentNode) {\n          parent.parentNode.selectedIndex;\n        }\n\n        return null;\n      },\n      set: function set(elem) {\n        /* eslint no-unused-expressions: \"off\" */\n        var parent = elem.parentNode;\n\n        if (parent) {\n          parent.selectedIndex;\n\n          if (parent.parentNode) {\n            parent.parentNode.selectedIndex;\n          }\n        }\n      }\n    };\n  }\n\n  jQuery.each([\"tabIndex\", \"readOnly\", \"maxLength\", \"cellSpacing\", \"cellPadding\", \"rowSpan\", \"colSpan\", \"useMap\", \"frameBorder\", \"contentEditable\"], function () {\n    jQuery.propFix[this.toLowerCase()] = this;\n  }); // Strip and collapse whitespace according to HTML spec\n  // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n\n  function stripAndCollapse(value) {\n    var tokens = value.match(rnothtmlwhite) || [];\n    return tokens.join(\" \");\n  }\n\n  function getClass(elem) {\n    return elem.getAttribute && elem.getAttribute(\"class\") || \"\";\n  }\n\n  function classesToArray(value) {\n    if (Array.isArray(value)) {\n      return value;\n    }\n\n    if (typeof value === \"string\") {\n      return value.match(rnothtmlwhite) || [];\n    }\n\n    return [];\n  }\n\n  jQuery.fn.extend({\n    addClass: function addClass(value) {\n      var classes,\n          elem,\n          cur,\n          curValue,\n          clazz,\n          j,\n          finalValue,\n          i = 0;\n\n      if (isFunction(value)) {\n        return this.each(function (j) {\n          jQuery(this).addClass(value.call(this, j, getClass(this)));\n        });\n      }\n\n      classes = classesToArray(value);\n\n      if (classes.length) {\n        while (elem = this[i++]) {\n          curValue = getClass(elem);\n          cur = elem.nodeType === 1 && \" \" + stripAndCollapse(curValue) + \" \";\n\n          if (cur) {\n            j = 0;\n\n            while (clazz = classes[j++]) {\n              if (cur.indexOf(\" \" + clazz + \" \") < 0) {\n                cur += clazz + \" \";\n              }\n            } // Only assign if different to avoid unneeded rendering.\n\n\n            finalValue = stripAndCollapse(cur);\n\n            if (curValue !== finalValue) {\n              elem.setAttribute(\"class\", finalValue);\n            }\n          }\n        }\n      }\n\n      return this;\n    },\n    removeClass: function removeClass(value) {\n      var classes,\n          elem,\n          cur,\n          curValue,\n          clazz,\n          j,\n          finalValue,\n          i = 0;\n\n      if (isFunction(value)) {\n        return this.each(function (j) {\n          jQuery(this).removeClass(value.call(this, j, getClass(this)));\n        });\n      }\n\n      if (!arguments.length) {\n        return this.attr(\"class\", \"\");\n      }\n\n      classes = classesToArray(value);\n\n      if (classes.length) {\n        while (elem = this[i++]) {\n          curValue = getClass(elem); // This expression is here for better compressibility (see addClass)\n\n          cur = elem.nodeType === 1 && \" \" + stripAndCollapse(curValue) + \" \";\n\n          if (cur) {\n            j = 0;\n\n            while (clazz = classes[j++]) {\n              // Remove *all* instances\n              while (cur.indexOf(\" \" + clazz + \" \") > -1) {\n                cur = cur.replace(\" \" + clazz + \" \", \" \");\n              }\n            } // Only assign if different to avoid unneeded rendering.\n\n\n            finalValue = stripAndCollapse(cur);\n\n            if (curValue !== finalValue) {\n              elem.setAttribute(\"class\", finalValue);\n            }\n          }\n        }\n      }\n\n      return this;\n    },\n    toggleClass: function toggleClass(value, stateVal) {\n      var type = _typeof(value),\n          isValidValue = type === \"string\" || Array.isArray(value);\n\n      if (typeof stateVal === \"boolean\" && isValidValue) {\n        return stateVal ? this.addClass(value) : this.removeClass(value);\n      }\n\n      if (isFunction(value)) {\n        return this.each(function (i) {\n          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);\n        });\n      }\n\n      return this.each(function () {\n        var className, i, self, classNames;\n\n        if (isValidValue) {\n          // Toggle individual class names\n          i = 0;\n          self = jQuery(this);\n          classNames = classesToArray(value);\n\n          while (className = classNames[i++]) {\n            // Check each className given, space separated list\n            if (self.hasClass(className)) {\n              self.removeClass(className);\n            } else {\n              self.addClass(className);\n            }\n          } // Toggle whole class name\n\n        } else if (value === undefined || type === \"boolean\") {\n          className = getClass(this);\n\n          if (className) {\n            // Store className if set\n            dataPriv.set(this, \"__className__\", className);\n          } // If the element has a class name or if we're passed `false`,\n          // then remove the whole classname (if there was one, the above saved it).\n          // Otherwise bring back whatever was previously saved (if anything),\n          // falling back to the empty string if nothing was stored.\n\n\n          if (this.setAttribute) {\n            this.setAttribute(\"class\", className || value === false ? \"\" : dataPriv.get(this, \"__className__\") || \"\");\n          }\n        }\n      });\n    },\n    hasClass: function hasClass(selector) {\n      var className,\n          elem,\n          i = 0;\n      className = \" \" + selector + \" \";\n\n      while (elem = this[i++]) {\n        if (elem.nodeType === 1 && (\" \" + stripAndCollapse(getClass(elem)) + \" \").indexOf(className) > -1) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  });\n  var rreturn = /\\r/g;\n  jQuery.fn.extend({\n    val: function val(value) {\n      var hooks,\n          ret,\n          valueIsFunction,\n          elem = this[0];\n\n      if (!arguments.length) {\n        if (elem) {\n          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];\n\n          if (hooks && \"get\" in hooks && (ret = hooks.get(elem, \"value\")) !== undefined) {\n            return ret;\n          }\n\n          ret = elem.value; // Handle most common string cases\n\n          if (typeof ret === \"string\") {\n            return ret.replace(rreturn, \"\");\n          } // Handle cases where value is null/undef or number\n\n\n          return ret == null ? \"\" : ret;\n        }\n\n        return;\n      }\n\n      valueIsFunction = isFunction(value);\n      return this.each(function (i) {\n        var val;\n\n        if (this.nodeType !== 1) {\n          return;\n        }\n\n        if (valueIsFunction) {\n          val = value.call(this, i, jQuery(this).val());\n        } else {\n          val = value;\n        } // Treat null/undefined as \"\"; convert numbers to string\n\n\n        if (val == null) {\n          val = \"\";\n        } else if (typeof val === \"number\") {\n          val += \"\";\n        } else if (Array.isArray(val)) {\n          val = jQuery.map(val, function (value) {\n            return value == null ? \"\" : value + \"\";\n          });\n        }\n\n        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting\n\n        if (!hooks || !(\"set\" in hooks) || hooks.set(this, val, \"value\") === undefined) {\n          this.value = val;\n        }\n      });\n    }\n  });\n  jQuery.extend({\n    valHooks: {\n      option: {\n        get: function get(elem) {\n          var val = jQuery.find.attr(elem, \"value\");\n          return val != null ? val : // Support: IE <=10 - 11 only\n          // option.text throws exceptions (#14686, #14858)\n          // Strip and collapse whitespace\n          // https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n          stripAndCollapse(jQuery.text(elem));\n        }\n      },\n      select: {\n        get: function get(elem) {\n          var value,\n              option,\n              i,\n              options = elem.options,\n              index = elem.selectedIndex,\n              one = elem.type === \"select-one\",\n              values = one ? null : [],\n              max = one ? index + 1 : options.length;\n\n          if (index < 0) {\n            i = max;\n          } else {\n            i = one ? index : 0;\n          } // Loop through all the selected options\n\n\n          for (; i < max; i++) {\n            option = options[i]; // Support: IE <=9 only\n            // IE8-9 doesn't update selected after form reset (#2551)\n\n            if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup\n            !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, \"optgroup\"))) {\n              // Get the specific value for the option\n              value = jQuery(option).val(); // We don't need an array for one selects\n\n              if (one) {\n                return value;\n              } // Multi-Selects return an array\n\n\n              values.push(value);\n            }\n          }\n\n          return values;\n        },\n        set: function set(elem, value) {\n          var optionSet,\n              option,\n              options = elem.options,\n              values = jQuery.makeArray(value),\n              i = options.length;\n\n          while (i--) {\n            option = options[i];\n            /* eslint-disable no-cond-assign */\n\n            if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {\n              optionSet = true;\n            }\n            /* eslint-enable no-cond-assign */\n\n          } // Force browsers to behave consistently when non-matching value is set\n\n\n          if (!optionSet) {\n            elem.selectedIndex = -1;\n          }\n\n          return values;\n        }\n      }\n    }\n  }); // Radios and checkboxes getter/setter\n\n  jQuery.each([\"radio\", \"checkbox\"], function () {\n    jQuery.valHooks[this] = {\n      set: function set(elem, value) {\n        if (Array.isArray(value)) {\n          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;\n        }\n      }\n    };\n\n    if (!support.checkOn) {\n      jQuery.valHooks[this].get = function (elem) {\n        return elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n      };\n    }\n  }); // Return jQuery for attributes-only inclusion\n\n  support.focusin = \"onfocusin\" in window;\n\n  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n      stopPropagationCallback = function stopPropagationCallback(e) {\n    e.stopPropagation();\n  };\n\n  jQuery.extend(jQuery.event, {\n    trigger: function trigger(event, data, elem, onlyHandlers) {\n      var i,\n          cur,\n          tmp,\n          bubbleType,\n          ontype,\n          handle,\n          special,\n          lastElement,\n          eventPath = [elem || document],\n          type = hasOwn.call(event, \"type\") ? event.type : event,\n          namespaces = hasOwn.call(event, \"namespace\") ? event.namespace.split(\".\") : [];\n      cur = lastElement = tmp = elem = elem || document; // Don't do events on text and comment nodes\n\n      if (elem.nodeType === 3 || elem.nodeType === 8) {\n        return;\n      } // focus/blur morphs to focusin/out; ensure we're not firing them right now\n\n\n      if (rfocusMorph.test(type + jQuery.event.triggered)) {\n        return;\n      }\n\n      if (type.indexOf(\".\") > -1) {\n        // Namespaced trigger; create a regexp to match event type in handle()\n        namespaces = type.split(\".\");\n        type = namespaces.shift();\n        namespaces.sort();\n      }\n\n      ontype = type.indexOf(\":\") < 0 && \"on\" + type; // Caller can pass in a jQuery.Event object, Object, or just an event type string\n\n      event = event[jQuery.expando] ? event : new jQuery.Event(type, _typeof(event) === \"object\" && event); // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\n      event.isTrigger = onlyHandlers ? 2 : 3;\n      event.namespace = namespaces.join(\".\");\n      event.rnamespace = event.namespace ? new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null; // Clean up the event in case it is being reused\n\n      event.result = undefined;\n\n      if (!event.target) {\n        event.target = elem;\n      } // Clone any incoming data and prepend the event, creating the handler arg list\n\n\n      data = data == null ? [event] : jQuery.makeArray(data, [event]); // Allow special events to draw outside the lines\n\n      special = jQuery.event.special[type] || {};\n\n      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {\n        return;\n      } // Determine event propagation path in advance, per W3C events spec (#9951)\n      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\n\n      if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {\n        bubbleType = special.delegateType || type;\n\n        if (!rfocusMorph.test(bubbleType + type)) {\n          cur = cur.parentNode;\n        }\n\n        for (; cur; cur = cur.parentNode) {\n          eventPath.push(cur);\n          tmp = cur;\n        } // Only add window if we got to document (e.g., not plain obj or detached DOM)\n\n\n        if (tmp === (elem.ownerDocument || document)) {\n          eventPath.push(tmp.defaultView || tmp.parentWindow || window);\n        }\n      } // Fire handlers on the event path\n\n\n      i = 0;\n\n      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {\n        lastElement = cur;\n        event.type = i > 1 ? bubbleType : special.bindType || type; // jQuery handler\n\n        handle = (dataPriv.get(cur, \"events\") || {})[event.type] && dataPriv.get(cur, \"handle\");\n\n        if (handle) {\n          handle.apply(cur, data);\n        } // Native handler\n\n\n        handle = ontype && cur[ontype];\n\n        if (handle && handle.apply && acceptData(cur)) {\n          event.result = handle.apply(cur, data);\n\n          if (event.result === false) {\n            event.preventDefault();\n          }\n        }\n      }\n\n      event.type = type; // If nobody prevented the default action, do it now\n\n      if (!onlyHandlers && !event.isDefaultPrevented()) {\n        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {\n          // Call a native DOM method on the target with the same name as the event.\n          // Don't do default actions on window, that's where global variables be (#6170)\n          if (ontype && isFunction(elem[type]) && !isWindow(elem)) {\n            // Don't re-trigger an onFOO event when we call its FOO() method\n            tmp = elem[ontype];\n\n            if (tmp) {\n              elem[ontype] = null;\n            } // Prevent re-triggering of the same event, since we already bubbled it above\n\n\n            jQuery.event.triggered = type;\n\n            if (event.isPropagationStopped()) {\n              lastElement.addEventListener(type, stopPropagationCallback);\n            }\n\n            elem[type]();\n\n            if (event.isPropagationStopped()) {\n              lastElement.removeEventListener(type, stopPropagationCallback);\n            }\n\n            jQuery.event.triggered = undefined;\n\n            if (tmp) {\n              elem[ontype] = tmp;\n            }\n          }\n        }\n      }\n\n      return event.result;\n    },\n    // Piggyback on a donor event to simulate a different one\n    // Used only for `focus(in | out)` events\n    simulate: function simulate(type, elem, event) {\n      var e = jQuery.extend(new jQuery.Event(), event, {\n        type: type,\n        isSimulated: true\n      });\n      jQuery.event.trigger(e, null, elem);\n    }\n  });\n  jQuery.fn.extend({\n    trigger: function trigger(type, data) {\n      return this.each(function () {\n        jQuery.event.trigger(type, data, this);\n      });\n    },\n    triggerHandler: function triggerHandler(type, data) {\n      var elem = this[0];\n\n      if (elem) {\n        return jQuery.event.trigger(type, data, elem, true);\n      }\n    }\n  }); // Support: Firefox <=44\n  // Firefox doesn't have focus(in | out) events\n  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n  //\n  // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n  // focus(in | out) events fire after focus & blur events,\n  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n  // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\n\n  if (!support.focusin) {\n    jQuery.each({\n      focus: \"focusin\",\n      blur: \"focusout\"\n    }, function (orig, fix) {\n      // Attach a single capturing handler on the document while someone wants focusin/focusout\n      var handler = function handler(event) {\n        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));\n      };\n\n      jQuery.event.special[fix] = {\n        setup: function setup() {\n          var doc = this.ownerDocument || this,\n              attaches = dataPriv.access(doc, fix);\n\n          if (!attaches) {\n            doc.addEventListener(orig, handler, true);\n          }\n\n          dataPriv.access(doc, fix, (attaches || 0) + 1);\n        },\n        teardown: function teardown() {\n          var doc = this.ownerDocument || this,\n              attaches = dataPriv.access(doc, fix) - 1;\n\n          if (!attaches) {\n            doc.removeEventListener(orig, handler, true);\n            dataPriv.remove(doc, fix);\n          } else {\n            dataPriv.access(doc, fix, attaches);\n          }\n        }\n      };\n    });\n  }\n\n  var location = window.location;\n  var nonce = Date.now();\n  var rquery = /\\?/; // Cross-browser xml parsing\n\n  jQuery.parseXML = function (data) {\n    var xml;\n\n    if (!data || typeof data !== \"string\") {\n      return null;\n    } // Support: IE 9 - 11 only\n    // IE throws on parseFromString with invalid input.\n\n\n    try {\n      xml = new window.DOMParser().parseFromString(data, \"text/xml\");\n    } catch (e) {\n      xml = undefined;\n    }\n\n    if (!xml || xml.getElementsByTagName(\"parsererror\").length) {\n      jQuery.error(\"Invalid XML: \" + data);\n    }\n\n    return xml;\n  };\n\n  var rbracket = /\\[\\]$/,\n      rCRLF = /\\r?\\n/g,\n      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n      rsubmittable = /^(?:input|select|textarea|keygen)/i;\n\n  function buildParams(prefix, obj, traditional, add) {\n    var name;\n\n    if (Array.isArray(obj)) {\n      // Serialize array item.\n      jQuery.each(obj, function (i, v) {\n        if (traditional || rbracket.test(prefix)) {\n          // Treat each array item as a scalar.\n          add(prefix, v);\n        } else {\n          // Item is non-scalar (array or object), encode its numeric index.\n          buildParams(prefix + \"[\" + (_typeof(v) === \"object\" && v != null ? i : \"\") + \"]\", v, traditional, add);\n        }\n      });\n    } else if (!traditional && toType(obj) === \"object\") {\n      // Serialize object item.\n      for (name in obj) {\n        buildParams(prefix + \"[\" + name + \"]\", obj[name], traditional, add);\n      }\n    } else {\n      // Serialize scalar item.\n      add(prefix, obj);\n    }\n  } // Serialize an array of form elements or a set of\n  // key/values into a query string\n\n\n  jQuery.param = function (a, traditional) {\n    var prefix,\n        s = [],\n        add = function add(key, valueOrFunction) {\n      // If value is a function, invoke it and use its return value\n      var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;\n      s[s.length] = encodeURIComponent(key) + \"=\" + encodeURIComponent(value == null ? \"\" : value);\n    };\n\n    if (a == null) {\n      return \"\";\n    } // If an array was passed in, assume that it is an array of form elements.\n\n\n    if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {\n      // Serialize the form elements\n      jQuery.each(a, function () {\n        add(this.name, this.value);\n      });\n    } else {\n      // If traditional, encode the \"old\" way (the way 1.3.2 or older\n      // did it), otherwise encode params recursively.\n      for (prefix in a) {\n        buildParams(prefix, a[prefix], traditional, add);\n      }\n    } // Return the resulting serialization\n\n\n    return s.join(\"&\");\n  };\n\n  jQuery.fn.extend({\n    serialize: function serialize() {\n      return jQuery.param(this.serializeArray());\n    },\n    serializeArray: function serializeArray() {\n      return this.map(function () {\n        // Can add propHook for \"elements\" to filter or add form elements\n        var elements = jQuery.prop(this, \"elements\");\n        return elements ? jQuery.makeArray(elements) : this;\n      }).filter(function () {\n        var type = this.type; // Use .is( \":disabled\" ) so that fieldset[disabled] works\n\n        return this.name && !jQuery(this).is(\":disabled\") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));\n      }).map(function (i, elem) {\n        var val = jQuery(this).val();\n\n        if (val == null) {\n          return null;\n        }\n\n        if (Array.isArray(val)) {\n          return jQuery.map(val, function (val) {\n            return {\n              name: elem.name,\n              value: val.replace(rCRLF, \"\\r\\n\")\n            };\n          });\n        }\n\n        return {\n          name: elem.name,\n          value: val.replace(rCRLF, \"\\r\\n\")\n        };\n      }).get();\n    }\n  });\n  var r20 = /%20/g,\n      rhash = /#.*$/,\n      rantiCache = /([?&])_=[^&]*/,\n      rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n      // #7653, #8125, #8152: local protocol detection\n  rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n      rnoContent = /^(?:GET|HEAD)$/,\n      rprotocol = /^\\/\\//,\n\n  /* Prefilters\n   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n   * 2) These are called:\n   *    - BEFORE asking for a transport\n   *    - AFTER param serialization (s.data is a string if s.processData is true)\n   * 3) key is the dataType\n   * 4) the catchall symbol \"*\" can be used\n   * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n   */\n  prefilters = {},\n\n  /* Transports bindings\n   * 1) key is the dataType\n   * 2) the catchall symbol \"*\" can be used\n   * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n   */\n  transports = {},\n      // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n  allTypes = \"*/\".concat(\"*\"),\n      // Anchor tag for parsing the document origin\n  originAnchor = document.createElement(\"a\");\n  originAnchor.href = location.href; // Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n\n  function addToPrefiltersOrTransports(structure) {\n    // dataTypeExpression is optional and defaults to \"*\"\n    return function (dataTypeExpression, func) {\n      if (typeof dataTypeExpression !== \"string\") {\n        func = dataTypeExpression;\n        dataTypeExpression = \"*\";\n      }\n\n      var dataType,\n          i = 0,\n          dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];\n\n      if (isFunction(func)) {\n        // For each dataType in the dataTypeExpression\n        while (dataType = dataTypes[i++]) {\n          // Prepend if requested\n          if (dataType[0] === \"+\") {\n            dataType = dataType.slice(1) || \"*\";\n            (structure[dataType] = structure[dataType] || []).unshift(func); // Otherwise append\n          } else {\n            (structure[dataType] = structure[dataType] || []).push(func);\n          }\n        }\n      }\n    };\n  } // Base inspection function for prefilters and transports\n\n\n  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {\n    var inspected = {},\n        seekingTransport = structure === transports;\n\n    function inspect(dataType) {\n      var selected;\n      inspected[dataType] = true;\n      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {\n        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);\n\n        if (typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[dataTypeOrTransport]) {\n          options.dataTypes.unshift(dataTypeOrTransport);\n          inspect(dataTypeOrTransport);\n          return false;\n        } else if (seekingTransport) {\n          return !(selected = dataTypeOrTransport);\n        }\n      });\n      return selected;\n    }\n\n    return inspect(options.dataTypes[0]) || !inspected[\"*\"] && inspect(\"*\");\n  } // A special extend for ajax options\n  // that takes \"flat\" options (not to be deep extended)\n  // Fixes #9887\n\n\n  function ajaxExtend(target, src) {\n    var key,\n        deep,\n        flatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n    for (key in src) {\n      if (src[key] !== undefined) {\n        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];\n      }\n    }\n\n    if (deep) {\n      jQuery.extend(true, target, deep);\n    }\n\n    return target;\n  }\n  /* Handles responses to an ajax request:\n   * - finds the right dataType (mediates between content-type and expected dataType)\n   * - returns the corresponding response\n   */\n\n\n  function ajaxHandleResponses(s, jqXHR, responses) {\n    var ct,\n        type,\n        finalDataType,\n        firstDataType,\n        contents = s.contents,\n        dataTypes = s.dataTypes; // Remove auto dataType and get content-type in the process\n\n    while (dataTypes[0] === \"*\") {\n      dataTypes.shift();\n\n      if (ct === undefined) {\n        ct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n      }\n    } // Check if we're dealing with a known content-type\n\n\n    if (ct) {\n      for (type in contents) {\n        if (contents[type] && contents[type].test(ct)) {\n          dataTypes.unshift(type);\n          break;\n        }\n      }\n    } // Check to see if we have a response for the expected dataType\n\n\n    if (dataTypes[0] in responses) {\n      finalDataType = dataTypes[0];\n    } else {\n      // Try convertible dataTypes\n      for (type in responses) {\n        if (!dataTypes[0] || s.converters[type + \" \" + dataTypes[0]]) {\n          finalDataType = type;\n          break;\n        }\n\n        if (!firstDataType) {\n          firstDataType = type;\n        }\n      } // Or just use first one\n\n\n      finalDataType = finalDataType || firstDataType;\n    } // If we found a dataType\n    // We add the dataType to the list if needed\n    // and return the corresponding response\n\n\n    if (finalDataType) {\n      if (finalDataType !== dataTypes[0]) {\n        dataTypes.unshift(finalDataType);\n      }\n\n      return responses[finalDataType];\n    }\n  }\n  /* Chain conversions given the request and the original response\n   * Also sets the responseXXX fields on the jqXHR instance\n   */\n\n\n  function ajaxConvert(s, response, jqXHR, isSuccess) {\n    var conv2,\n        current,\n        conv,\n        tmp,\n        prev,\n        converters = {},\n        // Work with a copy of dataTypes in case we need to modify it for conversion\n    dataTypes = s.dataTypes.slice(); // Create converters map with lowercased keys\n\n    if (dataTypes[1]) {\n      for (conv in s.converters) {\n        converters[conv.toLowerCase()] = s.converters[conv];\n      }\n    }\n\n    current = dataTypes.shift(); // Convert to each sequential dataType\n\n    while (current) {\n      if (s.responseFields[current]) {\n        jqXHR[s.responseFields[current]] = response;\n      } // Apply the dataFilter if provided\n\n\n      if (!prev && isSuccess && s.dataFilter) {\n        response = s.dataFilter(response, s.dataType);\n      }\n\n      prev = current;\n      current = dataTypes.shift();\n\n      if (current) {\n        // There's only work to do if current dataType is non-auto\n        if (current === \"*\") {\n          current = prev; // Convert response if prev dataType is non-auto and differs from current\n        } else if (prev !== \"*\" && prev !== current) {\n          // Seek a direct converter\n          conv = converters[prev + \" \" + current] || converters[\"* \" + current]; // If none found, seek a pair\n\n          if (!conv) {\n            for (conv2 in converters) {\n              // If conv2 outputs current\n              tmp = conv2.split(\" \");\n\n              if (tmp[1] === current) {\n                // If prev can be converted to accepted input\n                conv = converters[prev + \" \" + tmp[0]] || converters[\"* \" + tmp[0]];\n\n                if (conv) {\n                  // Condense equivalence converters\n                  if (conv === true) {\n                    conv = converters[conv2]; // Otherwise, insert the intermediate dataType\n                  } else if (converters[conv2] !== true) {\n                    current = tmp[0];\n                    dataTypes.unshift(tmp[1]);\n                  }\n\n                  break;\n                }\n              }\n            }\n          } // Apply converter (if not an equivalence)\n\n\n          if (conv !== true) {\n            // Unless errors are allowed to bubble, catch and return them\n            if (conv && s[\"throws\"]) {\n              response = conv(response);\n            } else {\n              try {\n                response = conv(response);\n              } catch (e) {\n                return {\n                  state: \"parsererror\",\n                  error: conv ? e : \"No conversion from \" + prev + \" to \" + current\n                };\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      state: \"success\",\n      data: response\n    };\n  }\n\n  jQuery.extend({\n    // Counter for holding the number of active queries\n    active: 0,\n    // Last-Modified header cache for next request\n    lastModified: {},\n    etag: {},\n    ajaxSettings: {\n      url: location.href,\n      type: \"GET\",\n      isLocal: rlocalProtocol.test(location.protocol),\n      global: true,\n      processData: true,\n      async: true,\n      contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n      /*\n      timeout: 0,\n      data: null,\n      dataType: null,\n      username: null,\n      password: null,\n      cache: null,\n      throws: false,\n      traditional: false,\n      headers: {},\n      */\n      accepts: {\n        \"*\": allTypes,\n        text: \"text/plain\",\n        html: \"text/html\",\n        xml: \"application/xml, text/xml\",\n        json: \"application/json, text/javascript\"\n      },\n      contents: {\n        xml: /\\bxml\\b/,\n        html: /\\bhtml/,\n        json: /\\bjson\\b/\n      },\n      responseFields: {\n        xml: \"responseXML\",\n        text: \"responseText\",\n        json: \"responseJSON\"\n      },\n      // Data converters\n      // Keys separate source (or catchall \"*\") and destination types with a single space\n      converters: {\n        // Convert anything to text\n        \"* text\": String,\n        // Text to html (true = no transformation)\n        \"text html\": true,\n        // Evaluate text as a json expression\n        \"text json\": JSON.parse,\n        // Parse text as xml\n        \"text xml\": jQuery.parseXML\n      },\n      // For options that shouldn't be deep extended:\n      // you can add your own custom options here if\n      // and when you create one that shouldn't be\n      // deep extended (see ajaxExtend)\n      flatOptions: {\n        url: true,\n        context: true\n      }\n    },\n    // Creates a full fledged settings object into target\n    // with both ajaxSettings and settings fields.\n    // If target is omitted, writes into ajaxSettings.\n    ajaxSetup: function ajaxSetup(target, settings) {\n      return settings ? // Building a settings object\n      ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings\n      ajaxExtend(jQuery.ajaxSettings, target);\n    },\n    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),\n    ajaxTransport: addToPrefiltersOrTransports(transports),\n    // Main method\n    ajax: function ajax(url, options) {\n      // If url is an object, simulate pre-1.5 signature\n      if (_typeof(url) === \"object\") {\n        options = url;\n        url = undefined;\n      } // Force options to be an object\n\n\n      options = options || {};\n\n      var transport,\n          // URL without anti-cache param\n      cacheURL,\n          // Response headers\n      responseHeadersString,\n          responseHeaders,\n          // timeout handle\n      timeoutTimer,\n          // Url cleanup var\n      urlAnchor,\n          // Request state (becomes false upon send and true upon completion)\n      completed,\n          // To know if global events are to be dispatched\n      fireGlobals,\n          // Loop variable\n      i,\n          // uncached part of the url\n      uncached,\n          // Create the final options object\n      s = jQuery.ajaxSetup({}, options),\n          // Callbacks context\n      callbackContext = s.context || s,\n          // Context for global events is callbackContext if it is a DOM node or jQuery collection\n      globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,\n          // Deferreds\n      deferred = jQuery.Deferred(),\n          completeDeferred = jQuery.Callbacks(\"once memory\"),\n          // Status-dependent callbacks\n      _statusCode = s.statusCode || {},\n          // Headers (they are sent all at once)\n      requestHeaders = {},\n          requestHeadersNames = {},\n          // Default abort message\n      strAbort = \"canceled\",\n          // Fake xhr\n      jqXHR = {\n        readyState: 0,\n        // Builds headers hashtable if needed\n        getResponseHeader: function getResponseHeader(key) {\n          var match;\n\n          if (completed) {\n            if (!responseHeaders) {\n              responseHeaders = {};\n\n              while (match = rheaders.exec(responseHeadersString)) {\n                responseHeaders[match[1].toLowerCase() + \" \"] = (responseHeaders[match[1].toLowerCase() + \" \"] || []).concat(match[2]);\n              }\n            }\n\n            match = responseHeaders[key.toLowerCase() + \" \"];\n          }\n\n          return match == null ? null : match.join(\", \");\n        },\n        // Raw string\n        getAllResponseHeaders: function getAllResponseHeaders() {\n          return completed ? responseHeadersString : null;\n        },\n        // Caches the header\n        setRequestHeader: function setRequestHeader(name, value) {\n          if (completed == null) {\n            name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;\n            requestHeaders[name] = value;\n          }\n\n          return this;\n        },\n        // Overrides response content-type header\n        overrideMimeType: function overrideMimeType(type) {\n          if (completed == null) {\n            s.mimeType = type;\n          }\n\n          return this;\n        },\n        // Status-dependent callbacks\n        statusCode: function statusCode(map) {\n          var code;\n\n          if (map) {\n            if (completed) {\n              // Execute the appropriate callbacks\n              jqXHR.always(map[jqXHR.status]);\n            } else {\n              // Lazy-add the new callbacks in a way that preserves old ones\n              for (code in map) {\n                _statusCode[code] = [_statusCode[code], map[code]];\n              }\n            }\n          }\n\n          return this;\n        },\n        // Cancel the request\n        abort: function abort(statusText) {\n          var finalText = statusText || strAbort;\n\n          if (transport) {\n            transport.abort(finalText);\n          }\n\n          done(0, finalText);\n          return this;\n        }\n      }; // Attach deferreds\n\n\n      deferred.promise(jqXHR); // Add protocol if not provided (prefilters might expect it)\n      // Handle falsy url in the settings object (#10093: consistency with old signature)\n      // We also use the url parameter if available\n\n      s.url = ((url || s.url || location.href) + \"\").replace(rprotocol, location.protocol + \"//\"); // Alias method option to type as per ticket #12004\n\n      s.type = options.method || options.type || s.method || s.type; // Extract dataTypes list\n\n      s.dataTypes = (s.dataType || \"*\").toLowerCase().match(rnothtmlwhite) || [\"\"]; // A cross-domain request is in order when the origin doesn't match the current origin.\n\n      if (s.crossDomain == null) {\n        urlAnchor = document.createElement(\"a\"); // Support: IE <=8 - 11, Edge 12 - 15\n        // IE throws exception on accessing the href property if url is malformed,\n        // e.g. http://example.com:80x/\n\n        try {\n          urlAnchor.href = s.url; // Support: IE <=8 - 11 only\n          // Anchor's host property isn't correctly set when s.url is relative\n\n          urlAnchor.href = urlAnchor.href;\n          s.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !== urlAnchor.protocol + \"//\" + urlAnchor.host;\n        } catch (e) {\n          // If there is an error parsing the URL, assume it is crossDomain,\n          // it can be rejected by the transport if it is invalid\n          s.crossDomain = true;\n        }\n      } // Convert data if not already a string\n\n\n      if (s.data && s.processData && typeof s.data !== \"string\") {\n        s.data = jQuery.param(s.data, s.traditional);\n      } // Apply prefilters\n\n\n      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there\n\n      if (completed) {\n        return jqXHR;\n      } // We can fire global events as of now if asked to\n      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\n\n      fireGlobals = jQuery.event && s.global; // Watch for a new set of requests\n\n      if (fireGlobals && jQuery.active++ === 0) {\n        jQuery.event.trigger(\"ajaxStart\");\n      } // Uppercase the type\n\n\n      s.type = s.type.toUpperCase(); // Determine if request has content\n\n      s.hasContent = !rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since\n      // and/or If-None-Match header later on\n      // Remove hash to simplify url manipulation\n\n      cacheURL = s.url.replace(rhash, \"\"); // More options handling for requests with no content\n\n      if (!s.hasContent) {\n        // Remember the hash so we can put it back\n        uncached = s.url.slice(cacheURL.length); // If data is available and should be processed, append data to url\n\n        if (s.data && (s.processData || typeof s.data === \"string\")) {\n          cacheURL += (rquery.test(cacheURL) ? \"&\" : \"?\") + s.data; // #9682: remove data so that it's not used in an eventual retry\n\n          delete s.data;\n        } // Add or update anti-cache param if needed\n\n\n        if (s.cache === false) {\n          cacheURL = cacheURL.replace(rantiCache, \"$1\");\n          uncached = (rquery.test(cacheURL) ? \"&\" : \"?\") + \"_=\" + nonce++ + uncached;\n        } // Put hash and anti-cache on the URL that will be requested (gh-1732)\n\n\n        s.url = cacheURL + uncached; // Change '%20' to '+' if this is encoded form body content (gh-2658)\n      } else if (s.data && s.processData && (s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") === 0) {\n        s.data = s.data.replace(r20, \"+\");\n      } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\n\n      if (s.ifModified) {\n        if (jQuery.lastModified[cacheURL]) {\n          jqXHR.setRequestHeader(\"If-Modified-Since\", jQuery.lastModified[cacheURL]);\n        }\n\n        if (jQuery.etag[cacheURL]) {\n          jqXHR.setRequestHeader(\"If-None-Match\", jQuery.etag[cacheURL]);\n        }\n      } // Set the correct header, if data is being sent\n\n\n      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {\n        jqXHR.setRequestHeader(\"Content-Type\", s.contentType);\n      } // Set the Accepts header for the server, depending on the dataType\n\n\n      jqXHR.setRequestHeader(\"Accept\", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\") : s.accepts[\"*\"]); // Check for headers option\n\n      for (i in s.headers) {\n        jqXHR.setRequestHeader(i, s.headers[i]);\n      } // Allow custom headers/mimetypes and early abort\n\n\n      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {\n        // Abort if not done already and return\n        return jqXHR.abort();\n      } // Aborting is no longer a cancellation\n\n\n      strAbort = \"abort\"; // Install callbacks on deferreds\n\n      completeDeferred.add(s.complete);\n      jqXHR.done(s.success);\n      jqXHR.fail(s.error); // Get transport\n\n      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort\n\n      if (!transport) {\n        done(-1, \"No Transport\");\n      } else {\n        jqXHR.readyState = 1; // Send global event\n\n        if (fireGlobals) {\n          globalEventContext.trigger(\"ajaxSend\", [jqXHR, s]);\n        } // If request was aborted inside ajaxSend, stop there\n\n\n        if (completed) {\n          return jqXHR;\n        } // Timeout\n\n\n        if (s.async && s.timeout > 0) {\n          timeoutTimer = window.setTimeout(function () {\n            jqXHR.abort(\"timeout\");\n          }, s.timeout);\n        }\n\n        try {\n          completed = false;\n          transport.send(requestHeaders, done);\n        } catch (e) {\n          // Rethrow post-completion exceptions\n          if (completed) {\n            throw e;\n          } // Propagate others as results\n\n\n          done(-1, e);\n        }\n      } // Callback for when everything is done\n\n\n      function done(status, nativeStatusText, responses, headers) {\n        var isSuccess,\n            success,\n            error,\n            response,\n            modified,\n            statusText = nativeStatusText; // Ignore repeat invocations\n\n        if (completed) {\n          return;\n        }\n\n        completed = true; // Clear timeout if it exists\n\n        if (timeoutTimer) {\n          window.clearTimeout(timeoutTimer);\n        } // Dereference transport for early garbage collection\n        // (no matter how long the jqXHR object will be used)\n\n\n        transport = undefined; // Cache response headers\n\n        responseHeadersString = headers || \"\"; // Set readyState\n\n        jqXHR.readyState = status > 0 ? 4 : 0; // Determine if successful\n\n        isSuccess = status >= 200 && status < 300 || status === 304; // Get response data\n\n        if (responses) {\n          response = ajaxHandleResponses(s, jqXHR, responses);\n        } // Convert no matter what (that way responseXXX fields are always set)\n\n\n        response = ajaxConvert(s, response, jqXHR, isSuccess); // If successful, handle type chaining\n\n        if (isSuccess) {\n          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n          if (s.ifModified) {\n            modified = jqXHR.getResponseHeader(\"Last-Modified\");\n\n            if (modified) {\n              jQuery.lastModified[cacheURL] = modified;\n            }\n\n            modified = jqXHR.getResponseHeader(\"etag\");\n\n            if (modified) {\n              jQuery.etag[cacheURL] = modified;\n            }\n          } // if no content\n\n\n          if (status === 204 || s.type === \"HEAD\") {\n            statusText = \"nocontent\"; // if not modified\n          } else if (status === 304) {\n            statusText = \"notmodified\"; // If we have data, let's convert it\n          } else {\n            statusText = response.state;\n            success = response.data;\n            error = response.error;\n            isSuccess = !error;\n          }\n        } else {\n          // Extract error from statusText and normalize for non-aborts\n          error = statusText;\n\n          if (status || !statusText) {\n            statusText = \"error\";\n\n            if (status < 0) {\n              status = 0;\n            }\n          }\n        } // Set data for the fake xhr object\n\n\n        jqXHR.status = status;\n        jqXHR.statusText = (nativeStatusText || statusText) + \"\"; // Success/Error\n\n        if (isSuccess) {\n          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);\n        } else {\n          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);\n        } // Status-dependent callbacks\n\n\n        jqXHR.statusCode(_statusCode);\n        _statusCode = undefined;\n\n        if (fireGlobals) {\n          globalEventContext.trigger(isSuccess ? \"ajaxSuccess\" : \"ajaxError\", [jqXHR, s, isSuccess ? success : error]);\n        } // Complete\n\n\n        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);\n\n        if (fireGlobals) {\n          globalEventContext.trigger(\"ajaxComplete\", [jqXHR, s]); // Handle the global AJAX counter\n\n          if (! --jQuery.active) {\n            jQuery.event.trigger(\"ajaxStop\");\n          }\n        }\n      }\n\n      return jqXHR;\n    },\n    getJSON: function getJSON(url, data, callback) {\n      return jQuery.get(url, data, callback, \"json\");\n    },\n    getScript: function getScript(url, callback) {\n      return jQuery.get(url, undefined, callback, \"script\");\n    }\n  });\n  jQuery.each([\"get\", \"post\"], function (i, method) {\n    jQuery[method] = function (url, data, callback, type) {\n      // Shift arguments if data argument was omitted\n      if (isFunction(data)) {\n        type = type || callback;\n        callback = data;\n        data = undefined;\n      } // The url can be an options object (which then must have .url)\n\n\n      return jQuery.ajax(jQuery.extend({\n        url: url,\n        type: method,\n        dataType: type,\n        data: data,\n        success: callback\n      }, jQuery.isPlainObject(url) && url));\n    };\n  });\n\n  jQuery._evalUrl = function (url, options) {\n    return jQuery.ajax({\n      url: url,\n      // Make this explicit, since user can override this through ajaxSetup (#11264)\n      type: \"GET\",\n      dataType: \"script\",\n      cache: true,\n      async: false,\n      global: false,\n      // Only evaluate the response if it is successful (gh-4126)\n      // dataFilter is not invoked for failure responses, so using it instead\n      // of the default converter is kludgy but it works.\n      converters: {\n        \"text script\": function textScript() {}\n      },\n      dataFilter: function dataFilter(response) {\n        jQuery.globalEval(response, options);\n      }\n    });\n  };\n\n  jQuery.fn.extend({\n    wrapAll: function wrapAll(html) {\n      var wrap;\n\n      if (this[0]) {\n        if (isFunction(html)) {\n          html = html.call(this[0]);\n        } // The elements to wrap the target around\n\n\n        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);\n\n        if (this[0].parentNode) {\n          wrap.insertBefore(this[0]);\n        }\n\n        wrap.map(function () {\n          var elem = this;\n\n          while (elem.firstElementChild) {\n            elem = elem.firstElementChild;\n          }\n\n          return elem;\n        }).append(this);\n      }\n\n      return this;\n    },\n    wrapInner: function wrapInner(html) {\n      if (isFunction(html)) {\n        return this.each(function (i) {\n          jQuery(this).wrapInner(html.call(this, i));\n        });\n      }\n\n      return this.each(function () {\n        var self = jQuery(this),\n            contents = self.contents();\n\n        if (contents.length) {\n          contents.wrapAll(html);\n        } else {\n          self.append(html);\n        }\n      });\n    },\n    wrap: function wrap(html) {\n      var htmlIsFunction = isFunction(html);\n      return this.each(function (i) {\n        jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);\n      });\n    },\n    unwrap: function unwrap(selector) {\n      this.parent(selector).not(\"body\").each(function () {\n        jQuery(this).replaceWith(this.childNodes);\n      });\n      return this;\n    }\n  });\n\n  jQuery.expr.pseudos.hidden = function (elem) {\n    return !jQuery.expr.pseudos.visible(elem);\n  };\n\n  jQuery.expr.pseudos.visible = function (elem) {\n    return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);\n  };\n\n  jQuery.ajaxSettings.xhr = function () {\n    try {\n      return new window.XMLHttpRequest();\n    } catch (e) {}\n  };\n\n  var xhrSuccessStatus = {\n    // File protocol always yields status code 0, assume 200\n    0: 200,\n    // Support: IE <=9 only\n    // #1450: sometimes IE returns 1223 when it should be 204\n    1223: 204\n  },\n      xhrSupported = jQuery.ajaxSettings.xhr();\n  support.cors = !!xhrSupported && \"withCredentials\" in xhrSupported;\n  support.ajax = xhrSupported = !!xhrSupported;\n  jQuery.ajaxTransport(function (options) {\n    var _callback, errorCallback; // Cross domain only allowed if supported through XMLHttpRequest\n\n\n    if (support.cors || xhrSupported && !options.crossDomain) {\n      return {\n        send: function send(headers, complete) {\n          var i,\n              xhr = options.xhr();\n          xhr.open(options.type, options.url, options.async, options.username, options.password); // Apply custom fields if provided\n\n          if (options.xhrFields) {\n            for (i in options.xhrFields) {\n              xhr[i] = options.xhrFields[i];\n            }\n          } // Override mime type if needed\n\n\n          if (options.mimeType && xhr.overrideMimeType) {\n            xhr.overrideMimeType(options.mimeType);\n          } // X-Requested-With header\n          // For cross-domain requests, seeing as conditions for a preflight are\n          // akin to a jigsaw puzzle, we simply never set it to be sure.\n          // (it can always be set on a per-request basis or even using ajaxSetup)\n          // For same-domain requests, won't change header if already provided.\n\n\n          if (!options.crossDomain && !headers[\"X-Requested-With\"]) {\n            headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\n          } // Set headers\n\n\n          for (i in headers) {\n            xhr.setRequestHeader(i, headers[i]);\n          } // Callback\n\n\n          _callback = function callback(type) {\n            return function () {\n              if (_callback) {\n                _callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;\n\n                if (type === \"abort\") {\n                  xhr.abort();\n                } else if (type === \"error\") {\n                  // Support: IE <=9 only\n                  // On a manual native abort, IE9 throws\n                  // errors on any property access that is not readyState\n                  if (typeof xhr.status !== \"number\") {\n                    complete(0, \"error\");\n                  } else {\n                    complete( // File: protocol always yields status 0; see #8605, #14207\n                    xhr.status, xhr.statusText);\n                  }\n                } else {\n                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE <=9 only\n                  // IE9 has no XHR2 but throws on binary (trac-11426)\n                  // For XHR2 non-text, let the caller handle it (gh-2498)\n                  (xhr.responseType || \"text\") !== \"text\" || typeof xhr.responseText !== \"string\" ? {\n                    binary: xhr.response\n                  } : {\n                    text: xhr.responseText\n                  }, xhr.getAllResponseHeaders());\n                }\n              }\n            };\n          }; // Listen to events\n\n\n          xhr.onload = _callback();\n          errorCallback = xhr.onerror = xhr.ontimeout = _callback(\"error\"); // Support: IE 9 only\n          // Use onreadystatechange to replace onabort\n          // to handle uncaught aborts\n\n          if (xhr.onabort !== undefined) {\n            xhr.onabort = errorCallback;\n          } else {\n            xhr.onreadystatechange = function () {\n              // Check readyState before timeout as it changes\n              if (xhr.readyState === 4) {\n                // Allow onerror to be called first,\n                // but that will not handle a native abort\n                // Also, save errorCallback to a variable\n                // as xhr.onerror cannot be accessed\n                window.setTimeout(function () {\n                  if (_callback) {\n                    errorCallback();\n                  }\n                });\n              }\n            };\n          } // Create the abort callback\n\n\n          _callback = _callback(\"abort\");\n\n          try {\n            // Do send the request (this may raise an exception)\n            xhr.send(options.hasContent && options.data || null);\n          } catch (e) {\n            // #14683: Only rethrow if this hasn't been notified as an error yet\n            if (_callback) {\n              throw e;\n            }\n          }\n        },\n        abort: function abort() {\n          if (_callback) {\n            _callback();\n          }\n        }\n      };\n    }\n  }); // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\n\n  jQuery.ajaxPrefilter(function (s) {\n    if (s.crossDomain) {\n      s.contents.script = false;\n    }\n  }); // Install script dataType\n\n  jQuery.ajaxSetup({\n    accepts: {\n      script: \"text/javascript, application/javascript, \" + \"application/ecmascript, application/x-ecmascript\"\n    },\n    contents: {\n      script: /\\b(?:java|ecma)script\\b/\n    },\n    converters: {\n      \"text script\": function textScript(text) {\n        jQuery.globalEval(text);\n        return text;\n      }\n    }\n  }); // Handle cache's special case and crossDomain\n\n  jQuery.ajaxPrefilter(\"script\", function (s) {\n    if (s.cache === undefined) {\n      s.cache = false;\n    }\n\n    if (s.crossDomain) {\n      s.type = \"GET\";\n    }\n  }); // Bind script tag hack transport\n\n  jQuery.ajaxTransport(\"script\", function (s) {\n    // This transport only deals with cross domain or forced-by-attrs requests\n    if (s.crossDomain || s.scriptAttrs) {\n      var script, _callback2;\n\n      return {\n        send: function send(_, complete) {\n          script = jQuery(\"<script>\").attr(s.scriptAttrs || {}).prop({\n            charset: s.scriptCharset,\n            src: s.url\n          }).on(\"load error\", _callback2 = function callback(evt) {\n            script.remove();\n            _callback2 = null;\n\n            if (evt) {\n              complete(evt.type === \"error\" ? 404 : 200, evt.type);\n            }\n          }); // Use native DOM manipulation to avoid our domManip AJAX trickery\n\n          document.head.appendChild(script[0]);\n        },\n        abort: function abort() {\n          if (_callback2) {\n            _callback2();\n          }\n        }\n      };\n    }\n  });\n  var oldCallbacks = [],\n      rjsonp = /(=)\\?(?=&|$)|\\?\\?/; // Default jsonp settings\n\n  jQuery.ajaxSetup({\n    jsonp: \"callback\",\n    jsonpCallback: function jsonpCallback() {\n      var callback = oldCallbacks.pop() || jQuery.expando + \"_\" + nonce++;\n      this[callback] = true;\n      return callback;\n    }\n  }); // Detect, normalize options and install callbacks for jsonp requests\n\n  jQuery.ajaxPrefilter(\"json jsonp\", function (s, originalSettings, jqXHR) {\n    var callbackName,\n        overwritten,\n        responseContainer,\n        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? \"url\" : typeof s.data === \"string\" && (s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") === 0 && rjsonp.test(s.data) && \"data\"); // Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\n    if (jsonProp || s.dataTypes[0] === \"jsonp\") {\n      // Get callback name, remembering preexisting value associated with it\n      callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback; // Insert callback into url or form data\n\n      if (jsonProp) {\n        s[jsonProp] = s[jsonProp].replace(rjsonp, \"$1\" + callbackName);\n      } else if (s.jsonp !== false) {\n        s.url += (rquery.test(s.url) ? \"&\" : \"?\") + s.jsonp + \"=\" + callbackName;\n      } // Use data converter to retrieve json after script execution\n\n\n      s.converters[\"script json\"] = function () {\n        if (!responseContainer) {\n          jQuery.error(callbackName + \" was not called\");\n        }\n\n        return responseContainer[0];\n      }; // Force json dataType\n\n\n      s.dataTypes[0] = \"json\"; // Install callback\n\n      overwritten = window[callbackName];\n\n      window[callbackName] = function () {\n        responseContainer = arguments;\n      }; // Clean-up function (fires after converters)\n\n\n      jqXHR.always(function () {\n        // If previous value didn't exist - remove it\n        if (overwritten === undefined) {\n          jQuery(window).removeProp(callbackName); // Otherwise restore preexisting value\n        } else {\n          window[callbackName] = overwritten;\n        } // Save back as free\n\n\n        if (s[callbackName]) {\n          // Make sure that re-using the options doesn't screw things around\n          s.jsonpCallback = originalSettings.jsonpCallback; // Save the callback name for future use\n\n          oldCallbacks.push(callbackName);\n        } // Call if it was a function and we have a response\n\n\n        if (responseContainer && isFunction(overwritten)) {\n          overwritten(responseContainer[0]);\n        }\n\n        responseContainer = overwritten = undefined;\n      }); // Delegate to script\n\n      return \"script\";\n    }\n  }); // Support: Safari 8 only\n  // In Safari 8 documents created via document.implementation.createHTMLDocument\n  // collapse sibling forms: the second one becomes a child of the first one.\n  // Because of that, this security measure has to be disabled in Safari 8.\n  // https://bugs.webkit.org/show_bug.cgi?id=137337\n\n  support.createHTMLDocument = function () {\n    var body = document.implementation.createHTMLDocument(\"\").body;\n    body.innerHTML = \"<form></form><form></form>\";\n    return body.childNodes.length === 2;\n  }(); // Argument \"data\" should be string of html\n  // context (optional): If specified, the fragment will be created in this context,\n  // defaults to document\n  // keepScripts (optional): If true, will include scripts passed in the html string\n\n\n  jQuery.parseHTML = function (data, context, keepScripts) {\n    if (typeof data !== \"string\") {\n      return [];\n    }\n\n    if (typeof context === \"boolean\") {\n      keepScripts = context;\n      context = false;\n    }\n\n    var base, parsed, scripts;\n\n    if (!context) {\n      // Stop scripts or inline event handlers from being executed immediately\n      // by using document.implementation\n      if (support.createHTMLDocument) {\n        context = document.implementation.createHTMLDocument(\"\"); // Set the base href for the created document\n        // so any parsed elements with URLs\n        // are based on the document's URL (gh-2965)\n\n        base = context.createElement(\"base\");\n        base.href = document.location.href;\n        context.head.appendChild(base);\n      } else {\n        context = document;\n      }\n    }\n\n    parsed = rsingleTag.exec(data);\n    scripts = !keepScripts && []; // Single tag\n\n    if (parsed) {\n      return [context.createElement(parsed[1])];\n    }\n\n    parsed = buildFragment([data], context, scripts);\n\n    if (scripts && scripts.length) {\n      jQuery(scripts).remove();\n    }\n\n    return jQuery.merge([], parsed.childNodes);\n  };\n  /**\n   * Load a url into a page\n   */\n\n\n  jQuery.fn.load = function (url, params, callback) {\n    var selector,\n        type,\n        response,\n        self = this,\n        off = url.indexOf(\" \");\n\n    if (off > -1) {\n      selector = stripAndCollapse(url.slice(off));\n      url = url.slice(0, off);\n    } // If it's a function\n\n\n    if (isFunction(params)) {\n      // We assume that it's the callback\n      callback = params;\n      params = undefined; // Otherwise, build a param string\n    } else if (params && _typeof(params) === \"object\") {\n      type = \"POST\";\n    } // If we have elements to modify, make the request\n\n\n    if (self.length > 0) {\n      jQuery.ajax({\n        url: url,\n        // If \"type\" variable is undefined, then \"GET\" method will be used.\n        // Make value of this field explicit since\n        // user can override it through ajaxSetup method\n        type: type || \"GET\",\n        dataType: \"html\",\n        data: params\n      }).done(function (responseText) {\n        // Save response for use in complete callback\n        response = arguments;\n        self.html(selector ? // If a selector was specified, locate the right elements in a dummy div\n        // Exclude scripts to avoid IE 'Permission Denied' errors\n        jQuery(\"<div>\").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result\n        responseText); // If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n        // but they are ignored because response was set above.\n        // If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n      }).always(callback && function (jqXHR, status) {\n        self.each(function () {\n          callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);\n        });\n      });\n    }\n\n    return this;\n  }; // Attach a bunch of functions for handling common AJAX events\n\n\n  jQuery.each([\"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\"], function (i, type) {\n    jQuery.fn[type] = function (fn) {\n      return this.on(type, fn);\n    };\n  });\n\n  jQuery.expr.pseudos.animated = function (elem) {\n    return jQuery.grep(jQuery.timers, function (fn) {\n      return elem === fn.elem;\n    }).length;\n  };\n\n  jQuery.offset = {\n    setOffset: function setOffset(elem, options, i) {\n      var curPosition,\n          curLeft,\n          curCSSTop,\n          curTop,\n          curOffset,\n          curCSSLeft,\n          calculatePosition,\n          position = jQuery.css(elem, \"position\"),\n          curElem = jQuery(elem),\n          props = {}; // Set position first, in-case top/left are set even on static elem\n\n      if (position === \"static\") {\n        elem.style.position = \"relative\";\n      }\n\n      curOffset = curElem.offset();\n      curCSSTop = jQuery.css(elem, \"top\");\n      curCSSLeft = jQuery.css(elem, \"left\");\n      calculatePosition = (position === \"absolute\" || position === \"fixed\") && (curCSSTop + curCSSLeft).indexOf(\"auto\") > -1; // Need to be able to calculate position if either\n      // top or left is auto and position is either absolute or fixed\n\n      if (calculatePosition) {\n        curPosition = curElem.position();\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n\n      if (isFunction(options)) {\n        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n        options = options.call(elem, i, jQuery.extend({}, curOffset));\n      }\n\n      if (options.top != null) {\n        props.top = options.top - curOffset.top + curTop;\n      }\n\n      if (options.left != null) {\n        props.left = options.left - curOffset.left + curLeft;\n      }\n\n      if (\"using\" in options) {\n        options.using.call(elem, props);\n      } else {\n        curElem.css(props);\n      }\n    }\n  };\n  jQuery.fn.extend({\n    // offset() relates an element's border box to the document origin\n    offset: function offset(options) {\n      // Preserve chaining for setter\n      if (arguments.length) {\n        return options === undefined ? this : this.each(function (i) {\n          jQuery.offset.setOffset(this, options, i);\n        });\n      }\n\n      var rect,\n          win,\n          elem = this[0];\n\n      if (!elem) {\n        return;\n      } // Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n      // Support: IE <=11 only\n      // Running getBoundingClientRect on a\n      // disconnected node in IE throws an error\n\n\n      if (!elem.getClientRects().length) {\n        return {\n          top: 0,\n          left: 0\n        };\n      } // Get document-relative position by adding viewport scroll to viewport-relative gBCR\n\n\n      rect = elem.getBoundingClientRect();\n      win = elem.ownerDocument.defaultView;\n      return {\n        top: rect.top + win.pageYOffset,\n        left: rect.left + win.pageXOffset\n      };\n    },\n    // position() relates an element's margin box to its offset parent's padding box\n    // This corresponds to the behavior of CSS absolute positioning\n    position: function position() {\n      if (!this[0]) {\n        return;\n      }\n\n      var offsetParent,\n          offset,\n          doc,\n          elem = this[0],\n          parentOffset = {\n        top: 0,\n        left: 0\n      }; // position:fixed elements are offset from the viewport, which itself always has zero offset\n\n      if (jQuery.css(elem, \"position\") === \"fixed\") {\n        // Assume position:fixed implies availability of getBoundingClientRect\n        offset = elem.getBoundingClientRect();\n      } else {\n        offset = this.offset(); // Account for the *real* offset parent, which can be the document or its root element\n        // when a statically positioned element is identified\n\n        doc = elem.ownerDocument;\n        offsetParent = elem.offsetParent || doc.documentElement;\n\n        while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, \"position\") === \"static\") {\n          offsetParent = offsetParent.parentNode;\n        }\n\n        if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {\n          // Incorporate borders into its offset, since they are outside its content origin\n          parentOffset = jQuery(offsetParent).offset();\n          parentOffset.top += jQuery.css(offsetParent, \"borderTopWidth\", true);\n          parentOffset.left += jQuery.css(offsetParent, \"borderLeftWidth\", true);\n        }\n      } // Subtract parent offsets and element margins\n\n\n      return {\n        top: offset.top - parentOffset.top - jQuery.css(elem, \"marginTop\", true),\n        left: offset.left - parentOffset.left - jQuery.css(elem, \"marginLeft\", true)\n      };\n    },\n    // This method will return documentElement in the following cases:\n    // 1) For the element inside the iframe without offsetParent, this method will return\n    //    documentElement of the parent window\n    // 2) For the hidden or detached element\n    // 3) For body or html element, i.e. in case of the html node - it will return itself\n    //\n    // but those exceptions were never presented as a real life use-cases\n    // and might be considered as more preferable results.\n    //\n    // This logic, however, is not guaranteed and can change at any point in the future\n    offsetParent: function offsetParent() {\n      return this.map(function () {\n        var offsetParent = this.offsetParent;\n\n        while (offsetParent && jQuery.css(offsetParent, \"position\") === \"static\") {\n          offsetParent = offsetParent.offsetParent;\n        }\n\n        return offsetParent || documentElement;\n      });\n    }\n  }); // Create scrollLeft and scrollTop methods\n\n  jQuery.each({\n    scrollLeft: \"pageXOffset\",\n    scrollTop: \"pageYOffset\"\n  }, function (method, prop) {\n    var top = \"pageYOffset\" === prop;\n\n    jQuery.fn[method] = function (val) {\n      return access(this, function (elem, method, val) {\n        // Coalesce documents and windows\n        var win;\n\n        if (isWindow(elem)) {\n          win = elem;\n        } else if (elem.nodeType === 9) {\n          win = elem.defaultView;\n        }\n\n        if (val === undefined) {\n          return win ? win[prop] : elem[method];\n        }\n\n        if (win) {\n          win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);\n        } else {\n          elem[method] = val;\n        }\n      }, method, val, arguments.length);\n    };\n  }); // Support: Safari <=7 - 9.1, Chrome <=37 - 49\n  // Add the top/left cssHooks using jQuery.fn.position\n  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n  // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n  // getComputedStyle returns percent when specified for top/left/bottom/right;\n  // rather than make the css module depend on the offset module, just check for it here\n\n  jQuery.each([\"top\", \"left\"], function (i, prop) {\n    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {\n      if (computed) {\n        computed = curCSS(elem, prop); // If curCSS returns percentage, fallback to offset\n\n        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + \"px\" : computed;\n      }\n    });\n  }); // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n\n  jQuery.each({\n    Height: \"height\",\n    Width: \"width\"\n  }, function (name, type) {\n    jQuery.each({\n      padding: \"inner\" + name,\n      content: type,\n      \"\": \"outer\" + name\n    }, function (defaultExtra, funcName) {\n      // Margin is only for outerHeight, outerWidth\n      jQuery.fn[funcName] = function (margin, value) {\n        var chainable = arguments.length && (defaultExtra || typeof margin !== \"boolean\"),\n            extra = defaultExtra || (margin === true || value === true ? \"margin\" : \"border\");\n        return access(this, function (elem, type, value) {\n          var doc;\n\n          if (isWindow(elem)) {\n            // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n            return funcName.indexOf(\"outer\") === 0 ? elem[\"inner\" + name] : elem.document.documentElement[\"client\" + name];\n          } // Get document width or height\n\n\n          if (elem.nodeType === 9) {\n            doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n            // whichever is greatest\n\n            return Math.max(elem.body[\"scroll\" + name], doc[\"scroll\" + name], elem.body[\"offset\" + name], doc[\"offset\" + name], doc[\"client\" + name]);\n          }\n\n          return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat\n          jQuery.css(elem, type, extra) : // Set width or height on the element\n          jQuery.style(elem, type, value, extra);\n        }, type, chainable ? margin : undefined, chainable);\n      };\n    });\n  });\n  jQuery.each((\"blur focus focusin focusout resize scroll click dblclick \" + \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" + \"change select submit keydown keypress keyup contextmenu\").split(\" \"), function (i, name) {\n    // Handle event binding\n    jQuery.fn[name] = function (data, fn) {\n      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);\n    };\n  });\n  jQuery.fn.extend({\n    hover: function hover(fnOver, fnOut) {\n      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);\n    }\n  });\n  jQuery.fn.extend({\n    bind: function bind(types, data, fn) {\n      return this.on(types, null, data, fn);\n    },\n    unbind: function unbind(types, fn) {\n      return this.off(types, null, fn);\n    },\n    delegate: function delegate(selector, types, data, fn) {\n      return this.on(types, selector, data, fn);\n    },\n    undelegate: function undelegate(selector, types, fn) {\n      // ( namespace ) or ( selector, types [, fn] )\n      return arguments.length === 1 ? this.off(selector, \"**\") : this.off(types, selector || \"**\", fn);\n    }\n  }); // Bind a function to a context, optionally partially applying any\n  // arguments.\n  // jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n  // However, it is not slated for removal any time soon\n\n  jQuery.proxy = function (fn, context) {\n    var tmp, args, proxy;\n\n    if (typeof context === \"string\") {\n      tmp = fn[context];\n      context = fn;\n      fn = tmp;\n    } // Quick check to determine if target is callable, in the spec\n    // this throws a TypeError, but we will just return undefined.\n\n\n    if (!isFunction(fn)) {\n      return undefined;\n    } // Simulated bind\n\n\n    args = _slice.call(arguments, 2);\n\n    proxy = function proxy() {\n      return fn.apply(context || this, args.concat(_slice.call(arguments)));\n    }; // Set the guid of unique handler to the same of original handler, so it can be removed\n\n\n    proxy.guid = fn.guid = fn.guid || jQuery.guid++;\n    return proxy;\n  };\n\n  jQuery.holdReady = function (hold) {\n    if (hold) {\n      jQuery.readyWait++;\n    } else {\n      jQuery.ready(true);\n    }\n  };\n\n  jQuery.isArray = Array.isArray;\n  jQuery.parseJSON = JSON.parse;\n  jQuery.nodeName = nodeName;\n  jQuery.isFunction = isFunction;\n  jQuery.isWindow = isWindow;\n  jQuery.camelCase = camelCase;\n  jQuery.type = toType;\n  jQuery.now = Date.now;\n\n  jQuery.isNumeric = function (obj) {\n    // As of jQuery 3.0, isNumeric is limited to\n    // strings and numbers (primitives or objects)\n    // that can be coerced to finite numbers (gh-2662)\n    var type = jQuery.type(obj);\n    return (type === \"number\" || type === \"string\") && // parseFloat NaNs numeric-cast false positives (\"\")\n    // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n    // subtraction forces infinities to NaN\n    !isNaN(obj - parseFloat(obj));\n  }; // Register as a named AMD module, since jQuery can be concatenated with other\n  // files that may use define, but not via a proper concatenation script that\n  // understands anonymous AMD modules. A named AMD is safest and most robust\n  // way to register. Lowercase jquery is used because AMD module names are\n  // derived from file names, and jQuery is normally delivered in a lowercase\n  // file name. Do this after creating the global so that if an AMD module wants\n  // to call noConflict to hide this version of jQuery, it will work.\n  // Note that for maximum portability, libraries that are not jQuery should\n  // declare themselves as anonymous modules, and avoid setting a global if an\n  // AMD loader is present. jQuery is a special case. For more information, see\n  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return jQuery;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n\n  var // Map over jQuery in case of overwrite\n  _jQuery = window.jQuery,\n      // Map over the $ in case of overwrite\n  _$ = window.$;\n\n  jQuery.noConflict = function (deep) {\n    if (window.$ === jQuery) {\n      window.$ = _$;\n    }\n\n    if (deep && window.jQuery === jQuery) {\n      window.jQuery = _jQuery;\n    }\n\n    return jQuery;\n  }; // Expose jQuery and $ identifiers, even in AMD\n  // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n  // and CommonJS for browser emulators (#13566)\n\n\n  if (!noGlobal) {\n    window.jQuery = window.$ = jQuery;\n  }\n\n  return jQuery;\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack-stream/node_modules/webpack/buildin/module.js */ \"./node_modules/webpack-stream/node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/jquery/dist/jquery.js?");

/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var root = __webpack_require__(/*! ./_root */ \"./node_modules/lodash/_root.js\");\n/** Built-in value references. */\n\n\nvar _Symbol = root.Symbol;\nmodule.exports = _Symbol;\n\n//# sourceURL=webpack:///./node_modules/lodash/_Symbol.js?");

/***/ }),

/***/ "./node_modules/lodash/_apply.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_apply.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0:\n      return func.call(thisArg);\n\n    case 1:\n      return func.call(thisArg, args[0]);\n\n    case 2:\n      return func.call(thisArg, args[0], args[1]);\n\n    case 3:\n      return func.call(thisArg, args[0], args[1], args[2]);\n  }\n\n  return func.apply(thisArg, args);\n}\n\nmodule.exports = apply;\n\n//# sourceURL=webpack:///./node_modules/lodash/_apply.js?");

/***/ }),

/***/ "./node_modules/lodash/_arrayLikeKeys.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayLikeKeys.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var baseTimes = __webpack_require__(/*! ./_baseTimes */ \"./node_modules/lodash/_baseTimes.js\"),\n    isArguments = __webpack_require__(/*! ./isArguments */ \"./node_modules/lodash/isArguments.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/lodash/isArray.js\"),\n    isBuffer = __webpack_require__(/*! ./isBuffer */ \"./node_modules/lodash/isBuffer.js\"),\n    isIndex = __webpack_require__(/*! ./_isIndex */ \"./node_modules/lodash/_isIndex.js\"),\n    isTypedArray = __webpack_require__(/*! ./isTypedArray */ \"./node_modules/lodash/isTypedArray.js\");\n/** Used for built-in method references. */\n\n\nvar objectProto = Object.prototype;\n/** Used to check objects for own properties. */\n\nvar hasOwnProperty = objectProto.hasOwnProperty;\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\n\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.\n    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.\n    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.\n    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.\n    isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n\n//# sourceURL=webpack:///./node_modules/lodash/_arrayLikeKeys.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _Symbol = __webpack_require__(/*! ./_Symbol */ \"./node_modules/lodash/_Symbol.js\"),\n    getRawTag = __webpack_require__(/*! ./_getRawTag */ \"./node_modules/lodash/_getRawTag.js\"),\n    objectToString = __webpack_require__(/*! ./_objectToString */ \"./node_modules/lodash/_objectToString.js\");\n/** `Object#toString` result references. */\n\n\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n/** Built-in value references. */\n\nvar symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\n\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n\n  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n\n//# sourceURL=webpack:///./node_modules/lodash/_baseGetTag.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseIsArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsArguments.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ \"./node_modules/lodash/_baseGetTag.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/lodash/isObjectLike.js\");\n/** `Object#toString` result references. */\n\n\nvar argsTag = '[object Arguments]';\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\n\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n\n//# sourceURL=webpack:///./node_modules/lodash/_baseIsArguments.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseIsNative.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIsNative.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isFunction = __webpack_require__(/*! ./isFunction */ \"./node_modules/lodash/isFunction.js\"),\n    isMasked = __webpack_require__(/*! ./_isMasked */ \"./node_modules/lodash/_isMasked.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/lodash/isObject.js\"),\n    toSource = __webpack_require__(/*! ./_toSource */ \"./node_modules/lodash/_toSource.js\");\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\n\n\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n/** Used to detect host constructors (Safari). */\n\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n/** Used for built-in method references. */\n\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n/** Used to resolve the decompiled source of functions. */\n\nvar funcToString = funcProto.toString;\n/** Used to check objects for own properties. */\n\nvar hasOwnProperty = objectProto.hasOwnProperty;\n/** Used to detect if a method is native. */\n\nvar reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&').replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$');\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\n\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n\n//# sourceURL=webpack:///./node_modules/lodash/_baseIsNative.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseIsTypedArray.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_baseIsTypedArray.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ \"./node_modules/lodash/_baseGetTag.js\"),\n    isLength = __webpack_require__(/*! ./isLength */ \"./node_modules/lodash/isLength.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/lodash/isObjectLike.js\");\n/** `Object#toString` result references. */\n\n\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n/** Used to identify `toStringTag` values of typed arrays. */\n\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\n\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n\n//# sourceURL=webpack:///./node_modules/lodash/_baseIsTypedArray.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseKeysIn.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseKeysIn.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/lodash/isObject.js\"),\n    isPrototype = __webpack_require__(/*! ./_isPrototype */ \"./node_modules/lodash/_isPrototype.js\"),\n    nativeKeysIn = __webpack_require__(/*! ./_nativeKeysIn */ \"./node_modules/lodash/_nativeKeysIn.js\");\n/** Used for built-in method references. */\n\n\nvar objectProto = Object.prototype;\n/** Used to check objects for own properties. */\n\nvar hasOwnProperty = objectProto.hasOwnProperty;\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\n\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = baseKeysIn;\n\n//# sourceURL=webpack:///./node_modules/lodash/_baseKeysIn.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseRest.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseRest.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var identity = __webpack_require__(/*! ./identity */ \"./node_modules/lodash/identity.js\"),\n    overRest = __webpack_require__(/*! ./_overRest */ \"./node_modules/lodash/_overRest.js\"),\n    setToString = __webpack_require__(/*! ./_setToString */ \"./node_modules/lodash/_setToString.js\");\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\n\n\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\nmodule.exports = baseRest;\n\n//# sourceURL=webpack:///./node_modules/lodash/_baseRest.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseSetToString.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseSetToString.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var constant = __webpack_require__(/*! ./constant */ \"./node_modules/lodash/constant.js\"),\n    defineProperty = __webpack_require__(/*! ./_defineProperty */ \"./node_modules/lodash/_defineProperty.js\"),\n    identity = __webpack_require__(/*! ./identity */ \"./node_modules/lodash/identity.js\");\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\n\n\nvar baseSetToString = !defineProperty ? identity : function (func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\nmodule.exports = baseSetToString;\n\n//# sourceURL=webpack:///./node_modules/lodash/_baseSetToString.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseTimes.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseTimes.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n\n  return result;\n}\n\nmodule.exports = baseTimes;\n\n//# sourceURL=webpack:///./node_modules/lodash/_baseTimes.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseUnary.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseUnary.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function (value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n\n//# sourceURL=webpack:///./node_modules/lodash/_baseUnary.js?");

/***/ }),

/***/ "./node_modules/lodash/_coreJsData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_coreJsData.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var root = __webpack_require__(/*! ./_root */ \"./node_modules/lodash/_root.js\");\n/** Used to detect overreaching core-js shims. */\n\n\nvar coreJsData = root['__core-js_shared__'];\nmodule.exports = coreJsData;\n\n//# sourceURL=webpack:///./node_modules/lodash/_coreJsData.js?");

/***/ }),

/***/ "./node_modules/lodash/_defineProperty.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_defineProperty.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var getNative = __webpack_require__(/*! ./_getNative */ \"./node_modules/lodash/_getNative.js\");\n\nvar defineProperty = function () {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}();\n\nmodule.exports = defineProperty;\n\n//# sourceURL=webpack:///./node_modules/lodash/_defineProperty.js?");

/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = (typeof global === \"undefined\" ? \"undefined\" : _typeof(global)) == 'object' && global && global.Object === Object && global;\nmodule.exports = freeGlobal;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack-stream/node_modules/webpack/buildin/global.js */ \"./node_modules/webpack-stream/node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/lodash/_freeGlobal.js?");

/***/ }),

/***/ "./node_modules/lodash/_getNative.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getNative.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var baseIsNative = __webpack_require__(/*! ./_baseIsNative */ \"./node_modules/lodash/_baseIsNative.js\"),\n    getValue = __webpack_require__(/*! ./_getValue */ \"./node_modules/lodash/_getValue.js\");\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\n\n\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n\n//# sourceURL=webpack:///./node_modules/lodash/_getNative.js?");

/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _Symbol = __webpack_require__(/*! ./_Symbol */ \"./node_modules/lodash/_Symbol.js\");\n/** Used for built-in method references. */\n\n\nvar objectProto = Object.prototype;\n/** Used to check objects for own properties. */\n\nvar hasOwnProperty = objectProto.hasOwnProperty;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\n\nvar nativeObjectToString = objectProto.toString;\n/** Built-in value references. */\n\nvar symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\n\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = getRawTag;\n\n//# sourceURL=webpack:///./node_modules/lodash/_getRawTag.js?");

/***/ }),

/***/ "./node_modules/lodash/_getValue.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_getValue.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n\n//# sourceURL=webpack:///./node_modules/lodash/_getValue.js?");

/***/ }),

/***/ "./node_modules/lodash/_isIndex.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_isIndex.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n/** Used to detect unsigned integer values. */\n\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\n\nfunction isIndex(value, length) {\n  var type = _typeof(value);\n\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n}\n\nmodule.exports = isIndex;\n\n//# sourceURL=webpack:///./node_modules/lodash/_isIndex.js?");

/***/ }),

/***/ "./node_modules/lodash/_isIterateeCall.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_isIterateeCall.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar eq = __webpack_require__(/*! ./eq */ \"./node_modules/lodash/eq.js\"),\n    isArrayLike = __webpack_require__(/*! ./isArrayLike */ \"./node_modules/lodash/isArrayLike.js\"),\n    isIndex = __webpack_require__(/*! ./_isIndex */ \"./node_modules/lodash/_isIndex.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/lodash/isObject.js\");\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\n\n\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n\n  var type = _typeof(index);\n\n  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {\n    return eq(object[index], value);\n  }\n\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n\n//# sourceURL=webpack:///./node_modules/lodash/_isIterateeCall.js?");

/***/ }),

/***/ "./node_modules/lodash/_isMasked.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_isMasked.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var coreJsData = __webpack_require__(/*! ./_coreJsData */ \"./node_modules/lodash/_coreJsData.js\");\n/** Used to detect methods masquerading as native. */\n\n\nvar maskSrcKey = function () {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? 'Symbol(src)_1.' + uid : '';\n}();\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\n\n\nfunction isMasked(func) {\n  return !!maskSrcKey && maskSrcKey in func;\n}\n\nmodule.exports = isMasked;\n\n//# sourceURL=webpack:///./node_modules/lodash/_isMasked.js?");

/***/ }),

/***/ "./node_modules/lodash/_isPrototype.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_isPrototype.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\n\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n\n//# sourceURL=webpack:///./node_modules/lodash/_isPrototype.js?");

/***/ }),

/***/ "./node_modules/lodash/_nativeKeysIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeKeysIn.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = nativeKeysIn;\n\n//# sourceURL=webpack:///./node_modules/lodash/_nativeKeysIn.js?");

/***/ }),

/***/ "./node_modules/lodash/_nodeUtil.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_nodeUtil.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar freeGlobal = __webpack_require__(/*! ./_freeGlobal */ \"./node_modules/lodash/_freeGlobal.js\");\n/** Detect free variable `exports`. */\n\n\nvar freeExports = ( false ? undefined : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;\n/** Detect free variable `module`. */\n\nvar freeModule = freeExports && ( false ? undefined : _typeof(module)) == 'object' && module && !module.nodeType && module;\n/** Detect the popular CommonJS extension `module.exports`. */\n\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n/** Detect free variable `process` from Node.js. */\n\nvar freeProcess = moduleExports && freeGlobal.process;\n/** Used to access faster Node.js helpers. */\n\nvar nodeUtil = function () {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    } // Legacy `process.binding('util')` for Node.js < 10.\n\n\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}();\n\nmodule.exports = nodeUtil;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack-stream/node_modules/webpack/buildin/module.js */ \"./node_modules/webpack-stream/node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/lodash/_nodeUtil.js?");

/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\n\nvar nativeObjectToString = objectProto.toString;\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\n\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n\n//# sourceURL=webpack:///./node_modules/lodash/_objectToString.js?");

/***/ }),

/***/ "./node_modules/lodash/_overRest.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_overRest.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var apply = __webpack_require__(/*! ./_apply */ \"./node_modules/lodash/_apply.js\");\n/* Built-in method references for those with the same name as other `lodash` methods. */\n\n\nvar nativeMax = Math.max;\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\n\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? func.length - 1 : start, 0);\n  return function () {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n\n    index = -1;\n    var otherArgs = Array(start + 1);\n\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\nmodule.exports = overRest;\n\n//# sourceURL=webpack:///./node_modules/lodash/_overRest.js?");

/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar freeGlobal = __webpack_require__(/*! ./_freeGlobal */ \"./node_modules/lodash/_freeGlobal.js\");\n/** Detect free variable `self`. */\n\n\nvar freeSelf = (typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) == 'object' && self && self.Object === Object && self;\n/** Used as a reference to the global object. */\n\nvar root = freeGlobal || freeSelf || Function('return this')();\nmodule.exports = root;\n\n//# sourceURL=webpack:///./node_modules/lodash/_root.js?");

/***/ }),

/***/ "./node_modules/lodash/_setToString.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setToString.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var baseSetToString = __webpack_require__(/*! ./_baseSetToString */ \"./node_modules/lodash/_baseSetToString.js\"),\n    shortOut = __webpack_require__(/*! ./_shortOut */ \"./node_modules/lodash/_shortOut.js\");\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\n\n\nvar setToString = shortOut(baseSetToString);\nmodule.exports = setToString;\n\n//# sourceURL=webpack:///./node_modules/lodash/_setToString.js?");

/***/ }),

/***/ "./node_modules/lodash/_shortOut.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_shortOut.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n/* Built-in method references for those with the same name as other `lodash` methods. */\n\nvar nativeNow = Date.now;\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\n\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n  return function () {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n    lastCalled = stamp;\n\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n\n    return func.apply(undefined, arguments);\n  };\n}\n\nmodule.exports = shortOut;\n\n//# sourceURL=webpack:///./node_modules/lodash/_shortOut.js?");

/***/ }),

/***/ "./node_modules/lodash/_toSource.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_toSource.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n/** Used to resolve the decompiled source of functions. */\n\nvar funcToString = funcProto.toString;\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\n\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n\n    try {\n      return func + '';\n    } catch (e) {}\n  }\n\n  return '';\n}\n\nmodule.exports = toSource;\n\n//# sourceURL=webpack:///./node_modules/lodash/_toSource.js?");

/***/ }),

/***/ "./node_modules/lodash/constant.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/constant.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function () {\n    return value;\n  };\n}\n\nmodule.exports = constant;\n\n//# sourceURL=webpack:///./node_modules/lodash/constant.js?");

/***/ }),

/***/ "./node_modules/lodash/debounce.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/debounce.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/lodash/isObject.js\"),\n    now = __webpack_require__(/*! ./now */ \"./node_modules/lodash/now.js\"),\n    toNumber = __webpack_require__(/*! ./toNumber */ \"./node_modules/lodash/toNumber.js\");\n/** Error message constants. */\n\n\nvar FUNC_ERROR_TEXT = 'Expected a function';\n/* Built-in method references for those with the same name as other `lodash` methods. */\n\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\n\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n\n  wait = toNumber(wait) || 0;\n\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time; // Start the timer for the trailing edge.\n\n    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.\n\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n\n    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n  }\n\n  function timerExpired() {\n    var time = now();\n\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    } // Restart the timer.\n\n\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n\n    return result;\n  }\n\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nmodule.exports = debounce;\n\n//# sourceURL=webpack:///./node_modules/lodash/debounce.js?");

/***/ }),

/***/ "./node_modules/lodash/defaults.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/defaults.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var baseRest = __webpack_require__(/*! ./_baseRest */ \"./node_modules/lodash/_baseRest.js\"),\n    eq = __webpack_require__(/*! ./eq */ \"./node_modules/lodash/eq.js\"),\n    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ \"./node_modules/lodash/_isIterateeCall.js\"),\n    keysIn = __webpack_require__(/*! ./keysIn */ \"./node_modules/lodash/keysIn.js\");\n/** Used for built-in method references. */\n\n\nvar objectProto = Object.prototype;\n/** Used to check objects for own properties. */\n\nvar hasOwnProperty = objectProto.hasOwnProperty;\n/**\n * Assigns own and inherited enumerable string keyed properties of source\n * objects to the destination object for all destination properties that\n * resolve to `undefined`. Source objects are applied from left to right.\n * Once a property is set, additional values of the same property are ignored.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.defaultsDeep\n * @example\n *\n * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n * // => { 'a': 1, 'b': 2 }\n */\n\nvar defaults = baseRest(function (object, sources) {\n  object = Object(object);\n  var index = -1;\n  var length = sources.length;\n  var guard = length > 2 ? sources[2] : undefined;\n\n  if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n    length = 1;\n  }\n\n  while (++index < length) {\n    var source = sources[index];\n    var props = keysIn(source);\n    var propsIndex = -1;\n    var propsLength = props.length;\n\n    while (++propsIndex < propsLength) {\n      var key = props[propsIndex];\n      var value = object[key];\n\n      if (value === undefined || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {\n        object[key] = source[key];\n      }\n    }\n  }\n\n  return object;\n});\nmodule.exports = defaults;\n\n//# sourceURL=webpack:///./node_modules/lodash/defaults.js?");

/***/ }),

/***/ "./node_modules/lodash/eq.js":
/*!***********************************!*\
  !*** ./node_modules/lodash/eq.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || value !== value && other !== other;\n}\n\nmodule.exports = eq;\n\n//# sourceURL=webpack:///./node_modules/lodash/eq.js?");

/***/ }),

/***/ "./node_modules/lodash/identity.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/identity.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n\n//# sourceURL=webpack:///./node_modules/lodash/identity.js?");

/***/ }),

/***/ "./node_modules/lodash/isArguments.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArguments.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ \"./node_modules/lodash/_baseIsArguments.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/lodash/isObjectLike.js\");\n/** Used for built-in method references. */\n\n\nvar objectProto = Object.prototype;\n/** Used to check objects for own properties. */\n\nvar hasOwnProperty = objectProto.hasOwnProperty;\n/** Built-in value references. */\n\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\n\nvar isArguments = baseIsArguments(function () {\n  return arguments;\n}()) ? baseIsArguments : function (value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');\n};\nmodule.exports = isArguments;\n\n//# sourceURL=webpack:///./node_modules/lodash/isArguments.js?");

/***/ }),

/***/ "./node_modules/lodash/isArray.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isArray.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\nmodule.exports = isArray;\n\n//# sourceURL=webpack:///./node_modules/lodash/isArray.js?");

/***/ }),

/***/ "./node_modules/lodash/isArrayLike.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArrayLike.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isFunction = __webpack_require__(/*! ./isFunction */ \"./node_modules/lodash/isFunction.js\"),\n    isLength = __webpack_require__(/*! ./isLength */ \"./node_modules/lodash/isLength.js\");\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\n\n\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n\n//# sourceURL=webpack:///./node_modules/lodash/isArrayLike.js?");

/***/ }),

/***/ "./node_modules/lodash/isBuffer.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isBuffer.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar root = __webpack_require__(/*! ./_root */ \"./node_modules/lodash/_root.js\"),\n    stubFalse = __webpack_require__(/*! ./stubFalse */ \"./node_modules/lodash/stubFalse.js\");\n/** Detect free variable `exports`. */\n\n\nvar freeExports = ( false ? undefined : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;\n/** Detect free variable `module`. */\n\nvar freeModule = freeExports && ( false ? undefined : _typeof(module)) == 'object' && module && !module.nodeType && module;\n/** Detect the popular CommonJS extension `module.exports`. */\n\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n/** Built-in value references. */\n\nvar Buffer = moduleExports ? root.Buffer : undefined;\n/* Built-in method references for those with the same name as other `lodash` methods. */\n\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\n\nvar isBuffer = nativeIsBuffer || stubFalse;\nmodule.exports = isBuffer;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack-stream/node_modules/webpack/buildin/module.js */ \"./node_modules/webpack-stream/node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/lodash/isBuffer.js?");

/***/ }),

/***/ "./node_modules/lodash/isFunction.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/isFunction.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ \"./node_modules/lodash/_baseGetTag.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/lodash/isObject.js\");\n/** `Object#toString` result references. */\n\n\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\n\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  } // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n\n\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n\n//# sourceURL=webpack:///./node_modules/lodash/isFunction.js?");

/***/ }),

/***/ "./node_modules/lodash/isLength.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isLength.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\n\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n\n//# sourceURL=webpack:///./node_modules/lodash/isLength.js?");

/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = _typeof(value);\n\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n\n//# sourceURL=webpack:///./node_modules/lodash/isObject.js?");

/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && _typeof(value) == 'object';\n}\n\nmodule.exports = isObjectLike;\n\n//# sourceURL=webpack:///./node_modules/lodash/isObjectLike.js?");

/***/ }),

/***/ "./node_modules/lodash/isSymbol.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isSymbol.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar baseGetTag = __webpack_require__(/*! ./_baseGetTag */ \"./node_modules/lodash/_baseGetTag.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/lodash/isObjectLike.js\");\n/** `Object#toString` result references. */\n\n\nvar symbolTag = '[object Symbol]';\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\n\nfunction isSymbol(value) {\n  return _typeof(value) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;\n}\n\nmodule.exports = isSymbol;\n\n//# sourceURL=webpack:///./node_modules/lodash/isSymbol.js?");

/***/ }),

/***/ "./node_modules/lodash/isTypedArray.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isTypedArray.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ \"./node_modules/lodash/_baseIsTypedArray.js\"),\n    baseUnary = __webpack_require__(/*! ./_baseUnary */ \"./node_modules/lodash/_baseUnary.js\"),\n    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ \"./node_modules/lodash/_nodeUtil.js\");\n/* Node.js helper references. */\n\n\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\n\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\nmodule.exports = isTypedArray;\n\n//# sourceURL=webpack:///./node_modules/lodash/isTypedArray.js?");

/***/ }),

/***/ "./node_modules/lodash/keysIn.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/keysIn.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ \"./node_modules/lodash/_arrayLikeKeys.js\"),\n    baseKeysIn = __webpack_require__(/*! ./_baseKeysIn */ \"./node_modules/lodash/_baseKeysIn.js\"),\n    isArrayLike = __webpack_require__(/*! ./isArrayLike */ \"./node_modules/lodash/isArrayLike.js\");\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\n\n\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nmodule.exports = keysIn;\n\n//# sourceURL=webpack:///./node_modules/lodash/keysIn.js?");

/***/ }),

/***/ "./node_modules/lodash/now.js":
/*!************************************!*\
  !*** ./node_modules/lodash/now.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var root = __webpack_require__(/*! ./_root */ \"./node_modules/lodash/_root.js\");\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\n\n\nvar now = function now() {\n  return root.Date.now();\n};\n\nmodule.exports = now;\n\n//# sourceURL=webpack:///./node_modules/lodash/now.js?");

/***/ }),

/***/ "./node_modules/lodash/stubFalse.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubFalse.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n\n//# sourceURL=webpack:///./node_modules/lodash/stubFalse.js?");

/***/ }),

/***/ "./node_modules/lodash/toNumber.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toNumber.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/lodash/isObject.js\"),\n    isSymbol = __webpack_require__(/*! ./isSymbol */ \"./node_modules/lodash/isSymbol.js\");\n/** Used as references for various `Number` constants. */\n\n\nvar NAN = 0 / 0;\n/** Used to match leading and trailing whitespace. */\n\nvar reTrim = /^\\s+|\\s+$/g;\n/** Used to detect bad signed hexadecimal string values. */\n\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n/** Used to detect binary string values. */\n\nvar reIsBinary = /^0b[01]+$/i;\n/** Used to detect octal string values. */\n\nvar reIsOctal = /^0o[0-7]+$/i;\n/** Built-in method references without a dependency on `root`. */\n\nvar freeParseInt = parseInt;\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\n\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n\n  if (isSymbol(value)) {\n    return NAN;\n  }\n\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? other + '' : other;\n  }\n\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n}\n\nmodule.exports = toNumber;\n\n//# sourceURL=webpack:///./node_modules/lodash/toNumber.js?");

/***/ }),

/***/ "./node_modules/plotly.js/dist/plotly-basic.js":
/*!*****************************************************!*\
  !*** ./node_modules/plotly.js/dist/plotly-basic.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;function _typeof(obj){if(typeof Symbol===\"function\"&&typeof Symbol.iterator===\"symbol\"){_typeof=function _typeof(obj){return typeof obj;};}else{_typeof=function _typeof(obj){return obj&&typeof Symbol===\"function\"&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj;};}return _typeof(obj);}/**\n* plotly.js (basic) v1.47.4\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n* Licensed under the MIT license\n*/(function(f){if(( false?undefined:_typeof(exports))===\"object\"&&typeof module!==\"undefined\"){module.exports=f();}else if(true){!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}else{ var g; }})(function(){var define,module,exports;return function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a;}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r);},p,p.exports,r,e,n,t);}return n[i].exports;}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++){o(t[i]);}return o;}return r;}()({1:[function(_dereq_,module,exports){'use strict';var Lib=_dereq_('../src/lib');var rules={\"X,X div\":\"direction:ltr;font-family:'Open Sans', verdana, arial, sans-serif;margin:0;padding:0;\",\"X input,X button\":\"font-family:'Open Sans', verdana, arial, sans-serif;\",\"X input:focus,X button:focus\":\"outline:none;\",\"X a\":\"text-decoration:none;\",\"X a:hover\":\"text-decoration:none;\",\"X .crisp\":\"shape-rendering:crispEdges;\",\"X .user-select-none\":\"-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-o-user-select:none;user-select:none;\",\"X svg\":\"overflow:hidden;\",\"X svg a\":\"fill:#447adb;\",\"X svg a:hover\":\"fill:#3c6dc5;\",\"X .main-svg\":\"position:absolute;top:0;left:0;pointer-events:none;\",\"X .main-svg .draglayer\":\"pointer-events:all;\",\"X .cursor-default\":\"cursor:default;\",\"X .cursor-pointer\":\"cursor:pointer;\",\"X .cursor-crosshair\":\"cursor:crosshair;\",\"X .cursor-move\":\"cursor:move;\",\"X .cursor-col-resize\":\"cursor:col-resize;\",\"X .cursor-row-resize\":\"cursor:row-resize;\",\"X .cursor-ns-resize\":\"cursor:ns-resize;\",\"X .cursor-ew-resize\":\"cursor:ew-resize;\",\"X .cursor-sw-resize\":\"cursor:sw-resize;\",\"X .cursor-s-resize\":\"cursor:s-resize;\",\"X .cursor-se-resize\":\"cursor:se-resize;\",\"X .cursor-w-resize\":\"cursor:w-resize;\",\"X .cursor-e-resize\":\"cursor:e-resize;\",\"X .cursor-nw-resize\":\"cursor:nw-resize;\",\"X .cursor-n-resize\":\"cursor:n-resize;\",\"X .cursor-ne-resize\":\"cursor:ne-resize;\",\"X .cursor-grab\":\"cursor:-webkit-grab;cursor:grab;\",\"X .modebar\":\"position:absolute;top:2px;right:2px;\",\"X .ease-bg\":\"-webkit-transition:background-color 0.3s ease 0s;-moz-transition:background-color 0.3s ease 0s;-ms-transition:background-color 0.3s ease 0s;-o-transition:background-color 0.3s ease 0s;transition:background-color 0.3s ease 0s;\",\"X .modebar--hover>:not(.watermark)\":\"opacity:0;-webkit-transition:opacity 0.3s ease 0s;-moz-transition:opacity 0.3s ease 0s;-ms-transition:opacity 0.3s ease 0s;-o-transition:opacity 0.3s ease 0s;transition:opacity 0.3s ease 0s;\",\"X:hover .modebar--hover .modebar-group\":\"opacity:1;\",\"X .modebar-group\":\"float:left;display:inline-block;box-sizing:border-box;padding-left:8px;position:relative;vertical-align:middle;white-space:nowrap;\",\"X .modebar-btn\":\"position:relative;font-size:16px;padding:3px 4px;height:22px;cursor:pointer;line-height:normal;box-sizing:border-box;\",\"X .modebar-btn svg\":\"position:relative;top:2px;\",\"X .modebar.vertical\":\"display:flex;flex-direction:column;flex-wrap:wrap;align-content:flex-end;max-height:100%;\",\"X .modebar.vertical svg\":\"top:-1px;\",\"X .modebar.vertical .modebar-group\":\"display:block;float:none;padding-left:0px;padding-bottom:8px;\",\"X .modebar.vertical .modebar-group .modebar-btn\":\"display:block;text-align:center;\",\"X [data-title]:before,X [data-title]:after\":\"position:absolute;-webkit-transform:translate3d(0, 0, 0);-moz-transform:translate3d(0, 0, 0);-ms-transform:translate3d(0, 0, 0);-o-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0);display:none;opacity:0;z-index:1001;pointer-events:none;top:110%;right:50%;\",\"X [data-title]:hover:before,X [data-title]:hover:after\":\"display:block;opacity:1;\",\"X [data-title]:before\":\"content:'';position:absolute;background:transparent;border:6px solid transparent;z-index:1002;margin-top:-12px;border-bottom-color:#69738a;margin-right:-6px;\",\"X [data-title]:after\":\"content:attr(data-title);background:#69738a;color:white;padding:8px 10px;font-size:12px;line-height:12px;white-space:nowrap;margin-right:-18px;border-radius:2px;\",\"X .vertical [data-title]:before,X .vertical [data-title]:after\":\"top:0%;right:200%;\",\"X .vertical [data-title]:before\":\"border:6px solid transparent;border-left-color:#69738a;margin-top:8px;margin-right:-30px;\",\"X .select-outline\":\"fill:none;stroke-width:1;shape-rendering:crispEdges;\",\"X .select-outline-1\":\"stroke:white;\",\"X .select-outline-2\":\"stroke:black;stroke-dasharray:2px 2px;\",Y:\"font-family:'Open Sans';position:fixed;top:50px;right:20px;z-index:10000;font-size:10pt;max-width:180px;\",\"Y p\":\"margin:0;\",\"Y .notifier-note\":\"min-width:180px;max-width:250px;border:1px solid #fff;z-index:3000;margin:0;background-color:#8c97af;background-color:rgba(140,151,175,0.9);color:#fff;padding:10px;overflow-wrap:break-word;word-wrap:break-word;-ms-hyphens:auto;-webkit-hyphens:auto;hyphens:auto;\",\"Y .notifier-close\":\"color:#fff;opacity:0.8;float:right;padding:0 5px;background:none;border:none;font-size:20px;font-weight:bold;line-height:20px;\",\"Y .notifier-close:hover\":\"color:#444;text-decoration:none;cursor:pointer;\"};for(var selector in rules){var fullSelector=selector.replace(/^,/,' ,').replace(/X/g,'.js-plotly-plot .plotly').replace(/Y/g,'.plotly-notifier');Lib.addStyleRule(fullSelector,rules[selector]);}},{\"../src/lib\":159}],2:[function(_dereq_,module,exports){'use strict';module.exports={'undo':{'width':857.1,'height':1000,'path':'m857 350q0-87-34-166t-91-137-137-92-166-34q-96 0-183 41t-147 114q-4 6-4 13t5 11l76 77q6 5 14 5 9-1 13-7 41-53 100-82t126-29q58 0 110 23t92 61 61 91 22 111-22 111-61 91-92 61-110 23q-55 0-105-20t-90-57l77-77q17-16 8-38-10-23-33-23h-250q-15 0-25 11t-11 25v250q0 24 22 33 22 10 39-8l72-72q60 57 137 88t159 31q87 0 166-34t137-92 91-137 34-166z','transform':'matrix(1 0 0 -1 0 850)'},'home':{'width':928.6,'height':1000,'path':'m786 296v-267q0-15-11-26t-25-10h-214v214h-143v-214h-214q-15 0-25 10t-11 26v267q0 1 0 2t0 2l321 264 321-264q1-1 1-4z m124 39l-34-41q-5-5-12-6h-2q-7 0-12 3l-386 322-386-322q-7-4-13-4-7 2-12 7l-35 41q-4 5-3 13t6 12l401 334q18 15 42 15t43-15l136-114v109q0 8 5 13t13 5h107q8 0 13-5t5-13v-227l122-102q5-5 6-12t-4-13z','transform':'matrix(1 0 0 -1 0 850)'},'camera-retro':{'width':1000,'height':1000,'path':'m518 386q0 8-5 13t-13 5q-37 0-63-27t-26-63q0-8 5-13t13-5 12 5 5 13q0 23 16 38t38 16q8 0 13 5t5 13z m125-73q0-59-42-101t-101-42-101 42-42 101 42 101 101 42 101-42 42-101z m-572-320h858v71h-858v-71z m643 320q0 89-62 152t-152 62-151-62-63-152 63-151 151-63 152 63 62 151z m-571 358h214v72h-214v-72z m-72-107h858v143h-462l-36-71h-360v-72z m929 143v-714q0-30-21-51t-50-21h-858q-29 0-50 21t-21 51v714q0 30 21 51t50 21h858q29 0 50-21t21-51z','transform':'matrix(1 0 0 -1 0 850)'},'zoombox':{'width':1000,'height':1000,'path':'m1000-25l-250 251c40 63 63 138 63 218 0 224-182 406-407 406-224 0-406-182-406-406s183-406 407-406c80 0 155 22 218 62l250-250 125 125z m-812 250l0 438 437 0 0-438-437 0z m62 375l313 0 0-312-313 0 0 312z','transform':'matrix(1 0 0 -1 0 850)'},'pan':{'width':1000,'height':1000,'path':'m1000 350l-187 188 0-125-250 0 0 250 125 0-188 187-187-187 125 0 0-250-250 0 0 125-188-188 186-187 0 125 252 0 0-250-125 0 187-188 188 188-125 0 0 250 250 0 0-126 187 188z','transform':'matrix(1 0 0 -1 0 850)'},'zoom_plus':{'width':875,'height':1000,'path':'m1 787l0-875 875 0 0 875-875 0z m687-500l-187 0 0-187-125 0 0 187-188 0 0 125 188 0 0 187 125 0 0-187 187 0 0-125z','transform':'matrix(1 0 0 -1 0 850)'},'zoom_minus':{'width':875,'height':1000,'path':'m0 788l0-876 875 0 0 876-875 0z m688-500l-500 0 0 125 500 0 0-125z','transform':'matrix(1 0 0 -1 0 850)'},'autoscale':{'width':1000,'height':1000,'path':'m250 850l-187 0-63 0 0-62 0-188 63 0 0 188 187 0 0 62z m688 0l-188 0 0-62 188 0 0-188 62 0 0 188 0 62-62 0z m-875-938l0 188-63 0 0-188 0-62 63 0 187 0 0 62-187 0z m875 188l0-188-188 0 0-62 188 0 62 0 0 62 0 188-62 0z m-125 188l-1 0-93-94-156 156 156 156 92-93 2 0 0 250-250 0 0-2 93-92-156-156-156 156 94 92 0 2-250 0 0-250 0 0 93 93 157-156-157-156-93 94 0 0 0-250 250 0 0 0-94 93 156 157 156-157-93-93 0 0 250 0 0 250z','transform':'matrix(1 0 0 -1 0 850)'},'tooltip_basic':{'width':1500,'height':1000,'path':'m375 725l0 0-375-375 375-374 0-1 1125 0 0 750-1125 0z','transform':'matrix(1 0 0 -1 0 850)'},'tooltip_compare':{'width':1125,'height':1000,'path':'m187 786l0 2-187-188 188-187 0 0 937 0 0 373-938 0z m0-499l0 1-187-188 188-188 0 0 937 0 0 376-938-1z','transform':'matrix(1 0 0 -1 0 850)'},'plotlylogo':{'width':1542,'height':1000,'path':'m0-10h182v-140h-182v140z m228 146h183v-286h-183v286z m225 714h182v-1000h-182v1000z m225-285h182v-715h-182v715z m225 142h183v-857h-183v857z m231-428h182v-429h-182v429z m225-291h183v-138h-183v138z','transform':'matrix(1 0 0 -1 0 850)'},'z-axis':{'width':1000,'height':1000,'path':'m833 5l-17 108v41l-130-65 130-66c0 0 0 38 0 39 0-1 36-14 39-25 4-15-6-22-16-30-15-12-39-16-56-20-90-22-187-23-279-23-261 0-341 34-353 59 3 60 228 110 228 110-140-8-351-35-351-116 0-120 293-142 474-142 155 0 477 22 477 142 0 50-74 79-163 96z m-374 94c-58-5-99-21-99-40 0-24 65-43 144-43 79 0 143 19 143 43 0 19-42 34-98 40v216h87l-132 135-133-135h88v-216z m167 515h-136v1c16 16 31 34 46 52l84 109v54h-230v-71h124v-1c-16-17-28-32-44-51l-89-114v-51h245v72z','transform':'matrix(1 0 0 -1 0 850)'},'3d_rotate':{'width':1000,'height':1000,'path':'m922 660c-5 4-9 7-14 11-359 263-580-31-580-31l-102 28 58-400c0 1 1 1 2 2 118 108 351 249 351 249s-62 27-100 42c88 83 222 183 347 122 16-8 30-17 44-27-2 1-4 2-6 4z m36-329c0 0 64 229-88 296-62 27-124 14-175-11 157-78 225-208 249-266 8-19 11-31 11-31 2 5 6 15 11 32-5-13-8-20-8-20z m-775-239c70-31 117-50 198-32-121 80-199 346-199 346l-96-15-58-12c0 0 55-226 155-287z m603 133l-317-139c0 0 4-4 19-14 7-5 24-15 24-15s-177-147-389 4c235-287 536-112 536-112l31-22 100 299-4-1z m-298-153c6-4 14-9 24-15 0 0-17 10-24 15z','transform':'matrix(1 0 0 -1 0 850)'},'camera':{'width':1000,'height':1000,'path':'m500 450c-83 0-150-67-150-150 0-83 67-150 150-150 83 0 150 67 150 150 0 83-67 150-150 150z m400 150h-120c-16 0-34 13-39 29l-31 93c-6 15-23 28-40 28h-340c-16 0-34-13-39-28l-31-94c-6-15-23-28-40-28h-120c-55 0-100-45-100-100v-450c0-55 45-100 100-100h800c55 0 100 45 100 100v450c0 55-45 100-100 100z m-400-550c-138 0-250 112-250 250 0 138 112 250 250 250 138 0 250-112 250-250 0-138-112-250-250-250z m365 380c-19 0-35 16-35 35 0 19 16 35 35 35 19 0 35-16 35-35 0-19-16-35-35-35z','transform':'matrix(1 0 0 -1 0 850)'},'movie':{'width':1000,'height':1000,'path':'m938 413l-188-125c0 37-17 71-44 94 64 38 107 107 107 187 0 121-98 219-219 219-121 0-219-98-219-219 0-61 25-117 66-156h-115c30 33 49 76 49 125 0 103-84 187-187 187s-188-84-188-187c0-57 26-107 65-141-38-22-65-62-65-109v-250c0-70 56-126 125-126h500c69 0 125 56 125 126l188-126c34 0 62 28 62 63v375c0 35-28 63-62 63z m-750 0c-69 0-125 56-125 125s56 125 125 125 125-56 125-125-56-125-125-125z m406-1c-87 0-157 70-157 157 0 86 70 156 157 156s156-70 156-156-70-157-156-157z','transform':'matrix(1 0 0 -1 0 850)'},'question':{'width':857.1,'height':1000,'path':'m500 82v107q0 8-5 13t-13 5h-107q-8 0-13-5t-5-13v-107q0-8 5-13t13-5h107q8 0 13 5t5 13z m143 375q0 49-31 91t-77 65-95 23q-136 0-207-119-9-14 4-24l74-55q4-4 10-4 9 0 14 7 30 38 48 51 19 14 48 14 27 0 48-15t21-33q0-21-11-34t-38-25q-35-16-65-48t-29-70v-20q0-8 5-13t13-5h107q8 0 13 5t5 13q0 10 12 27t30 28q18 10 28 16t25 19 25 27 16 34 7 45z m214-107q0-117-57-215t-156-156-215-58-216 58-155 156-58 215 58 215 155 156 216 58 215-58 156-156 57-215z','transform':'matrix(1 0 0 -1 0 850)'},'disk':{'width':857.1,'height':1000,'path':'m214-7h429v214h-429v-214z m500 0h72v500q0 8-6 21t-11 20l-157 156q-5 6-19 12t-22 5v-232q0-22-15-38t-38-16h-322q-22 0-37 16t-16 38v232h-72v-714h72v232q0 22 16 38t37 16h465q22 0 38-16t15-38v-232z m-214 518v178q0 8-5 13t-13 5h-107q-7 0-13-5t-5-13v-178q0-8 5-13t13-5h107q7 0 13 5t5 13z m357-18v-518q0-22-15-38t-38-16h-750q-23 0-38 16t-16 38v750q0 22 16 38t38 16h517q23 0 50-12t42-26l156-157q16-15 27-42t11-49z','transform':'matrix(1 0 0 -1 0 850)'},'lasso':{'width':1031,'height':1000,'path':'m1018 538c-36 207-290 336-568 286-277-48-473-256-436-463 10-57 36-108 76-151-13-66 11-137 68-183 34-28 75-41 114-42l-55-70 0 0c-2-1-3-2-4-3-10-14-8-34 5-45 14-11 34-8 45 4 1 1 2 3 2 5l0 0 113 140c16 11 31 24 45 40 4 3 6 7 8 11 48-3 100 0 151 9 278 48 473 255 436 462z m-624-379c-80 14-149 48-197 96 42 42 109 47 156 9 33-26 47-66 41-105z m-187-74c-19 16-33 37-39 60 50-32 109-55 174-68-42-25-95-24-135 8z m360 75c-34-7-69-9-102-8 8 62-16 128-68 170-73 59-175 54-244-5-9 20-16 40-20 61-28 159 121 317 333 354s407-60 434-217c28-159-121-318-333-355z','transform':'matrix(1 0 0 -1 0 850)'},'selectbox':{'width':1000,'height':1000,'path':'m0 850l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z m285 0l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z m-857-286l0-143 143 0 0 143-143 0z m857 0l0-143 143 0 0 143-143 0z m-857-285l0-143 143 0 0 143-143 0z m857 0l0-143 143 0 0 143-143 0z m-857-286l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z m285 0l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z','transform':'matrix(1 0 0 -1 0 850)'},'spikeline':{'width':1000,'height':1000,'path':'M512 409c0-57-46-104-103-104-57 0-104 47-104 104 0 57 47 103 104 103 57 0 103-46 103-103z m-327-39l92 0 0 92-92 0z m-185 0l92 0 0 92-92 0z m370-186l92 0 0 93-92 0z m0-184l92 0 0 92-92 0z','transform':'matrix(1.5 0 0 -1.5 0 850)'},'newplotlylogo':{'name':'newplotlylogo','svg':'<svg xmlns=\\'http://www.w3.org/2000/svg\\' viewBox=\\'0 0 132 132\\'><defs><style>.cls-1 {fill: #119dff;} .cls-2 {fill: #25fefd;} .cls-3 {fill: #fff;}</style></defs><title>plotly-logomark</title><g id=\\'symbol\\'><rect class=\\'cls-1\\' width=\\'132\\' height=\\'132\\' rx=\\'6\\' ry=\\'6\\'/><circle class=\\'cls-2\\' cx=\\'78\\' cy=\\'54\\' r=\\'6\\'/><circle class=\\'cls-2\\' cx=\\'102\\' cy=\\'30\\' r=\\'6\\'/><circle class=\\'cls-2\\' cx=\\'78\\' cy=\\'30\\' r=\\'6\\'/><circle class=\\'cls-2\\' cx=\\'54\\' cy=\\'30\\' r=\\'6\\'/><circle class=\\'cls-2\\' cx=\\'30\\' cy=\\'30\\' r=\\'6\\'/><circle class=\\'cls-2\\' cx=\\'30\\' cy=\\'54\\' r=\\'6\\'/><path class=\\'cls-3\\' d=\\'M30,72a6,6,0,0,0-6,6v24a6,6,0,0,0,12,0V78A6,6,0,0,0,30,72Z\\'/><path class=\\'cls-3\\' d=\\'M78,72a6,6,0,0,0-6,6v24a6,6,0,0,0,12,0V78A6,6,0,0,0,78,72Z\\'/><path class=\\'cls-3\\' d=\\'M54,48a6,6,0,0,0-6,6v48a6,6,0,0,0,12,0V54A6,6,0,0,0,54,48Z\\'/><path class=\\'cls-3\\' d=\\'M102,48a6,6,0,0,0-6,6v48a6,6,0,0,0,12,0V54A6,6,0,0,0,102,48Z\\'/></g></svg>'}};},{}],3:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports=_dereq_('../src/traces/bar');},{\"../src/traces/bar\":259}],4:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports=_dereq_('../src/core');},{\"../src/core\":142}],5:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Plotly=_dereq_('./core');Plotly.register([_dereq_('./bar'),_dereq_('./pie')]);module.exports=Plotly;},{\"./bar\":3,\"./core\":4,\"./pie\":6}],6:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports=_dereq_('../src/traces/pie');},{\"../src/traces/pie\":273}],7:[function(_dereq_,module,exports){// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\nvar objectCreate=Object.create||objectCreatePolyfill;var objectKeys=Object.keys||objectKeysPolyfill;var bind=Function.prototype.bind||functionBindPolyfill;function EventEmitter(){if(!this._events||!Object.prototype.hasOwnProperty.call(this,'_events')){this._events=objectCreate(null);this._eventsCount=0;}this._maxListeners=this._maxListeners||undefined;}module.exports=EventEmitter;// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter=EventEmitter;EventEmitter.prototype._events=undefined;EventEmitter.prototype._maxListeners=undefined;// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners=10;var hasDefineProperty;try{var o={};if(Object.defineProperty)Object.defineProperty(o,'x',{value:0});hasDefineProperty=o.x===0;}catch(err){hasDefineProperty=false;}if(hasDefineProperty){Object.defineProperty(EventEmitter,'defaultMaxListeners',{enumerable:true,get:function get(){return defaultMaxListeners;},set:function set(arg){// check whether the input is a positive number (whose value is zero or\n// greater and not a NaN).\nif(typeof arg!=='number'||arg<0||arg!==arg)throw new TypeError('\"defaultMaxListeners\" must be a positive number');defaultMaxListeners=arg;}});}else{EventEmitter.defaultMaxListeners=defaultMaxListeners;}// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners=function setMaxListeners(n){if(typeof n!=='number'||n<0||isNaN(n))throw new TypeError('\"n\" argument must be a positive number');this._maxListeners=n;return this;};function $getMaxListeners(that){if(that._maxListeners===undefined)return EventEmitter.defaultMaxListeners;return that._maxListeners;}EventEmitter.prototype.getMaxListeners=function getMaxListeners(){return $getMaxListeners(this);};// These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\nfunction emitNone(handler,isFn,self){if(isFn)handler.call(self);else{var len=handler.length;var listeners=arrayClone(handler,len);for(var i=0;i<len;++i){listeners[i].call(self);}}}function emitOne(handler,isFn,self,arg1){if(isFn)handler.call(self,arg1);else{var len=handler.length;var listeners=arrayClone(handler,len);for(var i=0;i<len;++i){listeners[i].call(self,arg1);}}}function emitTwo(handler,isFn,self,arg1,arg2){if(isFn)handler.call(self,arg1,arg2);else{var len=handler.length;var listeners=arrayClone(handler,len);for(var i=0;i<len;++i){listeners[i].call(self,arg1,arg2);}}}function emitThree(handler,isFn,self,arg1,arg2,arg3){if(isFn)handler.call(self,arg1,arg2,arg3);else{var len=handler.length;var listeners=arrayClone(handler,len);for(var i=0;i<len;++i){listeners[i].call(self,arg1,arg2,arg3);}}}function emitMany(handler,isFn,self,args){if(isFn)handler.apply(self,args);else{var len=handler.length;var listeners=arrayClone(handler,len);for(var i=0;i<len;++i){listeners[i].apply(self,args);}}}EventEmitter.prototype.emit=function emit(type){var er,handler,len,args,i,events;var doError=type==='error';events=this._events;if(events)doError=doError&&events.error==null;else if(!doError)return false;// If there is no 'error' event listener then throw.\nif(doError){if(arguments.length>1)er=arguments[1];if(er instanceof Error){throw er;// Unhandled 'error' event\n}else{// At least give some kind of context to the user\nvar err=new Error('Unhandled \"error\" event. ('+er+')');err.context=er;throw err;}return false;}handler=events[type];if(!handler)return false;var isFn=typeof handler==='function';len=arguments.length;switch(len){// fast cases\ncase 1:emitNone(handler,isFn,this);break;case 2:emitOne(handler,isFn,this,arguments[1]);break;case 3:emitTwo(handler,isFn,this,arguments[1],arguments[2]);break;case 4:emitThree(handler,isFn,this,arguments[1],arguments[2],arguments[3]);break;// slower\ndefault:args=new Array(len-1);for(i=1;i<len;i++){args[i-1]=arguments[i];}emitMany(handler,isFn,this,args);}return true;};function _addListener(target,type,listener,prepend){var m;var events;var existing;if(typeof listener!=='function')throw new TypeError('\"listener\" argument must be a function');events=target._events;if(!events){events=target._events=objectCreate(null);target._eventsCount=0;}else{// To avoid recursion in the case that type === \"newListener\"! Before\n// adding it to the listeners, first emit \"newListener\".\nif(events.newListener){target.emit('newListener',type,listener.listener?listener.listener:listener);// Re-assign `events` because a newListener handler could have caused the\n// this._events to be assigned to a new object\nevents=target._events;}existing=events[type];}if(!existing){// Optimize the case of one listener. Don't need the extra array object.\nexisting=events[type]=listener;++target._eventsCount;}else{if(typeof existing==='function'){// Adding the second element, need to change to array.\nexisting=events[type]=prepend?[listener,existing]:[existing,listener];}else{// If we've already got an array, just append.\nif(prepend){existing.unshift(listener);}else{existing.push(listener);}}// Check for listener leak\nif(!existing.warned){m=$getMaxListeners(target);if(m&&m>0&&existing.length>m){existing.warned=true;var w=new Error('Possible EventEmitter memory leak detected. '+existing.length+' \"'+String(type)+'\" listeners '+'added. Use emitter.setMaxListeners() to '+'increase limit.');w.name='MaxListenersExceededWarning';w.emitter=target;w.type=type;w.count=existing.length;if((typeof console===\"undefined\"?\"undefined\":_typeof(console))==='object'&&console.warn){console.warn('%s: %s',w.name,w.message);}}}}return target;}EventEmitter.prototype.addListener=function addListener(type,listener){return _addListener(this,type,listener,false);};EventEmitter.prototype.on=EventEmitter.prototype.addListener;EventEmitter.prototype.prependListener=function prependListener(type,listener){return _addListener(this,type,listener,true);};function onceWrapper(){if(!this.fired){this.target.removeListener(this.type,this.wrapFn);this.fired=true;switch(arguments.length){case 0:return this.listener.call(this.target);case 1:return this.listener.call(this.target,arguments[0]);case 2:return this.listener.call(this.target,arguments[0],arguments[1]);case 3:return this.listener.call(this.target,arguments[0],arguments[1],arguments[2]);default:var args=new Array(arguments.length);for(var i=0;i<args.length;++i){args[i]=arguments[i];}this.listener.apply(this.target,args);}}}function _onceWrap(target,type,listener){var state={fired:false,wrapFn:undefined,target:target,type:type,listener:listener};var wrapped=bind.call(onceWrapper,state);wrapped.listener=listener;state.wrapFn=wrapped;return wrapped;}EventEmitter.prototype.once=function once(type,listener){if(typeof listener!=='function')throw new TypeError('\"listener\" argument must be a function');this.on(type,_onceWrap(this,type,listener));return this;};EventEmitter.prototype.prependOnceListener=function prependOnceListener(type,listener){if(typeof listener!=='function')throw new TypeError('\"listener\" argument must be a function');this.prependListener(type,_onceWrap(this,type,listener));return this;};// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener=function removeListener(type,listener){var list,events,position,i,originalListener;if(typeof listener!=='function')throw new TypeError('\"listener\" argument must be a function');events=this._events;if(!events)return this;list=events[type];if(!list)return this;if(list===listener||list.listener===listener){if(--this._eventsCount===0)this._events=objectCreate(null);else{delete events[type];if(events.removeListener)this.emit('removeListener',type,list.listener||listener);}}else if(typeof list!=='function'){position=-1;for(i=list.length-1;i>=0;i--){if(list[i]===listener||list[i].listener===listener){originalListener=list[i].listener;position=i;break;}}if(position<0)return this;if(position===0)list.shift();else spliceOne(list,position);if(list.length===1)events[type]=list[0];if(events.removeListener)this.emit('removeListener',type,originalListener||listener);}return this;};EventEmitter.prototype.removeAllListeners=function removeAllListeners(type){var listeners,events,i;events=this._events;if(!events)return this;// not listening for removeListener, no need to emit\nif(!events.removeListener){if(arguments.length===0){this._events=objectCreate(null);this._eventsCount=0;}else if(events[type]){if(--this._eventsCount===0)this._events=objectCreate(null);else delete events[type];}return this;}// emit removeListener for all listeners on all events\nif(arguments.length===0){var keys=objectKeys(events);var key;for(i=0;i<keys.length;++i){key=keys[i];if(key==='removeListener')continue;this.removeAllListeners(key);}this.removeAllListeners('removeListener');this._events=objectCreate(null);this._eventsCount=0;return this;}listeners=events[type];if(typeof listeners==='function'){this.removeListener(type,listeners);}else if(listeners){// LIFO order\nfor(i=listeners.length-1;i>=0;i--){this.removeListener(type,listeners[i]);}}return this;};function _listeners(target,type,unwrap){var events=target._events;if(!events)return[];var evlistener=events[type];if(!evlistener)return[];if(typeof evlistener==='function')return unwrap?[evlistener.listener||evlistener]:[evlistener];return unwrap?unwrapListeners(evlistener):arrayClone(evlistener,evlistener.length);}EventEmitter.prototype.listeners=function listeners(type){return _listeners(this,type,true);};EventEmitter.prototype.rawListeners=function rawListeners(type){return _listeners(this,type,false);};EventEmitter.listenerCount=function(emitter,type){if(typeof emitter.listenerCount==='function'){return emitter.listenerCount(type);}else{return listenerCount.call(emitter,type);}};EventEmitter.prototype.listenerCount=listenerCount;function listenerCount(type){var events=this._events;if(events){var evlistener=events[type];if(typeof evlistener==='function'){return 1;}else if(evlistener){return evlistener.length;}}return 0;}EventEmitter.prototype.eventNames=function eventNames(){return this._eventsCount>0?Reflect.ownKeys(this._events):[];};// About 1.5x faster than the two-arg version of Array#splice().\nfunction spliceOne(list,index){for(var i=index,k=i+1,n=list.length;k<n;i+=1,k+=1){list[i]=list[k];}list.pop();}function arrayClone(arr,n){var copy=new Array(n);for(var i=0;i<n;++i){copy[i]=arr[i];}return copy;}function unwrapListeners(arr){var ret=new Array(arr.length);for(var i=0;i<ret.length;++i){ret[i]=arr[i].listener||arr[i];}return ret;}function objectCreatePolyfill(proto){var F=function F(){};F.prototype=proto;return new F();}function objectKeysPolyfill(obj){var keys=[];for(var k in obj){if(Object.prototype.hasOwnProperty.call(obj,k)){keys.push(k);}}return k;}function functionBindPolyfill(context){var fn=this;return function(){return fn.apply(context,arguments);};}},{}],8:[function(_dereq_,module,exports){!function(){var d3={version:\"3.5.17\"};var d3_arraySlice=[].slice,d3_array=function d3_array(list){return d3_arraySlice.call(list);};var d3_document=this.document;function d3_documentElement(node){return node&&(node.ownerDocument||node.document||node).documentElement;}function d3_window(node){return node&&(node.ownerDocument&&node.ownerDocument.defaultView||node.document&&node||node.defaultView);}if(d3_document){try{d3_array(d3_document.documentElement.childNodes)[0].nodeType;}catch(e){d3_array=function d3_array(list){var i=list.length,array=new Array(i);while(i--){array[i]=list[i];}return array;};}}if(!Date.now)Date.now=function(){return+new Date();};if(d3_document){try{d3_document.createElement(\"DIV\").style.setProperty(\"opacity\",0,\"\");}catch(error){var d3_element_prototype=this.Element.prototype,d3_element_setAttribute=d3_element_prototype.setAttribute,d3_element_setAttributeNS=d3_element_prototype.setAttributeNS,d3_style_prototype=this.CSSStyleDeclaration.prototype,d3_style_setProperty=d3_style_prototype.setProperty;d3_element_prototype.setAttribute=function(name,value){d3_element_setAttribute.call(this,name,value+\"\");};d3_element_prototype.setAttributeNS=function(space,local,value){d3_element_setAttributeNS.call(this,space,local,value+\"\");};d3_style_prototype.setProperty=function(name,value,priority){d3_style_setProperty.call(this,name,value+\"\",priority);};}}d3.ascending=d3_ascending;function d3_ascending(a,b){return a<b?-1:a>b?1:a>=b?0:NaN;}d3.descending=function(a,b){return b<a?-1:b>a?1:b>=a?0:NaN;};d3.min=function(array,f){var i=-1,n=array.length,a,b;if(arguments.length===1){while(++i<n){if((b=array[i])!=null&&b>=b){a=b;break;}}while(++i<n){if((b=array[i])!=null&&a>b)a=b;}}else{while(++i<n){if((b=f.call(array,array[i],i))!=null&&b>=b){a=b;break;}}while(++i<n){if((b=f.call(array,array[i],i))!=null&&a>b)a=b;}}return a;};d3.max=function(array,f){var i=-1,n=array.length,a,b;if(arguments.length===1){while(++i<n){if((b=array[i])!=null&&b>=b){a=b;break;}}while(++i<n){if((b=array[i])!=null&&b>a)a=b;}}else{while(++i<n){if((b=f.call(array,array[i],i))!=null&&b>=b){a=b;break;}}while(++i<n){if((b=f.call(array,array[i],i))!=null&&b>a)a=b;}}return a;};d3.extent=function(array,f){var i=-1,n=array.length,a,b,c;if(arguments.length===1){while(++i<n){if((b=array[i])!=null&&b>=b){a=c=b;break;}}while(++i<n){if((b=array[i])!=null){if(a>b)a=b;if(c<b)c=b;}}}else{while(++i<n){if((b=f.call(array,array[i],i))!=null&&b>=b){a=c=b;break;}}while(++i<n){if((b=f.call(array,array[i],i))!=null){if(a>b)a=b;if(c<b)c=b;}}}return[a,c];};function d3_number(x){return x===null?NaN:+x;}function d3_numeric(x){return!isNaN(x);}d3.sum=function(array,f){var s=0,n=array.length,a,i=-1;if(arguments.length===1){while(++i<n){if(d3_numeric(a=+array[i]))s+=a;}}else{while(++i<n){if(d3_numeric(a=+f.call(array,array[i],i)))s+=a;}}return s;};d3.mean=function(array,f){var s=0,n=array.length,a,i=-1,j=n;if(arguments.length===1){while(++i<n){if(d3_numeric(a=d3_number(array[i])))s+=a;else--j;}}else{while(++i<n){if(d3_numeric(a=d3_number(f.call(array,array[i],i))))s+=a;else--j;}}if(j)return s/j;};d3.quantile=function(values,p){var H=(values.length-1)*p+1,h=Math.floor(H),v=+values[h-1],e=H-h;return e?v+e*(values[h]-v):v;};d3.median=function(array,f){var numbers=[],n=array.length,a,i=-1;if(arguments.length===1){while(++i<n){if(d3_numeric(a=d3_number(array[i])))numbers.push(a);}}else{while(++i<n){if(d3_numeric(a=d3_number(f.call(array,array[i],i))))numbers.push(a);}}if(numbers.length)return d3.quantile(numbers.sort(d3_ascending),.5);};d3.variance=function(array,f){var n=array.length,m=0,a,d,s=0,i=-1,j=0;if(arguments.length===1){while(++i<n){if(d3_numeric(a=d3_number(array[i]))){d=a-m;m+=d/++j;s+=d*(a-m);}}}else{while(++i<n){if(d3_numeric(a=d3_number(f.call(array,array[i],i)))){d=a-m;m+=d/++j;s+=d*(a-m);}}}if(j>1)return s/(j-1);};d3.deviation=function(){var v=d3.variance.apply(this,arguments);return v?Math.sqrt(v):v;};function d3_bisector(compare){return{left:function left(a,x,lo,hi){if(arguments.length<3)lo=0;if(arguments.length<4)hi=a.length;while(lo<hi){var mid=lo+hi>>>1;if(compare(a[mid],x)<0)lo=mid+1;else hi=mid;}return lo;},right:function right(a,x,lo,hi){if(arguments.length<3)lo=0;if(arguments.length<4)hi=a.length;while(lo<hi){var mid=lo+hi>>>1;if(compare(a[mid],x)>0)hi=mid;else lo=mid+1;}return lo;}};}var d3_bisect=d3_bisector(d3_ascending);d3.bisectLeft=d3_bisect.left;d3.bisect=d3.bisectRight=d3_bisect.right;d3.bisector=function(f){return d3_bisector(f.length===1?function(d,x){return d3_ascending(f(d),x);}:f);};d3.shuffle=function(array,i0,i1){if((m=arguments.length)<3){i1=array.length;if(m<2)i0=0;}var m=i1-i0,t,i;while(m){i=Math.random()*m--|0;t=array[m+i0],array[m+i0]=array[i+i0],array[i+i0]=t;}return array;};d3.permute=function(array,indexes){var i=indexes.length,permutes=new Array(i);while(i--){permutes[i]=array[indexes[i]];}return permutes;};d3.pairs=function(array){var i=0,n=array.length-1,p0,p1=array[0],pairs=new Array(n<0?0:n);while(i<n){pairs[i]=[p0=p1,p1=array[++i]];}return pairs;};d3.transpose=function(matrix){if(!(n=matrix.length))return[];for(var i=-1,m=d3.min(matrix,d3_transposeLength),transpose=new Array(m);++i<m;){for(var j=-1,n,row=transpose[i]=new Array(n);++j<n;){row[j]=matrix[j][i];}}return transpose;};function d3_transposeLength(d){return d.length;}d3.zip=function(){return d3.transpose(arguments);};d3.keys=function(map){var keys=[];for(var key in map){keys.push(key);}return keys;};d3.values=function(map){var values=[];for(var key in map){values.push(map[key]);}return values;};d3.entries=function(map){var entries=[];for(var key in map){entries.push({key:key,value:map[key]});}return entries;};d3.merge=function(arrays){var n=arrays.length,m,i=-1,j=0,merged,array;while(++i<n){j+=arrays[i].length;}merged=new Array(j);while(--n>=0){array=arrays[n];m=array.length;while(--m>=0){merged[--j]=array[m];}}return merged;};var abs=Math.abs;d3.range=function(start,stop,step){if(arguments.length<3){step=1;if(arguments.length<2){stop=start;start=0;}}if((stop-start)/step===Infinity)throw new Error(\"infinite range\");var range=[],k=d3_range_integerScale(abs(step)),i=-1,j;start*=k,stop*=k,step*=k;if(step<0)while((j=start+step*++i)>stop){range.push(j/k);}else while((j=start+step*++i)<stop){range.push(j/k);}return range;};function d3_range_integerScale(x){var k=1;while(x*k%1){k*=10;}return k;}function d3_class(ctor,properties){for(var key in properties){Object.defineProperty(ctor.prototype,key,{value:properties[key],enumerable:false});}}d3.map=function(object,f){var map=new d3_Map();if(object instanceof d3_Map){object.forEach(function(key,value){map.set(key,value);});}else if(Array.isArray(object)){var i=-1,n=object.length,o;if(arguments.length===1)while(++i<n){map.set(i,object[i]);}else while(++i<n){map.set(f.call(object,o=object[i],i),o);}}else{for(var key in object){map.set(key,object[key]);}}return map;};function d3_Map(){this._=Object.create(null);}var d3_map_proto=\"__proto__\",d3_map_zero=\"\\x00\";d3_class(d3_Map,{has:d3_map_has,get:function get(key){return this._[d3_map_escape(key)];},set:function set(key,value){return this._[d3_map_escape(key)]=value;},remove:d3_map_remove,keys:d3_map_keys,values:function values(){var values=[];for(var key in this._){values.push(this._[key]);}return values;},entries:function entries(){var entries=[];for(var key in this._){entries.push({key:d3_map_unescape(key),value:this._[key]});}return entries;},size:d3_map_size,empty:d3_map_empty,forEach:function forEach(f){for(var key in this._){f.call(this,d3_map_unescape(key),this._[key]);}}});function d3_map_escape(key){return(key+=\"\")===d3_map_proto||key[0]===d3_map_zero?d3_map_zero+key:key;}function d3_map_unescape(key){return(key+=\"\")[0]===d3_map_zero?key.slice(1):key;}function d3_map_has(key){return d3_map_escape(key)in this._;}function d3_map_remove(key){return(key=d3_map_escape(key))in this._&&delete this._[key];}function d3_map_keys(){var keys=[];for(var key in this._){keys.push(d3_map_unescape(key));}return keys;}function d3_map_size(){var size=0;for(var key in this._){++size;}return size;}function d3_map_empty(){for(var key in this._){return false;}return true;}d3.nest=function(){var nest={},keys=[],sortKeys=[],sortValues,rollup;function map(mapType,array,depth){if(depth>=keys.length)return rollup?rollup.call(nest,array):sortValues?array.sort(sortValues):array;var i=-1,n=array.length,key=keys[depth++],keyValue,object,setter,valuesByKey=new d3_Map(),values;while(++i<n){if(values=valuesByKey.get(keyValue=key(object=array[i]))){values.push(object);}else{valuesByKey.set(keyValue,[object]);}}if(mapType){object=mapType();setter=function setter(keyValue,values){object.set(keyValue,map(mapType,values,depth));};}else{object={};setter=function setter(keyValue,values){object[keyValue]=map(mapType,values,depth);};}valuesByKey.forEach(setter);return object;}function entries(map,depth){if(depth>=keys.length)return map;var array=[],sortKey=sortKeys[depth++];map.forEach(function(key,keyMap){array.push({key:key,values:entries(keyMap,depth)});});return sortKey?array.sort(function(a,b){return sortKey(a.key,b.key);}):array;}nest.map=function(array,mapType){return map(mapType,array,0);};nest.entries=function(array){return entries(map(d3.map,array,0),0);};nest.key=function(d){keys.push(d);return nest;};nest.sortKeys=function(order){sortKeys[keys.length-1]=order;return nest;};nest.sortValues=function(order){sortValues=order;return nest;};nest.rollup=function(f){rollup=f;return nest;};return nest;};d3.set=function(array){var set=new d3_Set();if(array)for(var i=0,n=array.length;i<n;++i){set.add(array[i]);}return set;};function d3_Set(){this._=Object.create(null);}d3_class(d3_Set,{has:d3_map_has,add:function add(key){this._[d3_map_escape(key+=\"\")]=true;return key;},remove:d3_map_remove,values:d3_map_keys,size:d3_map_size,empty:d3_map_empty,forEach:function forEach(f){for(var key in this._){f.call(this,d3_map_unescape(key));}}});d3.behavior={};function d3_identity(d){return d;}d3.rebind=function(target,source){var i=1,n=arguments.length,method;while(++i<n){target[method=arguments[i]]=d3_rebind(target,source,source[method]);}return target;};function d3_rebind(target,source,method){return function(){var value=method.apply(source,arguments);return value===source?target:value;};}function d3_vendorSymbol(object,name){if(name in object)return name;name=name.charAt(0).toUpperCase()+name.slice(1);for(var i=0,n=d3_vendorPrefixes.length;i<n;++i){var prefixName=d3_vendorPrefixes[i]+name;if(prefixName in object)return prefixName;}}var d3_vendorPrefixes=[\"webkit\",\"ms\",\"moz\",\"Moz\",\"o\",\"O\"];function d3_noop(){}d3.dispatch=function(){var dispatch=new d3_dispatch(),i=-1,n=arguments.length;while(++i<n){dispatch[arguments[i]]=d3_dispatch_event(dispatch);}return dispatch;};function d3_dispatch(){}d3_dispatch.prototype.on=function(type,listener){var i=type.indexOf(\".\"),name=\"\";if(i>=0){name=type.slice(i+1);type=type.slice(0,i);}if(type)return arguments.length<2?this[type].on(name):this[type].on(name,listener);if(arguments.length===2){if(listener==null)for(type in this){if(this.hasOwnProperty(type))this[type].on(name,null);}return this;}};function d3_dispatch_event(dispatch){var listeners=[],listenerByName=new d3_Map();function event(){var z=listeners,i=-1,n=z.length,l;while(++i<n){if(l=z[i].on)l.apply(this,arguments);}return dispatch;}event.on=function(name,listener){var l=listenerByName.get(name),i;if(arguments.length<2)return l&&l.on;if(l){l.on=null;listeners=listeners.slice(0,i=listeners.indexOf(l)).concat(listeners.slice(i+1));listenerByName.remove(name);}if(listener)listeners.push(listenerByName.set(name,{on:listener}));return dispatch;};return event;}d3.event=null;function d3_eventPreventDefault(){d3.event.preventDefault();}function d3_eventSource(){var e=d3.event,s;while(s=e.sourceEvent){e=s;}return e;}function d3_eventDispatch(target){var dispatch=new d3_dispatch(),i=0,n=arguments.length;while(++i<n){dispatch[arguments[i]]=d3_dispatch_event(dispatch);}dispatch.of=function(thiz,argumentz){return function(e1){try{var e0=e1.sourceEvent=d3.event;e1.target=target;d3.event=e1;dispatch[e1.type].apply(thiz,argumentz);}finally{d3.event=e0;}};};return dispatch;}d3.requote=function(s){return s.replace(d3_requote_re,\"\\\\$&\");};var d3_requote_re=/[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;var d3_subclass={}.__proto__?function(object,prototype){object.__proto__=prototype;}:function(object,prototype){for(var property in prototype){object[property]=prototype[property];}};function d3_selection(groups){d3_subclass(groups,d3_selectionPrototype);return groups;}var d3_select=function d3_select(s,n){return n.querySelector(s);},d3_selectAll=function d3_selectAll(s,n){return n.querySelectorAll(s);},_d3_selectMatches=function d3_selectMatches(n,s){var d3_selectMatcher=n.matches||n[d3_vendorSymbol(n,\"matchesSelector\")];_d3_selectMatches=function d3_selectMatches(n,s){return d3_selectMatcher.call(n,s);};return _d3_selectMatches(n,s);};if(typeof Sizzle===\"function\"){d3_select=function d3_select(s,n){return Sizzle(s,n)[0]||null;};d3_selectAll=Sizzle;_d3_selectMatches=Sizzle.matchesSelector;}d3.selection=function(){return d3.select(d3_document.documentElement);};var d3_selectionPrototype=d3.selection.prototype=[];d3_selectionPrototype.select=function(selector){var subgroups=[],subgroup,subnode,group,node;selector=d3_selection_selector(selector);for(var j=-1,m=this.length;++j<m;){subgroups.push(subgroup=[]);subgroup.parentNode=(group=this[j]).parentNode;for(var i=-1,n=group.length;++i<n;){if(node=group[i]){subgroup.push(subnode=selector.call(node,node.__data__,i,j));if(subnode&&\"__data__\"in node)subnode.__data__=node.__data__;}else{subgroup.push(null);}}}return d3_selection(subgroups);};function d3_selection_selector(selector){return typeof selector===\"function\"?selector:function(){return d3_select(selector,this);};}d3_selectionPrototype.selectAll=function(selector){var subgroups=[],subgroup,node;selector=d3_selection_selectorAll(selector);for(var j=-1,m=this.length;++j<m;){for(var group=this[j],i=-1,n=group.length;++i<n;){if(node=group[i]){subgroups.push(subgroup=d3_array(selector.call(node,node.__data__,i,j)));subgroup.parentNode=node;}}}return d3_selection(subgroups);};function d3_selection_selectorAll(selector){return typeof selector===\"function\"?selector:function(){return d3_selectAll(selector,this);};}var d3_nsXhtml=\"http://www.w3.org/1999/xhtml\";var d3_nsPrefix={svg:\"http://www.w3.org/2000/svg\",xhtml:d3_nsXhtml,xlink:\"http://www.w3.org/1999/xlink\",xml:\"http://www.w3.org/XML/1998/namespace\",xmlns:\"http://www.w3.org/2000/xmlns/\"};d3.ns={prefix:d3_nsPrefix,qualify:function qualify(name){var i=name.indexOf(\":\"),prefix=name;if(i>=0&&(prefix=name.slice(0,i))!==\"xmlns\")name=name.slice(i+1);return d3_nsPrefix.hasOwnProperty(prefix)?{space:d3_nsPrefix[prefix],local:name}:name;}};d3_selectionPrototype.attr=function(name,value){if(arguments.length<2){if(typeof name===\"string\"){var node=this.node();name=d3.ns.qualify(name);return name.local?node.getAttributeNS(name.space,name.local):node.getAttribute(name);}for(value in name){this.each(d3_selection_attr(value,name[value]));}return this;}return this.each(d3_selection_attr(name,value));};function d3_selection_attr(name,value){name=d3.ns.qualify(name);function attrNull(){this.removeAttribute(name);}function attrNullNS(){this.removeAttributeNS(name.space,name.local);}function attrConstant(){this.setAttribute(name,value);}function attrConstantNS(){this.setAttributeNS(name.space,name.local,value);}function attrFunction(){var x=value.apply(this,arguments);if(x==null)this.removeAttribute(name);else this.setAttribute(name,x);}function attrFunctionNS(){var x=value.apply(this,arguments);if(x==null)this.removeAttributeNS(name.space,name.local);else this.setAttributeNS(name.space,name.local,x);}return value==null?name.local?attrNullNS:attrNull:typeof value===\"function\"?name.local?attrFunctionNS:attrFunction:name.local?attrConstantNS:attrConstant;}function d3_collapse(s){return s.trim().replace(/\\s+/g,\" \");}d3_selectionPrototype.classed=function(name,value){if(arguments.length<2){if(typeof name===\"string\"){var node=this.node(),n=(name=d3_selection_classes(name)).length,i=-1;if(value=node.classList){while(++i<n){if(!value.contains(name[i]))return false;}}else{value=node.getAttribute(\"class\");while(++i<n){if(!d3_selection_classedRe(name[i]).test(value))return false;}}return true;}for(value in name){this.each(d3_selection_classed(value,name[value]));}return this;}return this.each(d3_selection_classed(name,value));};function d3_selection_classedRe(name){return new RegExp(\"(?:^|\\\\s+)\"+d3.requote(name)+\"(?:\\\\s+|$)\",\"g\");}function d3_selection_classes(name){return(name+\"\").trim().split(/^|\\s+/);}function d3_selection_classed(name,value){name=d3_selection_classes(name).map(d3_selection_classedName);var n=name.length;function classedConstant(){var i=-1;while(++i<n){name[i](this,value);}}function classedFunction(){var i=-1,x=value.apply(this,arguments);while(++i<n){name[i](this,x);}}return typeof value===\"function\"?classedFunction:classedConstant;}function d3_selection_classedName(name){var re=d3_selection_classedRe(name);return function(node,value){if(c=node.classList)return value?c.add(name):c.remove(name);var c=node.getAttribute(\"class\")||\"\";if(value){re.lastIndex=0;if(!re.test(c))node.setAttribute(\"class\",d3_collapse(c+\" \"+name));}else{node.setAttribute(\"class\",d3_collapse(c.replace(re,\" \")));}};}d3_selectionPrototype.style=function(name,value,priority){var n=arguments.length;if(n<3){if(typeof name!==\"string\"){if(n<2)value=\"\";for(priority in name){this.each(d3_selection_style(priority,name[priority],value));}return this;}if(n<2){var node=this.node();return d3_window(node).getComputedStyle(node,null).getPropertyValue(name);}priority=\"\";}return this.each(d3_selection_style(name,value,priority));};function d3_selection_style(name,value,priority){function styleNull(){this.style.removeProperty(name);}function styleConstant(){this.style.setProperty(name,value,priority);}function styleFunction(){var x=value.apply(this,arguments);if(x==null)this.style.removeProperty(name);else this.style.setProperty(name,x,priority);}return value==null?styleNull:typeof value===\"function\"?styleFunction:styleConstant;}d3_selectionPrototype.property=function(name,value){if(arguments.length<2){if(typeof name===\"string\")return this.node()[name];for(value in name){this.each(d3_selection_property(value,name[value]));}return this;}return this.each(d3_selection_property(name,value));};function d3_selection_property(name,value){function propertyNull(){delete this[name];}function propertyConstant(){this[name]=value;}function propertyFunction(){var x=value.apply(this,arguments);if(x==null)delete this[name];else this[name]=x;}return value==null?propertyNull:typeof value===\"function\"?propertyFunction:propertyConstant;}d3_selectionPrototype.text=function(value){return arguments.length?this.each(typeof value===\"function\"?function(){var v=value.apply(this,arguments);this.textContent=v==null?\"\":v;}:value==null?function(){this.textContent=\"\";}:function(){this.textContent=value;}):this.node().textContent;};d3_selectionPrototype.html=function(value){return arguments.length?this.each(typeof value===\"function\"?function(){var v=value.apply(this,arguments);this.innerHTML=v==null?\"\":v;}:value==null?function(){this.innerHTML=\"\";}:function(){this.innerHTML=value;}):this.node().innerHTML;};d3_selectionPrototype.append=function(name){name=d3_selection_creator(name);return this.select(function(){return this.appendChild(name.apply(this,arguments));});};function d3_selection_creator(name){function create(){var document=this.ownerDocument,namespace=this.namespaceURI;return namespace===d3_nsXhtml&&document.documentElement.namespaceURI===d3_nsXhtml?document.createElement(name):document.createElementNS(namespace,name);}function createNS(){return this.ownerDocument.createElementNS(name.space,name.local);}return typeof name===\"function\"?name:(name=d3.ns.qualify(name)).local?createNS:create;}d3_selectionPrototype.insert=function(name,before){name=d3_selection_creator(name);before=d3_selection_selector(before);return this.select(function(){return this.insertBefore(name.apply(this,arguments),before.apply(this,arguments)||null);});};d3_selectionPrototype.remove=function(){return this.each(d3_selectionRemove);};function d3_selectionRemove(){var parent=this.parentNode;if(parent)parent.removeChild(this);}d3_selectionPrototype.data=function(value,key){var i=-1,n=this.length,group,node;if(!arguments.length){value=new Array(n=(group=this[0]).length);while(++i<n){if(node=group[i]){value[i]=node.__data__;}}return value;}function bind(group,groupData){var i,n=group.length,m=groupData.length,n0=Math.min(n,m),updateNodes=new Array(m),enterNodes=new Array(m),exitNodes=new Array(n),node,nodeData;if(key){var nodeByKeyValue=new d3_Map(),keyValues=new Array(n),keyValue;for(i=-1;++i<n;){if(node=group[i]){if(nodeByKeyValue.has(keyValue=key.call(node,node.__data__,i))){exitNodes[i]=node;}else{nodeByKeyValue.set(keyValue,node);}keyValues[i]=keyValue;}}for(i=-1;++i<m;){if(!(node=nodeByKeyValue.get(keyValue=key.call(groupData,nodeData=groupData[i],i)))){enterNodes[i]=d3_selection_dataNode(nodeData);}else if(node!==true){updateNodes[i]=node;node.__data__=nodeData;}nodeByKeyValue.set(keyValue,true);}for(i=-1;++i<n;){if(i in keyValues&&nodeByKeyValue.get(keyValues[i])!==true){exitNodes[i]=group[i];}}}else{for(i=-1;++i<n0;){node=group[i];nodeData=groupData[i];if(node){node.__data__=nodeData;updateNodes[i]=node;}else{enterNodes[i]=d3_selection_dataNode(nodeData);}}for(;i<m;++i){enterNodes[i]=d3_selection_dataNode(groupData[i]);}for(;i<n;++i){exitNodes[i]=group[i];}}enterNodes.update=updateNodes;enterNodes.parentNode=updateNodes.parentNode=exitNodes.parentNode=group.parentNode;enter.push(enterNodes);update.push(updateNodes);exit.push(exitNodes);}var enter=d3_selection_enter([]),update=d3_selection([]),exit=d3_selection([]);if(typeof value===\"function\"){while(++i<n){bind(group=this[i],value.call(group,group.parentNode.__data__,i));}}else{while(++i<n){bind(group=this[i],value);}}update.enter=function(){return enter;};update.exit=function(){return exit;};return update;};function d3_selection_dataNode(data){return{__data__:data};}d3_selectionPrototype.datum=function(value){return arguments.length?this.property(\"__data__\",value):this.property(\"__data__\");};d3_selectionPrototype.filter=function(filter){var subgroups=[],subgroup,group,node;if(typeof filter!==\"function\")filter=d3_selection_filter(filter);for(var j=0,m=this.length;j<m;j++){subgroups.push(subgroup=[]);subgroup.parentNode=(group=this[j]).parentNode;for(var i=0,n=group.length;i<n;i++){if((node=group[i])&&filter.call(node,node.__data__,i,j)){subgroup.push(node);}}}return d3_selection(subgroups);};function d3_selection_filter(selector){return function(){return _d3_selectMatches(this,selector);};}d3_selectionPrototype.order=function(){for(var j=-1,m=this.length;++j<m;){for(var group=this[j],i=group.length-1,next=group[i],node;--i>=0;){if(node=group[i]){if(next&&next!==node.nextSibling)next.parentNode.insertBefore(node,next);next=node;}}}return this;};d3_selectionPrototype.sort=function(comparator){comparator=d3_selection_sortComparator.apply(this,arguments);for(var j=-1,m=this.length;++j<m;){this[j].sort(comparator);}return this.order();};function d3_selection_sortComparator(comparator){if(!arguments.length)comparator=d3_ascending;return function(a,b){return a&&b?comparator(a.__data__,b.__data__):!a-!b;};}d3_selectionPrototype.each=function(callback){return d3_selection_each(this,function(node,i,j){callback.call(node,node.__data__,i,j);});};function d3_selection_each(groups,callback){for(var j=0,m=groups.length;j<m;j++){for(var group=groups[j],i=0,n=group.length,node;i<n;i++){if(node=group[i])callback(node,i,j);}}return groups;}d3_selectionPrototype.call=function(callback){var args=d3_array(arguments);callback.apply(args[0]=this,args);return this;};d3_selectionPrototype.empty=function(){return!this.node();};d3_selectionPrototype.node=function(){for(var j=0,m=this.length;j<m;j++){for(var group=this[j],i=0,n=group.length;i<n;i++){var node=group[i];if(node)return node;}}return null;};d3_selectionPrototype.size=function(){var n=0;d3_selection_each(this,function(){++n;});return n;};function d3_selection_enter(selection){d3_subclass(selection,d3_selection_enterPrototype);return selection;}var d3_selection_enterPrototype=[];d3.selection.enter=d3_selection_enter;d3.selection.enter.prototype=d3_selection_enterPrototype;d3_selection_enterPrototype.append=d3_selectionPrototype.append;d3_selection_enterPrototype.empty=d3_selectionPrototype.empty;d3_selection_enterPrototype.node=d3_selectionPrototype.node;d3_selection_enterPrototype.call=d3_selectionPrototype.call;d3_selection_enterPrototype.size=d3_selectionPrototype.size;d3_selection_enterPrototype.select=function(selector){var subgroups=[],subgroup,subnode,upgroup,group,node;for(var j=-1,m=this.length;++j<m;){upgroup=(group=this[j]).update;subgroups.push(subgroup=[]);subgroup.parentNode=group.parentNode;for(var i=-1,n=group.length;++i<n;){if(node=group[i]){subgroup.push(upgroup[i]=subnode=selector.call(group.parentNode,node.__data__,i,j));subnode.__data__=node.__data__;}else{subgroup.push(null);}}}return d3_selection(subgroups);};d3_selection_enterPrototype.insert=function(name,before){if(arguments.length<2)before=d3_selection_enterInsertBefore(this);return d3_selectionPrototype.insert.call(this,name,before);};function d3_selection_enterInsertBefore(enter){var i0,j0;return function(d,i,j){var group=enter[j].update,n=group.length,node;if(j!=j0)j0=j,i0=0;if(i>=i0)i0=i+1;while(!(node=group[i0])&&++i0<n){;}return node;};}d3.select=function(node){var group;if(typeof node===\"string\"){group=[d3_select(node,d3_document)];group.parentNode=d3_document.documentElement;}else{group=[node];group.parentNode=d3_documentElement(node);}return d3_selection([group]);};d3.selectAll=function(nodes){var group;if(typeof nodes===\"string\"){group=d3_array(d3_selectAll(nodes,d3_document));group.parentNode=d3_document.documentElement;}else{group=d3_array(nodes);group.parentNode=null;}return d3_selection([group]);};d3_selectionPrototype.on=function(type,listener,capture){var n=arguments.length;if(n<3){if(typeof type!==\"string\"){if(n<2)listener=false;for(capture in type){this.each(d3_selection_on(capture,type[capture],listener));}return this;}if(n<2)return(n=this.node()[\"__on\"+type])&&n._;capture=false;}return this.each(d3_selection_on(type,listener,capture));};function d3_selection_on(type,listener,capture){var name=\"__on\"+type,i=type.indexOf(\".\"),wrap=d3_selection_onListener;if(i>0)type=type.slice(0,i);var filter=d3_selection_onFilters.get(type);if(filter)type=filter,wrap=d3_selection_onFilter;function onRemove(){var l=this[name];if(l){this.removeEventListener(type,l,l.$);delete this[name];}}function onAdd(){var l=wrap(listener,d3_array(arguments));onRemove.call(this);this.addEventListener(type,this[name]=l,l.$=capture);l._=listener;}function removeAll(){var re=new RegExp(\"^__on([^.]+)\"+d3.requote(type)+\"$\"),match;for(var name in this){if(match=name.match(re)){var l=this[name];this.removeEventListener(match[1],l,l.$);delete this[name];}}}return i?listener?onAdd:onRemove:listener?d3_noop:removeAll;}var d3_selection_onFilters=d3.map({mouseenter:\"mouseover\",mouseleave:\"mouseout\"});if(d3_document){d3_selection_onFilters.forEach(function(k){if(\"on\"+k in d3_document)d3_selection_onFilters.remove(k);});}function d3_selection_onListener(listener,argumentz){return function(e){var o=d3.event;d3.event=e;argumentz[0]=this.__data__;try{listener.apply(this,argumentz);}finally{d3.event=o;}};}function d3_selection_onFilter(listener,argumentz){var l=d3_selection_onListener(listener,argumentz);return function(e){var target=this,related=e.relatedTarget;if(!related||related!==target&&!(related.compareDocumentPosition(target)&8)){l.call(target,e);}};}var d3_event_dragSelect,d3_event_dragId=0;function d3_event_dragSuppress(node){var name=\".dragsuppress-\"+ ++d3_event_dragId,click=\"click\"+name,w=d3.select(d3_window(node)).on(\"touchmove\"+name,d3_eventPreventDefault).on(\"dragstart\"+name,d3_eventPreventDefault).on(\"selectstart\"+name,d3_eventPreventDefault);if(d3_event_dragSelect==null){d3_event_dragSelect=\"onselectstart\"in node?false:d3_vendorSymbol(node.style,\"userSelect\");}if(d3_event_dragSelect){var style=d3_documentElement(node).style,select=style[d3_event_dragSelect];style[d3_event_dragSelect]=\"none\";}return function(suppressClick){w.on(name,null);if(d3_event_dragSelect)style[d3_event_dragSelect]=select;if(suppressClick){var off=function off(){w.on(click,null);};w.on(click,function(){d3_eventPreventDefault();off();},true);setTimeout(off,0);}};}d3.mouse=function(container){return d3_mousePoint(container,d3_eventSource());};var d3_mouse_bug44083=this.navigator&&/WebKit/.test(this.navigator.userAgent)?-1:0;function d3_mousePoint(container,e){if(e.changedTouches)e=e.changedTouches[0];var svg=container.ownerSVGElement||container;if(svg.createSVGPoint){var point=svg.createSVGPoint();if(d3_mouse_bug44083<0){var window=d3_window(container);if(window.scrollX||window.scrollY){svg=d3.select(\"body\").append(\"svg\").style({position:\"absolute\",top:0,left:0,margin:0,padding:0,border:\"none\"},\"important\");var ctm=svg[0][0].getScreenCTM();d3_mouse_bug44083=!(ctm.f||ctm.e);svg.remove();}}if(d3_mouse_bug44083)point.x=e.pageX,point.y=e.pageY;else point.x=e.clientX,point.y=e.clientY;point=point.matrixTransform(container.getScreenCTM().inverse());return[point.x,point.y];}var rect=container.getBoundingClientRect();return[e.clientX-rect.left-container.clientLeft,e.clientY-rect.top-container.clientTop];}d3.touch=function(container,touches,identifier){if(arguments.length<3)identifier=touches,touches=d3_eventSource().changedTouches;if(touches)for(var i=0,n=touches.length,touch;i<n;++i){if((touch=touches[i]).identifier===identifier){return d3_mousePoint(container,touch);}}};d3.behavior.drag=function(){var event=d3_eventDispatch(drag,\"drag\",\"dragstart\",\"dragend\"),origin=null,mousedown=dragstart(d3_noop,d3.mouse,d3_window,\"mousemove\",\"mouseup\"),touchstart=dragstart(d3_behavior_dragTouchId,d3.touch,d3_identity,\"touchmove\",\"touchend\");function drag(){this.on(\"mousedown.drag\",mousedown).on(\"touchstart.drag\",touchstart);}function dragstart(id,position,subject,move,end){return function(){var that=this,target=d3.event.target.correspondingElement||d3.event.target,parent=that.parentNode,dispatch=event.of(that,arguments),dragged=0,dragId=id(),dragName=\".drag\"+(dragId==null?\"\":\"-\"+dragId),dragOffset,dragSubject=d3.select(subject(target)).on(move+dragName,moved).on(end+dragName,ended),dragRestore=d3_event_dragSuppress(target),position0=position(parent,dragId);if(origin){dragOffset=origin.apply(that,arguments);dragOffset=[dragOffset.x-position0[0],dragOffset.y-position0[1]];}else{dragOffset=[0,0];}dispatch({type:\"dragstart\"});function moved(){var position1=position(parent,dragId),dx,dy;if(!position1)return;dx=position1[0]-position0[0];dy=position1[1]-position0[1];dragged|=dx|dy;position0=position1;dispatch({type:\"drag\",x:position1[0]+dragOffset[0],y:position1[1]+dragOffset[1],dx:dx,dy:dy});}function ended(){if(!position(parent,dragId))return;dragSubject.on(move+dragName,null).on(end+dragName,null);dragRestore(dragged);dispatch({type:\"dragend\"});}};}drag.origin=function(x){if(!arguments.length)return origin;origin=x;return drag;};return d3.rebind(drag,event,\"on\");};function d3_behavior_dragTouchId(){return d3.event.changedTouches[0].identifier;}d3.touches=function(container,touches){if(arguments.length<2)touches=d3_eventSource().touches;return touches?d3_array(touches).map(function(touch){var point=d3_mousePoint(container,touch);point.identifier=touch.identifier;return point;}):[];};var =1e-6,2=*,=Math.PI,=2*,=-,half=/2,d3_radians=/180,d3_degrees=180/;function d3_sgn(x){return x>0?1:x<0?-1:0;}function d3_cross2d(a,b,c){return(b[0]-a[0])*(c[1]-a[1])-(b[1]-a[1])*(c[0]-a[0]);}function d3_acos(x){return x>1?0:x<-1?:Math.acos(x);}function d3_asin(x){return x>1?half:x<-1?-half:Math.asin(x);}function d3_sinh(x){return((x=Math.exp(x))-1/x)/2;}function d3_cosh(x){return((x=Math.exp(x))+1/x)/2;}function d3_tanh(x){return((x=Math.exp(2*x))-1)/(x+1);}function d3_haversin(x){return(x=Math.sin(x/2))*x;}var =Math.SQRT2,2=2,4=4;d3.interpolateZoom=function(p0,p1){var ux0=p0[0],uy0=p0[1],w0=p0[2],ux1=p1[0],uy1=p1[1],w1=p1[2],dx=ux1-ux0,dy=uy1-uy0,d2=dx*dx+dy*dy,i,S;if(d2<2){S=Math.log(w1/w0)/;i=function i(t){return[ux0+t*dx,uy0+t*dy,w0*Math.exp(*t*S)];};}else{var d1=Math.sqrt(d2),b0=(w1*w1-w0*w0+4*d2)/(2*w0*2*d1),b1=(w1*w1-w0*w0-4*d2)/(2*w1*2*d1),r0=Math.log(Math.sqrt(b0*b0+1)-b0),r1=Math.log(Math.sqrt(b1*b1+1)-b1);S=(r1-r0)/;i=function i(t){var s=t*S,coshr0=d3_cosh(r0),u=w0/(2*d1)*(coshr0*d3_tanh(*s+r0)-d3_sinh(r0));return[ux0+u*dx,uy0+u*dy,w0*coshr0/d3_cosh(*s+r0)];};}i.duration=S*1e3;return i;};d3.behavior.zoom=function(){var view={x:0,y:0,k:1},translate0,center0,center,size=[960,500],scaleExtent=d3_behavior_zoomInfinity,duration=250,zooming=0,mousedown=\"mousedown.zoom\",mousemove=\"mousemove.zoom\",mouseup=\"mouseup.zoom\",mousewheelTimer,touchstart=\"touchstart.zoom\",touchtime,event=d3_eventDispatch(zoom,\"zoomstart\",\"zoom\",\"zoomend\"),x0,x1,y0,y1;if(!d3_behavior_zoomWheel){d3_behavior_zoomWheel=\"onwheel\"in d3_document?(d3_behavior_zoomDelta=function d3_behavior_zoomDelta(){return-d3.event.deltaY*(d3.event.deltaMode?120:1);},\"wheel\"):\"onmousewheel\"in d3_document?(d3_behavior_zoomDelta=function d3_behavior_zoomDelta(){return d3.event.wheelDelta;},\"mousewheel\"):(d3_behavior_zoomDelta=function d3_behavior_zoomDelta(){return-d3.event.detail;},\"MozMousePixelScroll\");}function zoom(g){g.on(mousedown,mousedowned).on(d3_behavior_zoomWheel+\".zoom\",mousewheeled).on(\"dblclick.zoom\",dblclicked).on(touchstart,touchstarted);}zoom.event=function(g){g.each(function(){var dispatch=event.of(this,arguments),view1=view;if(d3_transitionInheritId){d3.select(this).transition().each(\"start.zoom\",function(){view=this.__chart__||{x:0,y:0,k:1};zoomstarted(dispatch);}).tween(\"zoom:zoom\",function(){var dx=size[0],dy=size[1],cx=center0?center0[0]:dx/2,cy=center0?center0[1]:dy/2,i=d3.interpolateZoom([(cx-view.x)/view.k,(cy-view.y)/view.k,dx/view.k],[(cx-view1.x)/view1.k,(cy-view1.y)/view1.k,dx/view1.k]);return function(t){var l=i(t),k=dx/l[2];this.__chart__=view={x:cx-l[0]*k,y:cy-l[1]*k,k:k};zoomed(dispatch);};}).each(\"interrupt.zoom\",function(){zoomended(dispatch);}).each(\"end.zoom\",function(){zoomended(dispatch);});}else{this.__chart__=view;zoomstarted(dispatch);zoomed(dispatch);zoomended(dispatch);}});};zoom.translate=function(_){if(!arguments.length)return[view.x,view.y];view={x:+_[0],y:+_[1],k:view.k};rescale();return zoom;};zoom.scale=function(_){if(!arguments.length)return view.k;view={x:view.x,y:view.y,k:null};scaleTo(+_);rescale();return zoom;};zoom.scaleExtent=function(_){if(!arguments.length)return scaleExtent;scaleExtent=_==null?d3_behavior_zoomInfinity:[+_[0],+_[1]];return zoom;};zoom.center=function(_){if(!arguments.length)return center;center=_&&[+_[0],+_[1]];return zoom;};zoom.size=function(_){if(!arguments.length)return size;size=_&&[+_[0],+_[1]];return zoom;};zoom.duration=function(_){if(!arguments.length)return duration;duration=+_;return zoom;};zoom.x=function(z){if(!arguments.length)return x1;x1=z;x0=z.copy();view={x:0,y:0,k:1};return zoom;};zoom.y=function(z){if(!arguments.length)return y1;y1=z;y0=z.copy();view={x:0,y:0,k:1};return zoom;};function location(p){return[(p[0]-view.x)/view.k,(p[1]-view.y)/view.k];}function point(l){return[l[0]*view.k+view.x,l[1]*view.k+view.y];}function scaleTo(s){view.k=Math.max(scaleExtent[0],Math.min(scaleExtent[1],s));}function translateTo(p,l){l=point(l);view.x+=p[0]-l[0];view.y+=p[1]-l[1];}function zoomTo(that,p,l,k){that.__chart__={x:view.x,y:view.y,k:view.k};scaleTo(Math.pow(2,k));translateTo(center0=p,l);that=d3.select(that);if(duration>0)that=that.transition().duration(duration);that.call(zoom.event);}function rescale(){if(x1)x1.domain(x0.range().map(function(x){return(x-view.x)/view.k;}).map(x0.invert));if(y1)y1.domain(y0.range().map(function(y){return(y-view.y)/view.k;}).map(y0.invert));}function zoomstarted(dispatch){if(!zooming++)dispatch({type:\"zoomstart\"});}function zoomed(dispatch){rescale();dispatch({type:\"zoom\",scale:view.k,translate:[view.x,view.y]});}function zoomended(dispatch){if(! --zooming)dispatch({type:\"zoomend\"}),center0=null;}function mousedowned(){var that=this,dispatch=event.of(that,arguments),dragged=0,subject=d3.select(d3_window(that)).on(mousemove,moved).on(mouseup,ended),location0=location(d3.mouse(that)),dragRestore=d3_event_dragSuppress(that);d3_selection_interrupt.call(that);zoomstarted(dispatch);function moved(){dragged=1;translateTo(d3.mouse(that),location0);zoomed(dispatch);}function ended(){subject.on(mousemove,null).on(mouseup,null);dragRestore(dragged);zoomended(dispatch);}}function touchstarted(){var that=this,dispatch=event.of(that,arguments),locations0={},distance0=0,scale0,zoomName=\".zoom-\"+d3.event.changedTouches[0].identifier,touchmove=\"touchmove\"+zoomName,touchend=\"touchend\"+zoomName,targets=[],subject=d3.select(that),dragRestore=d3_event_dragSuppress(that);started();zoomstarted(dispatch);subject.on(mousedown,null).on(touchstart,started);function relocate(){var touches=d3.touches(that);scale0=view.k;touches.forEach(function(t){if(t.identifier in locations0)locations0[t.identifier]=location(t);});return touches;}function started(){var target=d3.event.target;d3.select(target).on(touchmove,moved).on(touchend,ended);targets.push(target);var changed=d3.event.changedTouches;for(var i=0,n=changed.length;i<n;++i){locations0[changed[i].identifier]=null;}var touches=relocate(),now=Date.now();if(touches.length===1){if(now-touchtime<500){var p=touches[0];zoomTo(that,p,locations0[p.identifier],Math.floor(Math.log(view.k)/Math.LN2)+1);d3_eventPreventDefault();}touchtime=now;}else if(touches.length>1){var p=touches[0],q=touches[1],dx=p[0]-q[0],dy=p[1]-q[1];distance0=dx*dx+dy*dy;}}function moved(){var touches=d3.touches(that),p0,l0,p1,l1;d3_selection_interrupt.call(that);for(var i=0,n=touches.length;i<n;++i,l1=null){p1=touches[i];if(l1=locations0[p1.identifier]){if(l0)break;p0=p1,l0=l1;}}if(l1){var distance1=(distance1=p1[0]-p0[0])*distance1+(distance1=p1[1]-p0[1])*distance1,scale1=distance0&&Math.sqrt(distance1/distance0);p0=[(p0[0]+p1[0])/2,(p0[1]+p1[1])/2];l0=[(l0[0]+l1[0])/2,(l0[1]+l1[1])/2];scaleTo(scale1*scale0);}touchtime=null;translateTo(p0,l0);zoomed(dispatch);}function ended(){if(d3.event.touches.length){var changed=d3.event.changedTouches;for(var i=0,n=changed.length;i<n;++i){delete locations0[changed[i].identifier];}for(var identifier in locations0){return void relocate();}}d3.selectAll(targets).on(zoomName,null);subject.on(mousedown,mousedowned).on(touchstart,touchstarted);dragRestore();zoomended(dispatch);}}function mousewheeled(){var dispatch=event.of(this,arguments);if(mousewheelTimer)clearTimeout(mousewheelTimer);else d3_selection_interrupt.call(this),translate0=location(center0=center||d3.mouse(this)),zoomstarted(dispatch);mousewheelTimer=setTimeout(function(){mousewheelTimer=null;zoomended(dispatch);},50);d3_eventPreventDefault();scaleTo(Math.pow(2,d3_behavior_zoomDelta()*.002)*view.k);translateTo(center0,translate0);zoomed(dispatch);}function dblclicked(){var p=d3.mouse(this),k=Math.log(view.k)/Math.LN2;zoomTo(this,p,location(p),d3.event.shiftKey?Math.ceil(k)-1:Math.floor(k)+1);}return d3.rebind(zoom,event,\"on\");};var d3_behavior_zoomInfinity=[0,Infinity],d3_behavior_zoomDelta,d3_behavior_zoomWheel;d3.color=d3_color;function d3_color(){}d3_color.prototype.toString=function(){return this.rgb()+\"\";};d3.hsl=d3_hsl;function d3_hsl(h,s,l){return this instanceof d3_hsl?void(this.h=+h,this.s=+s,this.l=+l):arguments.length<2?h instanceof d3_hsl?new d3_hsl(h.h,h.s,h.l):d3_rgb_parse(\"\"+h,d3_rgb_hsl,d3_hsl):new d3_hsl(h,s,l);}var d3_hslPrototype=d3_hsl.prototype=new d3_color();d3_hslPrototype.brighter=function(k){k=Math.pow(.7,arguments.length?k:1);return new d3_hsl(this.h,this.s,this.l/k);};d3_hslPrototype.darker=function(k){k=Math.pow(.7,arguments.length?k:1);return new d3_hsl(this.h,this.s,k*this.l);};d3_hslPrototype.rgb=function(){return d3_hsl_rgb(this.h,this.s,this.l);};function d3_hsl_rgb(h,s,l){var m1,m2;h=isNaN(h)?0:(h%=360)<0?h+360:h;s=isNaN(s)?0:s<0?0:s>1?1:s;l=l<0?0:l>1?1:l;m2=l<=.5?l*(1+s):l+s-l*s;m1=2*l-m2;function v(h){if(h>360)h-=360;else if(h<0)h+=360;if(h<60)return m1+(m2-m1)*h/60;if(h<180)return m2;if(h<240)return m1+(m2-m1)*(240-h)/60;return m1;}function vv(h){return Math.round(v(h)*255);}return new d3_rgb(vv(h+120),vv(h),vv(h-120));}d3.hcl=d3_hcl;function d3_hcl(h,c,l){return this instanceof d3_hcl?void(this.h=+h,this.c=+c,this.l=+l):arguments.length<2?h instanceof d3_hcl?new d3_hcl(h.h,h.c,h.l):h instanceof d3_lab?d3_lab_hcl(h.l,h.a,h.b):d3_lab_hcl((h=d3_rgb_lab((h=d3.rgb(h)).r,h.g,h.b)).l,h.a,h.b):new d3_hcl(h,c,l);}var d3_hclPrototype=d3_hcl.prototype=new d3_color();d3_hclPrototype.brighter=function(k){return new d3_hcl(this.h,this.c,Math.min(100,this.l+d3_lab_K*(arguments.length?k:1)));};d3_hclPrototype.darker=function(k){return new d3_hcl(this.h,this.c,Math.max(0,this.l-d3_lab_K*(arguments.length?k:1)));};d3_hclPrototype.rgb=function(){return d3_hcl_lab(this.h,this.c,this.l).rgb();};function d3_hcl_lab(h,c,l){if(isNaN(h))h=0;if(isNaN(c))c=0;return new d3_lab(l,Math.cos(h*=d3_radians)*c,Math.sin(h)*c);}d3.lab=d3_lab;function d3_lab(l,a,b){return this instanceof d3_lab?void(this.l=+l,this.a=+a,this.b=+b):arguments.length<2?l instanceof d3_lab?new d3_lab(l.l,l.a,l.b):l instanceof d3_hcl?d3_hcl_lab(l.h,l.c,l.l):d3_rgb_lab((l=d3_rgb(l)).r,l.g,l.b):new d3_lab(l,a,b);}var d3_lab_K=18;var d3_lab_X=.95047,d3_lab_Y=1,d3_lab_Z=1.08883;var d3_labPrototype=d3_lab.prototype=new d3_color();d3_labPrototype.brighter=function(k){return new d3_lab(Math.min(100,this.l+d3_lab_K*(arguments.length?k:1)),this.a,this.b);};d3_labPrototype.darker=function(k){return new d3_lab(Math.max(0,this.l-d3_lab_K*(arguments.length?k:1)),this.a,this.b);};d3_labPrototype.rgb=function(){return d3_lab_rgb(this.l,this.a,this.b);};function d3_lab_rgb(l,a,b){var y=(l+16)/116,x=y+a/500,z=y-b/200;x=d3_lab_xyz(x)*d3_lab_X;y=d3_lab_xyz(y)*d3_lab_Y;z=d3_lab_xyz(z)*d3_lab_Z;return new d3_rgb(d3_xyz_rgb(3.2404542*x-1.5371385*y-.4985314*z),d3_xyz_rgb(-.969266*x+1.8760108*y+.041556*z),d3_xyz_rgb(.0556434*x-.2040259*y+1.0572252*z));}function d3_lab_hcl(l,a,b){return l>0?new d3_hcl(Math.atan2(b,a)*d3_degrees,Math.sqrt(a*a+b*b),l):new d3_hcl(NaN,NaN,l);}function d3_lab_xyz(x){return x>.206893034?x*x*x:(x-4/29)/7.787037;}function d3_xyz_lab(x){return x>.008856?Math.pow(x,1/3):7.787037*x+4/29;}function d3_xyz_rgb(r){return Math.round(255*(r<=.00304?12.92*r:1.055*Math.pow(r,1/2.4)-.055));}d3.rgb=d3_rgb;function d3_rgb(r,g,b){return this instanceof d3_rgb?void(this.r=~~r,this.g=~~g,this.b=~~b):arguments.length<2?r instanceof d3_rgb?new d3_rgb(r.r,r.g,r.b):d3_rgb_parse(\"\"+r,d3_rgb,d3_hsl_rgb):new d3_rgb(r,g,b);}function d3_rgbNumber(value){return new d3_rgb(value>>16,value>>8&255,value&255);}function d3_rgbString(value){return d3_rgbNumber(value)+\"\";}var d3_rgbPrototype=d3_rgb.prototype=new d3_color();d3_rgbPrototype.brighter=function(k){k=Math.pow(.7,arguments.length?k:1);var r=this.r,g=this.g,b=this.b,i=30;if(!r&&!g&&!b)return new d3_rgb(i,i,i);if(r&&r<i)r=i;if(g&&g<i)g=i;if(b&&b<i)b=i;return new d3_rgb(Math.min(255,r/k),Math.min(255,g/k),Math.min(255,b/k));};d3_rgbPrototype.darker=function(k){k=Math.pow(.7,arguments.length?k:1);return new d3_rgb(k*this.r,k*this.g,k*this.b);};d3_rgbPrototype.hsl=function(){return d3_rgb_hsl(this.r,this.g,this.b);};d3_rgbPrototype.toString=function(){return\"#\"+d3_rgb_hex(this.r)+d3_rgb_hex(this.g)+d3_rgb_hex(this.b);};function d3_rgb_hex(v){return v<16?\"0\"+Math.max(0,v).toString(16):Math.min(255,v).toString(16);}function d3_rgb_parse(format,rgb,hsl){var r=0,g=0,b=0,m1,m2,color;m1=/([a-z]+)\\((.*)\\)/.exec(format=format.toLowerCase());if(m1){m2=m1[2].split(\",\");switch(m1[1]){case\"hsl\":{return hsl(parseFloat(m2[0]),parseFloat(m2[1])/100,parseFloat(m2[2])/100);}case\"rgb\":{return rgb(d3_rgb_parseNumber(m2[0]),d3_rgb_parseNumber(m2[1]),d3_rgb_parseNumber(m2[2]));}}}if(color=d3_rgb_names.get(format)){return rgb(color.r,color.g,color.b);}if(format!=null&&format.charAt(0)===\"#\"&&!isNaN(color=parseInt(format.slice(1),16))){if(format.length===4){r=(color&3840)>>4;r=r>>4|r;g=color&240;g=g>>4|g;b=color&15;b=b<<4|b;}else if(format.length===7){r=(color&16711680)>>16;g=(color&65280)>>8;b=color&255;}}return rgb(r,g,b);}function d3_rgb_hsl(r,g,b){var min=Math.min(r/=255,g/=255,b/=255),max=Math.max(r,g,b),d=max-min,h,s,l=(max+min)/2;if(d){s=l<.5?d/(max+min):d/(2-max-min);if(r==max)h=(g-b)/d+(g<b?6:0);else if(g==max)h=(b-r)/d+2;else h=(r-g)/d+4;h*=60;}else{h=NaN;s=l>0&&l<1?0:h;}return new d3_hsl(h,s,l);}function d3_rgb_lab(r,g,b){r=d3_rgb_xyz(r);g=d3_rgb_xyz(g);b=d3_rgb_xyz(b);var x=d3_xyz_lab((.4124564*r+.3575761*g+.1804375*b)/d3_lab_X),y=d3_xyz_lab((.2126729*r+.7151522*g+.072175*b)/d3_lab_Y),z=d3_xyz_lab((.0193339*r+.119192*g+.9503041*b)/d3_lab_Z);return d3_lab(116*y-16,500*(x-y),200*(y-z));}function d3_rgb_xyz(r){return(r/=255)<=.04045?r/12.92:Math.pow((r+.055)/1.055,2.4);}function d3_rgb_parseNumber(c){var f=parseFloat(c);return c.charAt(c.length-1)===\"%\"?Math.round(f*2.55):f;}var d3_rgb_names=d3.map({aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074});d3_rgb_names.forEach(function(key,value){d3_rgb_names.set(key,d3_rgbNumber(value));});function d3_functor(v){return typeof v===\"function\"?v:function(){return v;};}d3.functor=d3_functor;d3.xhr=d3_xhrType(d3_identity);function d3_xhrType(response){return function(url,mimeType,callback){if(arguments.length===2&&typeof mimeType===\"function\")callback=mimeType,mimeType=null;return d3_xhr(url,mimeType,response,callback);};}function d3_xhr(url,mimeType,response,callback){var xhr={},dispatch=d3.dispatch(\"beforesend\",\"progress\",\"load\",\"error\"),headers={},request=new XMLHttpRequest(),responseType=null;if(this.XDomainRequest&&!(\"withCredentials\"in request)&&/^(http(s)?:)?\\/\\//.test(url))request=new XDomainRequest();\"onload\"in request?request.onload=request.onerror=respond:request.onreadystatechange=function(){request.readyState>3&&respond();};function respond(){var status=request.status,result;if(!status&&d3_xhrHasResponse(request)||status>=200&&status<300||status===304){try{result=response.call(xhr,request);}catch(e){dispatch.error.call(xhr,e);return;}dispatch.load.call(xhr,result);}else{dispatch.error.call(xhr,request);}}request.onprogress=function(event){var o=d3.event;d3.event=event;try{dispatch.progress.call(xhr,request);}finally{d3.event=o;}};xhr.header=function(name,value){name=(name+\"\").toLowerCase();if(arguments.length<2)return headers[name];if(value==null)delete headers[name];else headers[name]=value+\"\";return xhr;};xhr.mimeType=function(value){if(!arguments.length)return mimeType;mimeType=value==null?null:value+\"\";return xhr;};xhr.responseType=function(value){if(!arguments.length)return responseType;responseType=value;return xhr;};xhr.response=function(value){response=value;return xhr;};[\"get\",\"post\"].forEach(function(method){xhr[method]=function(){return xhr.send.apply(xhr,[method].concat(d3_array(arguments)));};});xhr.send=function(method,data,callback){if(arguments.length===2&&typeof data===\"function\")callback=data,data=null;request.open(method,url,true);if(mimeType!=null&&!(\"accept\"in headers))headers[\"accept\"]=mimeType+\",*/*\";if(request.setRequestHeader)for(var name in headers){request.setRequestHeader(name,headers[name]);}if(mimeType!=null&&request.overrideMimeType)request.overrideMimeType(mimeType);if(responseType!=null)request.responseType=responseType;if(callback!=null)xhr.on(\"error\",callback).on(\"load\",function(request){callback(null,request);});dispatch.beforesend.call(xhr,request);request.send(data==null?null:data);return xhr;};xhr.abort=function(){request.abort();return xhr;};d3.rebind(xhr,dispatch,\"on\");return callback==null?xhr:xhr.get(d3_xhr_fixCallback(callback));}function d3_xhr_fixCallback(callback){return callback.length===1?function(error,request){callback(error==null?request:null);}:callback;}function d3_xhrHasResponse(request){var type=request.responseType;return type&&type!==\"text\"?request.response:request.responseText;}d3.dsv=function(delimiter,mimeType){var reFormat=new RegExp('[\"'+delimiter+\"\\n]\"),delimiterCode=delimiter.charCodeAt(0);function dsv(url,row,callback){if(arguments.length<3)callback=row,row=null;var xhr=d3_xhr(url,mimeType,row==null?response:typedResponse(row),callback);xhr.row=function(_){return arguments.length?xhr.response((row=_)==null?response:typedResponse(_)):row;};return xhr;}function response(request){return dsv.parse(request.responseText);}function typedResponse(f){return function(request){return dsv.parse(request.responseText,f);};}dsv.parse=function(text,f){var o;return dsv.parseRows(text,function(row,i){if(o)return o(row,i-1);var a=new Function(\"d\",\"return {\"+row.map(function(name,i){return JSON.stringify(name)+\": d[\"+i+\"]\";}).join(\",\")+\"}\");o=f?function(row,i){return f(a(row),i);}:a;});};dsv.parseRows=function(text,f){var EOL={},EOF={},rows=[],N=text.length,I=0,n=0,t,eol;function token(){if(I>=N)return EOF;if(eol)return eol=false,EOL;var j=I;if(text.charCodeAt(j)===34){var i=j;while(i++<N){if(text.charCodeAt(i)===34){if(text.charCodeAt(i+1)!==34)break;++i;}}I=i+2;var c=text.charCodeAt(i+1);if(c===13){eol=true;if(text.charCodeAt(i+2)===10)++I;}else if(c===10){eol=true;}return text.slice(j+1,i).replace(/\"\"/g,'\"');}while(I<N){var c=text.charCodeAt(I++),k=1;if(c===10)eol=true;else if(c===13){eol=true;if(text.charCodeAt(I)===10)++I,++k;}else if(c!==delimiterCode)continue;return text.slice(j,I-k);}return text.slice(j);}while((t=token())!==EOF){var a=[];while(t!==EOL&&t!==EOF){a.push(t);t=token();}if(f&&(a=f(a,n++))==null)continue;rows.push(a);}return rows;};dsv.format=function(rows){if(Array.isArray(rows[0]))return dsv.formatRows(rows);var fieldSet=new d3_Set(),fields=[];rows.forEach(function(row){for(var field in row){if(!fieldSet.has(field)){fields.push(fieldSet.add(field));}}});return[fields.map(formatValue).join(delimiter)].concat(rows.map(function(row){return fields.map(function(field){return formatValue(row[field]);}).join(delimiter);})).join(\"\\n\");};dsv.formatRows=function(rows){return rows.map(formatRow).join(\"\\n\");};function formatRow(row){return row.map(formatValue).join(delimiter);}function formatValue(text){return reFormat.test(text)?'\"'+text.replace(/\\\"/g,'\"\"')+'\"':text;}return dsv;};d3.csv=d3.dsv(\",\",\"text/csv\");d3.tsv=d3.dsv(\"\t\",\"text/tab-separated-values\");var d3_timer_queueHead,d3_timer_queueTail,d3_timer_interval,d3_timer_timeout,d3_timer_frame=this[d3_vendorSymbol(this,\"requestAnimationFrame\")]||function(callback){setTimeout(callback,17);};d3.timer=function(){d3_timer.apply(this,arguments);};function d3_timer(callback,delay,then){var n=arguments.length;if(n<2)delay=0;if(n<3)then=Date.now();var time=then+delay,timer={c:callback,t:time,n:null};if(d3_timer_queueTail)d3_timer_queueTail.n=timer;else d3_timer_queueHead=timer;d3_timer_queueTail=timer;if(!d3_timer_interval){d3_timer_timeout=clearTimeout(d3_timer_timeout);d3_timer_interval=1;d3_timer_frame(d3_timer_step);}return timer;}function d3_timer_step(){var now=d3_timer_mark(),delay=d3_timer_sweep()-now;if(delay>24){if(isFinite(delay)){clearTimeout(d3_timer_timeout);d3_timer_timeout=setTimeout(d3_timer_step,delay);}d3_timer_interval=0;}else{d3_timer_interval=1;d3_timer_frame(d3_timer_step);}}d3.timer.flush=function(){d3_timer_mark();d3_timer_sweep();};function d3_timer_mark(){var now=Date.now(),timer=d3_timer_queueHead;while(timer){if(now>=timer.t&&timer.c(now-timer.t))timer.c=null;timer=timer.n;}return now;}function d3_timer_sweep(){var t0,t1=d3_timer_queueHead,time=Infinity;while(t1){if(t1.c){if(t1.t<time)time=t1.t;t1=(t0=t1).n;}else{t1=t0?t0.n=t1.n:d3_timer_queueHead=t1.n;}}d3_timer_queueTail=t0;return time;}function d3_format_precision(x,p){return p-(x?Math.ceil(Math.log(x)/Math.LN10):1);}d3.round=function(x,n){return n?Math.round(x*(n=Math.pow(10,n)))/n:Math.round(x);};var d3_formatPrefixes=[\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"].map(d3_formatPrefix);d3.formatPrefix=function(value,precision){var i=0;if(value=+value){if(value<0)value*=-1;if(precision)value=d3.round(value,d3_format_precision(value,precision));i=1+Math.floor(1e-12+Math.log(value)/Math.LN10);i=Math.max(-24,Math.min(24,Math.floor((i-1)/3)*3));}return d3_formatPrefixes[8+i/3];};function d3_formatPrefix(d,i){var k=Math.pow(10,abs(8-i)*3);return{scale:i>8?function(d){return d/k;}:function(d){return d*k;},symbol:d};}function d3_locale_numberFormat(locale){var locale_decimal=locale.decimal,locale_thousands=locale.thousands,locale_grouping=locale.grouping,locale_currency=locale.currency,formatGroup=locale_grouping&&locale_thousands?function(value,width){var i=value.length,t=[],j=0,g=locale_grouping[0],length=0;while(i>0&&g>0){if(length+g+1>width)g=Math.max(1,width-length);t.push(value.substring(i-=g,i+g));if((length+=g+1)>width)break;g=locale_grouping[j=(j+1)%locale_grouping.length];}return t.reverse().join(locale_thousands);}:d3_identity;return function(specifier){var match=d3_format_re.exec(specifier),fill=match[1]||\" \",align=match[2]||\">\",sign=match[3]||\"-\",symbol=match[4]||\"\",zfill=match[5],width=+match[6],comma=match[7],precision=match[8],type=match[9],scale=1,prefix=\"\",suffix=\"\",integer=false,exponent=true;if(precision)precision=+precision.substring(1);if(zfill||fill===\"0\"&&align===\"=\"){zfill=fill=\"0\";align=\"=\";}switch(type){case\"n\":comma=true;type=\"g\";break;case\"%\":scale=100;suffix=\"%\";type=\"f\";break;case\"p\":scale=100;suffix=\"%\";type=\"r\";break;case\"b\":case\"o\":case\"x\":case\"X\":if(symbol===\"#\")prefix=\"0\"+type.toLowerCase();case\"c\":exponent=false;case\"d\":integer=true;precision=0;break;case\"s\":scale=-1;type=\"r\";break;}if(symbol===\"$\")prefix=locale_currency[0],suffix=locale_currency[1];if(type==\"r\"&&!precision)type=\"g\";if(precision!=null){if(type==\"g\")precision=Math.max(1,Math.min(21,precision));else if(type==\"e\"||type==\"f\")precision=Math.max(0,Math.min(20,precision));}type=d3_format_types.get(type)||d3_format_typeDefault;var zcomma=zfill&&comma;return function(value){var fullSuffix=suffix;if(integer&&value%1)return\"\";var negative=value<0||value===0&&1/value<0?(value=-value,\"-\"):sign===\"-\"?\"\":sign;if(scale<0){var unit=d3.formatPrefix(value,precision);value=unit.scale(value);fullSuffix=unit.symbol+suffix;}else{value*=scale;}value=type(value,precision);var i=value.lastIndexOf(\".\"),before,after;if(i<0){var j=exponent?value.lastIndexOf(\"e\"):-1;if(j<0)before=value,after=\"\";else before=value.substring(0,j),after=value.substring(j);}else{before=value.substring(0,i);after=locale_decimal+value.substring(i+1);}if(!zfill&&comma)before=formatGroup(before,Infinity);var length=prefix.length+before.length+after.length+(zcomma?0:negative.length),padding=length<width?new Array(length=width-length+1).join(fill):\"\";if(zcomma)before=formatGroup(padding+before,padding.length?width-after.length:Infinity);negative+=prefix;value=before+after;return(align===\"<\"?negative+value+padding:align===\">\"?padding+negative+value:align===\"^\"?padding.substring(0,length>>=1)+negative+value+padding.substring(length):negative+(zcomma?value:padding+value))+fullSuffix;};};}var d3_format_re=/(?:([^{])?([<>=^]))?([+\\- ])?([$#])?(0)?(\\d+)?(,)?(\\.-?\\d+)?([a-z%])?/i;var d3_format_types=d3.map({b:function b(x){return x.toString(2);},c:function c(x){return String.fromCharCode(x);},o:function o(x){return x.toString(8);},x:function x(_x2){return _x2.toString(16);},X:function X(x){return x.toString(16).toUpperCase();},g:function g(x,p){return x.toPrecision(p);},e:function e(x,p){return x.toExponential(p);},f:function f(x,p){return x.toFixed(p);},r:function r(x,p){return(x=d3.round(x,d3_format_precision(x,p))).toFixed(Math.max(0,Math.min(20,d3_format_precision(x*(1+1e-15),p))));}});function d3_format_typeDefault(x){return x+\"\";}var d3_time=d3.time={},d3_date=Date;function d3_date_utc(){this._=new Date(arguments.length>1?Date.UTC.apply(this,arguments):arguments[0]);}d3_date_utc.prototype={getDate:function getDate(){return this._.getUTCDate();},getDay:function getDay(){return this._.getUTCDay();},getFullYear:function getFullYear(){return this._.getUTCFullYear();},getHours:function getHours(){return this._.getUTCHours();},getMilliseconds:function getMilliseconds(){return this._.getUTCMilliseconds();},getMinutes:function getMinutes(){return this._.getUTCMinutes();},getMonth:function getMonth(){return this._.getUTCMonth();},getSeconds:function getSeconds(){return this._.getUTCSeconds();},getTime:function getTime(){return this._.getTime();},getTimezoneOffset:function getTimezoneOffset(){return 0;},valueOf:function valueOf(){return this._.valueOf();},setDate:function setDate(){d3_time_prototype.setUTCDate.apply(this._,arguments);},setDay:function setDay(){d3_time_prototype.setUTCDay.apply(this._,arguments);},setFullYear:function setFullYear(){d3_time_prototype.setUTCFullYear.apply(this._,arguments);},setHours:function setHours(){d3_time_prototype.setUTCHours.apply(this._,arguments);},setMilliseconds:function setMilliseconds(){d3_time_prototype.setUTCMilliseconds.apply(this._,arguments);},setMinutes:function setMinutes(){d3_time_prototype.setUTCMinutes.apply(this._,arguments);},setMonth:function setMonth(){d3_time_prototype.setUTCMonth.apply(this._,arguments);},setSeconds:function setSeconds(){d3_time_prototype.setUTCSeconds.apply(this._,arguments);},setTime:function setTime(){d3_time_prototype.setTime.apply(this._,arguments);}};var d3_time_prototype=Date.prototype;function d3_time_interval(local,step,number){function round(date){var d0=local(date),d1=offset(d0,1);return date-d0<d1-date?d0:d1;}function ceil(date){step(date=local(new d3_date(date-1)),1);return date;}function offset(date,k){step(date=new d3_date(+date),k);return date;}function range(t0,t1,dt){var time=ceil(t0),times=[];if(dt>1){while(time<t1){if(!(number(time)%dt))times.push(new Date(+time));step(time,1);}}else{while(time<t1){times.push(new Date(+time)),step(time,1);}}return times;}function range_utc(t0,t1,dt){try{d3_date=d3_date_utc;var utc=new d3_date_utc();utc._=t0;return range(utc,t1,dt);}finally{d3_date=Date;}}local.floor=local;local.round=round;local.ceil=ceil;local.offset=offset;local.range=range;var utc=local.utc=d3_time_interval_utc(local);utc.floor=utc;utc.round=d3_time_interval_utc(round);utc.ceil=d3_time_interval_utc(ceil);utc.offset=d3_time_interval_utc(offset);utc.range=range_utc;return local;}function d3_time_interval_utc(method){return function(date,k){try{d3_date=d3_date_utc;var utc=new d3_date_utc();utc._=date;return method(utc,k)._;}finally{d3_date=Date;}};}d3_time.year=d3_time_interval(function(date){date=d3_time.day(date);date.setMonth(0,1);return date;},function(date,offset){date.setFullYear(date.getFullYear()+offset);},function(date){return date.getFullYear();});d3_time.years=d3_time.year.range;d3_time.years.utc=d3_time.year.utc.range;d3_time.day=d3_time_interval(function(date){var day=new d3_date(2e3,0);day.setFullYear(date.getFullYear(),date.getMonth(),date.getDate());return day;},function(date,offset){date.setDate(date.getDate()+offset);},function(date){return date.getDate()-1;});d3_time.days=d3_time.day.range;d3_time.days.utc=d3_time.day.utc.range;d3_time.dayOfYear=function(date){var year=d3_time.year(date);return Math.floor((date-year-(date.getTimezoneOffset()-year.getTimezoneOffset())*6e4)/864e5);};[\"sunday\",\"monday\",\"tuesday\",\"wednesday\",\"thursday\",\"friday\",\"saturday\"].forEach(function(day,i){i=7-i;var interval=d3_time[day]=d3_time_interval(function(date){(date=d3_time.day(date)).setDate(date.getDate()-(date.getDay()+i)%7);return date;},function(date,offset){date.setDate(date.getDate()+Math.floor(offset)*7);},function(date){var day=d3_time.year(date).getDay();return Math.floor((d3_time.dayOfYear(date)+(day+i)%7)/7)-(day!==i);});d3_time[day+\"s\"]=interval.range;d3_time[day+\"s\"].utc=interval.utc.range;d3_time[day+\"OfYear\"]=function(date){var day=d3_time.year(date).getDay();return Math.floor((d3_time.dayOfYear(date)+(day+i)%7)/7);};});d3_time.week=d3_time.sunday;d3_time.weeks=d3_time.sunday.range;d3_time.weeks.utc=d3_time.sunday.utc.range;d3_time.weekOfYear=d3_time.sundayOfYear;function d3_locale_timeFormat(locale){var locale_dateTime=locale.dateTime,locale_date=locale.date,locale_time=locale.time,locale_periods=locale.periods,locale_days=locale.days,locale_shortDays=locale.shortDays,locale_months=locale.months,locale_shortMonths=locale.shortMonths;function d3_time_format(template){var n=template.length;function format(date){var string=[],i=-1,j=0,c,p,f;while(++i<n){if(template.charCodeAt(i)===37){string.push(template.slice(j,i));if((p=d3_time_formatPads[c=template.charAt(++i)])!=null)c=template.charAt(++i);if(f=d3_time_formats[c])c=f(date,p==null?c===\"e\"?\" \":\"0\":p);string.push(c);j=i+1;}}string.push(template.slice(j,i));return string.join(\"\");}format.parse=function(string){var d={y:1900,m:0,d:1,H:0,M:0,S:0,L:0,Z:null},i=d3_time_parse(d,template,string,0);if(i!=string.length)return null;if(\"p\"in d)d.H=d.H%12+d.p*12;var localZ=d.Z!=null&&d3_date!==d3_date_utc,date=new(localZ?d3_date_utc:d3_date)();if(\"j\"in d)date.setFullYear(d.y,0,d.j);else if(\"W\"in d||\"U\"in d){if(!(\"w\"in d))d.w=\"W\"in d?1:0;date.setFullYear(d.y,0,1);date.setFullYear(d.y,0,\"W\"in d?(d.w+6)%7+d.W*7-(date.getDay()+5)%7:d.w+d.U*7-(date.getDay()+6)%7);}else date.setFullYear(d.y,d.m,d.d);date.setHours(d.H+(d.Z/100|0),d.M+d.Z%100,d.S,d.L);return localZ?date._:date;};format.toString=function(){return template;};return format;}function d3_time_parse(date,template,string,j){var c,p,t,i=0,n=template.length,m=string.length;while(i<n){if(j>=m)return-1;c=template.charCodeAt(i++);if(c===37){t=template.charAt(i++);p=d3_time_parsers[t in d3_time_formatPads?template.charAt(i++):t];if(!p||(j=p(date,string,j))<0)return-1;}else if(c!=string.charCodeAt(j++)){return-1;}}return j;}d3_time_format.utc=function(template){var local=d3_time_format(template);function format(date){try{d3_date=d3_date_utc;var utc=new d3_date();utc._=date;return local(utc);}finally{d3_date=Date;}}format.parse=function(string){try{d3_date=d3_date_utc;var date=local.parse(string);return date&&date._;}finally{d3_date=Date;}};format.toString=local.toString;return format;};d3_time_format.multi=d3_time_format.utc.multi=d3_time_formatMulti;var d3_time_periodLookup=d3.map(),d3_time_dayRe=d3_time_formatRe(locale_days),d3_time_dayLookup=d3_time_formatLookup(locale_days),d3_time_dayAbbrevRe=d3_time_formatRe(locale_shortDays),d3_time_dayAbbrevLookup=d3_time_formatLookup(locale_shortDays),d3_time_monthRe=d3_time_formatRe(locale_months),d3_time_monthLookup=d3_time_formatLookup(locale_months),d3_time_monthAbbrevRe=d3_time_formatRe(locale_shortMonths),d3_time_monthAbbrevLookup=d3_time_formatLookup(locale_shortMonths);locale_periods.forEach(function(p,i){d3_time_periodLookup.set(p.toLowerCase(),i);});var d3_time_formats={a:function a(d){return locale_shortDays[d.getDay()];},A:function A(d){return locale_days[d.getDay()];},b:function b(d){return locale_shortMonths[d.getMonth()];},B:function B(d){return locale_months[d.getMonth()];},c:d3_time_format(locale_dateTime),d:function d(_d,p){return d3_time_formatPad(_d.getDate(),p,2);},e:function e(d,p){return d3_time_formatPad(d.getDate(),p,2);},H:function H(d,p){return d3_time_formatPad(d.getHours(),p,2);},I:function I(d,p){return d3_time_formatPad(d.getHours()%12||12,p,2);},j:function j(d,p){return d3_time_formatPad(1+d3_time.dayOfYear(d),p,3);},L:function L(d,p){return d3_time_formatPad(d.getMilliseconds(),p,3);},m:function m(d,p){return d3_time_formatPad(d.getMonth()+1,p,2);},M:function M(d,p){return d3_time_formatPad(d.getMinutes(),p,2);},p:function p(d){return locale_periods[+(d.getHours()>=12)];},S:function S(d,p){return d3_time_formatPad(d.getSeconds(),p,2);},U:function U(d,p){return d3_time_formatPad(d3_time.sundayOfYear(d),p,2);},w:function w(d){return d.getDay();},W:function W(d,p){return d3_time_formatPad(d3_time.mondayOfYear(d),p,2);},x:d3_time_format(locale_date),X:d3_time_format(locale_time),y:function y(d,p){return d3_time_formatPad(d.getFullYear()%100,p,2);},Y:function Y(d,p){return d3_time_formatPad(d.getFullYear()%1e4,p,4);},Z:d3_time_zone,\"%\":function _(){return\"%\";}};var d3_time_parsers={a:d3_time_parseWeekdayAbbrev,A:d3_time_parseWeekday,b:d3_time_parseMonthAbbrev,B:d3_time_parseMonth,c:d3_time_parseLocaleFull,d:d3_time_parseDay,e:d3_time_parseDay,H:d3_time_parseHour24,I:d3_time_parseHour24,j:d3_time_parseDayOfYear,L:d3_time_parseMilliseconds,m:d3_time_parseMonthNumber,M:d3_time_parseMinutes,p:d3_time_parseAmPm,S:d3_time_parseSeconds,U:d3_time_parseWeekNumberSunday,w:d3_time_parseWeekdayNumber,W:d3_time_parseWeekNumberMonday,x:d3_time_parseLocaleDate,X:d3_time_parseLocaleTime,y:d3_time_parseYear,Y:d3_time_parseFullYear,Z:d3_time_parseZone,\"%\":d3_time_parseLiteralPercent};function d3_time_parseWeekdayAbbrev(date,string,i){d3_time_dayAbbrevRe.lastIndex=0;var n=d3_time_dayAbbrevRe.exec(string.slice(i));return n?(date.w=d3_time_dayAbbrevLookup.get(n[0].toLowerCase()),i+n[0].length):-1;}function d3_time_parseWeekday(date,string,i){d3_time_dayRe.lastIndex=0;var n=d3_time_dayRe.exec(string.slice(i));return n?(date.w=d3_time_dayLookup.get(n[0].toLowerCase()),i+n[0].length):-1;}function d3_time_parseMonthAbbrev(date,string,i){d3_time_monthAbbrevRe.lastIndex=0;var n=d3_time_monthAbbrevRe.exec(string.slice(i));return n?(date.m=d3_time_monthAbbrevLookup.get(n[0].toLowerCase()),i+n[0].length):-1;}function d3_time_parseMonth(date,string,i){d3_time_monthRe.lastIndex=0;var n=d3_time_monthRe.exec(string.slice(i));return n?(date.m=d3_time_monthLookup.get(n[0].toLowerCase()),i+n[0].length):-1;}function d3_time_parseLocaleFull(date,string,i){return d3_time_parse(date,d3_time_formats.c.toString(),string,i);}function d3_time_parseLocaleDate(date,string,i){return d3_time_parse(date,d3_time_formats.x.toString(),string,i);}function d3_time_parseLocaleTime(date,string,i){return d3_time_parse(date,d3_time_formats.X.toString(),string,i);}function d3_time_parseAmPm(date,string,i){var n=d3_time_periodLookup.get(string.slice(i,i+=2).toLowerCase());return n==null?-1:(date.p=n,i);}return d3_time_format;}var d3_time_formatPads={\"-\":\"\",_:\" \",\"0\":\"0\"},d3_time_numberRe=/^\\s*\\d+/,d3_time_percentRe=/^%/;function d3_time_formatPad(value,fill,width){var sign=value<0?\"-\":\"\",string=(sign?-value:value)+\"\",length=string.length;return sign+(length<width?new Array(width-length+1).join(fill)+string:string);}function d3_time_formatRe(names){return new RegExp(\"^(?:\"+names.map(d3.requote).join(\"|\")+\")\",\"i\");}function d3_time_formatLookup(names){var map=new d3_Map(),i=-1,n=names.length;while(++i<n){map.set(names[i].toLowerCase(),i);}return map;}function d3_time_parseWeekdayNumber(date,string,i){d3_time_numberRe.lastIndex=0;var n=d3_time_numberRe.exec(string.slice(i,i+1));return n?(date.w=+n[0],i+n[0].length):-1;}function d3_time_parseWeekNumberSunday(date,string,i){d3_time_numberRe.lastIndex=0;var n=d3_time_numberRe.exec(string.slice(i));return n?(date.U=+n[0],i+n[0].length):-1;}function d3_time_parseWeekNumberMonday(date,string,i){d3_time_numberRe.lastIndex=0;var n=d3_time_numberRe.exec(string.slice(i));return n?(date.W=+n[0],i+n[0].length):-1;}function d3_time_parseFullYear(date,string,i){d3_time_numberRe.lastIndex=0;var n=d3_time_numberRe.exec(string.slice(i,i+4));return n?(date.y=+n[0],i+n[0].length):-1;}function d3_time_parseYear(date,string,i){d3_time_numberRe.lastIndex=0;var n=d3_time_numberRe.exec(string.slice(i,i+2));return n?(date.y=d3_time_expandYear(+n[0]),i+n[0].length):-1;}function d3_time_parseZone(date,string,i){return /^[+-]\\d{4}$/.test(string=string.slice(i,i+5))?(date.Z=-string,i+5):-1;}function d3_time_expandYear(d){return d+(d>68?1900:2e3);}function d3_time_parseMonthNumber(date,string,i){d3_time_numberRe.lastIndex=0;var n=d3_time_numberRe.exec(string.slice(i,i+2));return n?(date.m=n[0]-1,i+n[0].length):-1;}function d3_time_parseDay(date,string,i){d3_time_numberRe.lastIndex=0;var n=d3_time_numberRe.exec(string.slice(i,i+2));return n?(date.d=+n[0],i+n[0].length):-1;}function d3_time_parseDayOfYear(date,string,i){d3_time_numberRe.lastIndex=0;var n=d3_time_numberRe.exec(string.slice(i,i+3));return n?(date.j=+n[0],i+n[0].length):-1;}function d3_time_parseHour24(date,string,i){d3_time_numberRe.lastIndex=0;var n=d3_time_numberRe.exec(string.slice(i,i+2));return n?(date.H=+n[0],i+n[0].length):-1;}function d3_time_parseMinutes(date,string,i){d3_time_numberRe.lastIndex=0;var n=d3_time_numberRe.exec(string.slice(i,i+2));return n?(date.M=+n[0],i+n[0].length):-1;}function d3_time_parseSeconds(date,string,i){d3_time_numberRe.lastIndex=0;var n=d3_time_numberRe.exec(string.slice(i,i+2));return n?(date.S=+n[0],i+n[0].length):-1;}function d3_time_parseMilliseconds(date,string,i){d3_time_numberRe.lastIndex=0;var n=d3_time_numberRe.exec(string.slice(i,i+3));return n?(date.L=+n[0],i+n[0].length):-1;}function d3_time_zone(d){var z=d.getTimezoneOffset(),zs=z>0?\"-\":\"+\",zh=abs(z)/60|0,zm=abs(z)%60;return zs+d3_time_formatPad(zh,\"0\",2)+d3_time_formatPad(zm,\"0\",2);}function d3_time_parseLiteralPercent(date,string,i){d3_time_percentRe.lastIndex=0;var n=d3_time_percentRe.exec(string.slice(i,i+1));return n?i+n[0].length:-1;}function d3_time_formatMulti(formats){var n=formats.length,i=-1;while(++i<n){formats[i][0]=this(formats[i][0]);}return function(date){var i=0,f=formats[i];while(!f[1](date)){f=formats[++i];}return f[0](date);};}d3.locale=function(locale){return{numberFormat:d3_locale_numberFormat(locale),timeFormat:d3_locale_timeFormat(locale)};};var d3_locale_enUS=d3.locale({decimal:\".\",thousands:\",\",grouping:[3],currency:[\"$\",\"\"],dateTime:\"%a %b %e %X %Y\",date:\"%m/%d/%Y\",time:\"%H:%M:%S\",periods:[\"AM\",\"PM\"],days:[\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"],shortDays:[\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\"],months:[\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"],shortMonths:[\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"]});d3.format=d3_locale_enUS.numberFormat;d3.geo={};function d3_adder(){}d3_adder.prototype={s:0,t:0,add:function add(y){d3_adderSum(y,this.t,d3_adderTemp);d3_adderSum(d3_adderTemp.s,this.s,this);if(this.s)this.t+=d3_adderTemp.t;else this.s=d3_adderTemp.t;},reset:function reset(){this.s=this.t=0;},valueOf:function valueOf(){return this.s;}};var d3_adderTemp=new d3_adder();function d3_adderSum(a,b,o){var x=o.s=a+b,bv=x-a,av=x-bv;o.t=a-av+(b-bv);}d3.geo.stream=function(object,listener){if(object&&d3_geo_streamObjectType.hasOwnProperty(object.type)){d3_geo_streamObjectType[object.type](object,listener);}else{d3_geo_streamGeometry(object,listener);}};function d3_geo_streamGeometry(geometry,listener){if(geometry&&d3_geo_streamGeometryType.hasOwnProperty(geometry.type)){d3_geo_streamGeometryType[geometry.type](geometry,listener);}}var d3_geo_streamObjectType={Feature:function Feature(feature,listener){d3_geo_streamGeometry(feature.geometry,listener);},FeatureCollection:function FeatureCollection(object,listener){var features=object.features,i=-1,n=features.length;while(++i<n){d3_geo_streamGeometry(features[i].geometry,listener);}}};var d3_geo_streamGeometryType={Sphere:function Sphere(object,listener){listener.sphere();},Point:function Point(object,listener){object=object.coordinates;listener.point(object[0],object[1],object[2]);},MultiPoint:function MultiPoint(object,listener){var coordinates=object.coordinates,i=-1,n=coordinates.length;while(++i<n){object=coordinates[i],listener.point(object[0],object[1],object[2]);}},LineString:function LineString(object,listener){d3_geo_streamLine(object.coordinates,listener,0);},MultiLineString:function MultiLineString(object,listener){var coordinates=object.coordinates,i=-1,n=coordinates.length;while(++i<n){d3_geo_streamLine(coordinates[i],listener,0);}},Polygon:function Polygon(object,listener){d3_geo_streamPolygon(object.coordinates,listener);},MultiPolygon:function MultiPolygon(object,listener){var coordinates=object.coordinates,i=-1,n=coordinates.length;while(++i<n){d3_geo_streamPolygon(coordinates[i],listener);}},GeometryCollection:function GeometryCollection(object,listener){var geometries=object.geometries,i=-1,n=geometries.length;while(++i<n){d3_geo_streamGeometry(geometries[i],listener);}}};function d3_geo_streamLine(coordinates,listener,closed){var i=-1,n=coordinates.length-closed,coordinate;listener.lineStart();while(++i<n){coordinate=coordinates[i],listener.point(coordinate[0],coordinate[1],coordinate[2]);}listener.lineEnd();}function d3_geo_streamPolygon(coordinates,listener){var i=-1,n=coordinates.length;listener.polygonStart();while(++i<n){d3_geo_streamLine(coordinates[i],listener,1);}listener.polygonEnd();}d3.geo.area=function(object){d3_geo_areaSum=0;d3.geo.stream(object,d3_geo_area);return d3_geo_areaSum;};var d3_geo_areaSum,d3_geo_areaRingSum=new d3_adder();var d3_geo_area={sphere:function sphere(){d3_geo_areaSum+=4*;},point:d3_noop,lineStart:d3_noop,lineEnd:d3_noop,polygonStart:function polygonStart(){d3_geo_areaRingSum.reset();d3_geo_area.lineStart=d3_geo_areaRingStart;},polygonEnd:function polygonEnd(){var area=2*d3_geo_areaRingSum;d3_geo_areaSum+=area<0?4*+area:area;d3_geo_area.lineStart=d3_geo_area.lineEnd=d3_geo_area.point=d3_noop;}};function d3_geo_areaRingStart(){var 00,00,0,cos0,sin0;d3_geo_area.point=function(,){d3_geo_area.point=nextPoint;0=(00=)*d3_radians,cos0=Math.cos(=(00=)*d3_radians/2+/4),sin0=Math.sin();};function nextPoint(,){*=d3_radians;=*d3_radians/2+/4;var d=-0,sd=d>=0?1:-1,ad=sd*d,cos=Math.cos(),sin=Math.sin(),k=sin0*sin,u=cos0*cos+k*Math.cos(ad),v=k*sd*Math.sin(ad);d3_geo_areaRingSum.add(Math.atan2(v,u));0=,cos0=cos,sin0=sin;}d3_geo_area.lineEnd=function(){nextPoint(00,00);};}function d3_geo_cartesian(spherical){var =spherical[0],=spherical[1],cos=Math.cos();return[cos*Math.cos(),cos*Math.sin(),Math.sin()];}function d3_geo_cartesianDot(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2];}function d3_geo_cartesianCross(a,b){return[a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]];}function d3_geo_cartesianAdd(a,b){a[0]+=b[0];a[1]+=b[1];a[2]+=b[2];}function d3_geo_cartesianScale(vector,k){return[vector[0]*k,vector[1]*k,vector[2]*k];}function d3_geo_cartesianNormalize(d){var l=Math.sqrt(d[0]*d[0]+d[1]*d[1]+d[2]*d[2]);d[0]/=l;d[1]/=l;d[2]/=l;}function d3_geo_spherical(cartesian){return[Math.atan2(cartesian[1],cartesian[0]),d3_asin(cartesian[2])];}function d3_geo_sphericalEqual(a,b){return abs(a[0]-b[0])<&&abs(a[1]-b[1])<;}d3.geo.bounds=function(){var 0,0,1,1,_,__,__,p0,dSum,ranges,range;var bound={point:point,lineStart:lineStart,lineEnd:lineEnd,polygonStart:function polygonStart(){bound.point=ringPoint;bound.lineStart=ringStart;bound.lineEnd=ringEnd;dSum=0;d3_geo_area.polygonStart();},polygonEnd:function polygonEnd(){d3_geo_area.polygonEnd();bound.point=point;bound.lineStart=lineStart;bound.lineEnd=lineEnd;if(d3_geo_areaRingSum<0)0=-(1=180),0=-(1=90);else if(dSum>)1=90;else if(dSum<-)0=-90;range[0]=0,range[1]=1;}};function point(,){ranges.push(range=[0=,1=]);if(<0)0=;if(>1)1=;}function linePoint(,){var p=d3_geo_cartesian([*d3_radians,*d3_radians]);if(p0){var normal=d3_geo_cartesianCross(p0,p),equatorial=[normal[1],-normal[0],0],inflection=d3_geo_cartesianCross(equatorial,normal);d3_geo_cartesianNormalize(inflection);inflection=d3_geo_spherical(inflection);var d=-_,s=d>0?1:-1,i=inflection[0]*d3_degrees*s,antimeridian=abs(d)>180;if(antimeridian^(s*_<i&&i<s*)){var i=inflection[1]*d3_degrees;if(i>1)1=i;}else if(i=(i+360)%360-180,antimeridian^(s*_<i&&i<s*)){var i=-inflection[1]*d3_degrees;if(i<0)0=i;}else{if(<0)0=;if(>1)1=;}if(antimeridian){if(<_){if(angle(0,)>angle(0,1))1=;}else{if(angle(,1)>angle(0,1))0=;}}else{if(1>=0){if(<0)0=;if(>1)1=;}else{if(>_){if(angle(0,)>angle(0,1))1=;}else{if(angle(,1)>angle(0,1))0=;}}}}else{point(,);}p0=p,_=;}function lineStart(){bound.point=linePoint;}function lineEnd(){range[0]=0,range[1]=1;bound.point=point;p0=null;}function ringPoint(,){if(p0){var d=-_;dSum+=abs(d)>180?d+(d>0?360:-360):d;}else __=,__=;d3_geo_area.point(,);linePoint(,);}function ringStart(){d3_geo_area.lineStart();}function ringEnd(){ringPoint(__,__);d3_geo_area.lineEnd();if(abs(dSum)>)0=-(1=180);range[0]=0,range[1]=1;p0=null;}function angle(0,1){return(1-=0)<0?1+360:1;}function compareRanges(a,b){return a[0]-b[0];}function withinRange(x,range){return range[0]<=range[1]?range[0]<=x&&x<=range[1]:x<range[0]||range[1]<x;}return function(feature){1=1=-(0=0=Infinity);ranges=[];d3.geo.stream(feature,bound);var n=ranges.length;if(n){ranges.sort(compareRanges);for(var i=1,a=ranges[0],b,merged=[a];i<n;++i){b=ranges[i];if(withinRange(b[0],a)||withinRange(b[1],a)){if(angle(a[0],b[1])>angle(a[0],a[1]))a[1]=b[1];if(angle(b[0],a[1])>angle(a[0],a[1]))a[0]=b[0];}else{merged.push(a=b);}}var best=-Infinity,d;for(var n=merged.length-1,i=0,a=merged[n],b;i<=n;a=b,++i){b=merged[i];if((d=angle(a[1],b[0]))>best)best=d,0=b[0],1=a[1];}}ranges=range=null;return 0===Infinity||0===Infinity?[[NaN,NaN],[NaN,NaN]]:[[0,0],[1,1]];};}();d3.geo.centroid=function(object){d3_geo_centroidW0=d3_geo_centroidW1=d3_geo_centroidX0=d3_geo_centroidY0=d3_geo_centroidZ0=d3_geo_centroidX1=d3_geo_centroidY1=d3_geo_centroidZ1=d3_geo_centroidX2=d3_geo_centroidY2=d3_geo_centroidZ2=0;d3.geo.stream(object,d3_geo_centroid);var x=d3_geo_centroidX2,y=d3_geo_centroidY2,z=d3_geo_centroidZ2,m=x*x+y*y+z*z;if(m<2){x=d3_geo_centroidX1,y=d3_geo_centroidY1,z=d3_geo_centroidZ1;if(d3_geo_centroidW1<)x=d3_geo_centroidX0,y=d3_geo_centroidY0,z=d3_geo_centroidZ0;m=x*x+y*y+z*z;if(m<2)return[NaN,NaN];}return[Math.atan2(y,x)*d3_degrees,d3_asin(z/Math.sqrt(m))*d3_degrees];};var d3_geo_centroidW0,d3_geo_centroidW1,d3_geo_centroidX0,d3_geo_centroidY0,d3_geo_centroidZ0,d3_geo_centroidX1,d3_geo_centroidY1,d3_geo_centroidZ1,d3_geo_centroidX2,d3_geo_centroidY2,d3_geo_centroidZ2;var d3_geo_centroid={sphere:d3_noop,point:d3_geo_centroidPoint,lineStart:d3_geo_centroidLineStart,lineEnd:d3_geo_centroidLineEnd,polygonStart:function polygonStart(){d3_geo_centroid.lineStart=d3_geo_centroidRingStart;},polygonEnd:function polygonEnd(){d3_geo_centroid.lineStart=d3_geo_centroidLineStart;}};function d3_geo_centroidPoint(,){*=d3_radians;var cos=Math.cos(*=d3_radians);d3_geo_centroidPointXYZ(cos*Math.cos(),cos*Math.sin(),Math.sin());}function d3_geo_centroidPointXYZ(x,y,z){++d3_geo_centroidW0;d3_geo_centroidX0+=(x-d3_geo_centroidX0)/d3_geo_centroidW0;d3_geo_centroidY0+=(y-d3_geo_centroidY0)/d3_geo_centroidW0;d3_geo_centroidZ0+=(z-d3_geo_centroidZ0)/d3_geo_centroidW0;}function d3_geo_centroidLineStart(){var x0,y0,z0;d3_geo_centroid.point=function(,){*=d3_radians;var cos=Math.cos(*=d3_radians);x0=cos*Math.cos();y0=cos*Math.sin();z0=Math.sin();d3_geo_centroid.point=nextPoint;d3_geo_centroidPointXYZ(x0,y0,z0);};function nextPoint(,){*=d3_radians;var cos=Math.cos(*=d3_radians),x=cos*Math.cos(),y=cos*Math.sin(),z=Math.sin(),w=Math.atan2(Math.sqrt((w=y0*z-z0*y)*w+(w=z0*x-x0*z)*w+(w=x0*y-y0*x)*w),x0*x+y0*y+z0*z);d3_geo_centroidW1+=w;d3_geo_centroidX1+=w*(x0+(x0=x));d3_geo_centroidY1+=w*(y0+(y0=y));d3_geo_centroidZ1+=w*(z0+(z0=z));d3_geo_centroidPointXYZ(x0,y0,z0);}}function d3_geo_centroidLineEnd(){d3_geo_centroid.point=d3_geo_centroidPoint;}function d3_geo_centroidRingStart(){var 00,00,x0,y0,z0;d3_geo_centroid.point=function(,){00=,00=;d3_geo_centroid.point=nextPoint;*=d3_radians;var cos=Math.cos(*=d3_radians);x0=cos*Math.cos();y0=cos*Math.sin();z0=Math.sin();d3_geo_centroidPointXYZ(x0,y0,z0);};d3_geo_centroid.lineEnd=function(){nextPoint(00,00);d3_geo_centroid.lineEnd=d3_geo_centroidLineEnd;d3_geo_centroid.point=d3_geo_centroidPoint;};function nextPoint(,){*=d3_radians;var cos=Math.cos(*=d3_radians),x=cos*Math.cos(),y=cos*Math.sin(),z=Math.sin(),cx=y0*z-z0*y,cy=z0*x-x0*z,cz=x0*y-y0*x,m=Math.sqrt(cx*cx+cy*cy+cz*cz),u=x0*x+y0*y+z0*z,v=m&&-d3_acos(u)/m,w=Math.atan2(m,u);d3_geo_centroidX2+=v*cx;d3_geo_centroidY2+=v*cy;d3_geo_centroidZ2+=v*cz;d3_geo_centroidW1+=w;d3_geo_centroidX1+=w*(x0+(x0=x));d3_geo_centroidY1+=w*(y0+(y0=y));d3_geo_centroidZ1+=w*(z0+(z0=z));d3_geo_centroidPointXYZ(x0,y0,z0);}}function d3_geo_compose(a,b){function compose(x,y){return x=a(x,y),b(x[0],x[1]);}if(a.invert&&b.invert)compose.invert=function(x,y){return x=b.invert(x,y),x&&a.invert(x[0],x[1]);};return compose;}function d3_true(){return true;}function d3_geo_clipPolygon(segments,compare,clipStartInside,interpolate,listener){var subject=[],clip=[];segments.forEach(function(segment){if((n=segment.length-1)<=0)return;var n,p0=segment[0],p1=segment[n];if(d3_geo_sphericalEqual(p0,p1)){listener.lineStart();for(var i=0;i<n;++i){listener.point((p0=segment[i])[0],p0[1]);}listener.lineEnd();return;}var a=new d3_geo_clipPolygonIntersection(p0,segment,null,true),b=new d3_geo_clipPolygonIntersection(p0,null,a,false);a.o=b;subject.push(a);clip.push(b);a=new d3_geo_clipPolygonIntersection(p1,segment,null,false);b=new d3_geo_clipPolygonIntersection(p1,null,a,true);a.o=b;subject.push(a);clip.push(b);});clip.sort(compare);d3_geo_clipPolygonLinkCircular(subject);d3_geo_clipPolygonLinkCircular(clip);if(!subject.length)return;for(var i=0,entry=clipStartInside,n=clip.length;i<n;++i){clip[i].e=entry=!entry;}var start=subject[0],points,point;while(1){var current=start,isSubject=true;while(current.v){if((current=current.n)===start)return;}points=current.z;listener.lineStart();do{current.v=current.o.v=true;if(current.e){if(isSubject){for(var i=0,n=points.length;i<n;++i){listener.point((point=points[i])[0],point[1]);}}else{interpolate(current.x,current.n.x,1,listener);}current=current.n;}else{if(isSubject){points=current.p.z;for(var i=points.length-1;i>=0;--i){listener.point((point=points[i])[0],point[1]);}}else{interpolate(current.x,current.p.x,-1,listener);}current=current.p;}current=current.o;points=current.z;isSubject=!isSubject;}while(!current.v);listener.lineEnd();}}function d3_geo_clipPolygonLinkCircular(array){if(!(n=array.length))return;var n,i=0,a=array[0],b;while(++i<n){a.n=b=array[i];b.p=a;a=b;}a.n=b=array[0];b.p=a;}function d3_geo_clipPolygonIntersection(point,points,other,entry){this.x=point;this.z=points;this.o=other;this.e=entry;this.v=false;this.n=this.p=null;}function d3_geo_clip(pointVisible,clipLine,interpolate,clipStart){return function(rotate,listener){var line=clipLine(listener),rotatedClipStart=rotate.invert(clipStart[0],clipStart[1]);var clip={point:point,lineStart:lineStart,lineEnd:lineEnd,polygonStart:function polygonStart(){clip.point=pointRing;clip.lineStart=ringStart;clip.lineEnd=ringEnd;segments=[];polygon=[];},polygonEnd:function polygonEnd(){clip.point=point;clip.lineStart=lineStart;clip.lineEnd=lineEnd;segments=d3.merge(segments);var clipStartInside=d3_geo_pointInPolygon(rotatedClipStart,polygon);if(segments.length){if(!polygonStarted)listener.polygonStart(),polygonStarted=true;d3_geo_clipPolygon(segments,d3_geo_clipSort,clipStartInside,interpolate,listener);}else if(clipStartInside){if(!polygonStarted)listener.polygonStart(),polygonStarted=true;listener.lineStart();interpolate(null,null,1,listener);listener.lineEnd();}if(polygonStarted)listener.polygonEnd(),polygonStarted=false;segments=polygon=null;},sphere:function sphere(){listener.polygonStart();listener.lineStart();interpolate(null,null,1,listener);listener.lineEnd();listener.polygonEnd();}};function point(,){var point=rotate(,);if(pointVisible(=point[0],=point[1]))listener.point(,);}function pointLine(,){var point=rotate(,);line.point(point[0],point[1]);}function lineStart(){clip.point=pointLine;line.lineStart();}function lineEnd(){clip.point=point;line.lineEnd();}var segments;var buffer=d3_geo_clipBufferListener(),ringListener=clipLine(buffer),polygonStarted=false,polygon,ring;function pointRing(,){ring.push([,]);var point=rotate(,);ringListener.point(point[0],point[1]);}function ringStart(){ringListener.lineStart();ring=[];}function ringEnd(){pointRing(ring[0][0],ring[0][1]);ringListener.lineEnd();var clean=ringListener.clean(),ringSegments=buffer.buffer(),segment,n=ringSegments.length;ring.pop();polygon.push(ring);ring=null;if(!n)return;if(clean&1){segment=ringSegments[0];var n=segment.length-1,i=-1,point;if(n>0){if(!polygonStarted)listener.polygonStart(),polygonStarted=true;listener.lineStart();while(++i<n){listener.point((point=segment[i])[0],point[1]);}listener.lineEnd();}return;}if(n>1&&clean&2)ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));}return clip;};}function d3_geo_clipSegmentLength1(segment){return segment.length>1;}function d3_geo_clipBufferListener(){var lines=[],line;return{lineStart:function lineStart(){lines.push(line=[]);},point:function point(,){line.push([,]);},lineEnd:d3_noop,buffer:function buffer(){var buffer=lines;lines=[];line=null;return buffer;},rejoin:function rejoin(){if(lines.length>1)lines.push(lines.pop().concat(lines.shift()));}};}function d3_geo_clipSort(a,b){return((a=a.x)[0]<0?a[1]-half-:half-a[1])-((b=b.x)[0]<0?b[1]-half-:half-b[1]);}var d3_geo_clipAntimeridian=d3_geo_clip(d3_true,d3_geo_clipAntimeridianLine,d3_geo_clipAntimeridianInterpolate,[-,-/2]);function d3_geo_clipAntimeridianLine(listener){var 0=NaN,0=NaN,s0=NaN,_clean;return{lineStart:function lineStart(){listener.lineStart();_clean=1;},point:function point(1,1){var s1=1>0?:-,d=abs(1-0);if(abs(d-)<){listener.point(0,0=(0+1)/2>0?half:-half);listener.point(s0,0);listener.lineEnd();listener.lineStart();listener.point(s1,0);listener.point(1,0);_clean=0;}else if(s0!==s1&&d>=){if(abs(0-s0)<)0-=s0*;if(abs(1-s1)<)1-=s1*;0=d3_geo_clipAntimeridianIntersect(0,0,1,1);listener.point(s0,0);listener.lineEnd();listener.lineStart();listener.point(s1,0);_clean=0;}listener.point(0=1,0=1);s0=s1;},lineEnd:function lineEnd(){listener.lineEnd();0=0=NaN;},clean:function clean(){return 2-_clean;}};}function d3_geo_clipAntimeridianIntersect(0,0,1,1){var cos0,cos1,sin0_1=Math.sin(0-1);return abs(sin0_1)>?Math.atan((Math.sin(0)*(cos1=Math.cos(1))*Math.sin(1)-Math.sin(1)*(cos0=Math.cos(0))*Math.sin(0))/(cos0*cos1*sin0_1)):(0+1)/2;}function d3_geo_clipAntimeridianInterpolate(from,to,direction,listener){var ;if(from==null){=direction*half;listener.point(-,);listener.point(0,);listener.point(,);listener.point(,0);listener.point(,-);listener.point(0,-);listener.point(-,-);listener.point(-,0);listener.point(-,);}else if(abs(from[0]-to[0])>){var s=from[0]<to[0]?:-;=direction*s/2;listener.point(-s,);listener.point(0,);listener.point(s,);}else{listener.point(to[0],to[1]);}}function d3_geo_pointInPolygon(point,polygon){var meridian=point[0],parallel=point[1],meridianNormal=[Math.sin(meridian),-Math.cos(meridian),0],polarAngle=0,winding=0;d3_geo_areaRingSum.reset();for(var i=0,n=polygon.length;i<n;++i){var ring=polygon[i],m=ring.length;if(!m)continue;var point0=ring[0],0=point0[0],0=point0[1]/2+/4,sin0=Math.sin(0),cos0=Math.cos(0),j=1;while(true){if(j===m)j=0;point=ring[j];var =point[0],=point[1]/2+/4,sin=Math.sin(),cos=Math.cos(),d=-0,sd=d>=0?1:-1,ad=sd*d,antimeridian=ad>,k=sin0*sin;d3_geo_areaRingSum.add(Math.atan2(k*sd*Math.sin(ad),cos0*cos+k*Math.cos(ad)));polarAngle+=antimeridian?d+sd*:d;if(antimeridian^0>=meridian^>=meridian){var arc=d3_geo_cartesianCross(d3_geo_cartesian(point0),d3_geo_cartesian(point));d3_geo_cartesianNormalize(arc);var intersection=d3_geo_cartesianCross(meridianNormal,arc);d3_geo_cartesianNormalize(intersection);var arc=(antimeridian^d>=0?-1:1)*d3_asin(intersection[2]);if(parallel>arc||parallel===arc&&(arc[0]||arc[1])){winding+=antimeridian^d>=0?1:-1;}}if(!j++)break;0=,sin0=sin,cos0=cos,point0=point;}}return(polarAngle<-||polarAngle<&&d3_geo_areaRingSum<-)^winding&1;}function d3_geo_clipCircle(radius){var cr=Math.cos(radius),smallRadius=cr>0,notHemisphere=abs(cr)>,interpolate=d3_geo_circleInterpolate(radius,6*d3_radians);return d3_geo_clip(visible,clipLine,interpolate,smallRadius?[0,-radius]:[-,radius-]);function visible(,){return Math.cos()*Math.cos()>cr;}function clipLine(listener){var point0,c0,v0,v00,_clean2;return{lineStart:function lineStart(){v00=v0=false;_clean2=1;},point:function point(,){var point1=[,],point2,v=visible(,),c=smallRadius?v?0:code(,):v?code(+(<0?:-),):0;if(!point0&&(v00=v0=v))listener.lineStart();if(v!==v0){point2=intersect(point0,point1);if(d3_geo_sphericalEqual(point0,point2)||d3_geo_sphericalEqual(point1,point2)){point1[0]+=;point1[1]+=;v=visible(point1[0],point1[1]);}}if(v!==v0){_clean2=0;if(v){listener.lineStart();point2=intersect(point1,point0);listener.point(point2[0],point2[1]);}else{point2=intersect(point0,point1);listener.point(point2[0],point2[1]);listener.lineEnd();}point0=point2;}else if(notHemisphere&&point0&&smallRadius^v){var t;if(!(c&c0)&&(t=intersect(point1,point0,true))){_clean2=0;if(smallRadius){listener.lineStart();listener.point(t[0][0],t[0][1]);listener.point(t[1][0],t[1][1]);listener.lineEnd();}else{listener.point(t[1][0],t[1][1]);listener.lineEnd();listener.lineStart();listener.point(t[0][0],t[0][1]);}}}if(v&&(!point0||!d3_geo_sphericalEqual(point0,point1))){listener.point(point1[0],point1[1]);}point0=point1,v0=v,c0=c;},lineEnd:function lineEnd(){if(v0)listener.lineEnd();point0=null;},clean:function clean(){return _clean2|(v00&&v0)<<1;}};}function intersect(a,b,two){var pa=d3_geo_cartesian(a),pb=d3_geo_cartesian(b);var n1=[1,0,0],n2=d3_geo_cartesianCross(pa,pb),n2n2=d3_geo_cartesianDot(n2,n2),n1n2=n2[0],determinant=n2n2-n1n2*n1n2;if(!determinant)return!two&&a;var c1=cr*n2n2/determinant,c2=-cr*n1n2/determinant,n1xn2=d3_geo_cartesianCross(n1,n2),A=d3_geo_cartesianScale(n1,c1),B=d3_geo_cartesianScale(n2,c2);d3_geo_cartesianAdd(A,B);var u=n1xn2,w=d3_geo_cartesianDot(A,u),uu=d3_geo_cartesianDot(u,u),t2=w*w-uu*(d3_geo_cartesianDot(A,A)-1);if(t2<0)return;var t=Math.sqrt(t2),q=d3_geo_cartesianScale(u,(-w-t)/uu);d3_geo_cartesianAdd(q,A);q=d3_geo_spherical(q);if(!two)return q;var 0=a[0],1=b[0],0=a[1],1=b[1],z;if(1<0)z=0,0=1,1=z;var =1-0,polar=abs(-)<,meridian=polar||<;if(!polar&&1<0)z=0,0=1,1=z;if(meridian?polar?0+1>0^q[1]<(abs(q[0]-0)<?0:1):0<=q[1]&&q[1]<=1:>^(0<=q[0]&&q[0]<=1)){var q1=d3_geo_cartesianScale(u,(-w+t)/uu);d3_geo_cartesianAdd(q1,A);return[q,d3_geo_spherical(q1)];}}function code(,){var r=smallRadius?radius:-radius,code=0;if(<-r)code|=1;else if(>r)code|=2;if(<-r)code|=4;else if(>r)code|=8;return code;}}function d3_geom_clipLine(x0,y0,x1,y1){return function(line){var a=line.a,b=line.b,ax=a.x,ay=a.y,bx=b.x,by=b.y,t0=0,t1=1,dx=bx-ax,dy=by-ay,r;r=x0-ax;if(!dx&&r>0)return;r/=dx;if(dx<0){if(r<t0)return;if(r<t1)t1=r;}else if(dx>0){if(r>t1)return;if(r>t0)t0=r;}r=x1-ax;if(!dx&&r<0)return;r/=dx;if(dx<0){if(r>t1)return;if(r>t0)t0=r;}else if(dx>0){if(r<t0)return;if(r<t1)t1=r;}r=y0-ay;if(!dy&&r>0)return;r/=dy;if(dy<0){if(r<t0)return;if(r<t1)t1=r;}else if(dy>0){if(r>t1)return;if(r>t0)t0=r;}r=y1-ay;if(!dy&&r<0)return;r/=dy;if(dy<0){if(r>t1)return;if(r>t0)t0=r;}else if(dy>0){if(r<t0)return;if(r<t1)t1=r;}if(t0>0)line.a={x:ax+t0*dx,y:ay+t0*dy};if(t1<1)line.b={x:ax+t1*dx,y:ay+t1*dy};return line;};}var d3_geo_clipExtentMAX=1e9;d3.geo.clipExtent=function(){var x0,y0,x1,y1,_stream,clip,clipExtent={stream:function stream(output){if(_stream)_stream.valid=false;_stream=clip(output);_stream.valid=true;return _stream;},extent:function extent(_){if(!arguments.length)return[[x0,y0],[x1,y1]];clip=d3_geo_clipExtent(x0=+_[0][0],y0=+_[0][1],x1=+_[1][0],y1=+_[1][1]);if(_stream)_stream.valid=false,_stream=null;return clipExtent;}};return clipExtent.extent([[0,0],[960,500]]);};function d3_geo_clipExtent(x0,y0,x1,y1){return function(listener){var listener_=listener,bufferListener=d3_geo_clipBufferListener(),clipLine=d3_geom_clipLine(x0,y0,x1,y1),segments,polygon,ring;var clip={point:point,lineStart:lineStart,lineEnd:lineEnd,polygonStart:function polygonStart(){listener=bufferListener;segments=[];polygon=[];clean=true;},polygonEnd:function polygonEnd(){listener=listener_;segments=d3.merge(segments);var clipStartInside=insidePolygon([x0,y1]),inside=clean&&clipStartInside,visible=segments.length;if(inside||visible){listener.polygonStart();if(inside){listener.lineStart();interpolate(null,null,1,listener);listener.lineEnd();}if(visible){d3_geo_clipPolygon(segments,compare,clipStartInside,interpolate,listener);}listener.polygonEnd();}segments=polygon=ring=null;}};function insidePolygon(p){var wn=0,n=polygon.length,y=p[1];for(var i=0;i<n;++i){for(var j=1,v=polygon[i],m=v.length,a=v[0],b;j<m;++j){b=v[j];if(a[1]<=y){if(b[1]>y&&d3_cross2d(a,b,p)>0)++wn;}else{if(b[1]<=y&&d3_cross2d(a,b,p)<0)--wn;}a=b;}}return wn!==0;}function interpolate(from,to,direction,listener){var a=0,a1=0;if(from==null||(a=corner(from,direction))!==(a1=corner(to,direction))||comparePoints(from,to)<0^direction>0){do{listener.point(a===0||a===3?x0:x1,a>1?y1:y0);}while((a=(a+direction+4)%4)!==a1);}else{listener.point(to[0],to[1]);}}function pointVisible(x,y){return x0<=x&&x<=x1&&y0<=y&&y<=y1;}function point(x,y){if(pointVisible(x,y))listener.point(x,y);}var x__,y__,v__,x_,y_,v_,first,clean;function lineStart(){clip.point=linePoint;if(polygon)polygon.push(ring=[]);first=true;v_=false;x_=y_=NaN;}function lineEnd(){if(segments){linePoint(x__,y__);if(v__&&v_)bufferListener.rejoin();segments.push(bufferListener.buffer());}clip.point=point;if(v_)listener.lineEnd();}function linePoint(x,y){x=Math.max(-d3_geo_clipExtentMAX,Math.min(d3_geo_clipExtentMAX,x));y=Math.max(-d3_geo_clipExtentMAX,Math.min(d3_geo_clipExtentMAX,y));var v=pointVisible(x,y);if(polygon)ring.push([x,y]);if(first){x__=x,y__=y,v__=v;first=false;if(v){listener.lineStart();listener.point(x,y);}}else{if(v&&v_)listener.point(x,y);else{var l={a:{x:x_,y:y_},b:{x:x,y:y}};if(clipLine(l)){if(!v_){listener.lineStart();listener.point(l.a.x,l.a.y);}listener.point(l.b.x,l.b.y);if(!v)listener.lineEnd();clean=false;}else if(v){listener.lineStart();listener.point(x,y);clean=false;}}}x_=x,y_=y,v_=v;}return clip;};function corner(p,direction){return abs(p[0]-x0)<?direction>0?0:3:abs(p[0]-x1)<?direction>0?2:1:abs(p[1]-y0)<?direction>0?1:0:direction>0?3:2;}function compare(a,b){return comparePoints(a.x,b.x);}function comparePoints(a,b){var ca=corner(a,1),cb=corner(b,1);return ca!==cb?ca-cb:ca===0?b[1]-a[1]:ca===1?a[0]-b[0]:ca===2?a[1]-b[1]:b[0]-a[0];}}function d3_geo_conic(projectAt){var 0=0,1=/3,m=d3_geo_projectionMutator(projectAt),p=m(0,1);p.parallels=function(_){if(!arguments.length)return[0/*180,1/*180];return m(0=_[0]*/180,1=_[1]*/180);};return p;}function d3_geo_conicEqualArea(0,1){var sin0=Math.sin(0),n=(sin0+Math.sin(1))/2,C=1+sin0*(2*n-sin0),0=Math.sqrt(C)/n;function forward(,){var =Math.sqrt(C-2*n*Math.sin())/n;return[*Math.sin(*=n),0-*Math.cos()];}forward.invert=function(x,y){var 0_y=0-y;return[Math.atan2(x,0_y)/n,d3_asin((C-(x*x+0_y*0_y)*n*n)/(2*n))];};return forward;}(d3.geo.conicEqualArea=function(){return d3_geo_conic(d3_geo_conicEqualArea);}).raw=d3_geo_conicEqualArea;d3.geo.albers=function(){return d3.geo.conicEqualArea().rotate([96,0]).center([-.6,38.7]).parallels([29.5,45.5]).scale(1070);};d3.geo.albersUsa=function(){var lower48=d3.geo.albers();var alaska=d3.geo.conicEqualArea().rotate([154,0]).center([-2,58.5]).parallels([55,65]);var hawaii=d3.geo.conicEqualArea().rotate([157,0]).center([-3,19.9]).parallels([8,18]);var _point,pointStream={point:function point(x,y){_point=[x,y];}},lower48Point,alaskaPoint,hawaiiPoint;function albersUsa(coordinates){var x=coordinates[0],y=coordinates[1];_point=null;(lower48Point(x,y),_point)||(alaskaPoint(x,y),_point)||hawaiiPoint(x,y);return _point;}albersUsa.invert=function(coordinates){var k=lower48.scale(),t=lower48.translate(),x=(coordinates[0]-t[0])/k,y=(coordinates[1]-t[1])/k;return(y>=.12&&y<.234&&x>=-.425&&x<-.214?alaska:y>=.166&&y<.234&&x>=-.214&&x<-.115?hawaii:lower48).invert(coordinates);};albersUsa.stream=function(stream){var lower48Stream=lower48.stream(stream),alaskaStream=alaska.stream(stream),hawaiiStream=hawaii.stream(stream);return{point:function point(x,y){lower48Stream.point(x,y);alaskaStream.point(x,y);hawaiiStream.point(x,y);},sphere:function sphere(){lower48Stream.sphere();alaskaStream.sphere();hawaiiStream.sphere();},lineStart:function lineStart(){lower48Stream.lineStart();alaskaStream.lineStart();hawaiiStream.lineStart();},lineEnd:function lineEnd(){lower48Stream.lineEnd();alaskaStream.lineEnd();hawaiiStream.lineEnd();},polygonStart:function polygonStart(){lower48Stream.polygonStart();alaskaStream.polygonStart();hawaiiStream.polygonStart();},polygonEnd:function polygonEnd(){lower48Stream.polygonEnd();alaskaStream.polygonEnd();hawaiiStream.polygonEnd();}};};albersUsa.precision=function(_){if(!arguments.length)return lower48.precision();lower48.precision(_);alaska.precision(_);hawaii.precision(_);return albersUsa;};albersUsa.scale=function(_){if(!arguments.length)return lower48.scale();lower48.scale(_);alaska.scale(_*.35);hawaii.scale(_);return albersUsa.translate(lower48.translate());};albersUsa.translate=function(_){if(!arguments.length)return lower48.translate();var k=lower48.scale(),x=+_[0],y=+_[1];lower48Point=lower48.translate(_).clipExtent([[x-.455*k,y-.238*k],[x+.455*k,y+.238*k]]).stream(pointStream).point;alaskaPoint=alaska.translate([x-.307*k,y+.201*k]).clipExtent([[x-.425*k+,y+.12*k+],[x-.214*k-,y+.234*k-]]).stream(pointStream).point;hawaiiPoint=hawaii.translate([x-.205*k,y+.212*k]).clipExtent([[x-.214*k+,y+.166*k+],[x-.115*k-,y+.234*k-]]).stream(pointStream).point;return albersUsa;};return albersUsa.scale(1070);};var d3_geo_pathAreaSum,d3_geo_pathAreaPolygon,d3_geo_pathArea={point:d3_noop,lineStart:d3_noop,lineEnd:d3_noop,polygonStart:function polygonStart(){d3_geo_pathAreaPolygon=0;d3_geo_pathArea.lineStart=d3_geo_pathAreaRingStart;},polygonEnd:function polygonEnd(){d3_geo_pathArea.lineStart=d3_geo_pathArea.lineEnd=d3_geo_pathArea.point=d3_noop;d3_geo_pathAreaSum+=abs(d3_geo_pathAreaPolygon/2);}};function d3_geo_pathAreaRingStart(){var x00,y00,x0,y0;d3_geo_pathArea.point=function(x,y){d3_geo_pathArea.point=nextPoint;x00=x0=x,y00=y0=y;};function nextPoint(x,y){d3_geo_pathAreaPolygon+=y0*x-x0*y;x0=x,y0=y;}d3_geo_pathArea.lineEnd=function(){nextPoint(x00,y00);};}var d3_geo_pathBoundsX0,d3_geo_pathBoundsY0,d3_geo_pathBoundsX1,d3_geo_pathBoundsY1;var d3_geo_pathBounds={point:d3_geo_pathBoundsPoint,lineStart:d3_noop,lineEnd:d3_noop,polygonStart:d3_noop,polygonEnd:d3_noop};function d3_geo_pathBoundsPoint(x,y){if(x<d3_geo_pathBoundsX0)d3_geo_pathBoundsX0=x;if(x>d3_geo_pathBoundsX1)d3_geo_pathBoundsX1=x;if(y<d3_geo_pathBoundsY0)d3_geo_pathBoundsY0=y;if(y>d3_geo_pathBoundsY1)d3_geo_pathBoundsY1=y;}function d3_geo_pathBuffer(){var pointCircle=d3_geo_pathBufferCircle(4.5),buffer=[];var stream={point:point,lineStart:function lineStart(){stream.point=pointLineStart;},lineEnd:lineEnd,polygonStart:function polygonStart(){stream.lineEnd=lineEndPolygon;},polygonEnd:function polygonEnd(){stream.lineEnd=lineEnd;stream.point=point;},pointRadius:function pointRadius(_){pointCircle=d3_geo_pathBufferCircle(_);return stream;},result:function result(){if(buffer.length){var result=buffer.join(\"\");buffer=[];return result;}}};function point(x,y){buffer.push(\"M\",x,\",\",y,pointCircle);}function pointLineStart(x,y){buffer.push(\"M\",x,\",\",y);stream.point=pointLine;}function pointLine(x,y){buffer.push(\"L\",x,\",\",y);}function lineEnd(){stream.point=point;}function lineEndPolygon(){buffer.push(\"Z\");}return stream;}function d3_geo_pathBufferCircle(radius){return\"m0,\"+radius+\"a\"+radius+\",\"+radius+\" 0 1,1 0,\"+-2*radius+\"a\"+radius+\",\"+radius+\" 0 1,1 0,\"+2*radius+\"z\";}var d3_geo_pathCentroid={point:d3_geo_pathCentroidPoint,lineStart:d3_geo_pathCentroidLineStart,lineEnd:d3_geo_pathCentroidLineEnd,polygonStart:function polygonStart(){d3_geo_pathCentroid.lineStart=d3_geo_pathCentroidRingStart;},polygonEnd:function polygonEnd(){d3_geo_pathCentroid.point=d3_geo_pathCentroidPoint;d3_geo_pathCentroid.lineStart=d3_geo_pathCentroidLineStart;d3_geo_pathCentroid.lineEnd=d3_geo_pathCentroidLineEnd;}};function d3_geo_pathCentroidPoint(x,y){d3_geo_centroidX0+=x;d3_geo_centroidY0+=y;++d3_geo_centroidZ0;}function d3_geo_pathCentroidLineStart(){var x0,y0;d3_geo_pathCentroid.point=function(x,y){d3_geo_pathCentroid.point=nextPoint;d3_geo_pathCentroidPoint(x0=x,y0=y);};function nextPoint(x,y){var dx=x-x0,dy=y-y0,z=Math.sqrt(dx*dx+dy*dy);d3_geo_centroidX1+=z*(x0+x)/2;d3_geo_centroidY1+=z*(y0+y)/2;d3_geo_centroidZ1+=z;d3_geo_pathCentroidPoint(x0=x,y0=y);}}function d3_geo_pathCentroidLineEnd(){d3_geo_pathCentroid.point=d3_geo_pathCentroidPoint;}function d3_geo_pathCentroidRingStart(){var x00,y00,x0,y0;d3_geo_pathCentroid.point=function(x,y){d3_geo_pathCentroid.point=nextPoint;d3_geo_pathCentroidPoint(x00=x0=x,y00=y0=y);};function nextPoint(x,y){var dx=x-x0,dy=y-y0,z=Math.sqrt(dx*dx+dy*dy);d3_geo_centroidX1+=z*(x0+x)/2;d3_geo_centroidY1+=z*(y0+y)/2;d3_geo_centroidZ1+=z;z=y0*x-x0*y;d3_geo_centroidX2+=z*(x0+x);d3_geo_centroidY2+=z*(y0+y);d3_geo_centroidZ2+=z*3;d3_geo_pathCentroidPoint(x0=x,y0=y);}d3_geo_pathCentroid.lineEnd=function(){nextPoint(x00,y00);};}function d3_geo_pathContext(context){var _pointRadius=4.5;var stream={point:point,lineStart:function lineStart(){stream.point=pointLineStart;},lineEnd:lineEnd,polygonStart:function polygonStart(){stream.lineEnd=lineEndPolygon;},polygonEnd:function polygonEnd(){stream.lineEnd=lineEnd;stream.point=point;},pointRadius:function pointRadius(_){_pointRadius=_;return stream;},result:d3_noop};function point(x,y){context.moveTo(x+_pointRadius,y);context.arc(x,y,_pointRadius,0,);}function pointLineStart(x,y){context.moveTo(x,y);stream.point=pointLine;}function pointLine(x,y){context.lineTo(x,y);}function lineEnd(){stream.point=point;}function lineEndPolygon(){context.closePath();}return stream;}function d3_geo_resample(project){var 2=.5,cosMinDistance=Math.cos(30*d3_radians),maxDepth=16;function resample(stream){return(maxDepth?resampleRecursive:resampleNone)(stream);}function resampleNone(stream){return d3_geo_transformPoint(stream,function(x,y){x=project(x,y);stream.point(x[0],x[1]);});}function resampleRecursive(stream){var 00,00,x00,y00,a00,b00,c00,0,x0,y0,a0,b0,c0;var resample={point:point,lineStart:lineStart,lineEnd:lineEnd,polygonStart:function polygonStart(){stream.polygonStart();resample.lineStart=ringStart;},polygonEnd:function polygonEnd(){stream.polygonEnd();resample.lineStart=lineStart;}};function point(x,y){x=project(x,y);stream.point(x[0],x[1]);}function lineStart(){x0=NaN;resample.point=linePoint;stream.lineStart();}function linePoint(,){var c=d3_geo_cartesian([,]),p=project(,);resampleLineTo(x0,y0,0,a0,b0,c0,x0=p[0],y0=p[1],0=,a0=c[0],b0=c[1],c0=c[2],maxDepth,stream);stream.point(x0,y0);}function lineEnd(){resample.point=point;stream.lineEnd();}function ringStart(){lineStart();resample.point=ringPoint;resample.lineEnd=ringEnd;}function ringPoint(,){linePoint(00=,00=),x00=x0,y00=y0,a00=a0,b00=b0,c00=c0;resample.point=linePoint;}function ringEnd(){resampleLineTo(x0,y0,0,a0,b0,c0,x00,y00,00,a00,b00,c00,maxDepth,stream);resample.lineEnd=lineEnd;lineEnd();}return resample;}function resampleLineTo(x0,y0,0,a0,b0,c0,x1,y1,1,a1,b1,c1,depth,stream){var dx=x1-x0,dy=y1-y0,d2=dx*dx+dy*dy;if(d2>4*2&&depth--){var a=a0+a1,b=b0+b1,c=c0+c1,m=Math.sqrt(a*a+b*b+c*c),2=Math.asin(c/=m),2=abs(abs(c)-1)<||abs(0-1)<?(0+1)/2:Math.atan2(b,a),p=project(2,2),x2=p[0],y2=p[1],dx2=x2-x0,dy2=y2-y0,dz=dy*dx2-dx*dy2;if(dz*dz/d2>2||abs((dx*dx2+dy*dy2)/d2-.5)>.3||a0*a1+b0*b1+c0*c1<cosMinDistance){resampleLineTo(x0,y0,0,a0,b0,c0,x2,y2,2,a/=m,b/=m,c,depth,stream);stream.point(x2,y2);resampleLineTo(x2,y2,2,a,b,c,x1,y1,1,a1,b1,c1,depth,stream);}}}resample.precision=function(_){if(!arguments.length)return Math.sqrt(2);maxDepth=(2=_*_)>0&&16;return resample;};return resample;}d3.geo.path=function(){var pointRadius=4.5,projection,context,projectStream,contextStream,cacheStream;function path(object){if(object){if(typeof pointRadius===\"function\")contextStream.pointRadius(+pointRadius.apply(this,arguments));if(!cacheStream||!cacheStream.valid)cacheStream=projectStream(contextStream);d3.geo.stream(object,cacheStream);}return contextStream.result();}path.area=function(object){d3_geo_pathAreaSum=0;d3.geo.stream(object,projectStream(d3_geo_pathArea));return d3_geo_pathAreaSum;};path.centroid=function(object){d3_geo_centroidX0=d3_geo_centroidY0=d3_geo_centroidZ0=d3_geo_centroidX1=d3_geo_centroidY1=d3_geo_centroidZ1=d3_geo_centroidX2=d3_geo_centroidY2=d3_geo_centroidZ2=0;d3.geo.stream(object,projectStream(d3_geo_pathCentroid));return d3_geo_centroidZ2?[d3_geo_centroidX2/d3_geo_centroidZ2,d3_geo_centroidY2/d3_geo_centroidZ2]:d3_geo_centroidZ1?[d3_geo_centroidX1/d3_geo_centroidZ1,d3_geo_centroidY1/d3_geo_centroidZ1]:d3_geo_centroidZ0?[d3_geo_centroidX0/d3_geo_centroidZ0,d3_geo_centroidY0/d3_geo_centroidZ0]:[NaN,NaN];};path.bounds=function(object){d3_geo_pathBoundsX1=d3_geo_pathBoundsY1=-(d3_geo_pathBoundsX0=d3_geo_pathBoundsY0=Infinity);d3.geo.stream(object,projectStream(d3_geo_pathBounds));return[[d3_geo_pathBoundsX0,d3_geo_pathBoundsY0],[d3_geo_pathBoundsX1,d3_geo_pathBoundsY1]];};path.projection=function(_){if(!arguments.length)return projection;projectStream=(projection=_)?_.stream||d3_geo_pathProjectStream(_):d3_identity;return reset();};path.context=function(_){if(!arguments.length)return context;contextStream=(context=_)==null?new d3_geo_pathBuffer():new d3_geo_pathContext(_);if(typeof pointRadius!==\"function\")contextStream.pointRadius(pointRadius);return reset();};path.pointRadius=function(_){if(!arguments.length)return pointRadius;pointRadius=typeof _===\"function\"?_:(contextStream.pointRadius(+_),+_);return path;};function reset(){cacheStream=null;return path;}return path.projection(d3.geo.albersUsa()).context(null);};function d3_geo_pathProjectStream(project){var resample=d3_geo_resample(function(x,y){return project([x*d3_degrees,y*d3_degrees]);});return function(stream){return d3_geo_projectionRadians(resample(stream));};}d3.geo.transform=function(methods){return{stream:function stream(_stream2){var transform=new d3_geo_transform(_stream2);for(var k in methods){transform[k]=methods[k];}return transform;}};};function d3_geo_transform(stream){this.stream=stream;}d3_geo_transform.prototype={point:function point(x,y){this.stream.point(x,y);},sphere:function sphere(){this.stream.sphere();},lineStart:function lineStart(){this.stream.lineStart();},lineEnd:function lineEnd(){this.stream.lineEnd();},polygonStart:function polygonStart(){this.stream.polygonStart();},polygonEnd:function polygonEnd(){this.stream.polygonEnd();}};function d3_geo_transformPoint(stream,point){return{point:point,sphere:function sphere(){stream.sphere();},lineStart:function lineStart(){stream.lineStart();},lineEnd:function lineEnd(){stream.lineEnd();},polygonStart:function polygonStart(){stream.polygonStart();},polygonEnd:function polygonEnd(){stream.polygonEnd();}};}d3.geo.projection=d3_geo_projection;d3.geo.projectionMutator=d3_geo_projectionMutator;function d3_geo_projection(project){return d3_geo_projectionMutator(function(){return project;})();}function d3_geo_projectionMutator(projectAt){var project,rotate,projectRotate,projectResample=d3_geo_resample(function(x,y){x=project(x,y);return[x[0]*k+x,y-x[1]*k];}),k=150,x=480,y=250,=0,=0,=0,=0,=0,x,y,preclip=d3_geo_clipAntimeridian,postclip=d3_identity,clipAngle=null,clipExtent=null,stream;function projection(point){point=projectRotate(point[0]*d3_radians,point[1]*d3_radians);return[point[0]*k+x,y-point[1]*k];}function invert(point){point=projectRotate.invert((point[0]-x)/k,(y-point[1])/k);return point&&[point[0]*d3_degrees,point[1]*d3_degrees];}projection.stream=function(output){if(stream)stream.valid=false;stream=d3_geo_projectionRadians(preclip(rotate,projectResample(postclip(output))));stream.valid=true;return stream;};projection.clipAngle=function(_){if(!arguments.length)return clipAngle;preclip=_==null?(clipAngle=_,d3_geo_clipAntimeridian):d3_geo_clipCircle((clipAngle=+_)*d3_radians);return invalidate();};projection.clipExtent=function(_){if(!arguments.length)return clipExtent;clipExtent=_;postclip=_?d3_geo_clipExtent(_[0][0],_[0][1],_[1][0],_[1][1]):d3_identity;return invalidate();};projection.scale=function(_){if(!arguments.length)return k;k=+_;return reset();};projection.translate=function(_){if(!arguments.length)return[x,y];x=+_[0];y=+_[1];return reset();};projection.center=function(_){if(!arguments.length)return[*d3_degrees,*d3_degrees];=_[0]%360*d3_radians;=_[1]%360*d3_radians;return reset();};projection.rotate=function(_){if(!arguments.length)return[*d3_degrees,*d3_degrees,*d3_degrees];=_[0]%360*d3_radians;=_[1]%360*d3_radians;=_.length>2?_[2]%360*d3_radians:0;return reset();};d3.rebind(projection,projectResample,\"precision\");function reset(){projectRotate=d3_geo_compose(rotate=d3_geo_rotation(,,),project);var center=project(,);x=x-center[0]*k;y=y+center[1]*k;return invalidate();}function invalidate(){if(stream)stream.valid=false,stream=null;return projection;}return function(){project=projectAt.apply(this,arguments);projection.invert=project.invert&&invert;return reset();};}function d3_geo_projectionRadians(stream){return d3_geo_transformPoint(stream,function(x,y){stream.point(x*d3_radians,y*d3_radians);});}function d3_geo_equirectangular(,){return[,];}(d3.geo.equirectangular=function(){return d3_geo_projection(d3_geo_equirectangular);}).raw=d3_geo_equirectangular.invert=d3_geo_equirectangular;d3.geo.rotation=function(rotate){rotate=d3_geo_rotation(rotate[0]%360*d3_radians,rotate[1]*d3_radians,rotate.length>2?rotate[2]*d3_radians:0);function forward(coordinates){coordinates=rotate(coordinates[0]*d3_radians,coordinates[1]*d3_radians);return coordinates[0]*=d3_degrees,coordinates[1]*=d3_degrees,coordinates;}forward.invert=function(coordinates){coordinates=rotate.invert(coordinates[0]*d3_radians,coordinates[1]*d3_radians);return coordinates[0]*=d3_degrees,coordinates[1]*=d3_degrees,coordinates;};return forward;};function d3_geo_identityRotation(,){return[>?-:<-?+:,];}d3_geo_identityRotation.invert=d3_geo_equirectangular;function d3_geo_rotation(,,){return ?||?d3_geo_compose(d3_geo_rotation(),d3_geo_rotation(,)):d3_geo_rotation():||?d3_geo_rotation(,):d3_geo_identityRotation;}function d3_geo_forwardRotation(){return function(,){return +=,[>?-:<-?+:,];};}function d3_geo_rotation(){var rotation=d3_geo_forwardRotation();rotation.invert=d3_geo_forwardRotation(-);return rotation;}function d3_geo_rotation(,){var cos=Math.cos(),sin=Math.sin(),cos=Math.cos(),sin=Math.sin();function rotation(,){var cos=Math.cos(),x=Math.cos()*cos,y=Math.sin()*cos,z=Math.sin(),k=z*cos+x*sin;return[Math.atan2(y*cos-k*sin,x*cos-z*sin),d3_asin(k*cos+y*sin)];}rotation.invert=function(,){var cos=Math.cos(),x=Math.cos()*cos,y=Math.sin()*cos,z=Math.sin(),k=z*cos-y*sin;return[Math.atan2(y*cos+z*sin,x*cos+k*sin),d3_asin(k*cos-x*sin)];};return rotation;}d3.geo.circle=function(){var origin=[0,0],angle,precision=6,interpolate;function circle(){var center=typeof origin===\"function\"?origin.apply(this,arguments):origin,rotate=d3_geo_rotation(-center[0]*d3_radians,-center[1]*d3_radians,0).invert,ring=[];interpolate(null,null,1,{point:function point(x,y){ring.push(x=rotate(x,y));x[0]*=d3_degrees,x[1]*=d3_degrees;}});return{type:\"Polygon\",coordinates:[ring]};}circle.origin=function(x){if(!arguments.length)return origin;origin=x;return circle;};circle.angle=function(x){if(!arguments.length)return angle;interpolate=d3_geo_circleInterpolate((angle=+x)*d3_radians,precision*d3_radians);return circle;};circle.precision=function(_){if(!arguments.length)return precision;interpolate=d3_geo_circleInterpolate(angle*d3_radians,(precision=+_)*d3_radians);return circle;};return circle.angle(90);};function d3_geo_circleInterpolate(radius,precision){var cr=Math.cos(radius),sr=Math.sin(radius);return function(from,to,direction,listener){var step=direction*precision;if(from!=null){from=d3_geo_circleAngle(cr,from);to=d3_geo_circleAngle(cr,to);if(direction>0?from<to:from>to)from+=direction*;}else{from=radius+direction*;to=radius-.5*step;}for(var point,t=from;direction>0?t>to:t<to;t-=step){listener.point((point=d3_geo_spherical([cr,-sr*Math.cos(t),-sr*Math.sin(t)]))[0],point[1]);}};}function d3_geo_circleAngle(cr,point){var a=d3_geo_cartesian(point);a[0]-=cr;d3_geo_cartesianNormalize(a);var angle=d3_acos(-a[1]);return((-a[2]<0?-angle:angle)+2*Math.PI-)%(2*Math.PI);}d3.geo.distance=function(a,b){var =(b[0]-a[0])*d3_radians,0=a[1]*d3_radians,1=b[1]*d3_radians,sin=Math.sin(),cos=Math.cos(),sin0=Math.sin(0),cos0=Math.cos(0),sin1=Math.sin(1),cos1=Math.cos(1),t;return Math.atan2(Math.sqrt((t=cos1*sin)*t+(t=cos0*sin1-sin0*cos1*cos)*t),sin0*sin1+cos0*cos1*cos);};d3.geo.graticule=function(){var x1,x0,X1,X0,y1,y0,Y1,Y0,dx=10,dy=dx,DX=90,DY=360,x,y,X,Y,precision=2.5;function graticule(){return{type:\"MultiLineString\",coordinates:lines()};}function lines(){return d3.range(Math.ceil(X0/DX)*DX,X1,DX).map(X).concat(d3.range(Math.ceil(Y0/DY)*DY,Y1,DY).map(Y)).concat(d3.range(Math.ceil(x0/dx)*dx,x1,dx).filter(function(x){return abs(x%DX)>;}).map(x)).concat(d3.range(Math.ceil(y0/dy)*dy,y1,dy).filter(function(y){return abs(y%DY)>;}).map(y));}graticule.lines=function(){return lines().map(function(coordinates){return{type:\"LineString\",coordinates:coordinates};});};graticule.outline=function(){return{type:\"Polygon\",coordinates:[X(X0).concat(Y(Y1).slice(1),X(X1).reverse().slice(1),Y(Y0).reverse().slice(1))]};};graticule.extent=function(_){if(!arguments.length)return graticule.minorExtent();return graticule.majorExtent(_).minorExtent(_);};graticule.majorExtent=function(_){if(!arguments.length)return[[X0,Y0],[X1,Y1]];X0=+_[0][0],X1=+_[1][0];Y0=+_[0][1],Y1=+_[1][1];if(X0>X1)_=X0,X0=X1,X1=_;if(Y0>Y1)_=Y0,Y0=Y1,Y1=_;return graticule.precision(precision);};graticule.minorExtent=function(_){if(!arguments.length)return[[x0,y0],[x1,y1]];x0=+_[0][0],x1=+_[1][0];y0=+_[0][1],y1=+_[1][1];if(x0>x1)_=x0,x0=x1,x1=_;if(y0>y1)_=y0,y0=y1,y1=_;return graticule.precision(precision);};graticule.step=function(_){if(!arguments.length)return graticule.minorStep();return graticule.majorStep(_).minorStep(_);};graticule.majorStep=function(_){if(!arguments.length)return[DX,DY];DX=+_[0],DY=+_[1];return graticule;};graticule.minorStep=function(_){if(!arguments.length)return[dx,dy];dx=+_[0],dy=+_[1];return graticule;};graticule.precision=function(_){if(!arguments.length)return precision;precision=+_;x=d3_geo_graticuleX(y0,y1,90);y=d3_geo_graticuleY(x0,x1,precision);X=d3_geo_graticuleX(Y0,Y1,90);Y=d3_geo_graticuleY(X0,X1,precision);return graticule;};return graticule.majorExtent([[-180,-90+],[180,90-]]).minorExtent([[-180,-80-],[180,80+]]);};function d3_geo_graticuleX(y0,y1,dy){var y=d3.range(y0,y1-,dy).concat(y1);return function(x){return y.map(function(y){return[x,y];});};}function d3_geo_graticuleY(x0,x1,dx){var x=d3.range(x0,x1-,dx).concat(x1);return function(y){return x.map(function(x){return[x,y];});};}function d3_source(d){return d.source;}function d3_target(d){return d.target;}d3.geo.greatArc=function(){var source=d3_source,source_,target=d3_target,target_;function greatArc(){return{type:\"LineString\",coordinates:[source_||source.apply(this,arguments),target_||target.apply(this,arguments)]};}greatArc.distance=function(){return d3.geo.distance(source_||source.apply(this,arguments),target_||target.apply(this,arguments));};greatArc.source=function(_){if(!arguments.length)return source;source=_,source_=typeof _===\"function\"?null:_;return greatArc;};greatArc.target=function(_){if(!arguments.length)return target;target=_,target_=typeof _===\"function\"?null:_;return greatArc;};greatArc.precision=function(){return arguments.length?greatArc:0;};return greatArc;};d3.geo.interpolate=function(source,target){return d3_geo_interpolate(source[0]*d3_radians,source[1]*d3_radians,target[0]*d3_radians,target[1]*d3_radians);};function d3_geo_interpolate(x0,y0,x1,y1){var cy0=Math.cos(y0),sy0=Math.sin(y0),cy1=Math.cos(y1),sy1=Math.sin(y1),kx0=cy0*Math.cos(x0),ky0=cy0*Math.sin(x0),kx1=cy1*Math.cos(x1),ky1=cy1*Math.sin(x1),d=2*Math.asin(Math.sqrt(d3_haversin(y1-y0)+cy0*cy1*d3_haversin(x1-x0))),k=1/Math.sin(d);var interpolate=d?function(t){var B=Math.sin(t*=d)*k,A=Math.sin(d-t)*k,x=A*kx0+B*kx1,y=A*ky0+B*ky1,z=A*sy0+B*sy1;return[Math.atan2(y,x)*d3_degrees,Math.atan2(z,Math.sqrt(x*x+y*y))*d3_degrees];}:function(){return[x0*d3_degrees,y0*d3_degrees];};interpolate.distance=d;return interpolate;}d3.geo.length=function(object){d3_geo_lengthSum=0;d3.geo.stream(object,d3_geo_length);return d3_geo_lengthSum;};var d3_geo_lengthSum;var d3_geo_length={sphere:d3_noop,point:d3_noop,lineStart:d3_geo_lengthLineStart,lineEnd:d3_noop,polygonStart:d3_noop,polygonEnd:d3_noop};function d3_geo_lengthLineStart(){var 0,sin0,cos0;d3_geo_length.point=function(,){0=*d3_radians,sin0=Math.sin(*=d3_radians),cos0=Math.cos();d3_geo_length.point=nextPoint;};d3_geo_length.lineEnd=function(){d3_geo_length.point=d3_geo_length.lineEnd=d3_noop;};function nextPoint(,){var sin=Math.sin(*=d3_radians),cos=Math.cos(),t=abs((*=d3_radians)-0),cos=Math.cos(t);d3_geo_lengthSum+=Math.atan2(Math.sqrt((t=cos*Math.sin(t))*t+(t=cos0*sin-sin0*cos*cos)*t),sin0*sin+cos0*cos*cos);0=,sin0=sin,cos0=cos;}}function d3_geo_azimuthal(scale,angle){function azimuthal(,){var cos=Math.cos(),cos=Math.cos(),k=scale(cos*cos);return[k*cos*Math.sin(),k*Math.sin()];}azimuthal.invert=function(x,y){var =Math.sqrt(x*x+y*y),c=angle(),sinc=Math.sin(c),cosc=Math.cos(c);return[Math.atan2(x*sinc,*cosc),Math.asin(&&y*sinc/)];};return azimuthal;}var d3_geo_azimuthalEqualArea=d3_geo_azimuthal(function(coscos){return Math.sqrt(2/(1+coscos));},function(){return 2*Math.asin(/2);});(d3.geo.azimuthalEqualArea=function(){return d3_geo_projection(d3_geo_azimuthalEqualArea);}).raw=d3_geo_azimuthalEqualArea;var d3_geo_azimuthalEquidistant=d3_geo_azimuthal(function(coscos){var c=Math.acos(coscos);return c&&c/Math.sin(c);},d3_identity);(d3.geo.azimuthalEquidistant=function(){return d3_geo_projection(d3_geo_azimuthalEquidistant);}).raw=d3_geo_azimuthalEquidistant;function d3_geo_conicConformal(0,1){var cos0=Math.cos(0),t=function t(){return Math.tan(/4+/2);},n=0===1?Math.sin(0):Math.log(cos0/Math.cos(1))/Math.log(t(1)/t(0)),F=cos0*Math.pow(t(0),n)/n;if(!n)return d3_geo_mercator;function forward(,){if(F>0){if(<-half+)=-half+;}else{if(>half-)=half-;}var =F/Math.pow(t(),n);return[*Math.sin(n*),F-*Math.cos(n*)];}forward.invert=function(x,y){var 0_y=F-y,=d3_sgn(n)*Math.sqrt(x*x+0_y*0_y);return[Math.atan2(x,0_y)/n,2*Math.atan(Math.pow(F/,1/n))-half];};return forward;}(d3.geo.conicConformal=function(){return d3_geo_conic(d3_geo_conicConformal);}).raw=d3_geo_conicConformal;function d3_geo_conicEquidistant(0,1){var cos0=Math.cos(0),n=0===1?Math.sin(0):(cos0-Math.cos(1))/(1-0),G=cos0/n+0;if(abs(n)<)return d3_geo_equirectangular;function forward(,){var =G-;return[*Math.sin(n*),G-*Math.cos(n*)];}forward.invert=function(x,y){var 0_y=G-y;return[Math.atan2(x,0_y)/n,G-d3_sgn(n)*Math.sqrt(x*x+0_y*0_y)];};return forward;}(d3.geo.conicEquidistant=function(){return d3_geo_conic(d3_geo_conicEquidistant);}).raw=d3_geo_conicEquidistant;var d3_geo_gnomonic=d3_geo_azimuthal(function(coscos){return 1/coscos;},Math.atan);(d3.geo.gnomonic=function(){return d3_geo_projection(d3_geo_gnomonic);}).raw=d3_geo_gnomonic;function d3_geo_mercator(,){return[,Math.log(Math.tan(/4+/2))];}d3_geo_mercator.invert=function(x,y){return[x,2*Math.atan(Math.exp(y))-half];};function d3_geo_mercatorProjection(project){var m=d3_geo_projection(project),scale=m.scale,translate=m.translate,clipExtent=m.clipExtent,clipAuto;m.scale=function(){var v=scale.apply(m,arguments);return v===m?clipAuto?m.clipExtent(null):m:v;};m.translate=function(){var v=translate.apply(m,arguments);return v===m?clipAuto?m.clipExtent(null):m:v;};m.clipExtent=function(_){var v=clipExtent.apply(m,arguments);if(v===m){if(clipAuto=_==null){var k=*scale(),t=translate();clipExtent([[t[0]-k,t[1]-k],[t[0]+k,t[1]+k]]);}}else if(clipAuto){v=null;}return v;};return m.clipExtent(null);}(d3.geo.mercator=function(){return d3_geo_mercatorProjection(d3_geo_mercator);}).raw=d3_geo_mercator;var d3_geo_orthographic=d3_geo_azimuthal(function(){return 1;},Math.asin);(d3.geo.orthographic=function(){return d3_geo_projection(d3_geo_orthographic);}).raw=d3_geo_orthographic;var d3_geo_stereographic=d3_geo_azimuthal(function(coscos){return 1/(1+coscos);},function(){return 2*Math.atan();});(d3.geo.stereographic=function(){return d3_geo_projection(d3_geo_stereographic);}).raw=d3_geo_stereographic;function d3_geo_transverseMercator(,){return[Math.log(Math.tan(/4+/2)),-];}d3_geo_transverseMercator.invert=function(x,y){return[-y,2*Math.atan(Math.exp(x))-half];};(d3.geo.transverseMercator=function(){var projection=d3_geo_mercatorProjection(d3_geo_transverseMercator),center=projection.center,rotate=projection.rotate;projection.center=function(_){return _?center([-_[1],_[0]]):(_=center(),[_[1],-_[0]]);};projection.rotate=function(_){return _?rotate([_[0],_[1],_.length>2?_[2]+90:90]):(_=rotate(),[_[0],_[1],_[2]-90]);};return rotate([0,0,90]);}).raw=d3_geo_transverseMercator;d3.geom={};function d3_geom_pointX(d){return d[0];}function d3_geom_pointY(d){return d[1];}d3.geom.hull=function(vertices){var x=d3_geom_pointX,y=d3_geom_pointY;if(arguments.length)return hull(vertices);function hull(data){if(data.length<3)return[];var fx=d3_functor(x),fy=d3_functor(y),i,n=data.length,points=[],flippedPoints=[];for(i=0;i<n;i++){points.push([+fx.call(this,data[i],i),+fy.call(this,data[i],i),i]);}points.sort(d3_geom_hullOrder);for(i=0;i<n;i++){flippedPoints.push([points[i][0],-points[i][1]]);}var upper=d3_geom_hullUpper(points),lower=d3_geom_hullUpper(flippedPoints);var skipLeft=lower[0]===upper[0],skipRight=lower[lower.length-1]===upper[upper.length-1],polygon=[];for(i=upper.length-1;i>=0;--i){polygon.push(data[points[upper[i]][2]]);}for(i=+skipLeft;i<lower.length-skipRight;++i){polygon.push(data[points[lower[i]][2]]);}return polygon;}hull.x=function(_){return arguments.length?(x=_,hull):x;};hull.y=function(_){return arguments.length?(y=_,hull):y;};return hull;};function d3_geom_hullUpper(points){var n=points.length,hull=[0,1],hs=2;for(var i=2;i<n;i++){while(hs>1&&d3_cross2d(points[hull[hs-2]],points[hull[hs-1]],points[i])<=0){--hs;}hull[hs++]=i;}return hull.slice(0,hs);}function d3_geom_hullOrder(a,b){return a[0]-b[0]||a[1]-b[1];}d3.geom.polygon=function(coordinates){d3_subclass(coordinates,d3_geom_polygonPrototype);return coordinates;};var d3_geom_polygonPrototype=d3.geom.polygon.prototype=[];d3_geom_polygonPrototype.area=function(){var i=-1,n=this.length,a,b=this[n-1],area=0;while(++i<n){a=b;b=this[i];area+=a[1]*b[0]-a[0]*b[1];}return area*.5;};d3_geom_polygonPrototype.centroid=function(k){var i=-1,n=this.length,x=0,y=0,a,b=this[n-1],c;if(!arguments.length)k=-1/(6*this.area());while(++i<n){a=b;b=this[i];c=a[0]*b[1]-b[0]*a[1];x+=(a[0]+b[0])*c;y+=(a[1]+b[1])*c;}return[x*k,y*k];};d3_geom_polygonPrototype.clip=function(subject){var input,closed=d3_geom_polygonClosed(subject),i=-1,n=this.length-d3_geom_polygonClosed(this),j,m,a=this[n-1],b,c,d;while(++i<n){input=subject.slice();subject.length=0;b=this[i];c=input[(m=input.length-closed)-1];j=-1;while(++j<m){d=input[j];if(d3_geom_polygonInside(d,a,b)){if(!d3_geom_polygonInside(c,a,b)){subject.push(d3_geom_polygonIntersect(c,d,a,b));}subject.push(d);}else if(d3_geom_polygonInside(c,a,b)){subject.push(d3_geom_polygonIntersect(c,d,a,b));}c=d;}if(closed)subject.push(subject[0]);a=b;}return subject;};function d3_geom_polygonInside(p,a,b){return(b[0]-a[0])*(p[1]-a[1])<(b[1]-a[1])*(p[0]-a[0]);}function d3_geom_polygonIntersect(c,d,a,b){var x1=c[0],x3=a[0],x21=d[0]-x1,x43=b[0]-x3,y1=c[1],y3=a[1],y21=d[1]-y1,y43=b[1]-y3,ua=(x43*(y1-y3)-y43*(x1-x3))/(y43*x21-x43*y21);return[x1+ua*x21,y1+ua*y21];}function d3_geom_polygonClosed(coordinates){var a=coordinates[0],b=coordinates[coordinates.length-1];return!(a[0]-b[0]||a[1]-b[1]);}var d3_geom_voronoiEdges,d3_geom_voronoiCells,d3_geom_voronoiBeaches,d3_geom_voronoiBeachPool=[],d3_geom_voronoiFirstCircle,d3_geom_voronoiCircles,d3_geom_voronoiCirclePool=[];function d3_geom_voronoiBeach(){d3_geom_voronoiRedBlackNode(this);this.edge=this.site=this.circle=null;}function d3_geom_voronoiCreateBeach(site){var beach=d3_geom_voronoiBeachPool.pop()||new d3_geom_voronoiBeach();beach.site=site;return beach;}function d3_geom_voronoiDetachBeach(beach){d3_geom_voronoiDetachCircle(beach);d3_geom_voronoiBeaches.remove(beach);d3_geom_voronoiBeachPool.push(beach);d3_geom_voronoiRedBlackNode(beach);}function d3_geom_voronoiRemoveBeach(beach){var circle=beach.circle,x=circle.x,y=circle.cy,vertex={x:x,y:y},previous=beach.P,next=beach.N,disappearing=[beach];d3_geom_voronoiDetachBeach(beach);var lArc=previous;while(lArc.circle&&abs(x-lArc.circle.x)<&&abs(y-lArc.circle.cy)<){previous=lArc.P;disappearing.unshift(lArc);d3_geom_voronoiDetachBeach(lArc);lArc=previous;}disappearing.unshift(lArc);d3_geom_voronoiDetachCircle(lArc);var rArc=next;while(rArc.circle&&abs(x-rArc.circle.x)<&&abs(y-rArc.circle.cy)<){next=rArc.N;disappearing.push(rArc);d3_geom_voronoiDetachBeach(rArc);rArc=next;}disappearing.push(rArc);d3_geom_voronoiDetachCircle(rArc);var nArcs=disappearing.length,iArc;for(iArc=1;iArc<nArcs;++iArc){rArc=disappearing[iArc];lArc=disappearing[iArc-1];d3_geom_voronoiSetEdgeEnd(rArc.edge,lArc.site,rArc.site,vertex);}lArc=disappearing[0];rArc=disappearing[nArcs-1];rArc.edge=d3_geom_voronoiCreateEdge(lArc.site,rArc.site,null,vertex);d3_geom_voronoiAttachCircle(lArc);d3_geom_voronoiAttachCircle(rArc);}function d3_geom_voronoiAddBeach(site){var x=site.x,directrix=site.y,lArc,rArc,dxl,dxr,node=d3_geom_voronoiBeaches._;while(node){dxl=d3_geom_voronoiLeftBreakPoint(node,directrix)-x;if(dxl>)node=node.L;else{dxr=x-d3_geom_voronoiRightBreakPoint(node,directrix);if(dxr>){if(!node.R){lArc=node;break;}node=node.R;}else{if(dxl>-){lArc=node.P;rArc=node;}else if(dxr>-){lArc=node;rArc=node.N;}else{lArc=rArc=node;}break;}}}var newArc=d3_geom_voronoiCreateBeach(site);d3_geom_voronoiBeaches.insert(lArc,newArc);if(!lArc&&!rArc)return;if(lArc===rArc){d3_geom_voronoiDetachCircle(lArc);rArc=d3_geom_voronoiCreateBeach(lArc.site);d3_geom_voronoiBeaches.insert(newArc,rArc);newArc.edge=rArc.edge=d3_geom_voronoiCreateEdge(lArc.site,newArc.site);d3_geom_voronoiAttachCircle(lArc);d3_geom_voronoiAttachCircle(rArc);return;}if(!rArc){newArc.edge=d3_geom_voronoiCreateEdge(lArc.site,newArc.site);return;}d3_geom_voronoiDetachCircle(lArc);d3_geom_voronoiDetachCircle(rArc);var lSite=lArc.site,ax=lSite.x,ay=lSite.y,bx=site.x-ax,by=site.y-ay,rSite=rArc.site,cx=rSite.x-ax,cy=rSite.y-ay,d=2*(bx*cy-by*cx),hb=bx*bx+by*by,hc=cx*cx+cy*cy,vertex={x:(cy*hb-by*hc)/d+ax,y:(bx*hc-cx*hb)/d+ay};d3_geom_voronoiSetEdgeEnd(rArc.edge,lSite,rSite,vertex);newArc.edge=d3_geom_voronoiCreateEdge(lSite,site,null,vertex);rArc.edge=d3_geom_voronoiCreateEdge(site,rSite,null,vertex);d3_geom_voronoiAttachCircle(lArc);d3_geom_voronoiAttachCircle(rArc);}function d3_geom_voronoiLeftBreakPoint(arc,directrix){var site=arc.site,rfocx=site.x,rfocy=site.y,pby2=rfocy-directrix;if(!pby2)return rfocx;var lArc=arc.P;if(!lArc)return-Infinity;site=lArc.site;var lfocx=site.x,lfocy=site.y,plby2=lfocy-directrix;if(!plby2)return lfocx;var hl=lfocx-rfocx,aby2=1/pby2-1/plby2,b=hl/plby2;if(aby2)return(-b+Math.sqrt(b*b-2*aby2*(hl*hl/(-2*plby2)-lfocy+plby2/2+rfocy-pby2/2)))/aby2+rfocx;return(rfocx+lfocx)/2;}function d3_geom_voronoiRightBreakPoint(arc,directrix){var rArc=arc.N;if(rArc)return d3_geom_voronoiLeftBreakPoint(rArc,directrix);var site=arc.site;return site.y===directrix?site.x:Infinity;}function d3_geom_voronoiCell(site){this.site=site;this.edges=[];}d3_geom_voronoiCell.prototype.prepare=function(){var halfEdges=this.edges,iHalfEdge=halfEdges.length,edge;while(iHalfEdge--){edge=halfEdges[iHalfEdge].edge;if(!edge.b||!edge.a)halfEdges.splice(iHalfEdge,1);}halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);return halfEdges.length;};function d3_geom_voronoiCloseCells(extent){var x0=extent[0][0],x1=extent[1][0],y0=extent[0][1],y1=extent[1][1],x2,y2,x3,y3,cells=d3_geom_voronoiCells,iCell=cells.length,cell,iHalfEdge,halfEdges,nHalfEdges,start,end;while(iCell--){cell=cells[iCell];if(!cell||!cell.prepare())continue;halfEdges=cell.edges;nHalfEdges=halfEdges.length;iHalfEdge=0;while(iHalfEdge<nHalfEdges){end=halfEdges[iHalfEdge].end(),x3=end.x,y3=end.y;start=halfEdges[++iHalfEdge%nHalfEdges].start(),x2=start.x,y2=start.y;if(abs(x3-x2)>||abs(y3-y2)>){halfEdges.splice(iHalfEdge,0,new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site,end,abs(x3-x0)<&&y1-y3>?{x:x0,y:abs(x2-x0)<?y2:y1}:abs(y3-y1)<&&x1-x3>?{x:abs(y2-y1)<?x2:x1,y:y1}:abs(x3-x1)<&&y3-y0>?{x:x1,y:abs(x2-x1)<?y2:y0}:abs(y3-y0)<&&x3-x0>?{x:abs(y2-y0)<?x2:x0,y:y0}:null),cell.site,null));++nHalfEdges;}}}}function d3_geom_voronoiHalfEdgeOrder(a,b){return b.angle-a.angle;}function d3_geom_voronoiCircle(){d3_geom_voronoiRedBlackNode(this);this.x=this.y=this.arc=this.site=this.cy=null;}function d3_geom_voronoiAttachCircle(arc){var lArc=arc.P,rArc=arc.N;if(!lArc||!rArc)return;var lSite=lArc.site,cSite=arc.site,rSite=rArc.site;if(lSite===rSite)return;var bx=cSite.x,by=cSite.y,ax=lSite.x-bx,ay=lSite.y-by,cx=rSite.x-bx,cy=rSite.y-by;var d=2*(ax*cy-ay*cx);if(d>=-2)return;var ha=ax*ax+ay*ay,hc=cx*cx+cy*cy,x=(cy*ha-ay*hc)/d,y=(ax*hc-cx*ha)/d,cy=y+by;var circle=d3_geom_voronoiCirclePool.pop()||new d3_geom_voronoiCircle();circle.arc=arc;circle.site=cSite;circle.x=x+bx;circle.y=cy+Math.sqrt(x*x+y*y);circle.cy=cy;arc.circle=circle;var before=null,node=d3_geom_voronoiCircles._;while(node){if(circle.y<node.y||circle.y===node.y&&circle.x<=node.x){if(node.L)node=node.L;else{before=node.P;break;}}else{if(node.R)node=node.R;else{before=node;break;}}}d3_geom_voronoiCircles.insert(before,circle);if(!before)d3_geom_voronoiFirstCircle=circle;}function d3_geom_voronoiDetachCircle(arc){var circle=arc.circle;if(circle){if(!circle.P)d3_geom_voronoiFirstCircle=circle.N;d3_geom_voronoiCircles.remove(circle);d3_geom_voronoiCirclePool.push(circle);d3_geom_voronoiRedBlackNode(circle);arc.circle=null;}}function d3_geom_voronoiClipEdges(extent){var edges=d3_geom_voronoiEdges,clip=d3_geom_clipLine(extent[0][0],extent[0][1],extent[1][0],extent[1][1]),i=edges.length,e;while(i--){e=edges[i];if(!d3_geom_voronoiConnectEdge(e,extent)||!clip(e)||abs(e.a.x-e.b.x)<&&abs(e.a.y-e.b.y)<){e.a=e.b=null;edges.splice(i,1);}}}function d3_geom_voronoiConnectEdge(edge,extent){var vb=edge.b;if(vb)return true;var va=edge.a,x0=extent[0][0],x1=extent[1][0],y0=extent[0][1],y1=extent[1][1],lSite=edge.l,rSite=edge.r,lx=lSite.x,ly=lSite.y,rx=rSite.x,ry=rSite.y,fx=(lx+rx)/2,fy=(ly+ry)/2,fm,fb;if(ry===ly){if(fx<x0||fx>=x1)return;if(lx>rx){if(!va)va={x:fx,y:y0};else if(va.y>=y1)return;vb={x:fx,y:y1};}else{if(!va)va={x:fx,y:y1};else if(va.y<y0)return;vb={x:fx,y:y0};}}else{fm=(lx-rx)/(ry-ly);fb=fy-fm*fx;if(fm<-1||fm>1){if(lx>rx){if(!va)va={x:(y0-fb)/fm,y:y0};else if(va.y>=y1)return;vb={x:(y1-fb)/fm,y:y1};}else{if(!va)va={x:(y1-fb)/fm,y:y1};else if(va.y<y0)return;vb={x:(y0-fb)/fm,y:y0};}}else{if(ly<ry){if(!va)va={x:x0,y:fm*x0+fb};else if(va.x>=x1)return;vb={x:x1,y:fm*x1+fb};}else{if(!va)va={x:x1,y:fm*x1+fb};else if(va.x<x0)return;vb={x:x0,y:fm*x0+fb};}}}edge.a=va;edge.b=vb;return true;}function d3_geom_voronoiEdge(lSite,rSite){this.l=lSite;this.r=rSite;this.a=this.b=null;}function d3_geom_voronoiCreateEdge(lSite,rSite,va,vb){var edge=new d3_geom_voronoiEdge(lSite,rSite);d3_geom_voronoiEdges.push(edge);if(va)d3_geom_voronoiSetEdgeEnd(edge,lSite,rSite,va);if(vb)d3_geom_voronoiSetEdgeEnd(edge,rSite,lSite,vb);d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge,lSite,rSite));d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge,rSite,lSite));return edge;}function d3_geom_voronoiCreateBorderEdge(lSite,va,vb){var edge=new d3_geom_voronoiEdge(lSite,null);edge.a=va;edge.b=vb;d3_geom_voronoiEdges.push(edge);return edge;}function d3_geom_voronoiSetEdgeEnd(edge,lSite,rSite,vertex){if(!edge.a&&!edge.b){edge.a=vertex;edge.l=lSite;edge.r=rSite;}else if(edge.l===rSite){edge.b=vertex;}else{edge.a=vertex;}}function d3_geom_voronoiHalfEdge(edge,lSite,rSite){var va=edge.a,vb=edge.b;this.edge=edge;this.site=lSite;this.angle=rSite?Math.atan2(rSite.y-lSite.y,rSite.x-lSite.x):edge.l===lSite?Math.atan2(vb.x-va.x,va.y-vb.y):Math.atan2(va.x-vb.x,vb.y-va.y);}d3_geom_voronoiHalfEdge.prototype={start:function start(){return this.edge.l===this.site?this.edge.a:this.edge.b;},end:function end(){return this.edge.l===this.site?this.edge.b:this.edge.a;}};function d3_geom_voronoiRedBlackTree(){this._=null;}function d3_geom_voronoiRedBlackNode(node){node.U=node.C=node.L=node.R=node.P=node.N=null;}d3_geom_voronoiRedBlackTree.prototype={insert:function insert(after,node){var parent,grandpa,uncle;if(after){node.P=after;node.N=after.N;if(after.N)after.N.P=node;after.N=node;if(after.R){after=after.R;while(after.L){after=after.L;}after.L=node;}else{after.R=node;}parent=after;}else if(this._){after=d3_geom_voronoiRedBlackFirst(this._);node.P=null;node.N=after;after.P=after.L=node;parent=after;}else{node.P=node.N=null;this._=node;parent=null;}node.L=node.R=null;node.U=parent;node.C=true;after=node;while(parent&&parent.C){grandpa=parent.U;if(parent===grandpa.L){uncle=grandpa.R;if(uncle&&uncle.C){parent.C=uncle.C=false;grandpa.C=true;after=grandpa;}else{if(after===parent.R){d3_geom_voronoiRedBlackRotateLeft(this,parent);after=parent;parent=after.U;}parent.C=false;grandpa.C=true;d3_geom_voronoiRedBlackRotateRight(this,grandpa);}}else{uncle=grandpa.L;if(uncle&&uncle.C){parent.C=uncle.C=false;grandpa.C=true;after=grandpa;}else{if(after===parent.L){d3_geom_voronoiRedBlackRotateRight(this,parent);after=parent;parent=after.U;}parent.C=false;grandpa.C=true;d3_geom_voronoiRedBlackRotateLeft(this,grandpa);}}parent=after.U;}this._.C=false;},remove:function remove(node){if(node.N)node.N.P=node.P;if(node.P)node.P.N=node.N;node.N=node.P=null;var parent=node.U,sibling,left=node.L,right=node.R,next,red;if(!left)next=right;else if(!right)next=left;else next=d3_geom_voronoiRedBlackFirst(right);if(parent){if(parent.L===node)parent.L=next;else parent.R=next;}else{this._=next;}if(left&&right){red=next.C;next.C=node.C;next.L=left;left.U=next;if(next!==right){parent=next.U;next.U=node.U;node=next.R;parent.L=node;next.R=right;right.U=next;}else{next.U=parent;parent=next;node=next.R;}}else{red=node.C;node=next;}if(node)node.U=parent;if(red)return;if(node&&node.C){node.C=false;return;}do{if(node===this._)break;if(node===parent.L){sibling=parent.R;if(sibling.C){sibling.C=false;parent.C=true;d3_geom_voronoiRedBlackRotateLeft(this,parent);sibling=parent.R;}if(sibling.L&&sibling.L.C||sibling.R&&sibling.R.C){if(!sibling.R||!sibling.R.C){sibling.L.C=false;sibling.C=true;d3_geom_voronoiRedBlackRotateRight(this,sibling);sibling=parent.R;}sibling.C=parent.C;parent.C=sibling.R.C=false;d3_geom_voronoiRedBlackRotateLeft(this,parent);node=this._;break;}}else{sibling=parent.L;if(sibling.C){sibling.C=false;parent.C=true;d3_geom_voronoiRedBlackRotateRight(this,parent);sibling=parent.L;}if(sibling.L&&sibling.L.C||sibling.R&&sibling.R.C){if(!sibling.L||!sibling.L.C){sibling.R.C=false;sibling.C=true;d3_geom_voronoiRedBlackRotateLeft(this,sibling);sibling=parent.L;}sibling.C=parent.C;parent.C=sibling.L.C=false;d3_geom_voronoiRedBlackRotateRight(this,parent);node=this._;break;}}sibling.C=true;node=parent;parent=parent.U;}while(!node.C);if(node)node.C=false;}};function d3_geom_voronoiRedBlackRotateLeft(tree,node){var p=node,q=node.R,parent=p.U;if(parent){if(parent.L===p)parent.L=q;else parent.R=q;}else{tree._=q;}q.U=parent;p.U=q;p.R=q.L;if(p.R)p.R.U=p;q.L=p;}function d3_geom_voronoiRedBlackRotateRight(tree,node){var p=node,q=node.L,parent=p.U;if(parent){if(parent.L===p)parent.L=q;else parent.R=q;}else{tree._=q;}q.U=parent;p.U=q;p.L=q.R;if(p.L)p.L.U=p;q.R=p;}function d3_geom_voronoiRedBlackFirst(node){while(node.L){node=node.L;}return node;}function d3_geom_voronoi(sites,bbox){var site=sites.sort(d3_geom_voronoiVertexOrder).pop(),x0,y0,circle;d3_geom_voronoiEdges=[];d3_geom_voronoiCells=new Array(sites.length);d3_geom_voronoiBeaches=new d3_geom_voronoiRedBlackTree();d3_geom_voronoiCircles=new d3_geom_voronoiRedBlackTree();while(true){circle=d3_geom_voronoiFirstCircle;if(site&&(!circle||site.y<circle.y||site.y===circle.y&&site.x<circle.x)){if(site.x!==x0||site.y!==y0){d3_geom_voronoiCells[site.i]=new d3_geom_voronoiCell(site);d3_geom_voronoiAddBeach(site);x0=site.x,y0=site.y;}site=sites.pop();}else if(circle){d3_geom_voronoiRemoveBeach(circle.arc);}else{break;}}if(bbox)d3_geom_voronoiClipEdges(bbox),d3_geom_voronoiCloseCells(bbox);var diagram={cells:d3_geom_voronoiCells,edges:d3_geom_voronoiEdges};d3_geom_voronoiBeaches=d3_geom_voronoiCircles=d3_geom_voronoiEdges=d3_geom_voronoiCells=null;return diagram;}function d3_geom_voronoiVertexOrder(a,b){return b.y-a.y||b.x-a.x;}d3.geom.voronoi=function(points){var x=d3_geom_pointX,y=d3_geom_pointY,fx=x,fy=y,clipExtent=d3_geom_voronoiClipExtent;if(points)return voronoi(points);function voronoi(data){var polygons=new Array(data.length),x0=clipExtent[0][0],y0=clipExtent[0][1],x1=clipExtent[1][0],y1=clipExtent[1][1];d3_geom_voronoi(sites(data),clipExtent).cells.forEach(function(cell,i){var edges=cell.edges,site=cell.site,polygon=polygons[i]=edges.length?edges.map(function(e){var s=e.start();return[s.x,s.y];}):site.x>=x0&&site.x<=x1&&site.y>=y0&&site.y<=y1?[[x0,y1],[x1,y1],[x1,y0],[x0,y0]]:[];polygon.point=data[i];});return polygons;}function sites(data){return data.map(function(d,i){return{x:Math.round(fx(d,i)/)*,y:Math.round(fy(d,i)/)*,i:i};});}voronoi.links=function(data){return d3_geom_voronoi(sites(data)).edges.filter(function(edge){return edge.l&&edge.r;}).map(function(edge){return{source:data[edge.l.i],target:data[edge.r.i]};});};voronoi.triangles=function(data){var triangles=[];d3_geom_voronoi(sites(data)).cells.forEach(function(cell,i){var site=cell.site,edges=cell.edges.sort(d3_geom_voronoiHalfEdgeOrder),j=-1,m=edges.length,e0,s0,e1=edges[m-1].edge,s1=e1.l===site?e1.r:e1.l;while(++j<m){e0=e1;s0=s1;e1=edges[j].edge;s1=e1.l===site?e1.r:e1.l;if(i<s0.i&&i<s1.i&&d3_geom_voronoiTriangleArea(site,s0,s1)<0){triangles.push([data[i],data[s0.i],data[s1.i]]);}}});return triangles;};voronoi.x=function(_){return arguments.length?(fx=d3_functor(x=_),voronoi):x;};voronoi.y=function(_){return arguments.length?(fy=d3_functor(y=_),voronoi):y;};voronoi.clipExtent=function(_){if(!arguments.length)return clipExtent===d3_geom_voronoiClipExtent?null:clipExtent;clipExtent=_==null?d3_geom_voronoiClipExtent:_;return voronoi;};voronoi.size=function(_){if(!arguments.length)return clipExtent===d3_geom_voronoiClipExtent?null:clipExtent&&clipExtent[1];return voronoi.clipExtent(_&&[[0,0],_]);};return voronoi;};var d3_geom_voronoiClipExtent=[[-1e6,-1e6],[1e6,1e6]];function d3_geom_voronoiTriangleArea(a,b,c){return(a.x-c.x)*(b.y-a.y)-(a.x-b.x)*(c.y-a.y);}d3.geom.delaunay=function(vertices){return d3.geom.voronoi().triangles(vertices);};d3.geom.quadtree=function(points,x1,y1,x2,y2){var x=d3_geom_pointX,y=d3_geom_pointY,compat;if(compat=arguments.length){x=d3_geom_quadtreeCompatX;y=d3_geom_quadtreeCompatY;if(compat===3){y2=y1;x2=x1;y1=x1=0;}return quadtree(points);}function quadtree(data){var d,fx=d3_functor(x),fy=d3_functor(y),xs,ys,i,n,x1_,y1_,x2_,y2_;if(x1!=null){x1_=x1,y1_=y1,x2_=x2,y2_=y2;}else{x2_=y2_=-(x1_=y1_=Infinity);xs=[],ys=[];n=data.length;if(compat)for(i=0;i<n;++i){d=data[i];if(d.x<x1_)x1_=d.x;if(d.y<y1_)y1_=d.y;if(d.x>x2_)x2_=d.x;if(d.y>y2_)y2_=d.y;xs.push(d.x);ys.push(d.y);}else for(i=0;i<n;++i){var x_=+fx(d=data[i],i),y_=+fy(d,i);if(x_<x1_)x1_=x_;if(y_<y1_)y1_=y_;if(x_>x2_)x2_=x_;if(y_>y2_)y2_=y_;xs.push(x_);ys.push(y_);}}var dx=x2_-x1_,dy=y2_-y1_;if(dx>dy)y2_=y1_+dx;else x2_=x1_+dy;function insert(n,d,x,y,x1,y1,x2,y2){if(isNaN(x)||isNaN(y))return;if(n.leaf){var nx=n.x,ny=n.y;if(nx!=null){if(abs(nx-x)+abs(ny-y)<.01){insertChild(n,d,x,y,x1,y1,x2,y2);}else{var nPoint=n.point;n.x=n.y=n.point=null;insertChild(n,nPoint,nx,ny,x1,y1,x2,y2);insertChild(n,d,x,y,x1,y1,x2,y2);}}else{n.x=x,n.y=y,n.point=d;}}else{insertChild(n,d,x,y,x1,y1,x2,y2);}}function insertChild(n,d,x,y,x1,y1,x2,y2){var xm=(x1+x2)*.5,ym=(y1+y2)*.5,right=x>=xm,below=y>=ym,i=below<<1|right;n.leaf=false;n=n.nodes[i]||(n.nodes[i]=d3_geom_quadtreeNode());if(right)x1=xm;else x2=xm;if(below)y1=ym;else y2=ym;insert(n,d,x,y,x1,y1,x2,y2);}var root=d3_geom_quadtreeNode();root.add=function(d){insert(root,d,+fx(d,++i),+fy(d,i),x1_,y1_,x2_,y2_);};root.visit=function(f){d3_geom_quadtreeVisit(f,root,x1_,y1_,x2_,y2_);};root.find=function(point){return d3_geom_quadtreeFind(root,point[0],point[1],x1_,y1_,x2_,y2_);};i=-1;if(x1==null){while(++i<n){insert(root,data[i],xs[i],ys[i],x1_,y1_,x2_,y2_);}--i;}else data.forEach(root.add);xs=ys=data=d=null;return root;}quadtree.x=function(_){return arguments.length?(x=_,quadtree):x;};quadtree.y=function(_){return arguments.length?(y=_,quadtree):y;};quadtree.extent=function(_){if(!arguments.length)return x1==null?null:[[x1,y1],[x2,y2]];if(_==null)x1=y1=x2=y2=null;else x1=+_[0][0],y1=+_[0][1],x2=+_[1][0],y2=+_[1][1];return quadtree;};quadtree.size=function(_){if(!arguments.length)return x1==null?null:[x2-x1,y2-y1];if(_==null)x1=y1=x2=y2=null;else x1=y1=0,x2=+_[0],y2=+_[1];return quadtree;};return quadtree;};function d3_geom_quadtreeCompatX(d){return d.x;}function d3_geom_quadtreeCompatY(d){return d.y;}function d3_geom_quadtreeNode(){return{leaf:true,nodes:[],point:null,x:null,y:null};}function d3_geom_quadtreeVisit(f,node,x1,y1,x2,y2){if(!f(node,x1,y1,x2,y2)){var sx=(x1+x2)*.5,sy=(y1+y2)*.5,children=node.nodes;if(children[0])d3_geom_quadtreeVisit(f,children[0],x1,y1,sx,sy);if(children[1])d3_geom_quadtreeVisit(f,children[1],sx,y1,x2,sy);if(children[2])d3_geom_quadtreeVisit(f,children[2],x1,sy,sx,y2);if(children[3])d3_geom_quadtreeVisit(f,children[3],sx,sy,x2,y2);}}function d3_geom_quadtreeFind(root,x,y,x0,y0,x3,y3){var minDistance2=Infinity,closestPoint;(function find(node,x1,y1,x2,y2){if(x1>x3||y1>y3||x2<x0||y2<y0)return;if(point=node.point){var point,dx=x-node.x,dy=y-node.y,distance2=dx*dx+dy*dy;if(distance2<minDistance2){var distance=Math.sqrt(minDistance2=distance2);x0=x-distance,y0=y-distance;x3=x+distance,y3=y+distance;closestPoint=point;}}var children=node.nodes,xm=(x1+x2)*.5,ym=(y1+y2)*.5,right=x>=xm,below=y>=ym;for(var i=below<<1|right,j=i+4;i<j;++i){if(node=children[i&3])switch(i&3){case 0:find(node,x1,y1,xm,ym);break;case 1:find(node,xm,y1,x2,ym);break;case 2:find(node,x1,ym,xm,y2);break;case 3:find(node,xm,ym,x2,y2);break;}}})(root,x0,y0,x3,y3);return closestPoint;}d3.interpolateRgb=d3_interpolateRgb;function d3_interpolateRgb(a,b){a=d3.rgb(a);b=d3.rgb(b);var ar=a.r,ag=a.g,ab=a.b,br=b.r-ar,bg=b.g-ag,bb=b.b-ab;return function(t){return\"#\"+d3_rgb_hex(Math.round(ar+br*t))+d3_rgb_hex(Math.round(ag+bg*t))+d3_rgb_hex(Math.round(ab+bb*t));};}d3.interpolateObject=d3_interpolateObject;function d3_interpolateObject(a,b){var i={},c={},k;for(k in a){if(k in b){i[k]=d3_interpolate(a[k],b[k]);}else{c[k]=a[k];}}for(k in b){if(!(k in a)){c[k]=b[k];}}return function(t){for(k in i){c[k]=i[k](t);}return c;};}d3.interpolateNumber=d3_interpolateNumber;function d3_interpolateNumber(a,b){a=+a,b=+b;return function(t){return a*(1-t)+b*t;};}d3.interpolateString=d3_interpolateString;function d3_interpolateString(a,b){var bi=d3_interpolate_numberA.lastIndex=d3_interpolate_numberB.lastIndex=0,am,bm,bs,i=-1,s=[],q=[];a=a+\"\",b=b+\"\";while((am=d3_interpolate_numberA.exec(a))&&(bm=d3_interpolate_numberB.exec(b))){if((bs=bm.index)>bi){bs=b.slice(bi,bs);if(s[i])s[i]+=bs;else s[++i]=bs;}if((am=am[0])===(bm=bm[0])){if(s[i])s[i]+=bm;else s[++i]=bm;}else{s[++i]=null;q.push({i:i,x:d3_interpolateNumber(am,bm)});}bi=d3_interpolate_numberB.lastIndex;}if(bi<b.length){bs=b.slice(bi);if(s[i])s[i]+=bs;else s[++i]=bs;}return s.length<2?q[0]?(b=q[0].x,function(t){return b(t)+\"\";}):function(){return b;}:(b=q.length,function(t){for(var i=0,o;i<b;++i){s[(o=q[i]).i]=o.x(t);}return s.join(\"\");});}var d3_interpolate_numberA=/[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g,d3_interpolate_numberB=new RegExp(d3_interpolate_numberA.source,\"g\");d3.interpolate=d3_interpolate;function d3_interpolate(a,b){var i=d3.interpolators.length,f;while(--i>=0&&!(f=d3.interpolators[i](a,b))){;}return f;}d3.interpolators=[function(a,b){var t=_typeof(b);return(t===\"string\"?d3_rgb_names.has(b.toLowerCase())||/^(#|rgb\\(|hsl\\()/i.test(b)?d3_interpolateRgb:d3_interpolateString:b instanceof d3_color?d3_interpolateRgb:Array.isArray(b)?d3_interpolateArray:t===\"object\"&&isNaN(b)?d3_interpolateObject:d3_interpolateNumber)(a,b);}];d3.interpolateArray=d3_interpolateArray;function d3_interpolateArray(a,b){var x=[],c=[],na=a.length,nb=b.length,n0=Math.min(a.length,b.length),i;for(i=0;i<n0;++i){x.push(d3_interpolate(a[i],b[i]));}for(;i<na;++i){c[i]=a[i];}for(;i<nb;++i){c[i]=b[i];}return function(t){for(i=0;i<n0;++i){c[i]=x[i](t);}return c;};}var d3_ease_default=function d3_ease_default(){return d3_identity;};var d3_ease=d3.map({linear:d3_ease_default,poly:d3_ease_poly,quad:function quad(){return d3_ease_quad;},cubic:function cubic(){return d3_ease_cubic;},sin:function sin(){return d3_ease_sin;},exp:function exp(){return d3_ease_exp;},circle:function circle(){return d3_ease_circle;},elastic:d3_ease_elastic,back:d3_ease_back,bounce:function bounce(){return d3_ease_bounce;}});var d3_ease_mode=d3.map({\"in\":d3_identity,out:d3_ease_reverse,\"in-out\":d3_ease_reflect,\"out-in\":function outIn(f){return d3_ease_reflect(d3_ease_reverse(f));}});d3.ease=function(name){var i=name.indexOf(\"-\"),t=i>=0?name.slice(0,i):name,m=i>=0?name.slice(i+1):\"in\";t=d3_ease.get(t)||d3_ease_default;m=d3_ease_mode.get(m)||d3_identity;return d3_ease_clamp(m(t.apply(null,d3_arraySlice.call(arguments,1))));};function d3_ease_clamp(f){return function(t){return t<=0?0:t>=1?1:f(t);};}function d3_ease_reverse(f){return function(t){return 1-f(1-t);};}function d3_ease_reflect(f){return function(t){return .5*(t<.5?f(2*t):2-f(2-2*t));};}function d3_ease_quad(t){return t*t;}function d3_ease_cubic(t){return t*t*t;}function d3_ease_cubicInOut(t){if(t<=0)return 0;if(t>=1)return 1;var t2=t*t,t3=t2*t;return 4*(t<.5?t3:3*(t-t2)+t3-.75);}function d3_ease_poly(e){return function(t){return Math.pow(t,e);};}function d3_ease_sin(t){return 1-Math.cos(t*half);}function d3_ease_exp(t){return Math.pow(2,10*(t-1));}function d3_ease_circle(t){return 1-Math.sqrt(1-t*t);}function d3_ease_elastic(a,p){var s;if(arguments.length<2)p=.45;if(arguments.length)s=p/*Math.asin(1/a);else a=1,s=p/4;return function(t){return 1+a*Math.pow(2,-10*t)*Math.sin((t-s)*/p);};}function d3_ease_back(s){if(!s)s=1.70158;return function(t){return t*t*((s+1)*t-s);};}function d3_ease_bounce(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375;}d3.interpolateHcl=d3_interpolateHcl;function d3_interpolateHcl(a,b){a=d3.hcl(a);b=d3.hcl(b);var ah=a.h,ac=a.c,al=a.l,bh=b.h-ah,bc=b.c-ac,bl=b.l-al;if(isNaN(bc))bc=0,ac=isNaN(ac)?b.c:ac;if(isNaN(bh))bh=0,ah=isNaN(ah)?b.h:ah;else if(bh>180)bh-=360;else if(bh<-180)bh+=360;return function(t){return d3_hcl_lab(ah+bh*t,ac+bc*t,al+bl*t)+\"\";};}d3.interpolateHsl=d3_interpolateHsl;function d3_interpolateHsl(a,b){a=d3.hsl(a);b=d3.hsl(b);var ah=a.h,as=a.s,al=a.l,bh=b.h-ah,bs=b.s-as,bl=b.l-al;if(isNaN(bs))bs=0,as=isNaN(as)?b.s:as;if(isNaN(bh))bh=0,ah=isNaN(ah)?b.h:ah;else if(bh>180)bh-=360;else if(bh<-180)bh+=360;return function(t){return d3_hsl_rgb(ah+bh*t,as+bs*t,al+bl*t)+\"\";};}d3.interpolateLab=d3_interpolateLab;function d3_interpolateLab(a,b){a=d3.lab(a);b=d3.lab(b);var al=a.l,aa=a.a,ab=a.b,bl=b.l-al,ba=b.a-aa,bb=b.b-ab;return function(t){return d3_lab_rgb(al+bl*t,aa+ba*t,ab+bb*t)+\"\";};}d3.interpolateRound=d3_interpolateRound;function d3_interpolateRound(a,b){b-=a;return function(t){return Math.round(a+b*t);};}d3.transform=function(string){var g=d3_document.createElementNS(d3.ns.prefix.svg,\"g\");return(d3.transform=function(string){if(string!=null){g.setAttribute(\"transform\",string);var t=g.transform.baseVal.consolidate();}return new d3_transform(t?t.matrix:d3_transformIdentity);})(string);};function d3_transform(m){var r0=[m.a,m.b],r1=[m.c,m.d],kx=d3_transformNormalize(r0),kz=d3_transformDot(r0,r1),ky=d3_transformNormalize(d3_transformCombine(r1,r0,-kz))||0;if(r0[0]*r1[1]<r1[0]*r0[1]){r0[0]*=-1;r0[1]*=-1;kx*=-1;kz*=-1;}this.rotate=(kx?Math.atan2(r0[1],r0[0]):Math.atan2(-r1[0],r1[1]))*d3_degrees;this.translate=[m.e,m.f];this.scale=[kx,ky];this.skew=ky?Math.atan2(kz,ky)*d3_degrees:0;}d3_transform.prototype.toString=function(){return\"translate(\"+this.translate+\")rotate(\"+this.rotate+\")skewX(\"+this.skew+\")scale(\"+this.scale+\")\";};function d3_transformDot(a,b){return a[0]*b[0]+a[1]*b[1];}function d3_transformNormalize(a){var k=Math.sqrt(d3_transformDot(a,a));if(k){a[0]/=k;a[1]/=k;}return k;}function d3_transformCombine(a,b,k){a[0]+=k*b[0];a[1]+=k*b[1];return a;}var d3_transformIdentity={a:1,b:0,c:0,d:1,e:0,f:0};d3.interpolateTransform=d3_interpolateTransform;function d3_interpolateTransformPop(s){return s.length?s.pop()+\",\":\"\";}function d3_interpolateTranslate(ta,tb,s,q){if(ta[0]!==tb[0]||ta[1]!==tb[1]){var i=s.push(\"translate(\",null,\",\",null,\")\");q.push({i:i-4,x:d3_interpolateNumber(ta[0],tb[0])},{i:i-2,x:d3_interpolateNumber(ta[1],tb[1])});}else if(tb[0]||tb[1]){s.push(\"translate(\"+tb+\")\");}}function d3_interpolateRotate(ra,rb,s,q){if(ra!==rb){if(ra-rb>180)rb+=360;else if(rb-ra>180)ra+=360;q.push({i:s.push(d3_interpolateTransformPop(s)+\"rotate(\",null,\")\")-2,x:d3_interpolateNumber(ra,rb)});}else if(rb){s.push(d3_interpolateTransformPop(s)+\"rotate(\"+rb+\")\");}}function d3_interpolateSkew(wa,wb,s,q){if(wa!==wb){q.push({i:s.push(d3_interpolateTransformPop(s)+\"skewX(\",null,\")\")-2,x:d3_interpolateNumber(wa,wb)});}else if(wb){s.push(d3_interpolateTransformPop(s)+\"skewX(\"+wb+\")\");}}function d3_interpolateScale(ka,kb,s,q){if(ka[0]!==kb[0]||ka[1]!==kb[1]){var i=s.push(d3_interpolateTransformPop(s)+\"scale(\",null,\",\",null,\")\");q.push({i:i-4,x:d3_interpolateNumber(ka[0],kb[0])},{i:i-2,x:d3_interpolateNumber(ka[1],kb[1])});}else if(kb[0]!==1||kb[1]!==1){s.push(d3_interpolateTransformPop(s)+\"scale(\"+kb+\")\");}}function d3_interpolateTransform(a,b){var s=[],q=[];a=d3.transform(a),b=d3.transform(b);d3_interpolateTranslate(a.translate,b.translate,s,q);d3_interpolateRotate(a.rotate,b.rotate,s,q);d3_interpolateSkew(a.skew,b.skew,s,q);d3_interpolateScale(a.scale,b.scale,s,q);a=b=null;return function(t){var i=-1,n=q.length,o;while(++i<n){s[(o=q[i]).i]=o.x(t);}return s.join(\"\");};}function d3_uninterpolateNumber(a,b){b=(b-=a=+a)||1/b;return function(x){return(x-a)/b;};}function d3_uninterpolateClamp(a,b){b=(b-=a=+a)||1/b;return function(x){return Math.max(0,Math.min(1,(x-a)/b));};}d3.layout={};d3.layout.bundle=function(){return function(links){var paths=[],i=-1,n=links.length;while(++i<n){paths.push(d3_layout_bundlePath(links[i]));}return paths;};};function d3_layout_bundlePath(link){var start=link.source,end=link.target,lca=d3_layout_bundleLeastCommonAncestor(start,end),points=[start];while(start!==lca){start=start.parent;points.push(start);}var k=points.length;while(end!==lca){points.splice(k,0,end);end=end.parent;}return points;}function d3_layout_bundleAncestors(node){var ancestors=[],parent=node.parent;while(parent!=null){ancestors.push(node);node=parent;parent=parent.parent;}ancestors.push(node);return ancestors;}function d3_layout_bundleLeastCommonAncestor(a,b){if(a===b)return a;var aNodes=d3_layout_bundleAncestors(a),bNodes=d3_layout_bundleAncestors(b),aNode=aNodes.pop(),bNode=bNodes.pop(),sharedNode=null;while(aNode===bNode){sharedNode=aNode;aNode=aNodes.pop();bNode=bNodes.pop();}return sharedNode;}d3.layout.chord=function(){var chord={},chords,groups,matrix,n,padding=0,sortGroups,sortSubgroups,sortChords;function relayout(){var subgroups={},groupSums=[],groupIndex=d3.range(n),subgroupIndex=[],k,x,x0,i,j;chords=[];groups=[];k=0,i=-1;while(++i<n){x=0,j=-1;while(++j<n){x+=matrix[i][j];}groupSums.push(x);subgroupIndex.push(d3.range(n));k+=x;}if(sortGroups){groupIndex.sort(function(a,b){return sortGroups(groupSums[a],groupSums[b]);});}if(sortSubgroups){subgroupIndex.forEach(function(d,i){d.sort(function(a,b){return sortSubgroups(matrix[i][a],matrix[i][b]);});});}k=(-padding*n)/k;x=0,i=-1;while(++i<n){x0=x,j=-1;while(++j<n){var di=groupIndex[i],dj=subgroupIndex[di][j],v=matrix[di][dj],a0=x,a1=x+=v*k;subgroups[di+\"-\"+dj]={index:di,subindex:dj,startAngle:a0,endAngle:a1,value:v};}groups[di]={index:di,startAngle:x0,endAngle:x,value:groupSums[di]};x+=padding;}i=-1;while(++i<n){j=i-1;while(++j<n){var source=subgroups[i+\"-\"+j],target=subgroups[j+\"-\"+i];if(source.value||target.value){chords.push(source.value<target.value?{source:target,target:source}:{source:source,target:target});}}}if(sortChords)resort();}function resort(){chords.sort(function(a,b){return sortChords((a.source.value+a.target.value)/2,(b.source.value+b.target.value)/2);});}chord.matrix=function(x){if(!arguments.length)return matrix;n=(matrix=x)&&matrix.length;chords=groups=null;return chord;};chord.padding=function(x){if(!arguments.length)return padding;padding=x;chords=groups=null;return chord;};chord.sortGroups=function(x){if(!arguments.length)return sortGroups;sortGroups=x;chords=groups=null;return chord;};chord.sortSubgroups=function(x){if(!arguments.length)return sortSubgroups;sortSubgroups=x;chords=null;return chord;};chord.sortChords=function(x){if(!arguments.length)return sortChords;sortChords=x;if(chords)resort();return chord;};chord.chords=function(){if(!chords)relayout();return chords;};chord.groups=function(){if(!groups)relayout();return groups;};return chord;};d3.layout.force=function(){var force={},event=d3.dispatch(\"start\",\"tick\",\"end\"),timer,size=[1,1],drag,alpha,friction=.9,linkDistance=d3_layout_forceLinkDistance,linkStrength=d3_layout_forceLinkStrength,charge=-30,chargeDistance2=d3_layout_forceChargeDistance2,gravity=.1,theta2=.64,nodes=[],links=[],distances,strengths,charges;function repulse(node){return function(quad,x1,_,x2){if(quad.point!==node){var dx=quad.cx-node.x,dy=quad.cy-node.y,dw=x2-x1,dn=dx*dx+dy*dy;if(dw*dw/theta2<dn){if(dn<chargeDistance2){var k=quad.charge/dn;node.px-=dx*k;node.py-=dy*k;}return true;}if(quad.point&&dn&&dn<chargeDistance2){var k=quad.pointCharge/dn;node.px-=dx*k;node.py-=dy*k;}}return!quad.charge;};}force.tick=function(){if((alpha*=.99)<.005){timer=null;event.end({type:\"end\",alpha:alpha=0});return true;}var n=nodes.length,m=links.length,q,i,o,s,t,l,k,x,y;for(i=0;i<m;++i){o=links[i];s=o.source;t=o.target;x=t.x-s.x;y=t.y-s.y;if(l=x*x+y*y){l=alpha*strengths[i]*((l=Math.sqrt(l))-distances[i])/l;x*=l;y*=l;t.x-=x*(k=s.weight+t.weight?s.weight/(s.weight+t.weight):.5);t.y-=y*k;s.x+=x*(k=1-k);s.y+=y*k;}}if(k=alpha*gravity){x=size[0]/2;y=size[1]/2;i=-1;if(k)while(++i<n){o=nodes[i];o.x+=(x-o.x)*k;o.y+=(y-o.y)*k;}}if(charge){d3_layout_forceAccumulate(q=d3.geom.quadtree(nodes),alpha,charges);i=-1;while(++i<n){if(!(o=nodes[i]).fixed){q.visit(repulse(o));}}}i=-1;while(++i<n){o=nodes[i];if(o.fixed){o.x=o.px;o.y=o.py;}else{o.x-=(o.px-(o.px=o.x))*friction;o.y-=(o.py-(o.py=o.y))*friction;}}event.tick({type:\"tick\",alpha:alpha});};force.nodes=function(x){if(!arguments.length)return nodes;nodes=x;return force;};force.links=function(x){if(!arguments.length)return links;links=x;return force;};force.size=function(x){if(!arguments.length)return size;size=x;return force;};force.linkDistance=function(x){if(!arguments.length)return linkDistance;linkDistance=typeof x===\"function\"?x:+x;return force;};force.distance=force.linkDistance;force.linkStrength=function(x){if(!arguments.length)return linkStrength;linkStrength=typeof x===\"function\"?x:+x;return force;};force.friction=function(x){if(!arguments.length)return friction;friction=+x;return force;};force.charge=function(x){if(!arguments.length)return charge;charge=typeof x===\"function\"?x:+x;return force;};force.chargeDistance=function(x){if(!arguments.length)return Math.sqrt(chargeDistance2);chargeDistance2=x*x;return force;};force.gravity=function(x){if(!arguments.length)return gravity;gravity=+x;return force;};force.theta=function(x){if(!arguments.length)return Math.sqrt(theta2);theta2=x*x;return force;};force.alpha=function(x){if(!arguments.length)return alpha;x=+x;if(alpha){if(x>0){alpha=x;}else{timer.c=null,timer.t=NaN,timer=null;event.end({type:\"end\",alpha:alpha=0});}}else if(x>0){event.start({type:\"start\",alpha:alpha=x});timer=d3_timer(force.tick);}return force;};force.start=function(){var i,n=nodes.length,m=links.length,w=size[0],h=size[1],neighbors,o;for(i=0;i<n;++i){(o=nodes[i]).index=i;o.weight=0;}for(i=0;i<m;++i){o=links[i];if(typeof o.source==\"number\")o.source=nodes[o.source];if(typeof o.target==\"number\")o.target=nodes[o.target];++o.source.weight;++o.target.weight;}for(i=0;i<n;++i){o=nodes[i];if(isNaN(o.x))o.x=position(\"x\",w);if(isNaN(o.y))o.y=position(\"y\",h);if(isNaN(o.px))o.px=o.x;if(isNaN(o.py))o.py=o.y;}distances=[];if(typeof linkDistance===\"function\")for(i=0;i<m;++i){distances[i]=+linkDistance.call(this,links[i],i);}else for(i=0;i<m;++i){distances[i]=linkDistance;}strengths=[];if(typeof linkStrength===\"function\")for(i=0;i<m;++i){strengths[i]=+linkStrength.call(this,links[i],i);}else for(i=0;i<m;++i){strengths[i]=linkStrength;}charges=[];if(typeof charge===\"function\")for(i=0;i<n;++i){charges[i]=+charge.call(this,nodes[i],i);}else for(i=0;i<n;++i){charges[i]=charge;}function position(dimension,size){if(!neighbors){neighbors=new Array(n);for(j=0;j<n;++j){neighbors[j]=[];}for(j=0;j<m;++j){var o=links[j];neighbors[o.source.index].push(o.target);neighbors[o.target.index].push(o.source);}}var candidates=neighbors[i],j=-1,l=candidates.length,x;while(++j<l){if(!isNaN(x=candidates[j][dimension]))return x;}return Math.random()*size;}return force.resume();};force.resume=function(){return force.alpha(.1);};force.stop=function(){return force.alpha(0);};force.drag=function(){if(!drag)drag=d3.behavior.drag().origin(d3_identity).on(\"dragstart.force\",d3_layout_forceDragstart).on(\"drag.force\",dragmove).on(\"dragend.force\",d3_layout_forceDragend);if(!arguments.length)return drag;this.on(\"mouseover.force\",d3_layout_forceMouseover).on(\"mouseout.force\",d3_layout_forceMouseout).call(drag);};function dragmove(d){d.px=d3.event.x,d.py=d3.event.y;force.resume();}return d3.rebind(force,event,\"on\");};function d3_layout_forceDragstart(d){d.fixed|=2;}function d3_layout_forceDragend(d){d.fixed&=~6;}function d3_layout_forceMouseover(d){d.fixed|=4;d.px=d.x,d.py=d.y;}function d3_layout_forceMouseout(d){d.fixed&=~4;}function d3_layout_forceAccumulate(quad,alpha,charges){var cx=0,cy=0;quad.charge=0;if(!quad.leaf){var nodes=quad.nodes,n=nodes.length,i=-1,c;while(++i<n){c=nodes[i];if(c==null)continue;d3_layout_forceAccumulate(c,alpha,charges);quad.charge+=c.charge;cx+=c.charge*c.cx;cy+=c.charge*c.cy;}}if(quad.point){if(!quad.leaf){quad.point.x+=Math.random()-.5;quad.point.y+=Math.random()-.5;}var k=alpha*charges[quad.point.index];quad.charge+=quad.pointCharge=k;cx+=k*quad.point.x;cy+=k*quad.point.y;}quad.cx=cx/quad.charge;quad.cy=cy/quad.charge;}var d3_layout_forceLinkDistance=20,d3_layout_forceLinkStrength=1,d3_layout_forceChargeDistance2=Infinity;d3.layout.hierarchy=function(){var sort=d3_layout_hierarchySort,children=d3_layout_hierarchyChildren,value=d3_layout_hierarchyValue;function hierarchy(root){var stack=[root],nodes=[],node;root.depth=0;while((node=stack.pop())!=null){nodes.push(node);if((childs=children.call(hierarchy,node,node.depth))&&(n=childs.length)){var n,childs,child;while(--n>=0){stack.push(child=childs[n]);child.parent=node;child.depth=node.depth+1;}if(value)node.value=0;node.children=childs;}else{if(value)node.value=+value.call(hierarchy,node,node.depth)||0;delete node.children;}}d3_layout_hierarchyVisitAfter(root,function(node){var childs,parent;if(sort&&(childs=node.children))childs.sort(sort);if(value&&(parent=node.parent))parent.value+=node.value;});return nodes;}hierarchy.sort=function(x){if(!arguments.length)return sort;sort=x;return hierarchy;};hierarchy.children=function(x){if(!arguments.length)return children;children=x;return hierarchy;};hierarchy.value=function(x){if(!arguments.length)return value;value=x;return hierarchy;};hierarchy.revalue=function(root){if(value){d3_layout_hierarchyVisitBefore(root,function(node){if(node.children)node.value=0;});d3_layout_hierarchyVisitAfter(root,function(node){var parent;if(!node.children)node.value=+value.call(hierarchy,node,node.depth)||0;if(parent=node.parent)parent.value+=node.value;});}return root;};return hierarchy;};function d3_layout_hierarchyRebind(object,hierarchy){d3.rebind(object,hierarchy,\"sort\",\"children\",\"value\");object.nodes=object;object.links=d3_layout_hierarchyLinks;return object;}function d3_layout_hierarchyVisitBefore(node,callback){var nodes=[node];while((node=nodes.pop())!=null){callback(node);if((children=node.children)&&(n=children.length)){var n,children;while(--n>=0){nodes.push(children[n]);}}}}function d3_layout_hierarchyVisitAfter(node,callback){var nodes=[node],nodes2=[];while((node=nodes.pop())!=null){nodes2.push(node);if((children=node.children)&&(n=children.length)){var i=-1,n,children;while(++i<n){nodes.push(children[i]);}}}while((node=nodes2.pop())!=null){callback(node);}}function d3_layout_hierarchyChildren(d){return d.children;}function d3_layout_hierarchyValue(d){return d.value;}function d3_layout_hierarchySort(a,b){return b.value-a.value;}function d3_layout_hierarchyLinks(nodes){return d3.merge(nodes.map(function(parent){return(parent.children||[]).map(function(child){return{source:parent,target:child};});}));}d3.layout.partition=function(){var hierarchy=d3.layout.hierarchy(),size=[1,1];function position(node,x,dx,dy){var children=node.children;node.x=x;node.y=node.depth*dy;node.dx=dx;node.dy=dy;if(children&&(n=children.length)){var i=-1,n,c,d;dx=node.value?dx/node.value:0;while(++i<n){position(c=children[i],x,d=c.value*dx,dy);x+=d;}}}function depth(node){var children=node.children,d=0;if(children&&(n=children.length)){var i=-1,n;while(++i<n){d=Math.max(d,depth(children[i]));}}return 1+d;}function partition(d,i){var nodes=hierarchy.call(this,d,i);position(nodes[0],0,size[0],size[1]/depth(nodes[0]));return nodes;}partition.size=function(x){if(!arguments.length)return size;size=x;return partition;};return d3_layout_hierarchyRebind(partition,hierarchy);};d3.layout.pie=function(){var value=Number,sort=d3_layout_pieSortByValue,startAngle=0,endAngle=,padAngle=0;function pie(data){var n=data.length,values=data.map(function(d,i){return+value.call(pie,d,i);}),a=+(typeof startAngle===\"function\"?startAngle.apply(this,arguments):startAngle),da=(typeof endAngle===\"function\"?endAngle.apply(this,arguments):endAngle)-a,p=Math.min(Math.abs(da)/n,+(typeof padAngle===\"function\"?padAngle.apply(this,arguments):padAngle)),pa=p*(da<0?-1:1),sum=d3.sum(values),k=sum?(da-n*pa)/sum:0,index=d3.range(n),arcs=[],v;if(sort!=null)index.sort(sort===d3_layout_pieSortByValue?function(i,j){return values[j]-values[i];}:function(i,j){return sort(data[i],data[j]);});index.forEach(function(i){arcs[i]={data:data[i],value:v=values[i],startAngle:a,endAngle:a+=v*k+pa,padAngle:p};});return arcs;}pie.value=function(_){if(!arguments.length)return value;value=_;return pie;};pie.sort=function(_){if(!arguments.length)return sort;sort=_;return pie;};pie.startAngle=function(_){if(!arguments.length)return startAngle;startAngle=_;return pie;};pie.endAngle=function(_){if(!arguments.length)return endAngle;endAngle=_;return pie;};pie.padAngle=function(_){if(!arguments.length)return padAngle;padAngle=_;return pie;};return pie;};var d3_layout_pieSortByValue={};d3.layout.stack=function(){var values=d3_identity,order=d3_layout_stackOrderDefault,offset=d3_layout_stackOffsetZero,out=d3_layout_stackOut,x=d3_layout_stackX,y=d3_layout_stackY;function stack(data,index){if(!(n=data.length))return data;var series=data.map(function(d,i){return values.call(stack,d,i);});var points=series.map(function(d){return d.map(function(v,i){return[x.call(stack,v,i),y.call(stack,v,i)];});});var orders=order.call(stack,points,index);series=d3.permute(series,orders);points=d3.permute(points,orders);var offsets=offset.call(stack,points,index);var m=series[0].length,n,i,j,o;for(j=0;j<m;++j){out.call(stack,series[0][j],o=offsets[j],points[0][j][1]);for(i=1;i<n;++i){out.call(stack,series[i][j],o+=points[i-1][j][1],points[i][j][1]);}}return data;}stack.values=function(x){if(!arguments.length)return values;values=x;return stack;};stack.order=function(x){if(!arguments.length)return order;order=typeof x===\"function\"?x:d3_layout_stackOrders.get(x)||d3_layout_stackOrderDefault;return stack;};stack.offset=function(x){if(!arguments.length)return offset;offset=typeof x===\"function\"?x:d3_layout_stackOffsets.get(x)||d3_layout_stackOffsetZero;return stack;};stack.x=function(z){if(!arguments.length)return x;x=z;return stack;};stack.y=function(z){if(!arguments.length)return y;y=z;return stack;};stack.out=function(z){if(!arguments.length)return out;out=z;return stack;};return stack;};function d3_layout_stackX(d){return d.x;}function d3_layout_stackY(d){return d.y;}function d3_layout_stackOut(d,y0,y){d.y0=y0;d.y=y;}var d3_layout_stackOrders=d3.map({\"inside-out\":function insideOut(data){var n=data.length,i,j,max=data.map(d3_layout_stackMaxIndex),sums=data.map(d3_layout_stackReduceSum),index=d3.range(n).sort(function(a,b){return max[a]-max[b];}),top=0,bottom=0,tops=[],bottoms=[];for(i=0;i<n;++i){j=index[i];if(top<bottom){top+=sums[j];tops.push(j);}else{bottom+=sums[j];bottoms.push(j);}}return bottoms.reverse().concat(tops);},reverse:function reverse(data){return d3.range(data.length).reverse();},\"default\":d3_layout_stackOrderDefault});var d3_layout_stackOffsets=d3.map({silhouette:function silhouette(data){var n=data.length,m=data[0].length,sums=[],max=0,i,j,o,y0=[];for(j=0;j<m;++j){for(i=0,o=0;i<n;i++){o+=data[i][j][1];}if(o>max)max=o;sums.push(o);}for(j=0;j<m;++j){y0[j]=(max-sums[j])/2;}return y0;},wiggle:function wiggle(data){var n=data.length,x=data[0],m=x.length,i,j,k,s1,s2,s3,dx,o,o0,y0=[];y0[0]=o=o0=0;for(j=1;j<m;++j){for(i=0,s1=0;i<n;++i){s1+=data[i][j][1];}for(i=0,s2=0,dx=x[j][0]-x[j-1][0];i<n;++i){for(k=0,s3=(data[i][j][1]-data[i][j-1][1])/(2*dx);k<i;++k){s3+=(data[k][j][1]-data[k][j-1][1])/dx;}s2+=s3*data[i][j][1];}y0[j]=o-=s1?s2/s1*dx:0;if(o<o0)o0=o;}for(j=0;j<m;++j){y0[j]-=o0;}return y0;},expand:function expand(data){var n=data.length,m=data[0].length,k=1/n,i,j,o,y0=[];for(j=0;j<m;++j){for(i=0,o=0;i<n;i++){o+=data[i][j][1];}if(o)for(i=0;i<n;i++){data[i][j][1]/=o;}else for(i=0;i<n;i++){data[i][j][1]=k;}}for(j=0;j<m;++j){y0[j]=0;}return y0;},zero:d3_layout_stackOffsetZero});function d3_layout_stackOrderDefault(data){return d3.range(data.length);}function d3_layout_stackOffsetZero(data){var j=-1,m=data[0].length,y0=[];while(++j<m){y0[j]=0;}return y0;}function d3_layout_stackMaxIndex(array){var i=1,j=0,v=array[0][1],k,n=array.length;for(;i<n;++i){if((k=array[i][1])>v){j=i;v=k;}}return j;}function d3_layout_stackReduceSum(d){return d.reduce(d3_layout_stackSum,0);}function d3_layout_stackSum(p,d){return p+d[1];}d3.layout.histogram=function(){var frequency=true,valuer=Number,ranger=d3_layout_histogramRange,binner=d3_layout_histogramBinSturges;function histogram(data,i){var bins=[],values=data.map(valuer,this),range=ranger.call(this,values,i),thresholds=binner.call(this,range,values,i),bin,i=-1,n=values.length,m=thresholds.length-1,k=frequency?1:1/n,x;while(++i<m){bin=bins[i]=[];bin.dx=thresholds[i+1]-(bin.x=thresholds[i]);bin.y=0;}if(m>0){i=-1;while(++i<n){x=values[i];if(x>=range[0]&&x<=range[1]){bin=bins[d3.bisect(thresholds,x,1,m)-1];bin.y+=k;bin.push(data[i]);}}}return bins;}histogram.value=function(x){if(!arguments.length)return valuer;valuer=x;return histogram;};histogram.range=function(x){if(!arguments.length)return ranger;ranger=d3_functor(x);return histogram;};histogram.bins=function(x){if(!arguments.length)return binner;binner=typeof x===\"number\"?function(range){return d3_layout_histogramBinFixed(range,x);}:d3_functor(x);return histogram;};histogram.frequency=function(x){if(!arguments.length)return frequency;frequency=!!x;return histogram;};return histogram;};function d3_layout_histogramBinSturges(range,values){return d3_layout_histogramBinFixed(range,Math.ceil(Math.log(values.length)/Math.LN2+1));}function d3_layout_histogramBinFixed(range,n){var x=-1,b=+range[0],m=(range[1]-b)/n,f=[];while(++x<=n){f[x]=m*x+b;}return f;}function d3_layout_histogramRange(values){return[d3.min(values),d3.max(values)];}d3.layout.pack=function(){var hierarchy=d3.layout.hierarchy().sort(d3_layout_packSort),padding=0,size=[1,1],radius;function pack(d,i){var nodes=hierarchy.call(this,d,i),root=nodes[0],w=size[0],h=size[1],r=radius==null?Math.sqrt:typeof radius===\"function\"?radius:function(){return radius;};root.x=root.y=0;d3_layout_hierarchyVisitAfter(root,function(d){d.r=+r(d.value);});d3_layout_hierarchyVisitAfter(root,d3_layout_packSiblings);if(padding){var dr=padding*(radius?1:Math.max(2*root.r/w,2*root.r/h))/2;d3_layout_hierarchyVisitAfter(root,function(d){d.r+=dr;});d3_layout_hierarchyVisitAfter(root,d3_layout_packSiblings);d3_layout_hierarchyVisitAfter(root,function(d){d.r-=dr;});}d3_layout_packTransform(root,w/2,h/2,radius?1:1/Math.max(2*root.r/w,2*root.r/h));return nodes;}pack.size=function(_){if(!arguments.length)return size;size=_;return pack;};pack.radius=function(_){if(!arguments.length)return radius;radius=_==null||typeof _===\"function\"?_:+_;return pack;};pack.padding=function(_){if(!arguments.length)return padding;padding=+_;return pack;};return d3_layout_hierarchyRebind(pack,hierarchy);};function d3_layout_packSort(a,b){return a.value-b.value;}function d3_layout_packInsert(a,b){var c=a._pack_next;a._pack_next=b;b._pack_prev=a;b._pack_next=c;c._pack_prev=b;}function d3_layout_packSplice(a,b){a._pack_next=b;b._pack_prev=a;}function d3_layout_packIntersects(a,b){var dx=b.x-a.x,dy=b.y-a.y,dr=a.r+b.r;return .999*dr*dr>dx*dx+dy*dy;}function d3_layout_packSiblings(node){if(!(nodes=node.children)||!(n=nodes.length))return;var nodes,xMin=Infinity,xMax=-Infinity,yMin=Infinity,yMax=-Infinity,a,b,c,i,j,k,n;function bound(node){xMin=Math.min(node.x-node.r,xMin);xMax=Math.max(node.x+node.r,xMax);yMin=Math.min(node.y-node.r,yMin);yMax=Math.max(node.y+node.r,yMax);}nodes.forEach(d3_layout_packLink);a=nodes[0];a.x=-a.r;a.y=0;bound(a);if(n>1){b=nodes[1];b.x=b.r;b.y=0;bound(b);if(n>2){c=nodes[2];d3_layout_packPlace(a,b,c);bound(c);d3_layout_packInsert(a,c);a._pack_prev=c;d3_layout_packInsert(c,b);b=a._pack_next;for(i=3;i<n;i++){d3_layout_packPlace(a,b,c=nodes[i]);var isect=0,s1=1,s2=1;for(j=b._pack_next;j!==b;j=j._pack_next,s1++){if(d3_layout_packIntersects(j,c)){isect=1;break;}}if(isect==1){for(k=a._pack_prev;k!==j._pack_prev;k=k._pack_prev,s2++){if(d3_layout_packIntersects(k,c)){break;}}}if(isect){if(s1<s2||s1==s2&&b.r<a.r)d3_layout_packSplice(a,b=j);else d3_layout_packSplice(a=k,b);i--;}else{d3_layout_packInsert(a,c);b=c;bound(c);}}}}var cx=(xMin+xMax)/2,cy=(yMin+yMax)/2,cr=0;for(i=0;i<n;i++){c=nodes[i];c.x-=cx;c.y-=cy;cr=Math.max(cr,c.r+Math.sqrt(c.x*c.x+c.y*c.y));}node.r=cr;nodes.forEach(d3_layout_packUnlink);}function d3_layout_packLink(node){node._pack_next=node._pack_prev=node;}function d3_layout_packUnlink(node){delete node._pack_next;delete node._pack_prev;}function d3_layout_packTransform(node,x,y,k){var children=node.children;node.x=x+=k*node.x;node.y=y+=k*node.y;node.r*=k;if(children){var i=-1,n=children.length;while(++i<n){d3_layout_packTransform(children[i],x,y,k);}}}function d3_layout_packPlace(a,b,c){var db=a.r+c.r,dx=b.x-a.x,dy=b.y-a.y;if(db&&(dx||dy)){var da=b.r+c.r,dc=dx*dx+dy*dy;da*=da;db*=db;var x=.5+(db-da)/(2*dc),y=Math.sqrt(Math.max(0,2*da*(db+dc)-(db-=dc)*db-da*da))/(2*dc);c.x=a.x+x*dx+y*dy;c.y=a.y+x*dy-y*dx;}else{c.x=a.x+db;c.y=a.y;}}d3.layout.tree=function(){var hierarchy=d3.layout.hierarchy().sort(null).value(null),separation=d3_layout_treeSeparation,size=[1,1],nodeSize=null;function tree(d,i){var nodes=hierarchy.call(this,d,i),root0=nodes[0],root1=wrapTree(root0);d3_layout_hierarchyVisitAfter(root1,firstWalk),root1.parent.m=-root1.z;d3_layout_hierarchyVisitBefore(root1,secondWalk);if(nodeSize)d3_layout_hierarchyVisitBefore(root0,sizeNode);else{var left=root0,right=root0,bottom=root0;d3_layout_hierarchyVisitBefore(root0,function(node){if(node.x<left.x)left=node;if(node.x>right.x)right=node;if(node.depth>bottom.depth)bottom=node;});var tx=separation(left,right)/2-left.x,kx=size[0]/(right.x+separation(right,left)/2+tx),ky=size[1]/(bottom.depth||1);d3_layout_hierarchyVisitBefore(root0,function(node){node.x=(node.x+tx)*kx;node.y=node.depth*ky;});}return nodes;}function wrapTree(root0){var root1={A:null,children:[root0]},queue=[root1],node1;while((node1=queue.pop())!=null){for(var children=node1.children,child,i=0,n=children.length;i<n;++i){queue.push((children[i]=child={_:children[i],parent:node1,children:(child=children[i].children)&&child.slice()||[],A:null,a:null,z:0,m:0,c:0,s:0,t:null,i:i}).a=child);}}return root1.children[0];}function firstWalk(v){var children=v.children,siblings=v.parent.children,w=v.i?siblings[v.i-1]:null;if(children.length){d3_layout_treeShift(v);var midpoint=(children[0].z+children[children.length-1].z)/2;if(w){v.z=w.z+separation(v._,w._);v.m=v.z-midpoint;}else{v.z=midpoint;}}else if(w){v.z=w.z+separation(v._,w._);}v.parent.A=apportion(v,w,v.parent.A||siblings[0]);}function secondWalk(v){v._.x=v.z+v.parent.m;v.m+=v.parent.m;}function apportion(v,w,ancestor){if(w){var vip=v,vop=v,vim=w,vom=vip.parent.children[0],sip=vip.m,sop=vop.m,sim=vim.m,som=vom.m,shift;while(vim=d3_layout_treeRight(vim),vip=d3_layout_treeLeft(vip),vim&&vip){vom=d3_layout_treeLeft(vom);vop=d3_layout_treeRight(vop);vop.a=v;shift=vim.z+sim-vip.z-sip+separation(vim._,vip._);if(shift>0){d3_layout_treeMove(d3_layout_treeAncestor(vim,v,ancestor),v,shift);sip+=shift;sop+=shift;}sim+=vim.m;sip+=vip.m;som+=vom.m;sop+=vop.m;}if(vim&&!d3_layout_treeRight(vop)){vop.t=vim;vop.m+=sim-sop;}if(vip&&!d3_layout_treeLeft(vom)){vom.t=vip;vom.m+=sip-som;ancestor=v;}}return ancestor;}function sizeNode(node){node.x*=size[0];node.y=node.depth*size[1];}tree.separation=function(x){if(!arguments.length)return separation;separation=x;return tree;};tree.size=function(x){if(!arguments.length)return nodeSize?null:size;nodeSize=(size=x)==null?sizeNode:null;return tree;};tree.nodeSize=function(x){if(!arguments.length)return nodeSize?size:null;nodeSize=(size=x)==null?null:sizeNode;return tree;};return d3_layout_hierarchyRebind(tree,hierarchy);};function d3_layout_treeSeparation(a,b){return a.parent==b.parent?1:2;}function d3_layout_treeLeft(v){var children=v.children;return children.length?children[0]:v.t;}function d3_layout_treeRight(v){var children=v.children,n;return(n=children.length)?children[n-1]:v.t;}function d3_layout_treeMove(wm,wp,shift){var change=shift/(wp.i-wm.i);wp.c-=change;wp.s+=shift;wm.c+=change;wp.z+=shift;wp.m+=shift;}function d3_layout_treeShift(v){var shift=0,change=0,children=v.children,i=children.length,w;while(--i>=0){w=children[i];w.z+=shift;w.m+=shift;shift+=w.s+(change+=w.c);}}function d3_layout_treeAncestor(vim,v,ancestor){return vim.a.parent===v.parent?vim.a:ancestor;}d3.layout.cluster=function(){var hierarchy=d3.layout.hierarchy().sort(null).value(null),separation=d3_layout_treeSeparation,size=[1,1],nodeSize=false;function cluster(d,i){var nodes=hierarchy.call(this,d,i),root=nodes[0],previousNode,x=0;d3_layout_hierarchyVisitAfter(root,function(node){var children=node.children;if(children&&children.length){node.x=d3_layout_clusterX(children);node.y=d3_layout_clusterY(children);}else{node.x=previousNode?x+=separation(node,previousNode):0;node.y=0;previousNode=node;}});var left=d3_layout_clusterLeft(root),right=d3_layout_clusterRight(root),x0=left.x-separation(left,right)/2,x1=right.x+separation(right,left)/2;d3_layout_hierarchyVisitAfter(root,nodeSize?function(node){node.x=(node.x-root.x)*size[0];node.y=(root.y-node.y)*size[1];}:function(node){node.x=(node.x-x0)/(x1-x0)*size[0];node.y=(1-(root.y?node.y/root.y:1))*size[1];});return nodes;}cluster.separation=function(x){if(!arguments.length)return separation;separation=x;return cluster;};cluster.size=function(x){if(!arguments.length)return nodeSize?null:size;nodeSize=(size=x)==null;return cluster;};cluster.nodeSize=function(x){if(!arguments.length)return nodeSize?size:null;nodeSize=(size=x)!=null;return cluster;};return d3_layout_hierarchyRebind(cluster,hierarchy);};function d3_layout_clusterY(children){return 1+d3.max(children,function(child){return child.y;});}function d3_layout_clusterX(children){return children.reduce(function(x,child){return x+child.x;},0)/children.length;}function d3_layout_clusterLeft(node){var children=node.children;return children&&children.length?d3_layout_clusterLeft(children[0]):node;}function d3_layout_clusterRight(node){var children=node.children,n;return children&&(n=children.length)?d3_layout_clusterRight(children[n-1]):node;}d3.layout.treemap=function(){var hierarchy=d3.layout.hierarchy(),round=Math.round,size=[1,1],padding=null,pad=d3_layout_treemapPadNull,sticky=false,stickies,mode=\"squarify\",ratio=.5*(1+Math.sqrt(5));function scale(children,k){var i=-1,n=children.length,child,area;while(++i<n){area=(child=children[i]).value*(k<0?0:k);child.area=isNaN(area)||area<=0?0:area;}}function squarify(node){var children=node.children;if(children&&children.length){var rect=pad(node),row=[],remaining=children.slice(),child,best=Infinity,score,u=mode===\"slice\"?rect.dx:mode===\"dice\"?rect.dy:mode===\"slice-dice\"?node.depth&1?rect.dy:rect.dx:Math.min(rect.dx,rect.dy),n;scale(remaining,rect.dx*rect.dy/node.value);row.area=0;while((n=remaining.length)>0){row.push(child=remaining[n-1]);row.area+=child.area;if(mode!==\"squarify\"||(score=worst(row,u))<=best){remaining.pop();best=score;}else{row.area-=row.pop().area;position(row,u,rect,false);u=Math.min(rect.dx,rect.dy);row.length=row.area=0;best=Infinity;}}if(row.length){position(row,u,rect,true);row.length=row.area=0;}children.forEach(squarify);}}function stickify(node){var children=node.children;if(children&&children.length){var rect=pad(node),remaining=children.slice(),child,row=[];scale(remaining,rect.dx*rect.dy/node.value);row.area=0;while(child=remaining.pop()){row.push(child);row.area+=child.area;if(child.z!=null){position(row,child.z?rect.dx:rect.dy,rect,!remaining.length);row.length=row.area=0;}}children.forEach(stickify);}}function worst(row,u){var s=row.area,r,rmax=0,rmin=Infinity,i=-1,n=row.length;while(++i<n){if(!(r=row[i].area))continue;if(r<rmin)rmin=r;if(r>rmax)rmax=r;}s*=s;u*=u;return s?Math.max(u*rmax*ratio/s,s/(u*rmin*ratio)):Infinity;}function position(row,u,rect,flush){var i=-1,n=row.length,x=rect.x,y=rect.y,v=u?round(row.area/u):0,o;if(u==rect.dx){if(flush||v>rect.dy)v=rect.dy;while(++i<n){o=row[i];o.x=x;o.y=y;o.dy=v;x+=o.dx=Math.min(rect.x+rect.dx-x,v?round(o.area/v):0);}o.z=true;o.dx+=rect.x+rect.dx-x;rect.y+=v;rect.dy-=v;}else{if(flush||v>rect.dx)v=rect.dx;while(++i<n){o=row[i];o.x=x;o.y=y;o.dx=v;y+=o.dy=Math.min(rect.y+rect.dy-y,v?round(o.area/v):0);}o.z=false;o.dy+=rect.y+rect.dy-y;rect.x+=v;rect.dx-=v;}}function treemap(d){var nodes=stickies||hierarchy(d),root=nodes[0];root.x=root.y=0;if(root.value)root.dx=size[0],root.dy=size[1];else root.dx=root.dy=0;if(stickies)hierarchy.revalue(root);scale([root],root.dx*root.dy/root.value);(stickies?stickify:squarify)(root);if(sticky)stickies=nodes;return nodes;}treemap.size=function(x){if(!arguments.length)return size;size=x;return treemap;};treemap.padding=function(x){if(!arguments.length)return padding;function padFunction(node){var p=x.call(treemap,node,node.depth);return p==null?d3_layout_treemapPadNull(node):d3_layout_treemapPad(node,typeof p===\"number\"?[p,p,p,p]:p);}function padConstant(node){return d3_layout_treemapPad(node,x);}var type;pad=(padding=x)==null?d3_layout_treemapPadNull:(type=_typeof(x))===\"function\"?padFunction:type===\"number\"?(x=[x,x,x,x],padConstant):padConstant;return treemap;};treemap.round=function(x){if(!arguments.length)return round!=Number;round=x?Math.round:Number;return treemap;};treemap.sticky=function(x){if(!arguments.length)return sticky;sticky=x;stickies=null;return treemap;};treemap.ratio=function(x){if(!arguments.length)return ratio;ratio=x;return treemap;};treemap.mode=function(x){if(!arguments.length)return mode;mode=x+\"\";return treemap;};return d3_layout_hierarchyRebind(treemap,hierarchy);};function d3_layout_treemapPadNull(node){return{x:node.x,y:node.y,dx:node.dx,dy:node.dy};}function d3_layout_treemapPad(node,padding){var x=node.x+padding[3],y=node.y+padding[0],dx=node.dx-padding[1]-padding[3],dy=node.dy-padding[0]-padding[2];if(dx<0){x+=dx/2;dx=0;}if(dy<0){y+=dy/2;dy=0;}return{x:x,y:y,dx:dx,dy:dy};}d3.random={normal:function normal(,){var n=arguments.length;if(n<2)=1;if(n<1)=0;return function(){var x,y,r;do{x=Math.random()*2-1;y=Math.random()*2-1;r=x*x+y*y;}while(!r||r>1);return +*x*Math.sqrt(-2*Math.log(r)/r);};},logNormal:function logNormal(){var random=d3.random.normal.apply(d3,arguments);return function(){return Math.exp(random());};},bates:function bates(m){var random=d3.random.irwinHall(m);return function(){return random()/m;};},irwinHall:function irwinHall(m){return function(){for(var s=0,j=0;j<m;j++){s+=Math.random();}return s;};}};d3.scale={};function d3_scaleExtent(domain){var start=domain[0],stop=domain[domain.length-1];return start<stop?[start,stop]:[stop,start];}function d3_scaleRange(scale){return scale.rangeExtent?scale.rangeExtent():d3_scaleExtent(scale.range());}function d3_scale_bilinear(domain,range,uninterpolate,interpolate){var u=uninterpolate(domain[0],domain[1]),i=interpolate(range[0],range[1]);return function(x){return i(u(x));};}function d3_scale_nice(domain,nice){var i0=0,i1=domain.length-1,x0=domain[i0],x1=domain[i1],dx;if(x1<x0){dx=i0,i0=i1,i1=dx;dx=x0,x0=x1,x1=dx;}domain[i0]=nice.floor(x0);domain[i1]=nice.ceil(x1);return domain;}function d3_scale_niceStep(step){return step?{floor:function floor(x){return Math.floor(x/step)*step;},ceil:function ceil(x){return Math.ceil(x/step)*step;}}:d3_scale_niceIdentity;}var d3_scale_niceIdentity={floor:d3_identity,ceil:d3_identity};function d3_scale_polylinear(domain,range,uninterpolate,interpolate){var u=[],i=[],j=0,k=Math.min(domain.length,range.length)-1;if(domain[k]<domain[0]){domain=domain.slice().reverse();range=range.slice().reverse();}while(++j<=k){u.push(uninterpolate(domain[j-1],domain[j]));i.push(interpolate(range[j-1],range[j]));}return function(x){var j=d3.bisect(domain,x,1,k)-1;return i[j](u[j](x));};}d3.scale.linear=function(){return d3_scale_linear([0,1],[0,1],d3_interpolate,false);};function d3_scale_linear(domain,range,interpolate,clamp){var output,input;function rescale(){var linear=Math.min(domain.length,range.length)>2?d3_scale_polylinear:d3_scale_bilinear,uninterpolate=clamp?d3_uninterpolateClamp:d3_uninterpolateNumber;output=linear(domain,range,uninterpolate,interpolate);input=linear(range,domain,uninterpolate,d3_interpolate);return scale;}function scale(x){return output(x);}scale.invert=function(y){return input(y);};scale.domain=function(x){if(!arguments.length)return domain;domain=x.map(Number);return rescale();};scale.range=function(x){if(!arguments.length)return range;range=x;return rescale();};scale.rangeRound=function(x){return scale.range(x).interpolate(d3_interpolateRound);};scale.clamp=function(x){if(!arguments.length)return clamp;clamp=x;return rescale();};scale.interpolate=function(x){if(!arguments.length)return interpolate;interpolate=x;return rescale();};scale.ticks=function(m){return d3_scale_linearTicks(domain,m);};scale.tickFormat=function(m,format){return d3_scale_linearTickFormat(domain,m,format);};scale.nice=function(m){d3_scale_linearNice(domain,m);return rescale();};scale.copy=function(){return d3_scale_linear(domain,range,interpolate,clamp);};return rescale();}function d3_scale_linearRebind(scale,linear){return d3.rebind(scale,linear,\"range\",\"rangeRound\",\"interpolate\",\"clamp\");}function d3_scale_linearNice(domain,m){d3_scale_nice(domain,d3_scale_niceStep(d3_scale_linearTickRange(domain,m)[2]));d3_scale_nice(domain,d3_scale_niceStep(d3_scale_linearTickRange(domain,m)[2]));return domain;}function d3_scale_linearTickRange(domain,m){if(m==null)m=10;var extent=d3_scaleExtent(domain),span=extent[1]-extent[0],step=Math.pow(10,Math.floor(Math.log(span/m)/Math.LN10)),err=m/span*step;if(err<=.15)step*=10;else if(err<=.35)step*=5;else if(err<=.75)step*=2;extent[0]=Math.ceil(extent[0]/step)*step;extent[1]=Math.floor(extent[1]/step)*step+step*.5;extent[2]=step;return extent;}function d3_scale_linearTicks(domain,m){return d3.range.apply(d3,d3_scale_linearTickRange(domain,m));}function d3_scale_linearTickFormat(domain,m,format){var range=d3_scale_linearTickRange(domain,m);if(format){var match=d3_format_re.exec(format);match.shift();if(match[8]===\"s\"){var prefix=d3.formatPrefix(Math.max(abs(range[0]),abs(range[1])));if(!match[7])match[7]=\".\"+d3_scale_linearPrecision(prefix.scale(range[2]));match[8]=\"f\";format=d3.format(match.join(\"\"));return function(d){return format(prefix.scale(d))+prefix.symbol;};}if(!match[7])match[7]=\".\"+d3_scale_linearFormatPrecision(match[8],range);format=match.join(\"\");}else{format=\",.\"+d3_scale_linearPrecision(range[2])+\"f\";}return d3.format(format);}var d3_scale_linearFormatSignificant={s:1,g:1,p:1,r:1,e:1};function d3_scale_linearPrecision(value){return-Math.floor(Math.log(value)/Math.LN10+.01);}function d3_scale_linearFormatPrecision(type,range){var p=d3_scale_linearPrecision(range[2]);return type in d3_scale_linearFormatSignificant?Math.abs(p-d3_scale_linearPrecision(Math.max(abs(range[0]),abs(range[1]))))+ +(type!==\"e\"):p-(type===\"%\")*2;}d3.scale.log=function(){return d3_scale_log(d3.scale.linear().domain([0,1]),10,true,[1,10]);};function d3_scale_log(linear,base,positive,domain){function log(x){return(positive?Math.log(x<0?0:x):-Math.log(x>0?0:-x))/Math.log(base);}function pow(x){return positive?Math.pow(base,x):-Math.pow(base,-x);}function scale(x){return linear(log(x));}scale.invert=function(x){return pow(linear.invert(x));};scale.domain=function(x){if(!arguments.length)return domain;positive=x[0]>=0;linear.domain((domain=x.map(Number)).map(log));return scale;};scale.base=function(_){if(!arguments.length)return base;base=+_;linear.domain(domain.map(log));return scale;};scale.nice=function(){var niced=d3_scale_nice(domain.map(log),positive?Math:d3_scale_logNiceNegative);linear.domain(niced);domain=niced.map(pow);return scale;};scale.ticks=function(){var extent=d3_scaleExtent(domain),ticks=[],u=extent[0],v=extent[1],i=Math.floor(log(u)),j=Math.ceil(log(v)),n=base%1?2:base;if(isFinite(j-i)){if(positive){for(;i<j;i++){for(var k=1;k<n;k++){ticks.push(pow(i)*k);}}ticks.push(pow(i));}else{ticks.push(pow(i));for(;i++<j;){for(var k=n-1;k>0;k--){ticks.push(pow(i)*k);}}}for(i=0;ticks[i]<u;i++){}for(j=ticks.length;ticks[j-1]>v;j--){}ticks=ticks.slice(i,j);}return ticks;};scale.tickFormat=function(n,format){if(!arguments.length)return d3_scale_logFormat;if(arguments.length<2)format=d3_scale_logFormat;else if(typeof format!==\"function\")format=d3.format(format);var k=Math.max(1,base*n/scale.ticks().length);return function(d){var i=d/pow(Math.round(log(d)));if(i*base<base-.5)i*=base;return i<=k?format(d):\"\";};};scale.copy=function(){return d3_scale_log(linear.copy(),base,positive,domain);};return d3_scale_linearRebind(scale,linear);}var d3_scale_logFormat=d3.format(\".0e\"),d3_scale_logNiceNegative={floor:function floor(x){return-Math.ceil(-x);},ceil:function ceil(x){return-Math.floor(-x);}};d3.scale.pow=function(){return d3_scale_pow(d3.scale.linear(),1,[0,1]);};function d3_scale_pow(linear,exponent,domain){var powp=d3_scale_powPow(exponent),powb=d3_scale_powPow(1/exponent);function scale(x){return linear(powp(x));}scale.invert=function(x){return powb(linear.invert(x));};scale.domain=function(x){if(!arguments.length)return domain;linear.domain((domain=x.map(Number)).map(powp));return scale;};scale.ticks=function(m){return d3_scale_linearTicks(domain,m);};scale.tickFormat=function(m,format){return d3_scale_linearTickFormat(domain,m,format);};scale.nice=function(m){return scale.domain(d3_scale_linearNice(domain,m));};scale.exponent=function(x){if(!arguments.length)return exponent;powp=d3_scale_powPow(exponent=x);powb=d3_scale_powPow(1/exponent);linear.domain(domain.map(powp));return scale;};scale.copy=function(){return d3_scale_pow(linear.copy(),exponent,domain);};return d3_scale_linearRebind(scale,linear);}function d3_scale_powPow(e){return function(x){return x<0?-Math.pow(-x,e):Math.pow(x,e);};}d3.scale.sqrt=function(){return d3.scale.pow().exponent(.5);};d3.scale.ordinal=function(){return d3_scale_ordinal([],{t:\"range\",a:[[]]});};function d3_scale_ordinal(domain,ranger){var index,range,rangeBand;function scale(x){return range[((index.get(x)||(ranger.t===\"range\"?index.set(x,domain.push(x)):NaN))-1)%range.length];}function steps(start,step){return d3.range(domain.length).map(function(i){return start+step*i;});}scale.domain=function(x){if(!arguments.length)return domain;domain=[];index=new d3_Map();var i=-1,n=x.length,xi;while(++i<n){if(!index.has(xi=x[i]))index.set(xi,domain.push(xi));}return scale[ranger.t].apply(scale,ranger.a);};scale.range=function(x){if(!arguments.length)return range;range=x;rangeBand=0;ranger={t:\"range\",a:arguments};return scale;};scale.rangePoints=function(x,padding){if(arguments.length<2)padding=0;var start=x[0],stop=x[1],step=domain.length<2?(start=(start+stop)/2,0):(stop-start)/(domain.length-1+padding);range=steps(start+step*padding/2,step);rangeBand=0;ranger={t:\"rangePoints\",a:arguments};return scale;};scale.rangeRoundPoints=function(x,padding){if(arguments.length<2)padding=0;var start=x[0],stop=x[1],step=domain.length<2?(start=stop=Math.round((start+stop)/2),0):(stop-start)/(domain.length-1+padding)|0;range=steps(start+Math.round(step*padding/2+(stop-start-(domain.length-1+padding)*step)/2),step);rangeBand=0;ranger={t:\"rangeRoundPoints\",a:arguments};return scale;};scale.rangeBands=function(x,padding,outerPadding){if(arguments.length<2)padding=0;if(arguments.length<3)outerPadding=padding;var reverse=x[1]<x[0],start=x[reverse-0],stop=x[1-reverse],step=(stop-start)/(domain.length-padding+2*outerPadding);range=steps(start+step*outerPadding,step);if(reverse)range.reverse();rangeBand=step*(1-padding);ranger={t:\"rangeBands\",a:arguments};return scale;};scale.rangeRoundBands=function(x,padding,outerPadding){if(arguments.length<2)padding=0;if(arguments.length<3)outerPadding=padding;var reverse=x[1]<x[0],start=x[reverse-0],stop=x[1-reverse],step=Math.floor((stop-start)/(domain.length-padding+2*outerPadding));range=steps(start+Math.round((stop-start-(domain.length-padding)*step)/2),step);if(reverse)range.reverse();rangeBand=Math.round(step*(1-padding));ranger={t:\"rangeRoundBands\",a:arguments};return scale;};scale.rangeBand=function(){return rangeBand;};scale.rangeExtent=function(){return d3_scaleExtent(ranger.a[0]);};scale.copy=function(){return d3_scale_ordinal(domain,ranger);};return scale.domain(domain);}d3.scale.category10=function(){return d3.scale.ordinal().range(d3_category10);};d3.scale.category20=function(){return d3.scale.ordinal().range(d3_category20);};d3.scale.category20b=function(){return d3.scale.ordinal().range(d3_category20b);};d3.scale.category20c=function(){return d3.scale.ordinal().range(d3_category20c);};var d3_category10=[2062260,16744206,2924588,14034728,9725885,9197131,14907330,8355711,12369186,1556175].map(d3_rgbString);var d3_category20=[2062260,11454440,16744206,16759672,2924588,10018698,14034728,16750742,9725885,12955861,9197131,12885140,14907330,16234194,8355711,13092807,12369186,14408589,1556175,10410725].map(d3_rgbString);var d3_category20b=[3750777,5395619,7040719,10264286,6519097,9216594,11915115,13556636,9202993,12426809,15186514,15190932,8666169,11356490,14049643,15177372,8077683,10834324,13528509,14589654].map(d3_rgbString);var d3_category20c=[3244733,7057110,10406625,13032431,15095053,16616764,16625259,16634018,3253076,7652470,10607003,13101504,7695281,10394312,12369372,14342891,6513507,9868950,12434877,14277081].map(d3_rgbString);d3.scale.quantile=function(){return d3_scale_quantile([],[]);};function d3_scale_quantile(domain,range){var thresholds;function rescale(){var k=0,q=range.length;thresholds=[];while(++k<q){thresholds[k-1]=d3.quantile(domain,k/q);}return scale;}function scale(x){if(!isNaN(x=+x))return range[d3.bisect(thresholds,x)];}scale.domain=function(x){if(!arguments.length)return domain;domain=x.map(d3_number).filter(d3_numeric).sort(d3_ascending);return rescale();};scale.range=function(x){if(!arguments.length)return range;range=x;return rescale();};scale.quantiles=function(){return thresholds;};scale.invertExtent=function(y){y=range.indexOf(y);return y<0?[NaN,NaN]:[y>0?thresholds[y-1]:domain[0],y<thresholds.length?thresholds[y]:domain[domain.length-1]];};scale.copy=function(){return d3_scale_quantile(domain,range);};return rescale();}d3.scale.quantize=function(){return d3_scale_quantize(0,1,[0,1]);};function d3_scale_quantize(x0,x1,range){var kx,i;function scale(x){return range[Math.max(0,Math.min(i,Math.floor(kx*(x-x0))))];}function rescale(){kx=range.length/(x1-x0);i=range.length-1;return scale;}scale.domain=function(x){if(!arguments.length)return[x0,x1];x0=+x[0];x1=+x[x.length-1];return rescale();};scale.range=function(x){if(!arguments.length)return range;range=x;return rescale();};scale.invertExtent=function(y){y=range.indexOf(y);y=y<0?NaN:y/kx+x0;return[y,y+1/kx];};scale.copy=function(){return d3_scale_quantize(x0,x1,range);};return rescale();}d3.scale.threshold=function(){return d3_scale_threshold([.5],[0,1]);};function d3_scale_threshold(domain,range){function scale(x){if(x<=x)return range[d3.bisect(domain,x)];}scale.domain=function(_){if(!arguments.length)return domain;domain=_;return scale;};scale.range=function(_){if(!arguments.length)return range;range=_;return scale;};scale.invertExtent=function(y){y=range.indexOf(y);return[domain[y-1],domain[y]];};scale.copy=function(){return d3_scale_threshold(domain,range);};return scale;}d3.scale.identity=function(){return d3_scale_identity([0,1]);};function d3_scale_identity(domain){function identity(x){return+x;}identity.invert=identity;identity.domain=identity.range=function(x){if(!arguments.length)return domain;domain=x.map(identity);return identity;};identity.ticks=function(m){return d3_scale_linearTicks(domain,m);};identity.tickFormat=function(m,format){return d3_scale_linearTickFormat(domain,m,format);};identity.copy=function(){return d3_scale_identity(domain);};return identity;}d3.svg={};function d3_zero(){return 0;}d3.svg.arc=function(){var innerRadius=d3_svg_arcInnerRadius,outerRadius=d3_svg_arcOuterRadius,cornerRadius=d3_zero,padRadius=d3_svg_arcAuto,startAngle=d3_svg_arcStartAngle,endAngle=d3_svg_arcEndAngle,padAngle=d3_svg_arcPadAngle;function arc(){var r0=Math.max(0,+innerRadius.apply(this,arguments)),r1=Math.max(0,+outerRadius.apply(this,arguments)),a0=startAngle.apply(this,arguments)-half,a1=endAngle.apply(this,arguments)-half,da=Math.abs(a1-a0),cw=a0>a1?0:1;if(r1<r0)rc=r1,r1=r0,r0=rc;if(da>=)return circleSegment(r1,cw)+(r0?circleSegment(r0,1-cw):\"\")+\"Z\";var rc,cr,rp,ap,p0=0,p1=0,x0,y0,x1,y1,x2,y2,x3,y3,path=[];if(ap=(+padAngle.apply(this,arguments)||0)/2){rp=padRadius===d3_svg_arcAuto?Math.sqrt(r0*r0+r1*r1):+padRadius.apply(this,arguments);if(!cw)p1*=-1;if(r1)p1=d3_asin(rp/r1*Math.sin(ap));if(r0)p0=d3_asin(rp/r0*Math.sin(ap));}if(r1){x0=r1*Math.cos(a0+p1);y0=r1*Math.sin(a0+p1);x1=r1*Math.cos(a1-p1);y1=r1*Math.sin(a1-p1);var l1=Math.abs(a1-a0-2*p1)<=?0:1;if(p1&&d3_svg_arcSweep(x0,y0,x1,y1)===cw^l1){var h1=(a0+a1)/2;x0=r1*Math.cos(h1);y0=r1*Math.sin(h1);x1=y1=null;}}else{x0=y0=0;}if(r0){x2=r0*Math.cos(a1-p0);y2=r0*Math.sin(a1-p0);x3=r0*Math.cos(a0+p0);y3=r0*Math.sin(a0+p0);var l0=Math.abs(a0-a1+2*p0)<=?0:1;if(p0&&d3_svg_arcSweep(x2,y2,x3,y3)===1-cw^l0){var h0=(a0+a1)/2;x2=r0*Math.cos(h0);y2=r0*Math.sin(h0);x3=y3=null;}}else{x2=y2=0;}if(da>&&(rc=Math.min(Math.abs(r1-r0)/2,+cornerRadius.apply(this,arguments)))>.001){cr=r0<r1^cw?0:1;var rc1=rc,rc0=rc;if(da<){var oc=x3==null?[x2,y2]:x1==null?[x0,y0]:d3_geom_polygonIntersect([x0,y0],[x3,y3],[x1,y1],[x2,y2]),ax=x0-oc[0],ay=y0-oc[1],bx=x1-oc[0],by=y1-oc[1],kc=1/Math.sin(Math.acos((ax*bx+ay*by)/(Math.sqrt(ax*ax+ay*ay)*Math.sqrt(bx*bx+by*by)))/2),lc=Math.sqrt(oc[0]*oc[0]+oc[1]*oc[1]);rc0=Math.min(rc,(r0-lc)/(kc-1));rc1=Math.min(rc,(r1-lc)/(kc+1));}if(x1!=null){var t30=d3_svg_arcCornerTangents(x3==null?[x2,y2]:[x3,y3],[x0,y0],r1,rc1,cw),t12=d3_svg_arcCornerTangents([x1,y1],[x2,y2],r1,rc1,cw);if(rc===rc1){path.push(\"M\",t30[0],\"A\",rc1,\",\",rc1,\" 0 0,\",cr,\" \",t30[1],\"A\",r1,\",\",r1,\" 0 \",1-cw^d3_svg_arcSweep(t30[1][0],t30[1][1],t12[1][0],t12[1][1]),\",\",cw,\" \",t12[1],\"A\",rc1,\",\",rc1,\" 0 0,\",cr,\" \",t12[0]);}else{path.push(\"M\",t30[0],\"A\",rc1,\",\",rc1,\" 0 1,\",cr,\" \",t12[0]);}}else{path.push(\"M\",x0,\",\",y0);}if(x3!=null){var t03=d3_svg_arcCornerTangents([x0,y0],[x3,y3],r0,-rc0,cw),t21=d3_svg_arcCornerTangents([x2,y2],x1==null?[x0,y0]:[x1,y1],r0,-rc0,cw);if(rc===rc0){path.push(\"L\",t21[0],\"A\",rc0,\",\",rc0,\" 0 0,\",cr,\" \",t21[1],\"A\",r0,\",\",r0,\" 0 \",cw^d3_svg_arcSweep(t21[1][0],t21[1][1],t03[1][0],t03[1][1]),\",\",1-cw,\" \",t03[1],\"A\",rc0,\",\",rc0,\" 0 0,\",cr,\" \",t03[0]);}else{path.push(\"L\",t21[0],\"A\",rc0,\",\",rc0,\" 0 0,\",cr,\" \",t03[0]);}}else{path.push(\"L\",x2,\",\",y2);}}else{path.push(\"M\",x0,\",\",y0);if(x1!=null)path.push(\"A\",r1,\",\",r1,\" 0 \",l1,\",\",cw,\" \",x1,\",\",y1);path.push(\"L\",x2,\",\",y2);if(x3!=null)path.push(\"A\",r0,\",\",r0,\" 0 \",l0,\",\",1-cw,\" \",x3,\",\",y3);}path.push(\"Z\");return path.join(\"\");}function circleSegment(r1,cw){return\"M0,\"+r1+\"A\"+r1+\",\"+r1+\" 0 1,\"+cw+\" 0,\"+-r1+\"A\"+r1+\",\"+r1+\" 0 1,\"+cw+\" 0,\"+r1;}arc.innerRadius=function(v){if(!arguments.length)return innerRadius;innerRadius=d3_functor(v);return arc;};arc.outerRadius=function(v){if(!arguments.length)return outerRadius;outerRadius=d3_functor(v);return arc;};arc.cornerRadius=function(v){if(!arguments.length)return cornerRadius;cornerRadius=d3_functor(v);return arc;};arc.padRadius=function(v){if(!arguments.length)return padRadius;padRadius=v==d3_svg_arcAuto?d3_svg_arcAuto:d3_functor(v);return arc;};arc.startAngle=function(v){if(!arguments.length)return startAngle;startAngle=d3_functor(v);return arc;};arc.endAngle=function(v){if(!arguments.length)return endAngle;endAngle=d3_functor(v);return arc;};arc.padAngle=function(v){if(!arguments.length)return padAngle;padAngle=d3_functor(v);return arc;};arc.centroid=function(){var r=(+innerRadius.apply(this,arguments)+ +outerRadius.apply(this,arguments))/2,a=(+startAngle.apply(this,arguments)+ +endAngle.apply(this,arguments))/2-half;return[Math.cos(a)*r,Math.sin(a)*r];};return arc;};var d3_svg_arcAuto=\"auto\";function d3_svg_arcInnerRadius(d){return d.innerRadius;}function d3_svg_arcOuterRadius(d){return d.outerRadius;}function d3_svg_arcStartAngle(d){return d.startAngle;}function d3_svg_arcEndAngle(d){return d.endAngle;}function d3_svg_arcPadAngle(d){return d&&d.padAngle;}function d3_svg_arcSweep(x0,y0,x1,y1){return(x0-x1)*y0-(y0-y1)*x0>0?0:1;}function d3_svg_arcCornerTangents(p0,p1,r1,rc,cw){var x01=p0[0]-p1[0],y01=p0[1]-p1[1],lo=(cw?rc:-rc)/Math.sqrt(x01*x01+y01*y01),ox=lo*y01,oy=-lo*x01,x1=p0[0]+ox,y1=p0[1]+oy,x2=p1[0]+ox,y2=p1[1]+oy,x3=(x1+x2)/2,y3=(y1+y2)/2,dx=x2-x1,dy=y2-y1,d2=dx*dx+dy*dy,r=r1-rc,D=x1*y2-x2*y1,d=(dy<0?-1:1)*Math.sqrt(Math.max(0,r*r*d2-D*D)),cx0=(D*dy-dx*d)/d2,cy0=(-D*dx-dy*d)/d2,cx1=(D*dy+dx*d)/d2,cy1=(-D*dx+dy*d)/d2,dx0=cx0-x3,dy0=cy0-y3,dx1=cx1-x3,dy1=cy1-y3;if(dx0*dx0+dy0*dy0>dx1*dx1+dy1*dy1)cx0=cx1,cy0=cy1;return[[cx0-ox,cy0-oy],[cx0*r1/r,cy0*r1/r]];}function d3_svg_line(projection){var x=d3_geom_pointX,y=d3_geom_pointY,defined=d3_true,interpolate=d3_svg_lineLinear,interpolateKey=interpolate.key,tension=.7;function line(data){var segments=[],points=[],i=-1,n=data.length,d,fx=d3_functor(x),fy=d3_functor(y);function segment(){segments.push(\"M\",interpolate(projection(points),tension));}while(++i<n){if(defined.call(this,d=data[i],i)){points.push([+fx.call(this,d,i),+fy.call(this,d,i)]);}else if(points.length){segment();points=[];}}if(points.length)segment();return segments.length?segments.join(\"\"):null;}line.x=function(_){if(!arguments.length)return x;x=_;return line;};line.y=function(_){if(!arguments.length)return y;y=_;return line;};line.defined=function(_){if(!arguments.length)return defined;defined=_;return line;};line.interpolate=function(_){if(!arguments.length)return interpolateKey;if(typeof _===\"function\")interpolateKey=interpolate=_;else interpolateKey=(interpolate=d3_svg_lineInterpolators.get(_)||d3_svg_lineLinear).key;return line;};line.tension=function(_){if(!arguments.length)return tension;tension=_;return line;};return line;}d3.svg.line=function(){return d3_svg_line(d3_identity);};var d3_svg_lineInterpolators=d3.map({linear:d3_svg_lineLinear,\"linear-closed\":d3_svg_lineLinearClosed,step:d3_svg_lineStep,\"step-before\":d3_svg_lineStepBefore,\"step-after\":d3_svg_lineStepAfter,basis:d3_svg_lineBasis,\"basis-open\":d3_svg_lineBasisOpen,\"basis-closed\":d3_svg_lineBasisClosed,bundle:d3_svg_lineBundle,cardinal:d3_svg_lineCardinal,\"cardinal-open\":d3_svg_lineCardinalOpen,\"cardinal-closed\":d3_svg_lineCardinalClosed,monotone:d3_svg_lineMonotone});d3_svg_lineInterpolators.forEach(function(key,value){value.key=key;value.closed=/-closed$/.test(key);});function d3_svg_lineLinear(points){return points.length>1?points.join(\"L\"):points+\"Z\";}function d3_svg_lineLinearClosed(points){return points.join(\"L\")+\"Z\";}function d3_svg_lineStep(points){var i=0,n=points.length,p=points[0],path=[p[0],\",\",p[1]];while(++i<n){path.push(\"H\",(p[0]+(p=points[i])[0])/2,\"V\",p[1]);}if(n>1)path.push(\"H\",p[0]);return path.join(\"\");}function d3_svg_lineStepBefore(points){var i=0,n=points.length,p=points[0],path=[p[0],\",\",p[1]];while(++i<n){path.push(\"V\",(p=points[i])[1],\"H\",p[0]);}return path.join(\"\");}function d3_svg_lineStepAfter(points){var i=0,n=points.length,p=points[0],path=[p[0],\",\",p[1]];while(++i<n){path.push(\"H\",(p=points[i])[0],\"V\",p[1]);}return path.join(\"\");}function d3_svg_lineCardinalOpen(points,tension){return points.length<4?d3_svg_lineLinear(points):points[1]+d3_svg_lineHermite(points.slice(1,-1),d3_svg_lineCardinalTangents(points,tension));}function d3_svg_lineCardinalClosed(points,tension){return points.length<3?d3_svg_lineLinearClosed(points):points[0]+d3_svg_lineHermite((points.push(points[0]),points),d3_svg_lineCardinalTangents([points[points.length-2]].concat(points,[points[1]]),tension));}function d3_svg_lineCardinal(points,tension){return points.length<3?d3_svg_lineLinear(points):points[0]+d3_svg_lineHermite(points,d3_svg_lineCardinalTangents(points,tension));}function d3_svg_lineHermite(points,tangents){if(tangents.length<1||points.length!=tangents.length&&points.length!=tangents.length+2){return d3_svg_lineLinear(points);}var quad=points.length!=tangents.length,path=\"\",p0=points[0],p=points[1],t0=tangents[0],t=t0,pi=1;if(quad){path+=\"Q\"+(p[0]-t0[0]*2/3)+\",\"+(p[1]-t0[1]*2/3)+\",\"+p[0]+\",\"+p[1];p0=points[1];pi=2;}if(tangents.length>1){t=tangents[1];p=points[pi];pi++;path+=\"C\"+(p0[0]+t0[0])+\",\"+(p0[1]+t0[1])+\",\"+(p[0]-t[0])+\",\"+(p[1]-t[1])+\",\"+p[0]+\",\"+p[1];for(var i=2;i<tangents.length;i++,pi++){p=points[pi];t=tangents[i];path+=\"S\"+(p[0]-t[0])+\",\"+(p[1]-t[1])+\",\"+p[0]+\",\"+p[1];}}if(quad){var lp=points[pi];path+=\"Q\"+(p[0]+t[0]*2/3)+\",\"+(p[1]+t[1]*2/3)+\",\"+lp[0]+\",\"+lp[1];}return path;}function d3_svg_lineCardinalTangents(points,tension){var tangents=[],a=(1-tension)/2,p0,p1=points[0],p2=points[1],i=1,n=points.length;while(++i<n){p0=p1;p1=p2;p2=points[i];tangents.push([a*(p2[0]-p0[0]),a*(p2[1]-p0[1])]);}return tangents;}function d3_svg_lineBasis(points){if(points.length<3)return d3_svg_lineLinear(points);var i=1,n=points.length,pi=points[0],x0=pi[0],y0=pi[1],px=[x0,x0,x0,(pi=points[1])[0]],py=[y0,y0,y0,pi[1]],path=[x0,\",\",y0,\"L\",d3_svg_lineDot4(d3_svg_lineBasisBezier3,px),\",\",d3_svg_lineDot4(d3_svg_lineBasisBezier3,py)];points.push(points[n-1]);while(++i<=n){pi=points[i];px.shift();px.push(pi[0]);py.shift();py.push(pi[1]);d3_svg_lineBasisBezier(path,px,py);}points.pop();path.push(\"L\",pi);return path.join(\"\");}function d3_svg_lineBasisOpen(points){if(points.length<4)return d3_svg_lineLinear(points);var path=[],i=-1,n=points.length,pi,px=[0],py=[0];while(++i<3){pi=points[i];px.push(pi[0]);py.push(pi[1]);}path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3,px)+\",\"+d3_svg_lineDot4(d3_svg_lineBasisBezier3,py));--i;while(++i<n){pi=points[i];px.shift();px.push(pi[0]);py.shift();py.push(pi[1]);d3_svg_lineBasisBezier(path,px,py);}return path.join(\"\");}function d3_svg_lineBasisClosed(points){var path,i=-1,n=points.length,m=n+4,pi,px=[],py=[];while(++i<4){pi=points[i%n];px.push(pi[0]);py.push(pi[1]);}path=[d3_svg_lineDot4(d3_svg_lineBasisBezier3,px),\",\",d3_svg_lineDot4(d3_svg_lineBasisBezier3,py)];--i;while(++i<m){pi=points[i%n];px.shift();px.push(pi[0]);py.shift();py.push(pi[1]);d3_svg_lineBasisBezier(path,px,py);}return path.join(\"\");}function d3_svg_lineBundle(points,tension){var n=points.length-1;if(n){var x0=points[0][0],y0=points[0][1],dx=points[n][0]-x0,dy=points[n][1]-y0,i=-1,p,t;while(++i<=n){p=points[i];t=i/n;p[0]=tension*p[0]+(1-tension)*(x0+t*dx);p[1]=tension*p[1]+(1-tension)*(y0+t*dy);}}return d3_svg_lineBasis(points);}function d3_svg_lineDot4(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]+a[3]*b[3];}var d3_svg_lineBasisBezier1=[0,2/3,1/3,0],d3_svg_lineBasisBezier2=[0,1/3,2/3,0],d3_svg_lineBasisBezier3=[0,1/6,2/3,1/6];function d3_svg_lineBasisBezier(path,x,y){path.push(\"C\",d3_svg_lineDot4(d3_svg_lineBasisBezier1,x),\",\",d3_svg_lineDot4(d3_svg_lineBasisBezier1,y),\",\",d3_svg_lineDot4(d3_svg_lineBasisBezier2,x),\",\",d3_svg_lineDot4(d3_svg_lineBasisBezier2,y),\",\",d3_svg_lineDot4(d3_svg_lineBasisBezier3,x),\",\",d3_svg_lineDot4(d3_svg_lineBasisBezier3,y));}function d3_svg_lineSlope(p0,p1){return(p1[1]-p0[1])/(p1[0]-p0[0]);}function d3_svg_lineFiniteDifferences(points){var i=0,j=points.length-1,m=[],p0=points[0],p1=points[1],d=m[0]=d3_svg_lineSlope(p0,p1);while(++i<j){m[i]=(d+(d=d3_svg_lineSlope(p0=p1,p1=points[i+1])))/2;}m[i]=d;return m;}function d3_svg_lineMonotoneTangents(points){var tangents=[],d,a,b,s,m=d3_svg_lineFiniteDifferences(points),i=-1,j=points.length-1;while(++i<j){d=d3_svg_lineSlope(points[i],points[i+1]);if(abs(d)<){m[i]=m[i+1]=0;}else{a=m[i]/d;b=m[i+1]/d;s=a*a+b*b;if(s>9){s=d*3/Math.sqrt(s);m[i]=s*a;m[i+1]=s*b;}}}i=-1;while(++i<=j){s=(points[Math.min(j,i+1)][0]-points[Math.max(0,i-1)][0])/(6*(1+m[i]*m[i]));tangents.push([s||0,m[i]*s||0]);}return tangents;}function d3_svg_lineMonotone(points){return points.length<3?d3_svg_lineLinear(points):points[0]+d3_svg_lineHermite(points,d3_svg_lineMonotoneTangents(points));}d3.svg.line.radial=function(){var line=d3_svg_line(d3_svg_lineRadial);line.radius=line.x,delete line.x;line.angle=line.y,delete line.y;return line;};function d3_svg_lineRadial(points){var point,i=-1,n=points.length,r,a;while(++i<n){point=points[i];r=point[0];a=point[1]-half;point[0]=r*Math.cos(a);point[1]=r*Math.sin(a);}return points;}function d3_svg_area(projection){var x0=d3_geom_pointX,x1=d3_geom_pointX,y0=0,y1=d3_geom_pointY,defined=d3_true,interpolate=d3_svg_lineLinear,interpolateKey=interpolate.key,interpolateReverse=interpolate,L=\"L\",tension=.7;function area(data){var segments=[],points0=[],points1=[],i=-1,n=data.length,d,fx0=d3_functor(x0),fy0=d3_functor(y0),fx1=x0===x1?function(){return x;}:d3_functor(x1),fy1=y0===y1?function(){return y;}:d3_functor(y1),x,y;function segment(){segments.push(\"M\",interpolate(projection(points1),tension),L,interpolateReverse(projection(points0.reverse()),tension),\"Z\");}while(++i<n){if(defined.call(this,d=data[i],i)){points0.push([x=+fx0.call(this,d,i),y=+fy0.call(this,d,i)]);points1.push([+fx1.call(this,d,i),+fy1.call(this,d,i)]);}else if(points0.length){segment();points0=[];points1=[];}}if(points0.length)segment();return segments.length?segments.join(\"\"):null;}area.x=function(_){if(!arguments.length)return x1;x0=x1=_;return area;};area.x0=function(_){if(!arguments.length)return x0;x0=_;return area;};area.x1=function(_){if(!arguments.length)return x1;x1=_;return area;};area.y=function(_){if(!arguments.length)return y1;y0=y1=_;return area;};area.y0=function(_){if(!arguments.length)return y0;y0=_;return area;};area.y1=function(_){if(!arguments.length)return y1;y1=_;return area;};area.defined=function(_){if(!arguments.length)return defined;defined=_;return area;};area.interpolate=function(_){if(!arguments.length)return interpolateKey;if(typeof _===\"function\")interpolateKey=interpolate=_;else interpolateKey=(interpolate=d3_svg_lineInterpolators.get(_)||d3_svg_lineLinear).key;interpolateReverse=interpolate.reverse||interpolate;L=interpolate.closed?\"M\":\"L\";return area;};area.tension=function(_){if(!arguments.length)return tension;tension=_;return area;};return area;}d3_svg_lineStepBefore.reverse=d3_svg_lineStepAfter;d3_svg_lineStepAfter.reverse=d3_svg_lineStepBefore;d3.svg.area=function(){return d3_svg_area(d3_identity);};d3.svg.area.radial=function(){var area=d3_svg_area(d3_svg_lineRadial);area.radius=area.x,delete area.x;area.innerRadius=area.x0,delete area.x0;area.outerRadius=area.x1,delete area.x1;area.angle=area.y,delete area.y;area.startAngle=area.y0,delete area.y0;area.endAngle=area.y1,delete area.y1;return area;};d3.svg.chord=function(){var source=d3_source,target=d3_target,radius=d3_svg_chordRadius,startAngle=d3_svg_arcStartAngle,endAngle=d3_svg_arcEndAngle;function chord(d,i){var s=subgroup(this,source,d,i),t=subgroup(this,target,d,i);return\"M\"+s.p0+arc(s.r,s.p1,s.a1-s.a0)+(equals(s,t)?curve(s.r,s.p1,s.r,s.p0):curve(s.r,s.p1,t.r,t.p0)+arc(t.r,t.p1,t.a1-t.a0)+curve(t.r,t.p1,s.r,s.p0))+\"Z\";}function subgroup(self,f,d,i){var subgroup=f.call(self,d,i),r=radius.call(self,subgroup,i),a0=startAngle.call(self,subgroup,i)-half,a1=endAngle.call(self,subgroup,i)-half;return{r:r,a0:a0,a1:a1,p0:[r*Math.cos(a0),r*Math.sin(a0)],p1:[r*Math.cos(a1),r*Math.sin(a1)]};}function equals(a,b){return a.a0==b.a0&&a.a1==b.a1;}function arc(r,p,a){return\"A\"+r+\",\"+r+\" 0 \"+ +(a>)+\",1 \"+p;}function curve(r0,p0,r1,p1){return\"Q 0,0 \"+p1;}chord.radius=function(v){if(!arguments.length)return radius;radius=d3_functor(v);return chord;};chord.source=function(v){if(!arguments.length)return source;source=d3_functor(v);return chord;};chord.target=function(v){if(!arguments.length)return target;target=d3_functor(v);return chord;};chord.startAngle=function(v){if(!arguments.length)return startAngle;startAngle=d3_functor(v);return chord;};chord.endAngle=function(v){if(!arguments.length)return endAngle;endAngle=d3_functor(v);return chord;};return chord;};function d3_svg_chordRadius(d){return d.radius;}d3.svg.diagonal=function(){var source=d3_source,target=d3_target,projection=d3_svg_diagonalProjection;function diagonal(d,i){var p0=source.call(this,d,i),p3=target.call(this,d,i),m=(p0.y+p3.y)/2,p=[p0,{x:p0.x,y:m},{x:p3.x,y:m},p3];p=p.map(projection);return\"M\"+p[0]+\"C\"+p[1]+\" \"+p[2]+\" \"+p[3];}diagonal.source=function(x){if(!arguments.length)return source;source=d3_functor(x);return diagonal;};diagonal.target=function(x){if(!arguments.length)return target;target=d3_functor(x);return diagonal;};diagonal.projection=function(x){if(!arguments.length)return projection;projection=x;return diagonal;};return diagonal;};function d3_svg_diagonalProjection(d){return[d.x,d.y];}d3.svg.diagonal.radial=function(){var diagonal=d3.svg.diagonal(),projection=d3_svg_diagonalProjection,projection_=diagonal.projection;diagonal.projection=function(x){return arguments.length?projection_(d3_svg_diagonalRadialProjection(projection=x)):projection;};return diagonal;};function d3_svg_diagonalRadialProjection(projection){return function(){var d=projection.apply(this,arguments),r=d[0],a=d[1]-half;return[r*Math.cos(a),r*Math.sin(a)];};}d3.svg.symbol=function(){var type=d3_svg_symbolType,size=d3_svg_symbolSize;function symbol(d,i){return(d3_svg_symbols.get(type.call(this,d,i))||d3_svg_symbolCircle)(size.call(this,d,i));}symbol.type=function(x){if(!arguments.length)return type;type=d3_functor(x);return symbol;};symbol.size=function(x){if(!arguments.length)return size;size=d3_functor(x);return symbol;};return symbol;};function d3_svg_symbolSize(){return 64;}function d3_svg_symbolType(){return\"circle\";}function d3_svg_symbolCircle(size){var r=Math.sqrt(size/);return\"M0,\"+r+\"A\"+r+\",\"+r+\" 0 1,1 0,\"+-r+\"A\"+r+\",\"+r+\" 0 1,1 0,\"+r+\"Z\";}var d3_svg_symbols=d3.map({circle:d3_svg_symbolCircle,cross:function cross(size){var r=Math.sqrt(size/5)/2;return\"M\"+-3*r+\",\"+-r+\"H\"+-r+\"V\"+-3*r+\"H\"+r+\"V\"+-r+\"H\"+3*r+\"V\"+r+\"H\"+r+\"V\"+3*r+\"H\"+-r+\"V\"+r+\"H\"+-3*r+\"Z\";},diamond:function diamond(size){var ry=Math.sqrt(size/(2*d3_svg_symbolTan30)),rx=ry*d3_svg_symbolTan30;return\"M0,\"+-ry+\"L\"+rx+\",0\"+\" 0,\"+ry+\" \"+-rx+\",0\"+\"Z\";},square:function square(size){var r=Math.sqrt(size)/2;return\"M\"+-r+\",\"+-r+\"L\"+r+\",\"+-r+\" \"+r+\",\"+r+\" \"+-r+\",\"+r+\"Z\";},\"triangle-down\":function triangleDown(size){var rx=Math.sqrt(size/d3_svg_symbolSqrt3),ry=rx*d3_svg_symbolSqrt3/2;return\"M0,\"+ry+\"L\"+rx+\",\"+-ry+\" \"+-rx+\",\"+-ry+\"Z\";},\"triangle-up\":function triangleUp(size){var rx=Math.sqrt(size/d3_svg_symbolSqrt3),ry=rx*d3_svg_symbolSqrt3/2;return\"M0,\"+-ry+\"L\"+rx+\",\"+ry+\" \"+-rx+\",\"+ry+\"Z\";}});d3.svg.symbolTypes=d3_svg_symbols.keys();var d3_svg_symbolSqrt3=Math.sqrt(3),d3_svg_symbolTan30=Math.tan(30*d3_radians);d3_selectionPrototype.transition=function(name){var id=d3_transitionInheritId||++d3_transitionId,ns=d3_transitionNamespace(name),subgroups=[],subgroup,node,transition=d3_transitionInherit||{time:Date.now(),ease:d3_ease_cubicInOut,delay:0,duration:250};for(var j=-1,m=this.length;++j<m;){subgroups.push(subgroup=[]);for(var group=this[j],i=-1,n=group.length;++i<n;){if(node=group[i])d3_transitionNode(node,i,ns,id,transition);subgroup.push(node);}}return d3_transition(subgroups,ns,id);};d3_selectionPrototype.interrupt=function(name){return this.each(name==null?d3_selection_interrupt:d3_selection_interruptNS(d3_transitionNamespace(name)));};var d3_selection_interrupt=d3_selection_interruptNS(d3_transitionNamespace());function d3_selection_interruptNS(ns){return function(){var lock,activeId,active;if((lock=this[ns])&&(active=lock[activeId=lock.active])){active.timer.c=null;active.timer.t=NaN;if(--lock.count)delete lock[activeId];else delete this[ns];lock.active+=.5;active.event&&active.event.interrupt.call(this,this.__data__,active.index);}};}function d3_transition(groups,ns,id){d3_subclass(groups,d3_transitionPrototype);groups.namespace=ns;groups.id=id;return groups;}var d3_transitionPrototype=[],d3_transitionId=0,d3_transitionInheritId,d3_transitionInherit;d3_transitionPrototype.call=d3_selectionPrototype.call;d3_transitionPrototype.empty=d3_selectionPrototype.empty;d3_transitionPrototype.node=d3_selectionPrototype.node;d3_transitionPrototype.size=d3_selectionPrototype.size;d3.transition=function(selection,name){return selection&&selection.transition?d3_transitionInheritId?selection.transition(name):selection:d3.selection().transition(selection);};d3.transition.prototype=d3_transitionPrototype;d3_transitionPrototype.select=function(selector){var id=this.id,ns=this.namespace,subgroups=[],subgroup,subnode,node;selector=d3_selection_selector(selector);for(var j=-1,m=this.length;++j<m;){subgroups.push(subgroup=[]);for(var group=this[j],i=-1,n=group.length;++i<n;){if((node=group[i])&&(subnode=selector.call(node,node.__data__,i,j))){if(\"__data__\"in node)subnode.__data__=node.__data__;d3_transitionNode(subnode,i,ns,id,node[ns][id]);subgroup.push(subnode);}else{subgroup.push(null);}}}return d3_transition(subgroups,ns,id);};d3_transitionPrototype.selectAll=function(selector){var id=this.id,ns=this.namespace,subgroups=[],subgroup,subnodes,node,subnode,transition;selector=d3_selection_selectorAll(selector);for(var j=-1,m=this.length;++j<m;){for(var group=this[j],i=-1,n=group.length;++i<n;){if(node=group[i]){transition=node[ns][id];subnodes=selector.call(node,node.__data__,i,j);subgroups.push(subgroup=[]);for(var k=-1,o=subnodes.length;++k<o;){if(subnode=subnodes[k])d3_transitionNode(subnode,k,ns,id,transition);subgroup.push(subnode);}}}}return d3_transition(subgroups,ns,id);};d3_transitionPrototype.filter=function(filter){var subgroups=[],subgroup,group,node;if(typeof filter!==\"function\")filter=d3_selection_filter(filter);for(var j=0,m=this.length;j<m;j++){subgroups.push(subgroup=[]);for(var group=this[j],i=0,n=group.length;i<n;i++){if((node=group[i])&&filter.call(node,node.__data__,i,j)){subgroup.push(node);}}}return d3_transition(subgroups,this.namespace,this.id);};d3_transitionPrototype.tween=function(name,tween){var id=this.id,ns=this.namespace;if(arguments.length<2)return this.node()[ns][id].tween.get(name);return d3_selection_each(this,tween==null?function(node){node[ns][id].tween.remove(name);}:function(node){node[ns][id].tween.set(name,tween);});};function d3_transition_tween(groups,name,value,tween){var id=groups.id,ns=groups.namespace;return d3_selection_each(groups,typeof value===\"function\"?function(node,i,j){node[ns][id].tween.set(name,tween(value.call(node,node.__data__,i,j)));}:(value=tween(value),function(node){node[ns][id].tween.set(name,value);}));}d3_transitionPrototype.attr=function(nameNS,value){if(arguments.length<2){for(value in nameNS){this.attr(value,nameNS[value]);}return this;}var interpolate=nameNS==\"transform\"?d3_interpolateTransform:d3_interpolate,name=d3.ns.qualify(nameNS);function attrNull(){this.removeAttribute(name);}function attrNullNS(){this.removeAttributeNS(name.space,name.local);}function attrTween(b){return b==null?attrNull:(b+=\"\",function(){var a=this.getAttribute(name),i;return a!==b&&(i=interpolate(a,b),function(t){this.setAttribute(name,i(t));});});}function attrTweenNS(b){return b==null?attrNullNS:(b+=\"\",function(){var a=this.getAttributeNS(name.space,name.local),i;return a!==b&&(i=interpolate(a,b),function(t){this.setAttributeNS(name.space,name.local,i(t));});});}return d3_transition_tween(this,\"attr.\"+nameNS,value,name.local?attrTweenNS:attrTween);};d3_transitionPrototype.attrTween=function(nameNS,tween){var name=d3.ns.qualify(nameNS);function attrTween(d,i){var f=tween.call(this,d,i,this.getAttribute(name));return f&&function(t){this.setAttribute(name,f(t));};}function attrTweenNS(d,i){var f=tween.call(this,d,i,this.getAttributeNS(name.space,name.local));return f&&function(t){this.setAttributeNS(name.space,name.local,f(t));};}return this.tween(\"attr.\"+nameNS,name.local?attrTweenNS:attrTween);};d3_transitionPrototype.style=function(name,value,priority){var n=arguments.length;if(n<3){if(typeof name!==\"string\"){if(n<2)value=\"\";for(priority in name){this.style(priority,name[priority],value);}return this;}priority=\"\";}function styleNull(){this.style.removeProperty(name);}function styleString(b){return b==null?styleNull:(b+=\"\",function(){var a=d3_window(this).getComputedStyle(this,null).getPropertyValue(name),i;return a!==b&&(i=d3_interpolate(a,b),function(t){this.style.setProperty(name,i(t),priority);});});}return d3_transition_tween(this,\"style.\"+name,value,styleString);};d3_transitionPrototype.styleTween=function(name,tween,priority){if(arguments.length<3)priority=\"\";function styleTween(d,i){var f=tween.call(this,d,i,d3_window(this).getComputedStyle(this,null).getPropertyValue(name));return f&&function(t){this.style.setProperty(name,f(t),priority);};}return this.tween(\"style.\"+name,styleTween);};d3_transitionPrototype.text=function(value){return d3_transition_tween(this,\"text\",value,d3_transition_text);};function d3_transition_text(b){if(b==null)b=\"\";return function(){this.textContent=b;};}d3_transitionPrototype.remove=function(){var ns=this.namespace;return this.each(\"end.transition\",function(){var p;if(this[ns].count<2&&(p=this.parentNode))p.removeChild(this);});};d3_transitionPrototype.ease=function(value){var id=this.id,ns=this.namespace;if(arguments.length<1)return this.node()[ns][id].ease;if(typeof value!==\"function\")value=d3.ease.apply(d3,arguments);return d3_selection_each(this,function(node){node[ns][id].ease=value;});};d3_transitionPrototype.delay=function(value){var id=this.id,ns=this.namespace;if(arguments.length<1)return this.node()[ns][id].delay;return d3_selection_each(this,typeof value===\"function\"?function(node,i,j){node[ns][id].delay=+value.call(node,node.__data__,i,j);}:(value=+value,function(node){node[ns][id].delay=value;}));};d3_transitionPrototype.duration=function(value){var id=this.id,ns=this.namespace;if(arguments.length<1)return this.node()[ns][id].duration;return d3_selection_each(this,typeof value===\"function\"?function(node,i,j){node[ns][id].duration=Math.max(1,value.call(node,node.__data__,i,j));}:(value=Math.max(1,value),function(node){node[ns][id].duration=value;}));};d3_transitionPrototype.each=function(type,listener){var id=this.id,ns=this.namespace;if(arguments.length<2){var inherit=d3_transitionInherit,inheritId=d3_transitionInheritId;try{d3_transitionInheritId=id;d3_selection_each(this,function(node,i,j){d3_transitionInherit=node[ns][id];type.call(node,node.__data__,i,j);});}finally{d3_transitionInherit=inherit;d3_transitionInheritId=inheritId;}}else{d3_selection_each(this,function(node){var transition=node[ns][id];(transition.event||(transition.event=d3.dispatch(\"start\",\"end\",\"interrupt\"))).on(type,listener);});}return this;};d3_transitionPrototype.transition=function(){var id0=this.id,id1=++d3_transitionId,ns=this.namespace,subgroups=[],subgroup,group,node,transition;for(var j=0,m=this.length;j<m;j++){subgroups.push(subgroup=[]);for(var group=this[j],i=0,n=group.length;i<n;i++){if(node=group[i]){transition=node[ns][id0];d3_transitionNode(node,i,ns,id1,{time:transition.time,ease:transition.ease,delay:transition.delay+transition.duration,duration:transition.duration});}subgroup.push(node);}}return d3_transition(subgroups,ns,id1);};function d3_transitionNamespace(name){return name==null?\"__transition__\":\"__transition_\"+name+\"__\";}function d3_transitionNode(node,i,ns,id,inherit){var lock=node[ns]||(node[ns]={active:0,count:0}),transition=lock[id],time,timer,duration,ease,tweens;function schedule(elapsed){var delay=transition.delay;timer.t=delay+time;if(delay<=elapsed)return start(elapsed-delay);timer.c=start;}function start(elapsed){var activeId=lock.active,active=lock[activeId];if(active){active.timer.c=null;active.timer.t=NaN;--lock.count;delete lock[activeId];active.event&&active.event.interrupt.call(node,node.__data__,active.index);}for(var cancelId in lock){if(+cancelId<id){var cancel=lock[cancelId];cancel.timer.c=null;cancel.timer.t=NaN;--lock.count;delete lock[cancelId];}}timer.c=tick;d3_timer(function(){if(timer.c&&tick(elapsed||1)){timer.c=null;timer.t=NaN;}return 1;},0,time);lock.active=id;transition.event&&transition.event.start.call(node,node.__data__,i);tweens=[];transition.tween.forEach(function(key,value){if(value=value.call(node,node.__data__,i)){tweens.push(value);}});ease=transition.ease;duration=transition.duration;}function tick(elapsed){var t=elapsed/duration,e=ease(t),n=tweens.length;while(n>0){tweens[--n].call(node,e);}if(t>=1){transition.event&&transition.event.end.call(node,node.__data__,i);if(--lock.count)delete lock[id];else delete node[ns];return 1;}}if(!transition){time=inherit.time;timer=d3_timer(schedule,0,time);transition=lock[id]={tween:new d3_Map(),time:time,timer:timer,delay:inherit.delay,duration:inherit.duration,ease:inherit.ease,index:i};inherit=null;++lock.count;}}d3.svg.axis=function(){var scale=d3.scale.linear(),orient=d3_svg_axisDefaultOrient,innerTickSize=6,outerTickSize=6,tickPadding=3,tickArguments_=[10],tickValues=null,tickFormat_;function axis(g){g.each(function(){var g=d3.select(this);var scale0=this.__chart__||scale,scale1=this.__chart__=scale.copy();var ticks=tickValues==null?scale1.ticks?scale1.ticks.apply(scale1,tickArguments_):scale1.domain():tickValues,tickFormat=tickFormat_==null?scale1.tickFormat?scale1.tickFormat.apply(scale1,tickArguments_):d3_identity:tickFormat_,tick=g.selectAll(\".tick\").data(ticks,scale1),tickEnter=tick.enter().insert(\"g\",\".domain\").attr(\"class\",\"tick\").style(\"opacity\",),tickExit=d3.transition(tick.exit()).style(\"opacity\",).remove(),tickUpdate=d3.transition(tick.order()).style(\"opacity\",1),tickSpacing=Math.max(innerTickSize,0)+tickPadding,tickTransform;var range=d3_scaleRange(scale1),path=g.selectAll(\".domain\").data([0]),pathUpdate=(path.enter().append(\"path\").attr(\"class\",\"domain\"),d3.transition(path));tickEnter.append(\"line\");tickEnter.append(\"text\");var lineEnter=tickEnter.select(\"line\"),lineUpdate=tickUpdate.select(\"line\"),text=tick.select(\"text\").text(tickFormat),textEnter=tickEnter.select(\"text\"),textUpdate=tickUpdate.select(\"text\"),sign=orient===\"top\"||orient===\"left\"?-1:1,x1,x2,y1,y2;if(orient===\"bottom\"||orient===\"top\"){tickTransform=d3_svg_axisX,x1=\"x\",y1=\"y\",x2=\"x2\",y2=\"y2\";text.attr(\"dy\",sign<0?\"0em\":\".71em\").style(\"text-anchor\",\"middle\");pathUpdate.attr(\"d\",\"M\"+range[0]+\",\"+sign*outerTickSize+\"V0H\"+range[1]+\"V\"+sign*outerTickSize);}else{tickTransform=d3_svg_axisY,x1=\"y\",y1=\"x\",x2=\"y2\",y2=\"x2\";text.attr(\"dy\",\".32em\").style(\"text-anchor\",sign<0?\"end\":\"start\");pathUpdate.attr(\"d\",\"M\"+sign*outerTickSize+\",\"+range[0]+\"H0V\"+range[1]+\"H\"+sign*outerTickSize);}lineEnter.attr(y2,sign*innerTickSize);textEnter.attr(y1,sign*tickSpacing);lineUpdate.attr(x2,0).attr(y2,sign*innerTickSize);textUpdate.attr(x1,0).attr(y1,sign*tickSpacing);if(scale1.rangeBand){var x=scale1,dx=x.rangeBand()/2;scale0=scale1=function scale1(d){return x(d)+dx;};}else if(scale0.rangeBand){scale0=scale1;}else{tickExit.call(tickTransform,scale1,scale0);}tickEnter.call(tickTransform,scale0,scale1);tickUpdate.call(tickTransform,scale1,scale1);});}axis.scale=function(x){if(!arguments.length)return scale;scale=x;return axis;};axis.orient=function(x){if(!arguments.length)return orient;orient=x in d3_svg_axisOrients?x+\"\":d3_svg_axisDefaultOrient;return axis;};axis.ticks=function(){if(!arguments.length)return tickArguments_;tickArguments_=d3_array(arguments);return axis;};axis.tickValues=function(x){if(!arguments.length)return tickValues;tickValues=x;return axis;};axis.tickFormat=function(x){if(!arguments.length)return tickFormat_;tickFormat_=x;return axis;};axis.tickSize=function(x){var n=arguments.length;if(!n)return innerTickSize;innerTickSize=+x;outerTickSize=+arguments[n-1];return axis;};axis.innerTickSize=function(x){if(!arguments.length)return innerTickSize;innerTickSize=+x;return axis;};axis.outerTickSize=function(x){if(!arguments.length)return outerTickSize;outerTickSize=+x;return axis;};axis.tickPadding=function(x){if(!arguments.length)return tickPadding;tickPadding=+x;return axis;};axis.tickSubdivide=function(){return arguments.length&&axis;};return axis;};var d3_svg_axisDefaultOrient=\"bottom\",d3_svg_axisOrients={top:1,right:1,bottom:1,left:1};function d3_svg_axisX(selection,x0,x1){selection.attr(\"transform\",function(d){var v0=x0(d);return\"translate(\"+(isFinite(v0)?v0:x1(d))+\",0)\";});}function d3_svg_axisY(selection,y0,y1){selection.attr(\"transform\",function(d){var v0=y0(d);return\"translate(0,\"+(isFinite(v0)?v0:y1(d))+\")\";});}d3.svg.brush=function(){var event=d3_eventDispatch(brush,\"brushstart\",\"brush\",\"brushend\"),x=null,y=null,xExtent=[0,0],yExtent=[0,0],xExtentDomain,yExtentDomain,xClamp=true,yClamp=true,resizes=d3_svg_brushResizes[0];function brush(g){g.each(function(){var g=d3.select(this).style(\"pointer-events\",\"all\").style(\"-webkit-tap-highlight-color\",\"rgba(0,0,0,0)\").on(\"mousedown.brush\",brushstart).on(\"touchstart.brush\",brushstart);var background=g.selectAll(\".background\").data([0]);background.enter().append(\"rect\").attr(\"class\",\"background\").style(\"visibility\",\"hidden\").style(\"cursor\",\"crosshair\");g.selectAll(\".extent\").data([0]).enter().append(\"rect\").attr(\"class\",\"extent\").style(\"cursor\",\"move\");var resize=g.selectAll(\".resize\").data(resizes,d3_identity);resize.exit().remove();resize.enter().append(\"g\").attr(\"class\",function(d){return\"resize \"+d;}).style(\"cursor\",function(d){return d3_svg_brushCursor[d];}).append(\"rect\").attr(\"x\",function(d){return /[ew]$/.test(d)?-3:null;}).attr(\"y\",function(d){return /^[ns]/.test(d)?-3:null;}).attr(\"width\",6).attr(\"height\",6).style(\"visibility\",\"hidden\");resize.style(\"display\",brush.empty()?\"none\":null);var gUpdate=d3.transition(g),backgroundUpdate=d3.transition(background),range;if(x){range=d3_scaleRange(x);backgroundUpdate.attr(\"x\",range[0]).attr(\"width\",range[1]-range[0]);redrawX(gUpdate);}if(y){range=d3_scaleRange(y);backgroundUpdate.attr(\"y\",range[0]).attr(\"height\",range[1]-range[0]);redrawY(gUpdate);}redraw(gUpdate);});}brush.event=function(g){g.each(function(){var event_=event.of(this,arguments),extent1={x:xExtent,y:yExtent,i:xExtentDomain,j:yExtentDomain},extent0=this.__chart__||extent1;this.__chart__=extent1;if(d3_transitionInheritId){d3.select(this).transition().each(\"start.brush\",function(){xExtentDomain=extent0.i;yExtentDomain=extent0.j;xExtent=extent0.x;yExtent=extent0.y;event_({type:\"brushstart\"});}).tween(\"brush:brush\",function(){var xi=d3_interpolateArray(xExtent,extent1.x),yi=d3_interpolateArray(yExtent,extent1.y);xExtentDomain=yExtentDomain=null;return function(t){xExtent=extent1.x=xi(t);yExtent=extent1.y=yi(t);event_({type:\"brush\",mode:\"resize\"});};}).each(\"end.brush\",function(){xExtentDomain=extent1.i;yExtentDomain=extent1.j;event_({type:\"brush\",mode:\"resize\"});event_({type:\"brushend\"});});}else{event_({type:\"brushstart\"});event_({type:\"brush\",mode:\"resize\"});event_({type:\"brushend\"});}});};function redraw(g){g.selectAll(\".resize\").attr(\"transform\",function(d){return\"translate(\"+xExtent[+/e$/.test(d)]+\",\"+yExtent[+/^s/.test(d)]+\")\";});}function redrawX(g){g.select(\".extent\").attr(\"x\",xExtent[0]);g.selectAll(\".extent,.n>rect,.s>rect\").attr(\"width\",xExtent[1]-xExtent[0]);}function redrawY(g){g.select(\".extent\").attr(\"y\",yExtent[0]);g.selectAll(\".extent,.e>rect,.w>rect\").attr(\"height\",yExtent[1]-yExtent[0]);}function brushstart(){var target=this,eventTarget=d3.select(d3.event.target),event_=event.of(target,arguments),g=d3.select(target),resizing=eventTarget.datum(),resizingX=!/^(n|s)$/.test(resizing)&&x,resizingY=!/^(e|w)$/.test(resizing)&&y,dragging=eventTarget.classed(\"extent\"),dragRestore=d3_event_dragSuppress(target),center,origin=d3.mouse(target),offset;var w=d3.select(d3_window(target)).on(\"keydown.brush\",keydown).on(\"keyup.brush\",keyup);if(d3.event.changedTouches){w.on(\"touchmove.brush\",brushmove).on(\"touchend.brush\",brushend);}else{w.on(\"mousemove.brush\",brushmove).on(\"mouseup.brush\",brushend);}g.interrupt().selectAll(\"*\").interrupt();if(dragging){origin[0]=xExtent[0]-origin[0];origin[1]=yExtent[0]-origin[1];}else if(resizing){var ex=+/w$/.test(resizing),ey=+/^n/.test(resizing);offset=[xExtent[1-ex]-origin[0],yExtent[1-ey]-origin[1]];origin[0]=xExtent[ex];origin[1]=yExtent[ey];}else if(d3.event.altKey)center=origin.slice();g.style(\"pointer-events\",\"none\").selectAll(\".resize\").style(\"display\",null);d3.select(\"body\").style(\"cursor\",eventTarget.style(\"cursor\"));event_({type:\"brushstart\"});brushmove();function keydown(){if(d3.event.keyCode==32){if(!dragging){center=null;origin[0]-=xExtent[1];origin[1]-=yExtent[1];dragging=2;}d3_eventPreventDefault();}}function keyup(){if(d3.event.keyCode==32&&dragging==2){origin[0]+=xExtent[1];origin[1]+=yExtent[1];dragging=0;d3_eventPreventDefault();}}function brushmove(){var point=d3.mouse(target),moved=false;if(offset){point[0]+=offset[0];point[1]+=offset[1];}if(!dragging){if(d3.event.altKey){if(!center)center=[(xExtent[0]+xExtent[1])/2,(yExtent[0]+yExtent[1])/2];origin[0]=xExtent[+(point[0]<center[0])];origin[1]=yExtent[+(point[1]<center[1])];}else center=null;}if(resizingX&&move1(point,x,0)){redrawX(g);moved=true;}if(resizingY&&move1(point,y,1)){redrawY(g);moved=true;}if(moved){redraw(g);event_({type:\"brush\",mode:dragging?\"move\":\"resize\"});}}function move1(point,scale,i){var range=d3_scaleRange(scale),r0=range[0],r1=range[1],position=origin[i],extent=i?yExtent:xExtent,size=extent[1]-extent[0],min,max;if(dragging){r0-=position;r1-=size+position;}min=(i?yClamp:xClamp)?Math.max(r0,Math.min(r1,point[i])):point[i];if(dragging){max=(min+=position)+size;}else{if(center)position=Math.max(r0,Math.min(r1,2*center[i]-min));if(position<min){max=min;min=position;}else{max=position;}}if(extent[0]!=min||extent[1]!=max){if(i)yExtentDomain=null;else xExtentDomain=null;extent[0]=min;extent[1]=max;return true;}}function brushend(){brushmove();g.style(\"pointer-events\",\"all\").selectAll(\".resize\").style(\"display\",brush.empty()?\"none\":null);d3.select(\"body\").style(\"cursor\",null);w.on(\"mousemove.brush\",null).on(\"mouseup.brush\",null).on(\"touchmove.brush\",null).on(\"touchend.brush\",null).on(\"keydown.brush\",null).on(\"keyup.brush\",null);dragRestore();event_({type:\"brushend\"});}}brush.x=function(z){if(!arguments.length)return x;x=z;resizes=d3_svg_brushResizes[!x<<1|!y];return brush;};brush.y=function(z){if(!arguments.length)return y;y=z;resizes=d3_svg_brushResizes[!x<<1|!y];return brush;};brush.clamp=function(z){if(!arguments.length)return x&&y?[xClamp,yClamp]:x?xClamp:y?yClamp:null;if(x&&y)xClamp=!!z[0],yClamp=!!z[1];else if(x)xClamp=!!z;else if(y)yClamp=!!z;return brush;};brush.extent=function(z){var x0,x1,y0,y1,t;if(!arguments.length){if(x){if(xExtentDomain){x0=xExtentDomain[0],x1=xExtentDomain[1];}else{x0=xExtent[0],x1=xExtent[1];if(x.invert)x0=x.invert(x0),x1=x.invert(x1);if(x1<x0)t=x0,x0=x1,x1=t;}}if(y){if(yExtentDomain){y0=yExtentDomain[0],y1=yExtentDomain[1];}else{y0=yExtent[0],y1=yExtent[1];if(y.invert)y0=y.invert(y0),y1=y.invert(y1);if(y1<y0)t=y0,y0=y1,y1=t;}}return x&&y?[[x0,y0],[x1,y1]]:x?[x0,x1]:y&&[y0,y1];}if(x){x0=z[0],x1=z[1];if(y)x0=x0[0],x1=x1[0];xExtentDomain=[x0,x1];if(x.invert)x0=x(x0),x1=x(x1);if(x1<x0)t=x0,x0=x1,x1=t;if(x0!=xExtent[0]||x1!=xExtent[1])xExtent=[x0,x1];}if(y){y0=z[0],y1=z[1];if(x)y0=y0[1],y1=y1[1];yExtentDomain=[y0,y1];if(y.invert)y0=y(y0),y1=y(y1);if(y1<y0)t=y0,y0=y1,y1=t;if(y0!=yExtent[0]||y1!=yExtent[1])yExtent=[y0,y1];}return brush;};brush.clear=function(){if(!brush.empty()){xExtent=[0,0],yExtent=[0,0];xExtentDomain=yExtentDomain=null;}return brush;};brush.empty=function(){return!!x&&xExtent[0]==xExtent[1]||!!y&&yExtent[0]==yExtent[1];};return d3.rebind(brush,event,\"on\");};var d3_svg_brushCursor={n:\"ns-resize\",e:\"ew-resize\",s:\"ns-resize\",w:\"ew-resize\",nw:\"nwse-resize\",ne:\"nesw-resize\",se:\"nwse-resize\",sw:\"nesw-resize\"};var d3_svg_brushResizes=[[\"n\",\"e\",\"s\",\"w\",\"nw\",\"ne\",\"se\",\"sw\"],[\"e\",\"w\"],[\"n\",\"s\"],[]];var d3_time_format=d3_time.format=d3_locale_enUS.timeFormat;var d3_time_formatUtc=d3_time_format.utc;var d3_time_formatIso=d3_time_formatUtc(\"%Y-%m-%dT%H:%M:%S.%LZ\");d3_time_format.iso=Date.prototype.toISOString&&+new Date(\"2000-01-01T00:00:00.000Z\")?d3_time_formatIsoNative:d3_time_formatIso;function d3_time_formatIsoNative(date){return date.toISOString();}d3_time_formatIsoNative.parse=function(string){var date=new Date(string);return isNaN(date)?null:date;};d3_time_formatIsoNative.toString=d3_time_formatIso.toString;d3_time.second=d3_time_interval(function(date){return new d3_date(Math.floor(date/1e3)*1e3);},function(date,offset){date.setTime(date.getTime()+Math.floor(offset)*1e3);},function(date){return date.getSeconds();});d3_time.seconds=d3_time.second.range;d3_time.seconds.utc=d3_time.second.utc.range;d3_time.minute=d3_time_interval(function(date){return new d3_date(Math.floor(date/6e4)*6e4);},function(date,offset){date.setTime(date.getTime()+Math.floor(offset)*6e4);},function(date){return date.getMinutes();});d3_time.minutes=d3_time.minute.range;d3_time.minutes.utc=d3_time.minute.utc.range;d3_time.hour=d3_time_interval(function(date){var timezone=date.getTimezoneOffset()/60;return new d3_date((Math.floor(date/36e5-timezone)+timezone)*36e5);},function(date,offset){date.setTime(date.getTime()+Math.floor(offset)*36e5);},function(date){return date.getHours();});d3_time.hours=d3_time.hour.range;d3_time.hours.utc=d3_time.hour.utc.range;d3_time.month=d3_time_interval(function(date){date=d3_time.day(date);date.setDate(1);return date;},function(date,offset){date.setMonth(date.getMonth()+offset);},function(date){return date.getMonth();});d3_time.months=d3_time.month.range;d3_time.months.utc=d3_time.month.utc.range;function d3_time_scale(linear,methods,format){function scale(x){return linear(x);}scale.invert=function(x){return d3_time_scaleDate(linear.invert(x));};scale.domain=function(x){if(!arguments.length)return linear.domain().map(d3_time_scaleDate);linear.domain(x);return scale;};function tickMethod(extent,count){var span=extent[1]-extent[0],target=span/count,i=d3.bisect(d3_time_scaleSteps,target);return i==d3_time_scaleSteps.length?[methods.year,d3_scale_linearTickRange(extent.map(function(d){return d/31536e6;}),count)[2]]:!i?[d3_time_scaleMilliseconds,d3_scale_linearTickRange(extent,count)[2]]:methods[target/d3_time_scaleSteps[i-1]<d3_time_scaleSteps[i]/target?i-1:i];}scale.nice=function(interval,skip){var domain=scale.domain(),extent=d3_scaleExtent(domain),method=interval==null?tickMethod(extent,10):typeof interval===\"number\"&&tickMethod(extent,interval);if(method)interval=method[0],skip=method[1];function skipped(date){return!isNaN(date)&&!interval.range(date,d3_time_scaleDate(+date+1),skip).length;}return scale.domain(d3_scale_nice(domain,skip>1?{floor:function floor(date){while(skipped(date=interval.floor(date))){date=d3_time_scaleDate(date-1);}return date;},ceil:function ceil(date){while(skipped(date=interval.ceil(date))){date=d3_time_scaleDate(+date+1);}return date;}}:interval));};scale.ticks=function(interval,skip){var extent=d3_scaleExtent(scale.domain()),method=interval==null?tickMethod(extent,10):typeof interval===\"number\"?tickMethod(extent,interval):!interval.range&&[{range:interval},skip];if(method)interval=method[0],skip=method[1];return interval.range(extent[0],d3_time_scaleDate(+extent[1]+1),skip<1?1:skip);};scale.tickFormat=function(){return format;};scale.copy=function(){return d3_time_scale(linear.copy(),methods,format);};return d3_scale_linearRebind(scale,linear);}function d3_time_scaleDate(t){return new Date(t);}var d3_time_scaleSteps=[1e3,5e3,15e3,3e4,6e4,3e5,9e5,18e5,36e5,108e5,216e5,432e5,864e5,1728e5,6048e5,2592e6,7776e6,31536e6];var d3_time_scaleLocalMethods=[[d3_time.second,1],[d3_time.second,5],[d3_time.second,15],[d3_time.second,30],[d3_time.minute,1],[d3_time.minute,5],[d3_time.minute,15],[d3_time.minute,30],[d3_time.hour,1],[d3_time.hour,3],[d3_time.hour,6],[d3_time.hour,12],[d3_time.day,1],[d3_time.day,2],[d3_time.week,1],[d3_time.month,1],[d3_time.month,3],[d3_time.year,1]];var d3_time_scaleLocalFormat=d3_time_format.multi([[\".%L\",function(d){return d.getMilliseconds();}],[\":%S\",function(d){return d.getSeconds();}],[\"%I:%M\",function(d){return d.getMinutes();}],[\"%I %p\",function(d){return d.getHours();}],[\"%a %d\",function(d){return d.getDay()&&d.getDate()!=1;}],[\"%b %d\",function(d){return d.getDate()!=1;}],[\"%B\",function(d){return d.getMonth();}],[\"%Y\",d3_true]]);var d3_time_scaleMilliseconds={range:function range(start,stop,step){return d3.range(Math.ceil(start/step)*step,+stop,step).map(d3_time_scaleDate);},floor:d3_identity,ceil:d3_identity};d3_time_scaleLocalMethods.year=d3_time.year;d3_time.scale=function(){return d3_time_scale(d3.scale.linear(),d3_time_scaleLocalMethods,d3_time_scaleLocalFormat);};var d3_time_scaleUtcMethods=d3_time_scaleLocalMethods.map(function(m){return[m[0].utc,m[1]];});var d3_time_scaleUtcFormat=d3_time_formatUtc.multi([[\".%L\",function(d){return d.getUTCMilliseconds();}],[\":%S\",function(d){return d.getUTCSeconds();}],[\"%I:%M\",function(d){return d.getUTCMinutes();}],[\"%I %p\",function(d){return d.getUTCHours();}],[\"%a %d\",function(d){return d.getUTCDay()&&d.getUTCDate()!=1;}],[\"%b %d\",function(d){return d.getUTCDate()!=1;}],[\"%B\",function(d){return d.getUTCMonth();}],[\"%Y\",d3_true]]);d3_time_scaleUtcMethods.year=d3_time.year.utc;d3_time.scale.utc=function(){return d3_time_scale(d3.scale.linear(),d3_time_scaleUtcMethods,d3_time_scaleUtcFormat);};d3.text=d3_xhrType(function(request){return request.responseText;});d3.json=function(url,callback){return d3_xhr(url,\"application/json\",d3_json,callback);};function d3_json(request){return JSON.parse(request.responseText);}d3.html=function(url,callback){return d3_xhr(url,\"text/html\",d3_html,callback);};function d3_html(request){var range=d3_document.createRange();range.selectNode(d3_document.body);return range.createContextualFragment(request.responseText);}d3.xml=d3_xhrType(function(request){return request.responseXML;});if(typeof define===\"function\"&&define.amd)this.d3=d3,define(d3);else if(_typeof(module)===\"object\"&&module.exports)module.exports=d3;else this.d3=d3;}();},{}],9:[function(_dereq_,module,exports){(function(process,global){/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   3.3.1\n */(function(global,factory){_typeof(exports)==='object'&&typeof module!=='undefined'?module.exports=factory():typeof define==='function'&&define.amd?define(factory):global.ES6Promise=factory();})(this,function(){'use strict';function objectOrFunction(x){return typeof x==='function'||_typeof(x)==='object'&&x!==null;}function isFunction(x){return typeof x==='function';}var _isArray=undefined;if(!Array.isArray){_isArray=function _isArray(x){return Object.prototype.toString.call(x)==='[object Array]';};}else{_isArray=Array.isArray;}var isArray=_isArray;var len=0;var vertxNext=undefined;var customSchedulerFn=undefined;var asap=function asap(callback,arg){queue[len]=callback;queue[len+1]=arg;len+=2;if(len===2){// If len is 2, that means that we need to schedule an async flush.\n// If additional callbacks are queued before the queue is flushed, they\n// will be processed by this flush that we are scheduling.\nif(customSchedulerFn){customSchedulerFn(flush);}else{scheduleFlush();}}};function setScheduler(scheduleFn){customSchedulerFn=scheduleFn;}function setAsap(asapFn){asap=asapFn;}var browserWindow=typeof window!=='undefined'?window:undefined;var browserGlobal=browserWindow||{};var BrowserMutationObserver=browserGlobal.MutationObserver||browserGlobal.WebKitMutationObserver;var isNode=typeof self==='undefined'&&typeof process!=='undefined'&&{}.toString.call(process)==='[object process]';// test for web worker but not in IE10\nvar isWorker=typeof Uint8ClampedArray!=='undefined'&&typeof importScripts!=='undefined'&&typeof MessageChannel!=='undefined';// node\nfunction useNextTick(){// node version 0.10.x displays a deprecation warning when nextTick is used recursively\n// see https://github.com/cujojs/when/issues/410 for details\nreturn function(){return process.nextTick(flush);};}// vertx\nfunction useVertxTimer(){return function(){vertxNext(flush);};}function useMutationObserver(){var iterations=0;var observer=new BrowserMutationObserver(flush);var node=document.createTextNode('');observer.observe(node,{characterData:true});return function(){node.data=iterations=++iterations%2;};}// web worker\nfunction useMessageChannel(){var channel=new MessageChannel();channel.port1.onmessage=flush;return function(){return channel.port2.postMessage(0);};}function useSetTimeout(){// Store setTimeout reference so es6-promise will be unaffected by\n// other code modifying setTimeout (like sinon.useFakeTimers())\nvar globalSetTimeout=setTimeout;return function(){return globalSetTimeout(flush,1);};}var queue=new Array(1000);function flush(){for(var i=0;i<len;i+=2){var callback=queue[i];var arg=queue[i+1];callback(arg);queue[i]=undefined;queue[i+1]=undefined;}len=0;}function attemptVertx(){try{var r=_dereq_;var vertx=r('vertx');vertxNext=vertx.runOnLoop||vertx.runOnContext;return useVertxTimer();}catch(e){return useSetTimeout();}}var scheduleFlush=undefined;// Decide what async method to use to triggering processing of queued callbacks:\nif(isNode){scheduleFlush=useNextTick();}else if(BrowserMutationObserver){scheduleFlush=useMutationObserver();}else if(isWorker){scheduleFlush=useMessageChannel();}else if(browserWindow===undefined&&typeof _dereq_==='function'){scheduleFlush=attemptVertx();}else{scheduleFlush=useSetTimeout();}function then(onFulfillment,onRejection){var _arguments=arguments;var parent=this;var child=new this.constructor(noop);if(child[PROMISE_ID]===undefined){makePromise(child);}var _state=parent._state;if(_state){(function(){var callback=_arguments[_state-1];asap(function(){return invokeCallback(_state,child,callback,parent._result);});})();}else{subscribe(parent,child,onFulfillment,onRejection);}return child;}/**\n  `Promise.resolve` returns a promise that will become resolved with the\n  passed `value`. It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @static\n  @param {Any} value value that the returned promise will be resolved with\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/function resolve(object){/*jshint validthis:true */var Constructor=this;if(object&&_typeof(object)==='object'&&object.constructor===Constructor){return object;}var promise=new Constructor(noop);_resolve(promise,object);return promise;}var PROMISE_ID=Math.random().toString(36).substring(16);function noop(){}var PENDING=void 0;var FULFILLED=1;var REJECTED=2;var GET_THEN_ERROR=new ErrorObject();function selfFulfillment(){return new TypeError(\"You cannot resolve a promise with itself\");}function cannotReturnOwn(){return new TypeError('A promises callback cannot return that same promise.');}function getThen(promise){try{return promise.then;}catch(error){GET_THEN_ERROR.error=error;return GET_THEN_ERROR;}}function tryThen(then,value,fulfillmentHandler,rejectionHandler){try{then.call(value,fulfillmentHandler,rejectionHandler);}catch(e){return e;}}function handleForeignThenable(promise,thenable,then){asap(function(promise){var sealed=false;var error=tryThen(then,thenable,function(value){if(sealed){return;}sealed=true;if(thenable!==value){_resolve(promise,value);}else{fulfill(promise,value);}},function(reason){if(sealed){return;}sealed=true;_reject(promise,reason);},'Settle: '+(promise._label||' unknown promise'));if(!sealed&&error){sealed=true;_reject(promise,error);}},promise);}function handleOwnThenable(promise,thenable){if(thenable._state===FULFILLED){fulfill(promise,thenable._result);}else if(thenable._state===REJECTED){_reject(promise,thenable._result);}else{subscribe(thenable,undefined,function(value){return _resolve(promise,value);},function(reason){return _reject(promise,reason);});}}function handleMaybeThenable(promise,maybeThenable,then$$){if(maybeThenable.constructor===promise.constructor&&then$$===then&&maybeThenable.constructor.resolve===resolve){handleOwnThenable(promise,maybeThenable);}else{if(then$$===GET_THEN_ERROR){_reject(promise,GET_THEN_ERROR.error);}else if(then$$===undefined){fulfill(promise,maybeThenable);}else if(isFunction(then$$)){handleForeignThenable(promise,maybeThenable,then$$);}else{fulfill(promise,maybeThenable);}}}function _resolve(promise,value){if(promise===value){_reject(promise,selfFulfillment());}else if(objectOrFunction(value)){handleMaybeThenable(promise,value,getThen(value));}else{fulfill(promise,value);}}function publishRejection(promise){if(promise._onerror){promise._onerror(promise._result);}publish(promise);}function fulfill(promise,value){if(promise._state!==PENDING){return;}promise._result=value;promise._state=FULFILLED;if(promise._subscribers.length!==0){asap(publish,promise);}}function _reject(promise,reason){if(promise._state!==PENDING){return;}promise._state=REJECTED;promise._result=reason;asap(publishRejection,promise);}function subscribe(parent,child,onFulfillment,onRejection){var _subscribers=parent._subscribers;var length=_subscribers.length;parent._onerror=null;_subscribers[length]=child;_subscribers[length+FULFILLED]=onFulfillment;_subscribers[length+REJECTED]=onRejection;if(length===0&&parent._state){asap(publish,parent);}}function publish(promise){var subscribers=promise._subscribers;var settled=promise._state;if(subscribers.length===0){return;}var child=undefined,callback=undefined,detail=promise._result;for(var i=0;i<subscribers.length;i+=3){child=subscribers[i];callback=subscribers[i+settled];if(child){invokeCallback(settled,child,callback,detail);}else{callback(detail);}}promise._subscribers.length=0;}function ErrorObject(){this.error=null;}var TRY_CATCH_ERROR=new ErrorObject();function tryCatch(callback,detail){try{return callback(detail);}catch(e){TRY_CATCH_ERROR.error=e;return TRY_CATCH_ERROR;}}function invokeCallback(settled,promise,callback,detail){var hasCallback=isFunction(callback),value=undefined,error=undefined,succeeded=undefined,failed=undefined;if(hasCallback){value=tryCatch(callback,detail);if(value===TRY_CATCH_ERROR){failed=true;error=value.error;value=null;}else{succeeded=true;}if(promise===value){_reject(promise,cannotReturnOwn());return;}}else{value=detail;succeeded=true;}if(promise._state!==PENDING){// noop\n}else if(hasCallback&&succeeded){_resolve(promise,value);}else if(failed){_reject(promise,error);}else if(settled===FULFILLED){fulfill(promise,value);}else if(settled===REJECTED){_reject(promise,value);}}function initializePromise(promise,resolver){try{resolver(function resolvePromise(value){_resolve(promise,value);},function rejectPromise(reason){_reject(promise,reason);});}catch(e){_reject(promise,e);}}var id=0;function nextId(){return id++;}function makePromise(promise){promise[PROMISE_ID]=id++;promise._state=undefined;promise._result=undefined;promise._subscribers=[];}function Enumerator(Constructor,input){this._instanceConstructor=Constructor;this.promise=new Constructor(noop);if(!this.promise[PROMISE_ID]){makePromise(this.promise);}if(isArray(input)){this._input=input;this.length=input.length;this._remaining=input.length;this._result=new Array(this.length);if(this.length===0){fulfill(this.promise,this._result);}else{this.length=this.length||0;this._enumerate();if(this._remaining===0){fulfill(this.promise,this._result);}}}else{_reject(this.promise,validationError());}}function validationError(){return new Error('Array Methods must be provided an Array');};Enumerator.prototype._enumerate=function(){var length=this.length;var _input=this._input;for(var i=0;this._state===PENDING&&i<length;i++){this._eachEntry(_input[i],i);}};Enumerator.prototype._eachEntry=function(entry,i){var c=this._instanceConstructor;var resolve$$=c.resolve;if(resolve$$===resolve){var _then=getThen(entry);if(_then===then&&entry._state!==PENDING){this._settledAt(entry._state,i,entry._result);}else if(typeof _then!=='function'){this._remaining--;this._result[i]=entry;}else if(c===Promise){var promise=new c(noop);handleMaybeThenable(promise,entry,_then);this._willSettleAt(promise,i);}else{this._willSettleAt(new c(function(resolve$$){return resolve$$(entry);}),i);}}else{this._willSettleAt(resolve$$(entry),i);}};Enumerator.prototype._settledAt=function(state,i,value){var promise=this.promise;if(promise._state===PENDING){this._remaining--;if(state===REJECTED){_reject(promise,value);}else{this._result[i]=value;}}if(this._remaining===0){fulfill(promise,this._result);}};Enumerator.prototype._willSettleAt=function(promise,i){var enumerator=this;subscribe(promise,undefined,function(value){return enumerator._settledAt(FULFILLED,i,value);},function(reason){return enumerator._settledAt(REJECTED,i,reason);});};/**\n  `Promise.all` accepts an array of promises, and returns a new promise which\n  is fulfilled with an array of fulfillment values for the passed promises, or\n  rejected with the reason of the first passed promise to be rejected. It casts all\n  elements of the passed iterable to promises as it runs this algorithm.\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error(\"2\"));\n  let promise3 = reject(new Error(\"3\"));\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @static\n  @param {Array} entries array of promises\n  @param {String} label optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n  @static\n*/function all(entries){return new Enumerator(this,entries).promise;}/**\n  `Promise.race` returns a new promise which is settled in the same way as the\n  first passed promise to settle.\n\n  Example:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 2');\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // result === 'promise 2' because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `Promise.race` is deterministic in that only the state of the first\n  settled promise matters. For example, even if other promises given to the\n  `promises` array argument are resolved, but the first settled promise has\n  become rejected before the other promises became fulfilled, the returned\n  promise will become rejected:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error('promise 2'));\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // Code here never runs\n  }, function(reason){\n    // reason.message === 'promise 2' because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  An example real-world use case is implementing timeouts:\n\n  ```javascript\n  Promise.race([ajax('foo.json'), timeout(5000)])\n  ```\n\n  @method race\n  @static\n  @param {Array} promises array of promises to observe\n  Useful for tooling.\n  @return {Promise} a promise which settles in the same way as the first passed\n  promise to settle.\n*/function race(entries){/*jshint validthis:true */var Constructor=this;if(!isArray(entries)){return new Constructor(function(_,reject){return reject(new TypeError('You must pass an array to race.'));});}else{return new Constructor(function(resolve,reject){var length=entries.length;for(var i=0;i<length;i++){Constructor.resolve(entries[i]).then(resolve,reject);}});}}/**\n  `Promise.reject` returns a promise rejected with the passed `reason`.\n  It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @static\n  @param {Any} reason value that the returned promise will be rejected with.\n  Useful for tooling.\n  @return {Promise} a promise rejected with the given `reason`.\n*/function reject(reason){/*jshint validthis:true */var Constructor=this;var promise=new Constructor(noop);_reject(promise,reason);return promise;}function needsResolver(){throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');}function needsNew(){throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");}/**\n  Promise objects represent the eventual result of an asynchronous operation. The\n  primary way of interacting with a promise is through its `then` method, which\n  registers callbacks to receive either a promise's eventual value or the reason\n  why the promise cannot be fulfilled.\n\n  Terminology\n  -----------\n\n  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n  - `thenable` is an object or function that defines a `then` method.\n  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n  - `exception` is a value that is thrown using the throw statement.\n  - `reason` is a value that indicates why a promise was rejected.\n  - `settled` the final resting state of a promise, fulfilled or rejected.\n\n  A promise can be in one of three states: pending, fulfilled, or rejected.\n\n  Promises that are fulfilled have a fulfillment value and are in the fulfilled\n  state.  Promises that are rejected have a rejection reason and are in the\n  rejected state.  A fulfillment value is never a thenable.\n\n  Promises can also be said to *resolve* a value.  If this value is also a\n  promise, then the original promise's settled state will match the value's\n  settled state.  So a promise that *resolves* a promise that rejects will\n  itself reject, and a promise that *resolves* a promise that fulfills will\n  itself fulfill.\n\n\n  Basic Usage:\n  ------------\n\n  ```js\n  let promise = new Promise(function(resolve, reject) {\n    // on success\n    resolve(value);\n\n    // on failure\n    reject(reason);\n  });\n\n  promise.then(function(value) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Advanced Usage:\n  ---------------\n\n  Promises shine when abstracting away asynchronous interactions such as\n  `XMLHttpRequest`s.\n\n  ```js\n  function getJSON(url) {\n    return new Promise(function(resolve, reject){\n      let xhr = new XMLHttpRequest();\n\n      xhr.open('GET', url);\n      xhr.onreadystatechange = handler;\n      xhr.responseType = 'json';\n      xhr.setRequestHeader('Accept', 'application/json');\n      xhr.send();\n\n      function handler() {\n        if (this.readyState === this.DONE) {\n          if (this.status === 200) {\n            resolve(this.response);\n          } else {\n            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n          }\n        }\n      };\n    });\n  }\n\n  getJSON('/posts.json').then(function(json) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Unlike callbacks, promises are great composable primitives.\n\n  ```js\n  Promise.all([\n    getJSON('/posts'),\n    getJSON('/comments')\n  ]).then(function(values){\n    values[0] // => postsJSON\n    values[1] // => commentsJSON\n\n    return values;\n  });\n  ```\n\n  @class Promise\n  @param {function} resolver\n  Useful for tooling.\n  @constructor\n*/function Promise(resolver){this[PROMISE_ID]=nextId();this._result=this._state=undefined;this._subscribers=[];if(noop!==resolver){typeof resolver!=='function'&&needsResolver();this instanceof Promise?initializePromise(this,resolver):needsNew();}}Promise.all=all;Promise.race=race;Promise.resolve=resolve;Promise.reject=reject;Promise._setScheduler=setScheduler;Promise._setAsap=setAsap;Promise._asap=asap;Promise.prototype={constructor:Promise,/**\n    The primary way of interacting with a promise is through its `then` method,\n    which registers callbacks to receive either a promise's eventual value or the\n    reason why the promise cannot be fulfilled.\n  \n    ```js\n    findUser().then(function(user){\n      // user is available\n    }, function(reason){\n      // user is unavailable, and you are given the reason why\n    });\n    ```\n  \n    Chaining\n    --------\n  \n    The return value of `then` is itself a promise.  This second, 'downstream'\n    promise is resolved with the return value of the first promise's fulfillment\n    or rejection handler, or rejected if the handler throws an exception.\n  \n    ```js\n    findUser().then(function (user) {\n      return user.name;\n    }, function (reason) {\n      return 'default name';\n    }).then(function (userName) {\n      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n      // will be `'default name'`\n    });\n  \n    findUser().then(function (user) {\n      throw new Error('Found user, but still unhappy');\n    }, function (reason) {\n      throw new Error('`findUser` rejected and we're unhappy');\n    }).then(function (value) {\n      // never reached\n    }, function (reason) {\n      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n    });\n    ```\n    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n  \n    ```js\n    findUser().then(function (user) {\n      throw new PedagogicalException('Upstream error');\n    }).then(function (value) {\n      // never reached\n    }).then(function (value) {\n      // never reached\n    }, function (reason) {\n      // The `PedgagocialException` is propagated all the way down to here\n    });\n    ```\n  \n    Assimilation\n    ------------\n  \n    Sometimes the value you want to propagate to a downstream promise can only be\n    retrieved asynchronously. This can be achieved by returning a promise in the\n    fulfillment or rejection handler. The downstream promise will then be pending\n    until the returned promise is settled. This is called *assimilation*.\n  \n    ```js\n    findUser().then(function (user) {\n      return findCommentsByAuthor(user);\n    }).then(function (comments) {\n      // The user's comments are now available\n    });\n    ```\n  \n    If the assimliated promise rejects, then the downstream promise will also reject.\n  \n    ```js\n    findUser().then(function (user) {\n      return findCommentsByAuthor(user);\n    }).then(function (comments) {\n      // If `findCommentsByAuthor` fulfills, we'll have the value here\n    }, function (reason) {\n      // If `findCommentsByAuthor` rejects, we'll have the reason here\n    });\n    ```\n  \n    Simple Example\n    --------------\n  \n    Synchronous Example\n  \n    ```javascript\n    let result;\n  \n    try {\n      result = findResult();\n      // success\n    } catch(reason) {\n      // failure\n    }\n    ```\n  \n    Errback Example\n  \n    ```js\n    findResult(function(result, err){\n      if (err) {\n        // failure\n      } else {\n        // success\n      }\n    });\n    ```\n  \n    Promise Example;\n  \n    ```javascript\n    findResult().then(function(result){\n      // success\n    }, function(reason){\n      // failure\n    });\n    ```\n  \n    Advanced Example\n    --------------\n  \n    Synchronous Example\n  \n    ```javascript\n    let author, books;\n  \n    try {\n      author = findAuthor();\n      books  = findBooksByAuthor(author);\n      // success\n    } catch(reason) {\n      // failure\n    }\n    ```\n  \n    Errback Example\n  \n    ```js\n  \n    function foundBooks(books) {\n  \n    }\n  \n    function failure(reason) {\n  \n    }\n  \n    findAuthor(function(author, err){\n      if (err) {\n        failure(err);\n        // failure\n      } else {\n        try {\n          findBoooksByAuthor(author, function(books, err) {\n            if (err) {\n              failure(err);\n            } else {\n              try {\n                foundBooks(books);\n              } catch(reason) {\n                failure(reason);\n              }\n            }\n          });\n        } catch(error) {\n          failure(err);\n        }\n        // success\n      }\n    });\n    ```\n  \n    Promise Example;\n  \n    ```javascript\n    findAuthor().\n      then(findBooksByAuthor).\n      then(function(books){\n        // found books\n    }).catch(function(reason){\n      // something went wrong\n    });\n    ```\n  \n    @method then\n    @param {Function} onFulfilled\n    @param {Function} onRejected\n    Useful for tooling.\n    @return {Promise}\n  */then:then,/**\n    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n    as the catch block of a try/catch statement.\n  \n    ```js\n    function findAuthor(){\n      throw new Error('couldn't find that author');\n    }\n  \n    // synchronous\n    try {\n      findAuthor();\n    } catch(reason) {\n      // something went wrong\n    }\n  \n    // async with promises\n    findAuthor().catch(function(reason){\n      // something went wrong\n    });\n    ```\n  \n    @method catch\n    @param {Function} onRejection\n    Useful for tooling.\n    @return {Promise}\n  */'catch':function _catch(onRejection){return this.then(null,onRejection);}};function polyfill(){var local=undefined;if(typeof global!=='undefined'){local=global;}else if(typeof self!=='undefined'){local=self;}else{try{local=Function('return this')();}catch(e){throw new Error('polyfill failed because global object is unavailable in this environment');}}var P=local.Promise;if(P){var promiseToString=null;try{promiseToString=Object.prototype.toString.call(P.resolve());}catch(e){// silently ignored\n}if(promiseToString==='[object Promise]'&&!P.cast){return;}}local.Promise=Promise;}polyfill();// Strange compat..\nPromise.polyfill=polyfill;Promise.Promise=Promise;return Promise;});}).call(this,_dereq_('_process'),typeof global!==\"undefined\"?global:typeof self!==\"undefined\"?self:typeof window!==\"undefined\"?window:{});},{\"_process\":25}],10:[function(_dereq_,module,exports){/**\r\n * inspired by is-number <https://github.com/jonschlinkert/is-number>\r\n * but significantly simplified and sped up by ignoring number and string constructors\r\n * ie these return false:\r\n *   new Number(1)\r\n *   new String('1')\r\n */'use strict';var allBlankCharCodes=_dereq_('is-string-blank');module.exports=function(n){var type=_typeof(n);if(type==='string'){var original=n;n=+n;// whitespace strings cast to zero - filter them out\nif(n===0&&allBlankCharCodes(original))return false;}else if(type!=='number')return false;return n-n<1;};},{\"is-string-blank\":15}],11:[function(_dereq_,module,exports){module.exports=fromQuat;/**\n * Creates a matrix from a quaternion rotation.\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @returns {mat4} out\n */function fromQuat(out,q){var x=q[0],y=q[1],z=q[2],w=q[3],x2=x+x,y2=y+y,z2=z+z,xx=x*x2,yx=y*x2,yy=y*y2,zx=z*x2,zy=z*y2,zz=z*z2,wx=w*x2,wy=w*y2,wz=w*z2;out[0]=1-yy-zz;out[1]=yx+wz;out[2]=zx-wy;out[3]=0;out[4]=yx-wz;out[5]=1-xx-zz;out[6]=zy+wx;out[7]=0;out[8]=zx+wy;out[9]=zy-wx;out[10]=1-xx-yy;out[11]=0;out[12]=0;out[13]=0;out[14]=0;out[15]=1;return out;};},{}],12:[function(_dereq_,module,exports){(function(global){'use strict';var isBrowser=_dereq_('is-browser');var hasHover;if(typeof global.matchMedia==='function'){hasHover=!global.matchMedia('(hover: none)').matches;}else{hasHover=isBrowser;}module.exports=hasHover;}).call(this,typeof global!==\"undefined\"?global:typeof self!==\"undefined\"?self:typeof window!==\"undefined\"?window:{});},{\"is-browser\":14}],13:[function(_dereq_,module,exports){'use strict';var isBrowser=_dereq_('is-browser');function detect(){var supported=false;try{var opts=Object.defineProperty({},'passive',{get:function get(){supported=true;}});window.addEventListener('test',null,opts);window.removeEventListener('test',null,opts);}catch(e){supported=false;}return supported;}module.exports=isBrowser&&detect();},{\"is-browser\":14}],14:[function(_dereq_,module,exports){module.exports=true;},{}],15:[function(_dereq_,module,exports){'use strict';/**\r\n * Is this string all whitespace?\r\n * This solution kind of makes my brain hurt, but it's significantly faster\r\n * than !str.trim() or any other solution I could find.\r\n *\r\n * whitespace codes from: http://en.wikipedia.org/wiki/Whitespace_character\r\n * and verified with:\r\n *\r\n *  for(var i = 0; i < 65536; i++) {\r\n *      var s = String.fromCharCode(i);\r\n *      if(+s===0 && !s.trim()) console.log(i, s);\r\n *  }\r\n *\r\n * which counts a couple of these as *not* whitespace, but finds nothing else\r\n * that *is* whitespace. Note that charCodeAt stops at 16 bits, but it appears\r\n * that there are no whitespace characters above this, and code points above\r\n * this do not map onto white space characters.\r\n */module.exports=function(str){var l=str.length,a;for(var i=0;i<l;i++){a=str.charCodeAt(i);if((a<9||a>13)&&a!==32&&a!==133&&a!==160&&a!==5760&&a!==6158&&(a<8192||a>8205)&&a!==8232&&a!==8233&&a!==8239&&a!==8287&&a!==8288&&a!==12288&&a!==65279){return false;}}return true;};},{}],16:[function(_dereq_,module,exports){var rootPosition={left:0,top:0};module.exports=mouseEventOffset;function mouseEventOffset(ev,target,out){target=target||ev.currentTarget||ev.srcElement;if(!Array.isArray(out)){out=[0,0];}var cx=ev.clientX||0;var cy=ev.clientY||0;var rect=getBoundingClientOffset(target);out[0]=cx-rect.left;out[1]=cy-rect.top;return out;}function getBoundingClientOffset(element){if(element===window||element===document||element===document.body){return rootPosition;}else{return element.getBoundingClientRect();}}},{}],17:[function(_dereq_,module,exports){/*\n * @copyright 2016 Sean Connelly (@voidqk), http://syntheti.cc\n * @license MIT\n * @preserve Project Home: https://github.com/voidqk/polybooljs\n */var BuildLog=_dereq_('./lib/build-log');var Epsilon=_dereq_('./lib/epsilon');var Intersecter=_dereq_('./lib/intersecter');var SegmentChainer=_dereq_('./lib/segment-chainer');var SegmentSelector=_dereq_('./lib/segment-selector');var GeoJSON=_dereq_('./lib/geojson');var _buildLog=false;var _epsilon=Epsilon();var PolyBool;PolyBool={// getter/setter for buildLog\nbuildLog:function buildLog(bl){if(bl===true)_buildLog=BuildLog();else if(bl===false)_buildLog=false;return _buildLog===false?false:_buildLog.list;},// getter/setter for epsilon\nepsilon:function epsilon(v){return _epsilon.epsilon(v);},// core API\nsegments:function segments(poly){var i=Intersecter(true,_epsilon,_buildLog);poly.regions.forEach(i.addRegion);return{segments:i.calculate(poly.inverted),inverted:poly.inverted};},combine:function combine(segments1,segments2){var i3=Intersecter(false,_epsilon,_buildLog);return{combined:i3.calculate(segments1.segments,segments1.inverted,segments2.segments,segments2.inverted),inverted1:segments1.inverted,inverted2:segments2.inverted};},selectUnion:function selectUnion(combined){return{segments:SegmentSelector.union(combined.combined,_buildLog),inverted:combined.inverted1||combined.inverted2};},selectIntersect:function selectIntersect(combined){return{segments:SegmentSelector.intersect(combined.combined,_buildLog),inverted:combined.inverted1&&combined.inverted2};},selectDifference:function selectDifference(combined){return{segments:SegmentSelector.difference(combined.combined,_buildLog),inverted:combined.inverted1&&!combined.inverted2};},selectDifferenceRev:function selectDifferenceRev(combined){return{segments:SegmentSelector.differenceRev(combined.combined,_buildLog),inverted:!combined.inverted1&&combined.inverted2};},selectXor:function selectXor(combined){return{segments:SegmentSelector.xor(combined.combined,_buildLog),inverted:combined.inverted1!==combined.inverted2};},polygon:function polygon(segments){return{regions:SegmentChainer(segments.segments,_epsilon,_buildLog),inverted:segments.inverted};},// GeoJSON converters\npolygonFromGeoJSON:function polygonFromGeoJSON(geojson){return GeoJSON.toPolygon(PolyBool,geojson);},polygonToGeoJSON:function polygonToGeoJSON(poly){return GeoJSON.fromPolygon(PolyBool,_epsilon,poly);},// helper functions for common operations\nunion:function union(poly1,poly2){return operate(poly1,poly2,PolyBool.selectUnion);},intersect:function intersect(poly1,poly2){return operate(poly1,poly2,PolyBool.selectIntersect);},difference:function difference(poly1,poly2){return operate(poly1,poly2,PolyBool.selectDifference);},differenceRev:function differenceRev(poly1,poly2){return operate(poly1,poly2,PolyBool.selectDifferenceRev);},xor:function xor(poly1,poly2){return operate(poly1,poly2,PolyBool.selectXor);}};function operate(poly1,poly2,selector){var seg1=PolyBool.segments(poly1);var seg2=PolyBool.segments(poly2);var comb=PolyBool.combine(seg1,seg2);var seg3=selector(comb);return PolyBool.polygon(seg3);}if((typeof window===\"undefined\"?\"undefined\":_typeof(window))==='object')window.PolyBool=PolyBool;module.exports=PolyBool;},{\"./lib/build-log\":18,\"./lib/epsilon\":19,\"./lib/geojson\":20,\"./lib/intersecter\":21,\"./lib/segment-chainer\":23,\"./lib/segment-selector\":24}],18:[function(_dereq_,module,exports){// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n//\n// used strictly for logging the processing of the algorithm... only useful if you intend on\n// looking under the covers (for pretty UI's or debugging)\n//\nfunction BuildLog(){var my;var nextSegmentId=0;var curVert=false;function push(type,data){my.list.push({type:type,data:data?JSON.parse(JSON.stringify(data)):void 0});return my;}my={list:[],segmentId:function segmentId(){return nextSegmentId++;},checkIntersection:function checkIntersection(seg1,seg2){return push('check',{seg1:seg1,seg2:seg2});},segmentChop:function segmentChop(seg,end){push('div_seg',{seg:seg,pt:end});return push('chop',{seg:seg,pt:end});},statusRemove:function statusRemove(seg){return push('pop_seg',{seg:seg});},segmentUpdate:function segmentUpdate(seg){return push('seg_update',{seg:seg});},segmentNew:function segmentNew(seg,primary){return push('new_seg',{seg:seg,primary:primary});},segmentRemove:function segmentRemove(seg){return push('rem_seg',{seg:seg});},tempStatus:function tempStatus(seg,above,below){return push('temp_status',{seg:seg,above:above,below:below});},rewind:function rewind(seg){return push('rewind',{seg:seg});},status:function status(seg,above,below){return push('status',{seg:seg,above:above,below:below});},vert:function vert(x){if(x===curVert)return my;curVert=x;return push('vert',{x:x});},log:function log(data){if(typeof data!=='string')data=JSON.stringify(data,false,'  ');return push('log',{txt:data});},reset:function reset(){return push('reset');},selected:function selected(segs){return push('selected',{segs:segs});},chainStart:function chainStart(seg){return push('chain_start',{seg:seg});},chainRemoveHead:function chainRemoveHead(index,pt){return push('chain_rem_head',{index:index,pt:pt});},chainRemoveTail:function chainRemoveTail(index,pt){return push('chain_rem_tail',{index:index,pt:pt});},chainNew:function chainNew(pt1,pt2){return push('chain_new',{pt1:pt1,pt2:pt2});},chainMatch:function chainMatch(index){return push('chain_match',{index:index});},chainClose:function chainClose(index){return push('chain_close',{index:index});},chainAddHead:function chainAddHead(index,pt){return push('chain_add_head',{index:index,pt:pt});},chainAddTail:function chainAddTail(index,pt){return push('chain_add_tail',{index:index,pt:pt});},chainConnect:function chainConnect(index1,index2){return push('chain_con',{index1:index1,index2:index2});},chainReverse:function chainReverse(index){return push('chain_rev',{index:index});},chainJoin:function chainJoin(index1,index2){return push('chain_join',{index1:index1,index2:index2});},done:function done(){return push('done');}};return my;}module.exports=BuildLog;},{}],19:[function(_dereq_,module,exports){// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n//\n// provides the raw computation functions that takes epsilon into account\n//\n// zero is defined to be between (-epsilon, epsilon) exclusive\n//\nfunction Epsilon(eps){if(typeof eps!=='number')eps=0.0000000001;// sane default? sure why not\nvar my={epsilon:function epsilon(v){if(typeof v==='number')eps=v;return eps;},pointAboveOrOnLine:function pointAboveOrOnLine(pt,left,right){var Ax=left[0];var Ay=left[1];var Bx=right[0];var By=right[1];var Cx=pt[0];var Cy=pt[1];return(Bx-Ax)*(Cy-Ay)-(By-Ay)*(Cx-Ax)>=-eps;},pointBetween:function pointBetween(p,left,right){// p must be collinear with left->right\n// returns false if p == left, p == right, or left == right\nvar d_py_ly=p[1]-left[1];var d_rx_lx=right[0]-left[0];var d_px_lx=p[0]-left[0];var d_ry_ly=right[1]-left[1];var dot=d_px_lx*d_rx_lx+d_py_ly*d_ry_ly;// if `dot` is 0, then `p` == `left` or `left` == `right` (reject)\n// if `dot` is less than 0, then `p` is to the left of `left` (reject)\nif(dot<eps)return false;var sqlen=d_rx_lx*d_rx_lx+d_ry_ly*d_ry_ly;// if `dot` > `sqlen`, then `p` is to the right of `right` (reject)\n// therefore, if `dot - sqlen` is greater than 0, then `p` is to the right of `right` (reject)\nif(dot-sqlen>-eps)return false;return true;},pointsSameX:function pointsSameX(p1,p2){return Math.abs(p1[0]-p2[0])<eps;},pointsSameY:function pointsSameY(p1,p2){return Math.abs(p1[1]-p2[1])<eps;},pointsSame:function pointsSame(p1,p2){return my.pointsSameX(p1,p2)&&my.pointsSameY(p1,p2);},pointsCompare:function pointsCompare(p1,p2){// returns -1 if p1 is smaller, 1 if p2 is smaller, 0 if equal\nif(my.pointsSameX(p1,p2))return my.pointsSameY(p1,p2)?0:p1[1]<p2[1]?-1:1;return p1[0]<p2[0]?-1:1;},pointsCollinear:function pointsCollinear(pt1,pt2,pt3){// does pt1->pt2->pt3 make a straight line?\n// essentially this is just checking to see if the slope(pt1->pt2) === slope(pt2->pt3)\n// if slopes are equal, then they must be collinear, because they share pt2\nvar dx1=pt1[0]-pt2[0];var dy1=pt1[1]-pt2[1];var dx2=pt2[0]-pt3[0];var dy2=pt2[1]-pt3[1];return Math.abs(dx1*dy2-dx2*dy1)<eps;},linesIntersect:function linesIntersect(a0,a1,b0,b1){// returns false if the lines are coincident (e.g., parallel or on top of each other)\n//\n// returns an object if the lines intersect:\n//   {\n//     pt: [x, y],    where the intersection point is at\n//     alongA: where intersection point is along A,\n//     alongB: where intersection point is along B\n//   }\n//\n//  alongA and alongB will each be one of: -2, -1, 0, 1, 2\n//\n//  with the following meaning:\n//\n//    -2   intersection point is before segment's first point\n//    -1   intersection point is directly on segment's first point\n//     0   intersection point is between segment's first and second points (exclusive)\n//     1   intersection point is directly on segment's second point\n//     2   intersection point is after segment's second point\nvar adx=a1[0]-a0[0];var ady=a1[1]-a0[1];var bdx=b1[0]-b0[0];var bdy=b1[1]-b0[1];var axb=adx*bdy-ady*bdx;if(Math.abs(axb)<eps)return false;// lines are coincident\nvar dx=a0[0]-b0[0];var dy=a0[1]-b0[1];var A=(bdx*dy-bdy*dx)/axb;var B=(adx*dy-ady*dx)/axb;var ret={alongA:0,alongB:0,pt:[a0[0]+A*adx,a0[1]+A*ady]};// categorize where intersection point is along A and B\nif(A<=-eps)ret.alongA=-2;else if(A<eps)ret.alongA=-1;else if(A-1<=-eps)ret.alongA=0;else if(A-1<eps)ret.alongA=1;else ret.alongA=2;if(B<=-eps)ret.alongB=-2;else if(B<eps)ret.alongB=-1;else if(B-1<=-eps)ret.alongB=0;else if(B-1<eps)ret.alongB=1;else ret.alongB=2;return ret;},pointInsideRegion:function pointInsideRegion(pt,region){var x=pt[0];var y=pt[1];var last_x=region[region.length-1][0];var last_y=region[region.length-1][1];var inside=false;for(var i=0;i<region.length;i++){var curr_x=region[i][0];var curr_y=region[i][1];// if y is between curr_y and last_y, and\n// x is to the right of the boundary created by the line\nif(curr_y-y>eps!=last_y-y>eps&&(last_x-curr_x)*(y-curr_y)/(last_y-curr_y)+curr_x-x>eps)inside=!inside;last_x=curr_x;last_y=curr_y;}return inside;}};return my;}module.exports=Epsilon;},{}],20:[function(_dereq_,module,exports){// (c) Copyright 2017, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n//\n// convert between PolyBool polygon format and GeoJSON formats (Polygon and MultiPolygon)\n//\nvar GeoJSON={// convert a GeoJSON object to a PolyBool polygon\ntoPolygon:function toPolygon(PolyBool,geojson){// converts list of LineString's to segments\nfunction GeoPoly(coords){// check for empty coords\nif(coords.length<=0)return PolyBool.segments({inverted:false,regions:[]});// convert LineString to segments\nfunction LineString(ls){// remove tail which should be the same as head\nvar reg=ls.slice(0,ls.length-1);return PolyBool.segments({inverted:false,regions:[reg]});}// the first LineString is considered the outside\nvar out=LineString(coords[0]);// the rest of the LineStrings are considered interior holes, so subtract them from the\n// current result\nfor(var i=1;i<coords.length;i++){out=PolyBool.selectDifference(PolyBool.combine(out,LineString(coords[i])));}return out;}if(geojson.type==='Polygon'){// single polygon, so just convert it and we're done\nreturn PolyBool.polygon(GeoPoly(geojson.coordinates));}else if(geojson.type==='MultiPolygon'){// multiple polygons, so union all the polygons together\nvar out=PolyBool.segments({inverted:false,regions:[]});for(var i=0;i<geojson.coordinates.length;i++){out=PolyBool.selectUnion(PolyBool.combine(out,GeoPoly(geojson.coordinates[i])));}return PolyBool.polygon(out);}throw new Error('PolyBool: Cannot convert GeoJSON object to PolyBool polygon');},// convert a PolyBool polygon to a GeoJSON object\nfromPolygon:function fromPolygon(PolyBool,eps,poly){// make sure out polygon is clean\npoly=PolyBool.polygon(PolyBool.segments(poly));// test if r1 is inside r2\nfunction regionInsideRegion(r1,r2){// we're guaranteed no lines intersect (because the polygon is clean), but a vertex\n// could be on the edge -- so we just average pt[0] and pt[1] to produce a point on the\n// edge of the first line, which cannot be on an edge\nreturn eps.pointInsideRegion([(r1[0][0]+r1[1][0])*0.5,(r1[0][1]+r1[1][1])*0.5],r2);}// calculate inside heirarchy\n//\n//  _____________________   _______    roots -> A       -> F\n// |          A          | |   F   |            |          |\n// |  _______   _______  | |  ___  |            +-- B      +-- G\n// | |   B   | |   C   | | | |   | |            |   |\n// | |  ___  | |  ___  | | | |   | |            |   +-- D\n// | | | D | | | | E | | | | | G | |            |\n// | | |___| | | |___| | | | |   | |            +-- C\n// | |_______| |_______| | | |___| |                |\n// |_____________________| |_______|                +-- E\nfunction newNode(region){return{region:region,children:[]};}var roots=newNode(null);function addChild(root,region){// first check if we're inside any children\nfor(var i=0;i<root.children.length;i++){var child=root.children[i];if(regionInsideRegion(region,child.region)){// we are, so insert inside them instead\naddChild(child,region);return;}}// not inside any children, so check to see if any children are inside us\nvar node=newNode(region);for(var i=0;i<root.children.length;i++){var child=root.children[i];if(regionInsideRegion(child.region,region)){// oops... move the child beneath us, and remove them from root\nnode.children.push(child);root.children.splice(i,1);i--;}}// now we can add ourselves\nroot.children.push(node);}// add all regions to the root\nfor(var i=0;i<poly.regions.length;i++){var region=poly.regions[i];if(region.length<3)// regions must have at least 3 points (sanity check)\ncontinue;addChild(roots,region);}// with our heirarchy, we can distinguish between exterior borders, and interior holes\n// the root nodes are exterior, children are interior, children's children are exterior,\n// children's children's children are interior, etc\n// while we're at it, exteriors are counter-clockwise, and interiors are clockwise\nfunction forceWinding(region,clockwise){// first, see if we're clockwise or counter-clockwise\n// https://en.wikipedia.org/wiki/Shoelace_formula\nvar winding=0;var last_x=region[region.length-1][0];var last_y=region[region.length-1][1];var copy=[];for(var i=0;i<region.length;i++){var curr_x=region[i][0];var curr_y=region[i][1];copy.push([curr_x,curr_y]);// create a copy while we're at it\nwinding+=curr_y*last_x-curr_x*last_y;last_x=curr_x;last_y=curr_y;}// this assumes Cartesian coordinates (Y is positive going up)\nvar isclockwise=winding<0;if(isclockwise!==clockwise)copy.reverse();// while we're here, the last point must be the first point...\ncopy.push([copy[0][0],copy[0][1]]);return copy;}var geopolys=[];function addExterior(node){var poly=[forceWinding(node.region,false)];geopolys.push(poly);// children of exteriors are interior\nfor(var i=0;i<node.children.length;i++){poly.push(getInterior(node.children[i]));}}function getInterior(node){// children of interiors are exterior\nfor(var i=0;i<node.children.length;i++){addExterior(node.children[i]);}// return the clockwise interior\nreturn forceWinding(node.region,true);}// root nodes are exterior\nfor(var i=0;i<roots.children.length;i++){addExterior(roots.children[i]);}// lastly, construct the approrpriate GeoJSON object\nif(geopolys.length<=0)// empty GeoJSON Polygon\nreturn{type:'Polygon',coordinates:[]};if(geopolys.length==1)// use a GeoJSON Polygon\nreturn{type:'Polygon',coordinates:geopolys[0]};return{// otherwise, use a GeoJSON MultiPolygon\ntype:'MultiPolygon',coordinates:geopolys};}};module.exports=GeoJSON;},{}],21:[function(_dereq_,module,exports){// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n//\n// this is the core work-horse\n//\nvar LinkedList=_dereq_('./linked-list');function Intersecter(selfIntersection,eps,buildLog){// selfIntersection is true/false depending on the phase of the overall algorithm\n//\n// segment creation\n//\nfunction segmentNew(start,end){return{id:buildLog?buildLog.segmentId():-1,start:start,end:end,myFill:{above:null,// is there fill above us?\nbelow:null// is there fill below us?\n},otherFill:null};}function segmentCopy(start,end,seg){return{id:buildLog?buildLog.segmentId():-1,start:start,end:end,myFill:{above:seg.myFill.above,below:seg.myFill.below},otherFill:null};}//\n// event logic\n//\nvar event_root=LinkedList.create();function eventCompare(p1_isStart,p1_1,p1_2,p2_isStart,p2_1,p2_2){// compare the selected points first\nvar comp=eps.pointsCompare(p1_1,p2_1);if(comp!==0)return comp;// the selected points are the same\nif(eps.pointsSame(p1_2,p2_2))// if the non-selected points are the same too...\nreturn 0;// then the segments are equal\nif(p1_isStart!==p2_isStart)// if one is a start and the other isn't...\nreturn p1_isStart?1:-1;// favor the one that isn't the start\n// otherwise, we'll have to calculate which one is below the other manually\nreturn eps.pointAboveOrOnLine(p1_2,p2_isStart?p2_1:p2_2,// order matters\np2_isStart?p2_2:p2_1)?1:-1;}function eventAdd(ev,other_pt){event_root.insertBefore(ev,function(here){// should ev be inserted before here?\nvar comp=eventCompare(ev.isStart,ev.pt,other_pt,here.isStart,here.pt,here.other.pt);return comp<0;});}function eventAddSegmentStart(seg,primary){var ev_start=LinkedList.node({isStart:true,pt:seg.start,seg:seg,primary:primary,other:null,status:null});eventAdd(ev_start,seg.end);return ev_start;}function eventAddSegmentEnd(ev_start,seg,primary){var ev_end=LinkedList.node({isStart:false,pt:seg.end,seg:seg,primary:primary,other:ev_start,status:null});ev_start.other=ev_end;eventAdd(ev_end,ev_start.pt);}function eventAddSegment(seg,primary){var ev_start=eventAddSegmentStart(seg,primary);eventAddSegmentEnd(ev_start,seg,primary);return ev_start;}function eventUpdateEnd(ev,end){// slides an end backwards\n//   (start)------------(end)    to:\n//   (start)---(end)\nif(buildLog)buildLog.segmentChop(ev.seg,end);ev.other.remove();ev.seg.end=end;ev.other.pt=end;eventAdd(ev.other,ev.pt);}function eventDivide(ev,pt){var ns=segmentCopy(pt,ev.seg.end,ev.seg);eventUpdateEnd(ev,pt);return eventAddSegment(ns,ev.primary);}function _calculate(primaryPolyInverted,secondaryPolyInverted){// if selfIntersection is true then there is no secondary polygon, so that isn't used\n//\n// status logic\n//\nvar status_root=LinkedList.create();function statusCompare(ev1,ev2){var a1=ev1.seg.start;var a2=ev1.seg.end;var b1=ev2.seg.start;var b2=ev2.seg.end;if(eps.pointsCollinear(a1,b1,b2)){if(eps.pointsCollinear(a2,b1,b2))return 1;//eventCompare(true, a1, a2, true, b1, b2);\nreturn eps.pointAboveOrOnLine(a2,b1,b2)?1:-1;}return eps.pointAboveOrOnLine(a1,b1,b2)?1:-1;}function statusFindSurrounding(ev){return status_root.findTransition(function(here){var comp=statusCompare(ev,here.ev);return comp>0;});}function checkIntersection(ev1,ev2){// returns the segment equal to ev1, or false if nothing equal\nvar seg1=ev1.seg;var seg2=ev2.seg;var a1=seg1.start;var a2=seg1.end;var b1=seg2.start;var b2=seg2.end;if(buildLog)buildLog.checkIntersection(seg1,seg2);var i=eps.linesIntersect(a1,a2,b1,b2);if(i===false){// segments are parallel or coincident\n// if points aren't collinear, then the segments are parallel, so no intersections\nif(!eps.pointsCollinear(a1,a2,b1))return false;// otherwise, segments are on top of each other somehow (aka coincident)\nif(eps.pointsSame(a1,b2)||eps.pointsSame(a2,b1))return false;// segments touch at endpoints... no intersection\nvar a1_equ_b1=eps.pointsSame(a1,b1);var a2_equ_b2=eps.pointsSame(a2,b2);if(a1_equ_b1&&a2_equ_b2)return ev2;// segments are exactly equal\nvar a1_between=!a1_equ_b1&&eps.pointBetween(a1,b1,b2);var a2_between=!a2_equ_b2&&eps.pointBetween(a2,b1,b2);// handy for debugging:\n// buildLog.log({\n//\ta1_equ_b1: a1_equ_b1,\n//\ta2_equ_b2: a2_equ_b2,\n//\ta1_between: a1_between,\n//\ta2_between: a2_between\n// });\nif(a1_equ_b1){if(a2_between){//  (a1)---(a2)\n//  (b1)----------(b2)\neventDivide(ev2,a2);}else{//  (a1)----------(a2)\n//  (b1)---(b2)\neventDivide(ev1,b2);}return ev2;}else if(a1_between){if(!a2_equ_b2){// make a2 equal to b2\nif(a2_between){//         (a1)---(a2)\n//  (b1)-----------------(b2)\neventDivide(ev2,a2);}else{//         (a1)----------(a2)\n//  (b1)----------(b2)\neventDivide(ev1,b2);}}//         (a1)---(a2)\n//  (b1)----------(b2)\neventDivide(ev2,a1);}}else{// otherwise, lines intersect at i.pt, which may or may not be between the endpoints\n// is A divided between its endpoints? (exclusive)\nif(i.alongA===0){if(i.alongB===-1)// yes, at exactly b1\neventDivide(ev1,b1);else if(i.alongB===0)// yes, somewhere between B's endpoints\neventDivide(ev1,i.pt);else if(i.alongB===1)// yes, at exactly b2\neventDivide(ev1,b2);}// is B divided between its endpoints? (exclusive)\nif(i.alongB===0){if(i.alongA===-1)// yes, at exactly a1\neventDivide(ev2,a1);else if(i.alongA===0)// yes, somewhere between A's endpoints (exclusive)\neventDivide(ev2,i.pt);else if(i.alongA===1)// yes, at exactly a2\neventDivide(ev2,a2);}}return false;}//\n// main event loop\n//\nvar segments=[];while(!event_root.isEmpty()){var ev=event_root.getHead();if(buildLog)buildLog.vert(ev.pt[0]);if(ev.isStart){var checkBothIntersections=function checkBothIntersections(){if(above){var eve=checkIntersection(ev,above);if(eve)return eve;}if(below)return checkIntersection(ev,below);return false;};if(buildLog)buildLog.segmentNew(ev.seg,ev.primary);var surrounding=statusFindSurrounding(ev);var above=surrounding.before?surrounding.before.ev:null;var below=surrounding.after?surrounding.after.ev:null;if(buildLog){buildLog.tempStatus(ev.seg,above?above.seg:false,below?below.seg:false);}var eve=checkBothIntersections();if(eve){// ev and eve are equal\n// we'll keep eve and throw away ev\n// merge ev.seg's fill information into eve.seg\nif(selfIntersection){var toggle;// are we a toggling edge?\nif(ev.seg.myFill.below===null)toggle=true;else toggle=ev.seg.myFill.above!==ev.seg.myFill.below;// merge two segments that belong to the same polygon\n// think of this as sandwiching two segments together, where `eve.seg` is\n// the bottom -- this will cause the above fill flag to toggle\nif(toggle)eve.seg.myFill.above=!eve.seg.myFill.above;}else{// merge two segments that belong to different polygons\n// each segment has distinct knowledge, so no special logic is needed\n// note that this can only happen once per segment in this phase, because we\n// are guaranteed that all self-intersections are gone\neve.seg.otherFill=ev.seg.myFill;}if(buildLog)buildLog.segmentUpdate(eve.seg);ev.other.remove();ev.remove();}if(event_root.getHead()!==ev){// something was inserted before us in the event queue, so loop back around and\n// process it before continuing\nif(buildLog)buildLog.rewind(ev.seg);continue;}//\n// calculate fill flags\n//\nif(selfIntersection){var toggle;// are we a toggling edge?\nif(ev.seg.myFill.below===null)// if we are a new segment...\ntoggle=true;// then we toggle\nelse// we are a segment that has previous knowledge from a division\ntoggle=ev.seg.myFill.above!==ev.seg.myFill.below;// calculate toggle\n// next, calculate whether we are filled below us\nif(!below){// if nothing is below us...\n// we are filled below us if the polygon is inverted\nev.seg.myFill.below=primaryPolyInverted;}else{// otherwise, we know the answer -- it's the same if whatever is below\n// us is filled above it\nev.seg.myFill.below=below.seg.myFill.above;}// since now we know if we're filled below us, we can calculate whether\n// we're filled above us by applying toggle to whatever is below us\nif(toggle)ev.seg.myFill.above=!ev.seg.myFill.below;else ev.seg.myFill.above=ev.seg.myFill.below;}else{// now we fill in any missing transition information, since we are all-knowing\n// at this point\nif(ev.seg.otherFill===null){// if we don't have other information, then we need to figure out if we're\n// inside the other polygon\nvar inside;if(!below){// if nothing is below us, then we're inside if the other polygon is\n// inverted\ninside=ev.primary?secondaryPolyInverted:primaryPolyInverted;}else{// otherwise, something is below us\n// so copy the below segment's other polygon's above\nif(ev.primary===below.primary)inside=below.seg.otherFill.above;else inside=below.seg.myFill.above;}ev.seg.otherFill={above:inside,below:inside};}}if(buildLog){buildLog.status(ev.seg,above?above.seg:false,below?below.seg:false);}// insert the status and remember it for later removal\nev.other.status=surrounding.insert(LinkedList.node({ev:ev}));}else{var st=ev.status;if(st===null){throw new Error('PolyBool: Zero-length segment detected; your epsilon is '+'probably too small or too large');}// removing the status will create two new adjacent edges, so we'll need to check\n// for those\nif(status_root.exists(st.prev)&&status_root.exists(st.next))checkIntersection(st.prev.ev,st.next.ev);if(buildLog)buildLog.statusRemove(st.ev.seg);// remove the status\nst.remove();// if we've reached this point, we've calculated everything there is to know, so\n// save the segment for reporting\nif(!ev.primary){// make sure `seg.myFill` actually points to the primary polygon though\nvar s=ev.seg.myFill;ev.seg.myFill=ev.seg.otherFill;ev.seg.otherFill=s;}segments.push(ev.seg);}// remove the event and continue\nevent_root.getHead().remove();}if(buildLog)buildLog.done();return segments;}// return the appropriate API depending on what we're doing\nif(!selfIntersection){// performing combination of polygons, so only deal with already-processed segments\nreturn{calculate:function calculate(segments1,inverted1,segments2,inverted2){// segmentsX come from the self-intersection API, or this API\n// invertedX is whether we treat that list of segments as an inverted polygon or not\n// returns segments that can be used for further operations\nsegments1.forEach(function(seg){eventAddSegment(segmentCopy(seg.start,seg.end,seg),true);});segments2.forEach(function(seg){eventAddSegment(segmentCopy(seg.start,seg.end,seg),false);});return _calculate(inverted1,inverted2);}};}// otherwise, performing self-intersection, so deal with regions\nreturn{addRegion:function addRegion(region){// regions are a list of points:\n//  [ [0, 0], [100, 0], [50, 100] ]\n// you can add multiple regions before running calculate\nvar pt1;var pt2=region[region.length-1];for(var i=0;i<region.length;i++){pt1=pt2;pt2=region[i];var forward=eps.pointsCompare(pt1,pt2);if(forward===0)// points are equal, so we have a zero-length segment\ncontinue;// just skip it\neventAddSegment(segmentNew(forward<0?pt1:pt2,forward<0?pt2:pt1),true);}},calculate:function calculate(inverted){// is the polygon inverted?\n// returns segments\nreturn _calculate(inverted,false);}};}module.exports=Intersecter;},{\"./linked-list\":22}],22:[function(_dereq_,module,exports){// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n//\n// simple linked list implementation that allows you to traverse down nodes and save positions\n//\nvar LinkedList={create:function create(){var my={root:{root:true,next:null},exists:function exists(node){if(node===null||node===my.root)return false;return true;},isEmpty:function isEmpty(){return my.root.next===null;},getHead:function getHead(){return my.root.next;},insertBefore:function insertBefore(node,check){var last=my.root;var here=my.root.next;while(here!==null){if(check(here)){node.prev=here.prev;node.next=here;here.prev.next=node;here.prev=node;return;}last=here;here=here.next;}last.next=node;node.prev=last;node.next=null;},findTransition:function findTransition(check){var prev=my.root;var here=my.root.next;while(here!==null){if(check(here))break;prev=here;here=here.next;}return{before:prev===my.root?null:prev,after:here,insert:function insert(node){node.prev=prev;node.next=here;prev.next=node;if(here!==null)here.prev=node;return node;}};}};return my;},node:function node(data){data.prev=null;data.next=null;data.remove=function(){data.prev.next=data.next;if(data.next)data.next.prev=data.prev;data.prev=null;data.next=null;};return data;}};module.exports=LinkedList;},{}],23:[function(_dereq_,module,exports){// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n//\n// converts a list of segments into a list of regions, while also removing unnecessary verticies\n//\nfunction SegmentChainer(segments,eps,buildLog){var chains=[];var regions=[];segments.forEach(function(seg){var pt1=seg.start;var pt2=seg.end;if(eps.pointsSame(pt1,pt2)){console.warn('PolyBool: Warning: Zero-length segment detected; your epsilon is '+'probably too small or too large');return;}if(buildLog)buildLog.chainStart(seg);// search for two chains that this segment matches\nvar first_match={index:0,matches_head:false,matches_pt1:false};var second_match={index:0,matches_head:false,matches_pt1:false};var next_match=first_match;function setMatch(index,matches_head,matches_pt1){// return true if we've matched twice\nnext_match.index=index;next_match.matches_head=matches_head;next_match.matches_pt1=matches_pt1;if(next_match===first_match){next_match=second_match;return false;}next_match=null;return true;// we've matched twice, we're done here\n}for(var i=0;i<chains.length;i++){var chain=chains[i];var head=chain[0];var head2=chain[1];var tail=chain[chain.length-1];var tail2=chain[chain.length-2];if(eps.pointsSame(head,pt1)){if(setMatch(i,true,true))break;}else if(eps.pointsSame(head,pt2)){if(setMatch(i,true,false))break;}else if(eps.pointsSame(tail,pt1)){if(setMatch(i,false,true))break;}else if(eps.pointsSame(tail,pt2)){if(setMatch(i,false,false))break;}}if(next_match===first_match){// we didn't match anything, so create a new chain\nchains.push([pt1,pt2]);if(buildLog)buildLog.chainNew(pt1,pt2);return;}if(next_match===second_match){// we matched a single chain\nif(buildLog)buildLog.chainMatch(first_match.index);// add the other point to the apporpriate end, and check to see if we've closed the\n// chain into a loop\nvar index=first_match.index;var pt=first_match.matches_pt1?pt2:pt1;// if we matched pt1, then we add pt2, etc\nvar addToHead=first_match.matches_head;// if we matched at head, then add to the head\nvar chain=chains[index];var grow=addToHead?chain[0]:chain[chain.length-1];var grow2=addToHead?chain[1]:chain[chain.length-2];var oppo=addToHead?chain[chain.length-1]:chain[0];var oppo2=addToHead?chain[chain.length-2]:chain[1];if(eps.pointsCollinear(grow2,grow,pt)){// grow isn't needed because it's directly between grow2 and pt:\n// grow2 ---grow---> pt\nif(addToHead){if(buildLog)buildLog.chainRemoveHead(first_match.index,pt);chain.shift();}else{if(buildLog)buildLog.chainRemoveTail(first_match.index,pt);chain.pop();}grow=grow2;// old grow is gone... new grow is what grow2 was\n}if(eps.pointsSame(oppo,pt)){// we're closing the loop, so remove chain from chains\nchains.splice(index,1);if(eps.pointsCollinear(oppo2,oppo,grow)){// oppo isn't needed because it's directly between oppo2 and grow:\n// oppo2 ---oppo--->grow\nif(addToHead){if(buildLog)buildLog.chainRemoveTail(first_match.index,grow);chain.pop();}else{if(buildLog)buildLog.chainRemoveHead(first_match.index,grow);chain.shift();}}if(buildLog)buildLog.chainClose(first_match.index);// we have a closed chain!\nregions.push(chain);return;}// not closing a loop, so just add it to the apporpriate side\nif(addToHead){if(buildLog)buildLog.chainAddHead(first_match.index,pt);chain.unshift(pt);}else{if(buildLog)buildLog.chainAddTail(first_match.index,pt);chain.push(pt);}return;}// otherwise, we matched two chains, so we need to combine those chains together\nfunction reverseChain(index){if(buildLog)buildLog.chainReverse(index);chains[index].reverse();// gee, that's easy\n}function appendChain(index1,index2){// index1 gets index2 appended to it, and index2 is removed\nvar chain1=chains[index1];var chain2=chains[index2];var tail=chain1[chain1.length-1];var tail2=chain1[chain1.length-2];var head=chain2[0];var head2=chain2[1];if(eps.pointsCollinear(tail2,tail,head)){// tail isn't needed because it's directly between tail2 and head\n// tail2 ---tail---> head\nif(buildLog)buildLog.chainRemoveTail(index1,tail);chain1.pop();tail=tail2;// old tail is gone... new tail is what tail2 was\n}if(eps.pointsCollinear(tail,head,head2)){// head isn't needed because it's directly between tail and head2\n// tail ---head---> head2\nif(buildLog)buildLog.chainRemoveHead(index2,head);chain2.shift();}if(buildLog)buildLog.chainJoin(index1,index2);chains[index1]=chain1.concat(chain2);chains.splice(index2,1);}var F=first_match.index;var S=second_match.index;if(buildLog)buildLog.chainConnect(F,S);var reverseF=chains[F].length<chains[S].length;// reverse the shorter chain, if needed\nif(first_match.matches_head){if(second_match.matches_head){if(reverseF){// <<<< F <<<< --- >>>> S >>>>\nreverseChain(F);// >>>> F >>>> --- >>>> S >>>>\nappendChain(F,S);}else{// <<<< F <<<< --- >>>> S >>>>\nreverseChain(S);// <<<< F <<<< --- <<<< S <<<<   logically same as:\n// >>>> S >>>> --- >>>> F >>>>\nappendChain(S,F);}}else{// <<<< F <<<< --- <<<< S <<<<   logically same as:\n// >>>> S >>>> --- >>>> F >>>>\nappendChain(S,F);}}else{if(second_match.matches_head){// >>>> F >>>> --- >>>> S >>>>\nappendChain(F,S);}else{if(reverseF){// >>>> F >>>> --- <<<< S <<<<\nreverseChain(F);// <<<< F <<<< --- <<<< S <<<<   logically same as:\n// >>>> S >>>> --- >>>> F >>>>\nappendChain(S,F);}else{// >>>> F >>>> --- <<<< S <<<<\nreverseChain(S);// >>>> F >>>> --- >>>> S >>>>\nappendChain(F,S);}}}});return regions;}module.exports=SegmentChainer;},{}],24:[function(_dereq_,module,exports){// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n//\n// filter a list of segments based on boolean operations\n//\nfunction select(segments,selection,buildLog){var result=[];segments.forEach(function(seg){var index=(seg.myFill.above?8:0)+(seg.myFill.below?4:0)+(seg.otherFill&&seg.otherFill.above?2:0)+(seg.otherFill&&seg.otherFill.below?1:0);if(selection[index]!==0){// copy the segment to the results, while also calculating the fill status\nresult.push({id:buildLog?buildLog.segmentId():-1,start:seg.start,end:seg.end,myFill:{above:selection[index]===1,// 1 if filled above\nbelow:selection[index]===2// 2 if filled below\n},otherFill:null});}});if(buildLog)buildLog.selected(result);return result;}var SegmentSelector={union:function union(segments,buildLog){// primary | secondary\n// above1 below1 above2 below2    Keep?               Value\n//    0      0      0      0   =>   no                  0\n//    0      0      0      1   =>   yes filled below    2\n//    0      0      1      0   =>   yes filled above    1\n//    0      0      1      1   =>   no                  0\n//    0      1      0      0   =>   yes filled below    2\n//    0      1      0      1   =>   yes filled below    2\n//    0      1      1      0   =>   no                  0\n//    0      1      1      1   =>   no                  0\n//    1      0      0      0   =>   yes filled above    1\n//    1      0      0      1   =>   no                  0\n//    1      0      1      0   =>   yes filled above    1\n//    1      0      1      1   =>   no                  0\n//    1      1      0      0   =>   no                  0\n//    1      1      0      1   =>   no                  0\n//    1      1      1      0   =>   no                  0\n//    1      1      1      1   =>   no                  0\nreturn select(segments,[0,2,1,0,2,2,0,0,1,0,1,0,0,0,0,0],buildLog);},intersect:function intersect(segments,buildLog){// primary & secondary\n// above1 below1 above2 below2    Keep?               Value\n//    0      0      0      0   =>   no                  0\n//    0      0      0      1   =>   no                  0\n//    0      0      1      0   =>   no                  0\n//    0      0      1      1   =>   no                  0\n//    0      1      0      0   =>   no                  0\n//    0      1      0      1   =>   yes filled below    2\n//    0      1      1      0   =>   no                  0\n//    0      1      1      1   =>   yes filled below    2\n//    1      0      0      0   =>   no                  0\n//    1      0      0      1   =>   no                  0\n//    1      0      1      0   =>   yes filled above    1\n//    1      0      1      1   =>   yes filled above    1\n//    1      1      0      0   =>   no                  0\n//    1      1      0      1   =>   yes filled below    2\n//    1      1      1      0   =>   yes filled above    1\n//    1      1      1      1   =>   no                  0\nreturn select(segments,[0,0,0,0,0,2,0,2,0,0,1,1,0,2,1,0],buildLog);},difference:function difference(segments,buildLog){// primary - secondary\n// above1 below1 above2 below2    Keep?               Value\n//    0      0      0      0   =>   no                  0\n//    0      0      0      1   =>   no                  0\n//    0      0      1      0   =>   no                  0\n//    0      0      1      1   =>   no                  0\n//    0      1      0      0   =>   yes filled below    2\n//    0      1      0      1   =>   no                  0\n//    0      1      1      0   =>   yes filled below    2\n//    0      1      1      1   =>   no                  0\n//    1      0      0      0   =>   yes filled above    1\n//    1      0      0      1   =>   yes filled above    1\n//    1      0      1      0   =>   no                  0\n//    1      0      1      1   =>   no                  0\n//    1      1      0      0   =>   no                  0\n//    1      1      0      1   =>   yes filled above    1\n//    1      1      1      0   =>   yes filled below    2\n//    1      1      1      1   =>   no                  0\nreturn select(segments,[0,0,0,0,2,0,2,0,1,1,0,0,0,1,2,0],buildLog);},differenceRev:function differenceRev(segments,buildLog){// secondary - primary\n// above1 below1 above2 below2    Keep?               Value\n//    0      0      0      0   =>   no                  0\n//    0      0      0      1   =>   yes filled below    2\n//    0      0      1      0   =>   yes filled above    1\n//    0      0      1      1   =>   no                  0\n//    0      1      0      0   =>   no                  0\n//    0      1      0      1   =>   no                  0\n//    0      1      1      0   =>   yes filled above    1\n//    0      1      1      1   =>   yes filled above    1\n//    1      0      0      0   =>   no                  0\n//    1      0      0      1   =>   yes filled below    2\n//    1      0      1      0   =>   no                  0\n//    1      0      1      1   =>   yes filled below    2\n//    1      1      0      0   =>   no                  0\n//    1      1      0      1   =>   no                  0\n//    1      1      1      0   =>   no                  0\n//    1      1      1      1   =>   no                  0\nreturn select(segments,[0,2,1,0,0,0,1,1,0,2,0,2,0,0,0,0],buildLog);},xor:function xor(segments,buildLog){// primary ^ secondary\n// above1 below1 above2 below2    Keep?               Value\n//    0      0      0      0   =>   no                  0\n//    0      0      0      1   =>   yes filled below    2\n//    0      0      1      0   =>   yes filled above    1\n//    0      0      1      1   =>   no                  0\n//    0      1      0      0   =>   yes filled below    2\n//    0      1      0      1   =>   no                  0\n//    0      1      1      0   =>   no                  0\n//    0      1      1      1   =>   yes filled above    1\n//    1      0      0      0   =>   yes filled above    1\n//    1      0      0      1   =>   no                  0\n//    1      0      1      0   =>   no                  0\n//    1      0      1      1   =>   yes filled below    2\n//    1      1      0      0   =>   no                  0\n//    1      1      0      1   =>   yes filled above    1\n//    1      1      1      0   =>   yes filled below    2\n//    1      1      1      1   =>   no                  0\nreturn select(segments,[0,2,1,0,2,0,0,1,1,0,0,2,0,1,2,0],buildLog);}};module.exports=SegmentSelector;},{}],25:[function(_dereq_,module,exports){// shim for using process in browser\nvar process=module.exports={};// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\nvar cachedSetTimeout;var cachedClearTimeout;function defaultSetTimout(){throw new Error('setTimeout has not been defined');}function defaultClearTimeout(){throw new Error('clearTimeout has not been defined');}(function(){try{if(typeof setTimeout==='function'){cachedSetTimeout=setTimeout;}else{cachedSetTimeout=defaultSetTimout;}}catch(e){cachedSetTimeout=defaultSetTimout;}try{if(typeof clearTimeout==='function'){cachedClearTimeout=clearTimeout;}else{cachedClearTimeout=defaultClearTimeout;}}catch(e){cachedClearTimeout=defaultClearTimeout;}})();function runTimeout(fun){if(cachedSetTimeout===setTimeout){//normal enviroments in sane situations\nreturn setTimeout(fun,0);}// if setTimeout wasn't available but was latter defined\nif((cachedSetTimeout===defaultSetTimout||!cachedSetTimeout)&&setTimeout){cachedSetTimeout=setTimeout;return setTimeout(fun,0);}try{// when when somebody has screwed with setTimeout but no I.E. maddness\nreturn cachedSetTimeout(fun,0);}catch(e){try{// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\nreturn cachedSetTimeout.call(null,fun,0);}catch(e){// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\nreturn cachedSetTimeout.call(this,fun,0);}}}function runClearTimeout(marker){if(cachedClearTimeout===clearTimeout){//normal enviroments in sane situations\nreturn clearTimeout(marker);}// if clearTimeout wasn't available but was latter defined\nif((cachedClearTimeout===defaultClearTimeout||!cachedClearTimeout)&&clearTimeout){cachedClearTimeout=clearTimeout;return clearTimeout(marker);}try{// when when somebody has screwed with setTimeout but no I.E. maddness\nreturn cachedClearTimeout(marker);}catch(e){try{// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\nreturn cachedClearTimeout.call(null,marker);}catch(e){// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n// Some versions of I.E. have different rules for clearTimeout vs setTimeout\nreturn cachedClearTimeout.call(this,marker);}}}var queue=[];var draining=false;var currentQueue;var queueIndex=-1;function cleanUpNextTick(){if(!draining||!currentQueue){return;}draining=false;if(currentQueue.length){queue=currentQueue.concat(queue);}else{queueIndex=-1;}if(queue.length){drainQueue();}}function drainQueue(){if(draining){return;}var timeout=runTimeout(cleanUpNextTick);draining=true;var len=queue.length;while(len){currentQueue=queue;queue=[];while(++queueIndex<len){if(currentQueue){currentQueue[queueIndex].run();}}queueIndex=-1;len=queue.length;}currentQueue=null;draining=false;runClearTimeout(timeout);}process.nextTick=function(fun){var args=new Array(arguments.length-1);if(arguments.length>1){for(var i=1;i<arguments.length;i++){args[i-1]=arguments[i];}}queue.push(new Item(fun,args));if(queue.length===1&&!draining){runTimeout(drainQueue);}};// v8 likes predictible objects\nfunction Item(fun,array){this.fun=fun;this.array=array;}Item.prototype.run=function(){this.fun.apply(null,this.array);};process.title='browser';process.browser=true;process.env={};process.argv=[];process.version='';// empty string to avoid regexp issues\nprocess.versions={};function noop(){}process.on=noop;process.addListener=noop;process.once=noop;process.off=noop;process.removeListener=noop;process.removeAllListeners=noop;process.emit=noop;process.prependListener=noop;process.prependOnceListener=noop;process.listeners=function(name){return[];};process.binding=function(name){throw new Error('process.binding is not supported');};process.cwd=function(){return'/';};process.chdir=function(dir){throw new Error('process.chdir is not supported');};process.umask=function(){return 0;};},{}],26:[function(_dereq_,module,exports){// TinyColor v1.4.1\n// https://github.com/bgrins/TinyColor\n// Brian Grinstead, MIT License\n(function(Math){var trimLeft=/^\\s+/,trimRight=/\\s+$/,tinyCounter=0,mathRound=Math.round,mathMin=Math.min,mathMax=Math.max,mathRandom=Math.random;function tinycolor(color,opts){color=color?color:'';opts=opts||{};// If input is already a tinycolor, return itself\nif(color instanceof tinycolor){return color;}// If we are called as a function, call using new instead\nif(!(this instanceof tinycolor)){return new tinycolor(color,opts);}var rgb=inputToRGB(color);this._originalInput=color,this._r=rgb.r,this._g=rgb.g,this._b=rgb.b,this._a=rgb.a,this._roundA=mathRound(100*this._a)/100,this._format=opts.format||rgb.format;this._gradientType=opts.gradientType;// Don't let the range of [0,255] come back in [0,1].\n// Potentially lose a little bit of precision here, but will fix issues where\n// .5 gets interpreted as half of the total, instead of half of 1\n// If it was supposed to be 128, this was already taken care of by `inputToRgb`\nif(this._r<1){this._r=mathRound(this._r);}if(this._g<1){this._g=mathRound(this._g);}if(this._b<1){this._b=mathRound(this._b);}this._ok=rgb.ok;this._tc_id=tinyCounter++;}tinycolor.prototype={isDark:function isDark(){return this.getBrightness()<128;},isLight:function isLight(){return!this.isDark();},isValid:function isValid(){return this._ok;},getOriginalInput:function getOriginalInput(){return this._originalInput;},getFormat:function getFormat(){return this._format;},getAlpha:function getAlpha(){return this._a;},getBrightness:function getBrightness(){//http://www.w3.org/TR/AERT#color-contrast\nvar rgb=this.toRgb();return(rgb.r*299+rgb.g*587+rgb.b*114)/1000;},getLuminance:function getLuminance(){//http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\nvar rgb=this.toRgb();var RsRGB,GsRGB,BsRGB,R,G,B;RsRGB=rgb.r/255;GsRGB=rgb.g/255;BsRGB=rgb.b/255;if(RsRGB<=0.03928){R=RsRGB/12.92;}else{R=Math.pow((RsRGB+0.055)/1.055,2.4);}if(GsRGB<=0.03928){G=GsRGB/12.92;}else{G=Math.pow((GsRGB+0.055)/1.055,2.4);}if(BsRGB<=0.03928){B=BsRGB/12.92;}else{B=Math.pow((BsRGB+0.055)/1.055,2.4);}return 0.2126*R+0.7152*G+0.0722*B;},setAlpha:function setAlpha(value){this._a=boundAlpha(value);this._roundA=mathRound(100*this._a)/100;return this;},toHsv:function toHsv(){var hsv=rgbToHsv(this._r,this._g,this._b);return{h:hsv.h*360,s:hsv.s,v:hsv.v,a:this._a};},toHsvString:function toHsvString(){var hsv=rgbToHsv(this._r,this._g,this._b);var h=mathRound(hsv.h*360),s=mathRound(hsv.s*100),v=mathRound(hsv.v*100);return this._a==1?\"hsv(\"+h+\", \"+s+\"%, \"+v+\"%)\":\"hsva(\"+h+\", \"+s+\"%, \"+v+\"%, \"+this._roundA+\")\";},toHsl:function toHsl(){var hsl=rgbToHsl(this._r,this._g,this._b);return{h:hsl.h*360,s:hsl.s,l:hsl.l,a:this._a};},toHslString:function toHslString(){var hsl=rgbToHsl(this._r,this._g,this._b);var h=mathRound(hsl.h*360),s=mathRound(hsl.s*100),l=mathRound(hsl.l*100);return this._a==1?\"hsl(\"+h+\", \"+s+\"%, \"+l+\"%)\":\"hsla(\"+h+\", \"+s+\"%, \"+l+\"%, \"+this._roundA+\")\";},toHex:function toHex(allow3Char){return rgbToHex(this._r,this._g,this._b,allow3Char);},toHexString:function toHexString(allow3Char){return'#'+this.toHex(allow3Char);},toHex8:function toHex8(allow4Char){return rgbaToHex(this._r,this._g,this._b,this._a,allow4Char);},toHex8String:function toHex8String(allow4Char){return'#'+this.toHex8(allow4Char);},toRgb:function toRgb(){return{r:mathRound(this._r),g:mathRound(this._g),b:mathRound(this._b),a:this._a};},toRgbString:function toRgbString(){return this._a==1?\"rgb(\"+mathRound(this._r)+\", \"+mathRound(this._g)+\", \"+mathRound(this._b)+\")\":\"rgba(\"+mathRound(this._r)+\", \"+mathRound(this._g)+\", \"+mathRound(this._b)+\", \"+this._roundA+\")\";},toPercentageRgb:function toPercentageRgb(){return{r:mathRound(bound01(this._r,255)*100)+\"%\",g:mathRound(bound01(this._g,255)*100)+\"%\",b:mathRound(bound01(this._b,255)*100)+\"%\",a:this._a};},toPercentageRgbString:function toPercentageRgbString(){return this._a==1?\"rgb(\"+mathRound(bound01(this._r,255)*100)+\"%, \"+mathRound(bound01(this._g,255)*100)+\"%, \"+mathRound(bound01(this._b,255)*100)+\"%)\":\"rgba(\"+mathRound(bound01(this._r,255)*100)+\"%, \"+mathRound(bound01(this._g,255)*100)+\"%, \"+mathRound(bound01(this._b,255)*100)+\"%, \"+this._roundA+\")\";},toName:function toName(){if(this._a===0){return\"transparent\";}if(this._a<1){return false;}return hexNames[rgbToHex(this._r,this._g,this._b,true)]||false;},toFilter:function toFilter(secondColor){var hex8String='#'+rgbaToArgbHex(this._r,this._g,this._b,this._a);var secondHex8String=hex8String;var gradientType=this._gradientType?\"GradientType = 1, \":\"\";if(secondColor){var s=tinycolor(secondColor);secondHex8String='#'+rgbaToArgbHex(s._r,s._g,s._b,s._a);}return\"progid:DXImageTransform.Microsoft.gradient(\"+gradientType+\"startColorstr=\"+hex8String+\",endColorstr=\"+secondHex8String+\")\";},toString:function toString(format){var formatSet=!!format;format=format||this._format;var formattedString=false;var hasAlpha=this._a<1&&this._a>=0;var needsAlphaFormat=!formatSet&&hasAlpha&&(format===\"hex\"||format===\"hex6\"||format===\"hex3\"||format===\"hex4\"||format===\"hex8\"||format===\"name\");if(needsAlphaFormat){// Special case for \"transparent\", all other non-alpha formats\n// will return rgba when there is transparency.\nif(format===\"name\"&&this._a===0){return this.toName();}return this.toRgbString();}if(format===\"rgb\"){formattedString=this.toRgbString();}if(format===\"prgb\"){formattedString=this.toPercentageRgbString();}if(format===\"hex\"||format===\"hex6\"){formattedString=this.toHexString();}if(format===\"hex3\"){formattedString=this.toHexString(true);}if(format===\"hex4\"){formattedString=this.toHex8String(true);}if(format===\"hex8\"){formattedString=this.toHex8String();}if(format===\"name\"){formattedString=this.toName();}if(format===\"hsl\"){formattedString=this.toHslString();}if(format===\"hsv\"){formattedString=this.toHsvString();}return formattedString||this.toHexString();},clone:function clone(){return tinycolor(this.toString());},_applyModification:function _applyModification(fn,args){var color=fn.apply(null,[this].concat([].slice.call(args)));this._r=color._r;this._g=color._g;this._b=color._b;this.setAlpha(color._a);return this;},lighten:function lighten(){return this._applyModification(_lighten,arguments);},brighten:function brighten(){return this._applyModification(_brighten,arguments);},darken:function darken(){return this._applyModification(_darken,arguments);},desaturate:function desaturate(){return this._applyModification(_desaturate,arguments);},saturate:function saturate(){return this._applyModification(_saturate,arguments);},greyscale:function greyscale(){return this._applyModification(_greyscale,arguments);},spin:function spin(){return this._applyModification(_spin,arguments);},_applyCombination:function _applyCombination(fn,args){return fn.apply(null,[this].concat([].slice.call(args)));},analogous:function analogous(){return this._applyCombination(_analogous,arguments);},complement:function complement(){return this._applyCombination(_complement,arguments);},monochromatic:function monochromatic(){return this._applyCombination(_monochromatic,arguments);},splitcomplement:function splitcomplement(){return this._applyCombination(_splitcomplement,arguments);},triad:function triad(){return this._applyCombination(_triad,arguments);},tetrad:function tetrad(){return this._applyCombination(_tetrad,arguments);}};// If input is an object, force 1 into \"1.0\" to handle ratios properly\n// String input requires \"1.0\" as input, so 1 will be treated as 1\ntinycolor.fromRatio=function(color,opts){if(_typeof(color)==\"object\"){var newColor={};for(var i in color){if(color.hasOwnProperty(i)){if(i===\"a\"){newColor[i]=color[i];}else{newColor[i]=convertToPercentage(color[i]);}}}color=newColor;}return tinycolor(color,opts);};// Given a string or object, convert that input to RGB\n// Possible string inputs:\n//\n//     \"red\"\n//     \"#f00\" or \"f00\"\n//     \"#ff0000\" or \"ff0000\"\n//     \"#ff000000\" or \"ff000000\"\n//     \"rgb 255 0 0\" or \"rgb (255, 0, 0)\"\n//     \"rgb 1.0 0 0\" or \"rgb (1, 0, 0)\"\n//     \"rgba (255, 0, 0, 1)\" or \"rgba 255, 0, 0, 1\"\n//     \"rgba (1.0, 0, 0, 1)\" or \"rgba 1.0, 0, 0, 1\"\n//     \"hsl(0, 100%, 50%)\" or \"hsl 0 100% 50%\"\n//     \"hsla(0, 100%, 50%, 1)\" or \"hsla 0 100% 50%, 1\"\n//     \"hsv(0, 100%, 100%)\" or \"hsv 0 100% 100%\"\n//\nfunction inputToRGB(color){var rgb={r:0,g:0,b:0};var a=1;var s=null;var v=null;var l=null;var ok=false;var format=false;if(typeof color==\"string\"){color=stringInputToObject(color);}if(_typeof(color)==\"object\"){if(isValidCSSUnit(color.r)&&isValidCSSUnit(color.g)&&isValidCSSUnit(color.b)){rgb=rgbToRgb(color.r,color.g,color.b);ok=true;format=String(color.r).substr(-1)===\"%\"?\"prgb\":\"rgb\";}else if(isValidCSSUnit(color.h)&&isValidCSSUnit(color.s)&&isValidCSSUnit(color.v)){s=convertToPercentage(color.s);v=convertToPercentage(color.v);rgb=hsvToRgb(color.h,s,v);ok=true;format=\"hsv\";}else if(isValidCSSUnit(color.h)&&isValidCSSUnit(color.s)&&isValidCSSUnit(color.l)){s=convertToPercentage(color.s);l=convertToPercentage(color.l);rgb=hslToRgb(color.h,s,l);ok=true;format=\"hsl\";}if(color.hasOwnProperty(\"a\")){a=color.a;}}a=boundAlpha(a);return{ok:ok,format:color.format||format,r:mathMin(255,mathMax(rgb.r,0)),g:mathMin(255,mathMax(rgb.g,0)),b:mathMin(255,mathMax(rgb.b,0)),a:a};}// Conversion Functions\n// --------------------\n// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:\n// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>\n// `rgbToRgb`\n// Handle bounds / percentage checking to conform to CSS color spec\n// <http://www.w3.org/TR/css3-color/>\n// *Assumes:* r, g, b in [0, 255] or [0, 1]\n// *Returns:* { r, g, b } in [0, 255]\nfunction rgbToRgb(r,g,b){return{r:bound01(r,255)*255,g:bound01(g,255)*255,b:bound01(b,255)*255};}// `rgbToHsl`\n// Converts an RGB color value to HSL.\n// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]\n// *Returns:* { h, s, l } in [0,1]\nfunction rgbToHsl(r,g,b){r=bound01(r,255);g=bound01(g,255);b=bound01(b,255);var max=mathMax(r,g,b),min=mathMin(r,g,b);var h,s,l=(max+min)/2;if(max==min){h=s=0;// achromatic\n}else{var d=max-min;s=l>0.5?d/(2-max-min):d/(max+min);switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break;}h/=6;}return{h:h,s:s,l:l};}// `hslToRgb`\n// Converts an HSL color value to RGB.\n// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]\n// *Returns:* { r, g, b } in the set [0, 255]\nfunction hslToRgb(h,s,l){var r,g,b;h=bound01(h,360);s=bound01(s,100);l=bound01(l,100);function hue2rgb(p,q,t){if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*(2/3-t)*6;return p;}if(s===0){r=g=b=l;// achromatic\n}else{var q=l<0.5?l*(1+s):l+s-l*s;var p=2*l-q;r=hue2rgb(p,q,h+1/3);g=hue2rgb(p,q,h);b=hue2rgb(p,q,h-1/3);}return{r:r*255,g:g*255,b:b*255};}// `rgbToHsv`\n// Converts an RGB color value to HSV\n// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]\n// *Returns:* { h, s, v } in [0,1]\nfunction rgbToHsv(r,g,b){r=bound01(r,255);g=bound01(g,255);b=bound01(b,255);var max=mathMax(r,g,b),min=mathMin(r,g,b);var h,s,v=max;var d=max-min;s=max===0?0:d/max;if(max==min){h=0;// achromatic\n}else{switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break;}h/=6;}return{h:h,s:s,v:v};}// `hsvToRgb`\n// Converts an HSV color value to RGB.\n// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]\n// *Returns:* { r, g, b } in the set [0, 255]\nfunction hsvToRgb(h,s,v){h=bound01(h,360)*6;s=bound01(s,100);v=bound01(v,100);var i=Math.floor(h),f=h-i,p=v*(1-s),q=v*(1-f*s),t=v*(1-(1-f)*s),mod=i%6,r=[v,q,p,p,t,v][mod],g=[t,v,v,q,p,p][mod],b=[p,p,t,v,v,q][mod];return{r:r*255,g:g*255,b:b*255};}// `rgbToHex`\n// Converts an RGB color to hex\n// Assumes r, g, and b are contained in the set [0, 255]\n// Returns a 3 or 6 character hex\nfunction rgbToHex(r,g,b,allow3Char){var hex=[pad2(mathRound(r).toString(16)),pad2(mathRound(g).toString(16)),pad2(mathRound(b).toString(16))];// Return a 3 character hex if possible\nif(allow3Char&&hex[0].charAt(0)==hex[0].charAt(1)&&hex[1].charAt(0)==hex[1].charAt(1)&&hex[2].charAt(0)==hex[2].charAt(1)){return hex[0].charAt(0)+hex[1].charAt(0)+hex[2].charAt(0);}return hex.join(\"\");}// `rgbaToHex`\n// Converts an RGBA color plus alpha transparency to hex\n// Assumes r, g, b are contained in the set [0, 255] and\n// a in [0, 1]. Returns a 4 or 8 character rgba hex\nfunction rgbaToHex(r,g,b,a,allow4Char){var hex=[pad2(mathRound(r).toString(16)),pad2(mathRound(g).toString(16)),pad2(mathRound(b).toString(16)),pad2(convertDecimalToHex(a))];// Return a 4 character hex if possible\nif(allow4Char&&hex[0].charAt(0)==hex[0].charAt(1)&&hex[1].charAt(0)==hex[1].charAt(1)&&hex[2].charAt(0)==hex[2].charAt(1)&&hex[3].charAt(0)==hex[3].charAt(1)){return hex[0].charAt(0)+hex[1].charAt(0)+hex[2].charAt(0)+hex[3].charAt(0);}return hex.join(\"\");}// `rgbaToArgbHex`\n// Converts an RGBA color to an ARGB Hex8 string\n// Rarely used, but required for \"toFilter()\"\nfunction rgbaToArgbHex(r,g,b,a){var hex=[pad2(convertDecimalToHex(a)),pad2(mathRound(r).toString(16)),pad2(mathRound(g).toString(16)),pad2(mathRound(b).toString(16))];return hex.join(\"\");}// `equals`\n// Can be called with any tinycolor input\ntinycolor.equals=function(color1,color2){if(!color1||!color2){return false;}return tinycolor(color1).toRgbString()==tinycolor(color2).toRgbString();};tinycolor.random=function(){return tinycolor.fromRatio({r:mathRandom(),g:mathRandom(),b:mathRandom()});};// Modification Functions\n// ----------------------\n// Thanks to less.js for some of the basics here\n// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>\nfunction _desaturate(color,amount){amount=amount===0?0:amount||10;var hsl=tinycolor(color).toHsl();hsl.s-=amount/100;hsl.s=clamp01(hsl.s);return tinycolor(hsl);}function _saturate(color,amount){amount=amount===0?0:amount||10;var hsl=tinycolor(color).toHsl();hsl.s+=amount/100;hsl.s=clamp01(hsl.s);return tinycolor(hsl);}function _greyscale(color){return tinycolor(color).desaturate(100);}function _lighten(color,amount){amount=amount===0?0:amount||10;var hsl=tinycolor(color).toHsl();hsl.l+=amount/100;hsl.l=clamp01(hsl.l);return tinycolor(hsl);}function _brighten(color,amount){amount=amount===0?0:amount||10;var rgb=tinycolor(color).toRgb();rgb.r=mathMax(0,mathMin(255,rgb.r-mathRound(255*-(amount/100))));rgb.g=mathMax(0,mathMin(255,rgb.g-mathRound(255*-(amount/100))));rgb.b=mathMax(0,mathMin(255,rgb.b-mathRound(255*-(amount/100))));return tinycolor(rgb);}function _darken(color,amount){amount=amount===0?0:amount||10;var hsl=tinycolor(color).toHsl();hsl.l-=amount/100;hsl.l=clamp01(hsl.l);return tinycolor(hsl);}// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.\n// Values outside of this range will be wrapped into this range.\nfunction _spin(color,amount){var hsl=tinycolor(color).toHsl();var hue=(hsl.h+amount)%360;hsl.h=hue<0?360+hue:hue;return tinycolor(hsl);}// Combination Functions\n// ---------------------\n// Thanks to jQuery xColor for some of the ideas behind these\n// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>\nfunction _complement(color){var hsl=tinycolor(color).toHsl();hsl.h=(hsl.h+180)%360;return tinycolor(hsl);}function _triad(color){var hsl=tinycolor(color).toHsl();var h=hsl.h;return[tinycolor(color),tinycolor({h:(h+120)%360,s:hsl.s,l:hsl.l}),tinycolor({h:(h+240)%360,s:hsl.s,l:hsl.l})];}function _tetrad(color){var hsl=tinycolor(color).toHsl();var h=hsl.h;return[tinycolor(color),tinycolor({h:(h+90)%360,s:hsl.s,l:hsl.l}),tinycolor({h:(h+180)%360,s:hsl.s,l:hsl.l}),tinycolor({h:(h+270)%360,s:hsl.s,l:hsl.l})];}function _splitcomplement(color){var hsl=tinycolor(color).toHsl();var h=hsl.h;return[tinycolor(color),tinycolor({h:(h+72)%360,s:hsl.s,l:hsl.l}),tinycolor({h:(h+216)%360,s:hsl.s,l:hsl.l})];}function _analogous(color,results,slices){results=results||6;slices=slices||30;var hsl=tinycolor(color).toHsl();var part=360/slices;var ret=[tinycolor(color)];for(hsl.h=(hsl.h-(part*results>>1)+720)%360;--results;){hsl.h=(hsl.h+part)%360;ret.push(tinycolor(hsl));}return ret;}function _monochromatic(color,results){results=results||6;var hsv=tinycolor(color).toHsv();var h=hsv.h,s=hsv.s,v=hsv.v;var ret=[];var modification=1/results;while(results--){ret.push(tinycolor({h:h,s:s,v:v}));v=(v+modification)%1;}return ret;}// Utility Functions\n// ---------------------\ntinycolor.mix=function(color1,color2,amount){amount=amount===0?0:amount||50;var rgb1=tinycolor(color1).toRgb();var rgb2=tinycolor(color2).toRgb();var p=amount/100;var rgba={r:(rgb2.r-rgb1.r)*p+rgb1.r,g:(rgb2.g-rgb1.g)*p+rgb1.g,b:(rgb2.b-rgb1.b)*p+rgb1.b,a:(rgb2.a-rgb1.a)*p+rgb1.a};return tinycolor(rgba);};// Readability Functions\n// ---------------------\n// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)\n// `contrast`\n// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)\ntinycolor.readability=function(color1,color2){var c1=tinycolor(color1);var c2=tinycolor(color2);return(Math.max(c1.getLuminance(),c2.getLuminance())+0.05)/(Math.min(c1.getLuminance(),c2.getLuminance())+0.05);};// `isReadable`\n// Ensure that foreground and background color combinations meet WCAG2 guidelines.\n// The third argument is an optional Object.\n//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';\n//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.\n// If the entire object is absent, isReadable defaults to {level:\"AA\",size:\"small\"}.\n// *Example*\n//    tinycolor.isReadable(\"#000\", \"#111\") => false\n//    tinycolor.isReadable(\"#000\", \"#111\",{level:\"AA\",size:\"large\"}) => false\ntinycolor.isReadable=function(color1,color2,wcag2){var readability=tinycolor.readability(color1,color2);var wcag2Parms,out;out=false;wcag2Parms=validateWCAG2Parms(wcag2);switch(wcag2Parms.level+wcag2Parms.size){case\"AAsmall\":case\"AAAlarge\":out=readability>=4.5;break;case\"AAlarge\":out=readability>=3;break;case\"AAAsmall\":out=readability>=7;break;}return out;};// `mostReadable`\n// Given a base color and a list of possible foreground or background\n// colors for that base, returns the most readable color.\n// Optionally returns Black or White if the most readable color is unreadable.\n// *Example*\n//    tinycolor.mostReadable(tinycolor.mostReadable(\"#123\", [\"#124\", \"#125\"],{includeFallbackColors:false}).toHexString(); // \"#112255\"\n//    tinycolor.mostReadable(tinycolor.mostReadable(\"#123\", [\"#124\", \"#125\"],{includeFallbackColors:true}).toHexString();  // \"#ffffff\"\n//    tinycolor.mostReadable(\"#a8015a\", [\"#faf3f3\"],{includeFallbackColors:true,level:\"AAA\",size:\"large\"}).toHexString(); // \"#faf3f3\"\n//    tinycolor.mostReadable(\"#a8015a\", [\"#faf3f3\"],{includeFallbackColors:true,level:\"AAA\",size:\"small\"}).toHexString(); // \"#ffffff\"\ntinycolor.mostReadable=function(baseColor,colorList,args){var bestColor=null;var bestScore=0;var readability;var includeFallbackColors,level,size;args=args||{};includeFallbackColors=args.includeFallbackColors;level=args.level;size=args.size;for(var i=0;i<colorList.length;i++){readability=tinycolor.readability(baseColor,colorList[i]);if(readability>bestScore){bestScore=readability;bestColor=tinycolor(colorList[i]);}}if(tinycolor.isReadable(baseColor,bestColor,{\"level\":level,\"size\":size})||!includeFallbackColors){return bestColor;}else{args.includeFallbackColors=false;return tinycolor.mostReadable(baseColor,[\"#fff\",\"#000\"],args);}};// Big List of Colors\n// ------------------\n// <http://www.w3.org/TR/css3-color/#svg-color>\nvar names=tinycolor.names={aliceblue:\"f0f8ff\",antiquewhite:\"faebd7\",aqua:\"0ff\",aquamarine:\"7fffd4\",azure:\"f0ffff\",beige:\"f5f5dc\",bisque:\"ffe4c4\",black:\"000\",blanchedalmond:\"ffebcd\",blue:\"00f\",blueviolet:\"8a2be2\",brown:\"a52a2a\",burlywood:\"deb887\",burntsienna:\"ea7e5d\",cadetblue:\"5f9ea0\",chartreuse:\"7fff00\",chocolate:\"d2691e\",coral:\"ff7f50\",cornflowerblue:\"6495ed\",cornsilk:\"fff8dc\",crimson:\"dc143c\",cyan:\"0ff\",darkblue:\"00008b\",darkcyan:\"008b8b\",darkgoldenrod:\"b8860b\",darkgray:\"a9a9a9\",darkgreen:\"006400\",darkgrey:\"a9a9a9\",darkkhaki:\"bdb76b\",darkmagenta:\"8b008b\",darkolivegreen:\"556b2f\",darkorange:\"ff8c00\",darkorchid:\"9932cc\",darkred:\"8b0000\",darksalmon:\"e9967a\",darkseagreen:\"8fbc8f\",darkslateblue:\"483d8b\",darkslategray:\"2f4f4f\",darkslategrey:\"2f4f4f\",darkturquoise:\"00ced1\",darkviolet:\"9400d3\",deeppink:\"ff1493\",deepskyblue:\"00bfff\",dimgray:\"696969\",dimgrey:\"696969\",dodgerblue:\"1e90ff\",firebrick:\"b22222\",floralwhite:\"fffaf0\",forestgreen:\"228b22\",fuchsia:\"f0f\",gainsboro:\"dcdcdc\",ghostwhite:\"f8f8ff\",gold:\"ffd700\",goldenrod:\"daa520\",gray:\"808080\",green:\"008000\",greenyellow:\"adff2f\",grey:\"808080\",honeydew:\"f0fff0\",hotpink:\"ff69b4\",indianred:\"cd5c5c\",indigo:\"4b0082\",ivory:\"fffff0\",khaki:\"f0e68c\",lavender:\"e6e6fa\",lavenderblush:\"fff0f5\",lawngreen:\"7cfc00\",lemonchiffon:\"fffacd\",lightblue:\"add8e6\",lightcoral:\"f08080\",lightcyan:\"e0ffff\",lightgoldenrodyellow:\"fafad2\",lightgray:\"d3d3d3\",lightgreen:\"90ee90\",lightgrey:\"d3d3d3\",lightpink:\"ffb6c1\",lightsalmon:\"ffa07a\",lightseagreen:\"20b2aa\",lightskyblue:\"87cefa\",lightslategray:\"789\",lightslategrey:\"789\",lightsteelblue:\"b0c4de\",lightyellow:\"ffffe0\",lime:\"0f0\",limegreen:\"32cd32\",linen:\"faf0e6\",magenta:\"f0f\",maroon:\"800000\",mediumaquamarine:\"66cdaa\",mediumblue:\"0000cd\",mediumorchid:\"ba55d3\",mediumpurple:\"9370db\",mediumseagreen:\"3cb371\",mediumslateblue:\"7b68ee\",mediumspringgreen:\"00fa9a\",mediumturquoise:\"48d1cc\",mediumvioletred:\"c71585\",midnightblue:\"191970\",mintcream:\"f5fffa\",mistyrose:\"ffe4e1\",moccasin:\"ffe4b5\",navajowhite:\"ffdead\",navy:\"000080\",oldlace:\"fdf5e6\",olive:\"808000\",olivedrab:\"6b8e23\",orange:\"ffa500\",orangered:\"ff4500\",orchid:\"da70d6\",palegoldenrod:\"eee8aa\",palegreen:\"98fb98\",paleturquoise:\"afeeee\",palevioletred:\"db7093\",papayawhip:\"ffefd5\",peachpuff:\"ffdab9\",peru:\"cd853f\",pink:\"ffc0cb\",plum:\"dda0dd\",powderblue:\"b0e0e6\",purple:\"800080\",rebeccapurple:\"663399\",red:\"f00\",rosybrown:\"bc8f8f\",royalblue:\"4169e1\",saddlebrown:\"8b4513\",salmon:\"fa8072\",sandybrown:\"f4a460\",seagreen:\"2e8b57\",seashell:\"fff5ee\",sienna:\"a0522d\",silver:\"c0c0c0\",skyblue:\"87ceeb\",slateblue:\"6a5acd\",slategray:\"708090\",slategrey:\"708090\",snow:\"fffafa\",springgreen:\"00ff7f\",steelblue:\"4682b4\",tan:\"d2b48c\",teal:\"008080\",thistle:\"d8bfd8\",tomato:\"ff6347\",turquoise:\"40e0d0\",violet:\"ee82ee\",wheat:\"f5deb3\",white:\"fff\",whitesmoke:\"f5f5f5\",yellow:\"ff0\",yellowgreen:\"9acd32\"};// Make it easy to access colors via `hexNames[hex]`\nvar hexNames=tinycolor.hexNames=flip(names);// Utilities\n// ---------\n// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`\nfunction flip(o){var flipped={};for(var i in o){if(o.hasOwnProperty(i)){flipped[o[i]]=i;}}return flipped;}// Return a valid alpha value [0,1] with all invalid values being set to 1\nfunction boundAlpha(a){a=parseFloat(a);if(isNaN(a)||a<0||a>1){a=1;}return a;}// Take input from [0, n] and return it as [0, 1]\nfunction bound01(n,max){if(isOnePointZero(n)){n=\"100%\";}var processPercent=isPercentage(n);n=mathMin(max,mathMax(0,parseFloat(n)));// Automatically convert percentage into number\nif(processPercent){n=parseInt(n*max,10)/100;}// Handle floating point rounding errors\nif(Math.abs(n-max)<0.000001){return 1;}// Convert into [0, 1] range if it isn't already\nreturn n%max/parseFloat(max);}// Force a number between 0 and 1\nfunction clamp01(val){return mathMin(1,mathMax(0,val));}// Parse a base-16 hex value into a base-10 integer\nfunction parseIntFromHex(val){return parseInt(val,16);}// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1\n// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>\nfunction isOnePointZero(n){return typeof n==\"string\"&&n.indexOf('.')!=-1&&parseFloat(n)===1;}// Check to see if string passed in is a percentage\nfunction isPercentage(n){return typeof n===\"string\"&&n.indexOf('%')!=-1;}// Force a hex value to have 2 characters\nfunction pad2(c){return c.length==1?'0'+c:''+c;}// Replace a decimal with it's percentage value\nfunction convertToPercentage(n){if(n<=1){n=n*100+\"%\";}return n;}// Converts a decimal to a hex value\nfunction convertDecimalToHex(d){return Math.round(parseFloat(d)*255).toString(16);}// Converts a hex value to a decimal\nfunction convertHexToDecimal(h){return parseIntFromHex(h)/255;}var matchers=function(){// <http://www.w3.org/TR/css3-values/#integers>\nvar CSS_INTEGER=\"[-\\\\+]?\\\\d+%?\";// <http://www.w3.org/TR/css3-values/#number-value>\nvar CSS_NUMBER=\"[-\\\\+]?\\\\d*\\\\.\\\\d+%?\";// Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.\nvar CSS_UNIT=\"(?:\"+CSS_NUMBER+\")|(?:\"+CSS_INTEGER+\")\";// Actual matching.\n// Parentheses and commas are optional, but not required.\n// Whitespace can take the place of commas or opening paren\nvar PERMISSIVE_MATCH3=\"[\\\\s|\\\\(]+(\"+CSS_UNIT+\")[,|\\\\s]+(\"+CSS_UNIT+\")[,|\\\\s]+(\"+CSS_UNIT+\")\\\\s*\\\\)?\";var PERMISSIVE_MATCH4=\"[\\\\s|\\\\(]+(\"+CSS_UNIT+\")[,|\\\\s]+(\"+CSS_UNIT+\")[,|\\\\s]+(\"+CSS_UNIT+\")[,|\\\\s]+(\"+CSS_UNIT+\")\\\\s*\\\\)?\";return{CSS_UNIT:new RegExp(CSS_UNIT),rgb:new RegExp(\"rgb\"+PERMISSIVE_MATCH3),rgba:new RegExp(\"rgba\"+PERMISSIVE_MATCH4),hsl:new RegExp(\"hsl\"+PERMISSIVE_MATCH3),hsla:new RegExp(\"hsla\"+PERMISSIVE_MATCH4),hsv:new RegExp(\"hsv\"+PERMISSIVE_MATCH3),hsva:new RegExp(\"hsva\"+PERMISSIVE_MATCH4),hex3:/^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,hex6:/^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,hex4:/^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,hex8:/^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/};}();// `isValidCSSUnit`\n// Take in a single string / number and check to see if it looks like a CSS unit\n// (see `matchers` above for definition).\nfunction isValidCSSUnit(color){return!!matchers.CSS_UNIT.exec(color);}// `stringInputToObject`\n// Permissive string parsing.  Take in a number of formats, and output an object\n// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`\nfunction stringInputToObject(color){color=color.replace(trimLeft,'').replace(trimRight,'').toLowerCase();var named=false;if(names[color]){color=names[color];named=true;}else if(color=='transparent'){return{r:0,g:0,b:0,a:0,format:\"name\"};}// Try to match string input using regular expressions.\n// Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]\n// Just return an object and let the conversion functions handle that.\n// This way the result will be the same whether the tinycolor is initialized with string or object.\nvar match;if(match=matchers.rgb.exec(color)){return{r:match[1],g:match[2],b:match[3]};}if(match=matchers.rgba.exec(color)){return{r:match[1],g:match[2],b:match[3],a:match[4]};}if(match=matchers.hsl.exec(color)){return{h:match[1],s:match[2],l:match[3]};}if(match=matchers.hsla.exec(color)){return{h:match[1],s:match[2],l:match[3],a:match[4]};}if(match=matchers.hsv.exec(color)){return{h:match[1],s:match[2],v:match[3]};}if(match=matchers.hsva.exec(color)){return{h:match[1],s:match[2],v:match[3],a:match[4]};}if(match=matchers.hex8.exec(color)){return{r:parseIntFromHex(match[1]),g:parseIntFromHex(match[2]),b:parseIntFromHex(match[3]),a:convertHexToDecimal(match[4]),format:named?\"name\":\"hex8\"};}if(match=matchers.hex6.exec(color)){return{r:parseIntFromHex(match[1]),g:parseIntFromHex(match[2]),b:parseIntFromHex(match[3]),format:named?\"name\":\"hex\"};}if(match=matchers.hex4.exec(color)){return{r:parseIntFromHex(match[1]+''+match[1]),g:parseIntFromHex(match[2]+''+match[2]),b:parseIntFromHex(match[3]+''+match[3]),a:convertHexToDecimal(match[4]+''+match[4]),format:named?\"name\":\"hex8\"};}if(match=matchers.hex3.exec(color)){return{r:parseIntFromHex(match[1]+''+match[1]),g:parseIntFromHex(match[2]+''+match[2]),b:parseIntFromHex(match[3]+''+match[3]),format:named?\"name\":\"hex\"};}return false;}function validateWCAG2Parms(parms){// return valid WCAG2 parms for isReadable.\n// If input parms are invalid, return {\"level\":\"AA\", \"size\":\"small\"}\nvar level,size;parms=parms||{\"level\":\"AA\",\"size\":\"small\"};level=(parms.level||\"AA\").toUpperCase();size=(parms.size||\"small\").toLowerCase();if(level!==\"AA\"&&level!==\"AAA\"){level=\"AA\";}if(size!==\"small\"&&size!==\"large\"){size=\"small\";}return{\"level\":level,\"size\":size};}// Node: Export function\nif(typeof module!==\"undefined\"&&module.exports){module.exports=tinycolor;}// AMD/requirejs: Define the module\nelse if(typeof define==='function'&&define.amd){define(function(){return tinycolor;});}// Browser: Expose to window\nelse{window.tinycolor=tinycolor;}})(Math);},{}],27:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';/**\n * All paths are tuned for maximum scalability of the arrowhead,\n * ie throughout arrowwidth=0.3..3 the head is joined smoothly\n * to the line, with the line coming from the left and ending at (0, 0).\n *\n * `backoff` is the distance to move the arrowhead and the end of the line,\n * in order that the arrowhead points to the desired place, either at\n * the tip of the arrow or (in the case of circle or square)\n * the center of the symbol.\n *\n * `noRotate`, if truthy, says that this arrowhead should not rotate with the\n * arrow. That's the case for squares, which should always be straight, and\n * circles, for which it's irrelevant.\n */module.exports=[// no arrow\n{path:'',backoff:0},// wide with flat back\n{path:'M-2.4,-3V3L0.6,0Z',backoff:0.6},// narrower with flat back\n{path:'M-3.7,-2.5V2.5L1.3,0Z',backoff:1.3},// barbed\n{path:'M-4.45,-3L-1.65,-0.2V0.2L-4.45,3L1.55,0Z',backoff:1.55},// wide line-drawn\n{path:'M-2.2,-2.2L-0.2,-0.2V0.2L-2.2,2.2L-1.4,3L1.6,0L-1.4,-3Z',backoff:1.6},// narrower line-drawn\n{path:'M-4.4,-2.1L-0.6,-0.2V0.2L-4.4,2.1L-4,3L2,0L-4,-3Z',backoff:2},// circle\n{path:'M2,0A2,2 0 1,1 0,-2A2,2 0 0,1 2,0Z',backoff:0,noRotate:true},// square\n{path:'M2,2V-2H-2V2Z',backoff:0,noRotate:true}];},{}],28:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var ARROWPATHS=_dereq_('./arrow_paths');var fontAttrs=_dereq_('../../plots/font_attributes');var cartesianConstants=_dereq_('../../plots/cartesian/constants');var templatedArray=_dereq_('../../plot_api/plot_template').templatedArray;module.exports=templatedArray('annotation',{visible:{valType:'boolean',dflt:true,editType:'calc+arraydraw'},text:{valType:'string',editType:'calc+arraydraw'},textangle:{valType:'angle',dflt:0,editType:'calc+arraydraw'},font:fontAttrs({editType:'calc+arraydraw',colorEditType:'arraydraw'}),width:{valType:'number',min:1,dflt:null,editType:'calc+arraydraw'},height:{valType:'number',min:1,dflt:null,editType:'calc+arraydraw'},opacity:{valType:'number',min:0,max:1,dflt:1,editType:'arraydraw'},align:{valType:'enumerated',values:['left','center','right'],dflt:'center',editType:'arraydraw'},valign:{valType:'enumerated',values:['top','middle','bottom'],dflt:'middle',editType:'arraydraw'},bgcolor:{valType:'color',dflt:'rgba(0,0,0,0)',editType:'arraydraw'},bordercolor:{valType:'color',dflt:'rgba(0,0,0,0)',editType:'arraydraw'},borderpad:{valType:'number',min:0,dflt:1,editType:'calc+arraydraw'},borderwidth:{valType:'number',min:0,dflt:1,editType:'calc+arraydraw'},// arrow\nshowarrow:{valType:'boolean',dflt:true,editType:'calc+arraydraw'},arrowcolor:{valType:'color',editType:'arraydraw'},arrowhead:{valType:'integer',min:0,max:ARROWPATHS.length,dflt:1,editType:'arraydraw'},startarrowhead:{valType:'integer',min:0,max:ARROWPATHS.length,dflt:1,editType:'arraydraw'},arrowside:{valType:'flaglist',flags:['end','start'],extras:['none'],dflt:'end',editType:'arraydraw'},arrowsize:{valType:'number',min:0.3,dflt:1,editType:'calc+arraydraw'},startarrowsize:{valType:'number',min:0.3,dflt:1,editType:'calc+arraydraw'},arrowwidth:{valType:'number',min:0.1,editType:'calc+arraydraw'},standoff:{valType:'number',min:0,dflt:0,editType:'calc+arraydraw'},startstandoff:{valType:'number',min:0,dflt:0,editType:'calc+arraydraw'},ax:{valType:'any',editType:'calc+arraydraw'},ay:{valType:'any',editType:'calc+arraydraw'},axref:{valType:'enumerated',dflt:'pixel',values:['pixel',cartesianConstants.idRegex.x.toString()],editType:'calc'},ayref:{valType:'enumerated',dflt:'pixel',values:['pixel',cartesianConstants.idRegex.y.toString()],editType:'calc'},// positioning\nxref:{valType:'enumerated',values:['paper',cartesianConstants.idRegex.x.toString()],editType:'calc'},x:{valType:'any',editType:'calc+arraydraw'},xanchor:{valType:'enumerated',values:['auto','left','center','right'],dflt:'auto',editType:'calc+arraydraw'},xshift:{valType:'number',dflt:0,editType:'calc+arraydraw'},yref:{valType:'enumerated',values:['paper',cartesianConstants.idRegex.y.toString()],editType:'calc'},y:{valType:'any',editType:'calc+arraydraw'},yanchor:{valType:'enumerated',values:['auto','top','middle','bottom'],dflt:'auto',editType:'calc+arraydraw'},yshift:{valType:'number',dflt:0,editType:'calc+arraydraw'},clicktoshow:{valType:'enumerated',values:[false,'onoff','onout'],dflt:false,editType:'arraydraw'},xclick:{valType:'any',editType:'arraydraw'},yclick:{valType:'any',editType:'arraydraw'},hovertext:{valType:'string',editType:'arraydraw'},hoverlabel:{bgcolor:{valType:'color',editType:'arraydraw'},bordercolor:{valType:'color',editType:'arraydraw'},font:fontAttrs({editType:'arraydraw'}),editType:'arraydraw'},captureevents:{valType:'boolean',editType:'arraydraw'},editType:'calc',_deprecated:{ref:{valType:'string',editType:'calc'}}});},{\"../../plot_api/plot_template\":193,\"../../plots/cartesian/constants\":209,\"../../plots/font_attributes\":229,\"./arrow_paths\":27}],29:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var Axes=_dereq_('../../plots/cartesian/axes');var draw=_dereq_('./draw').draw;module.exports=function calcAutorange(gd){var fullLayout=gd._fullLayout;var annotationList=Lib.filterVisible(fullLayout.annotations);if(annotationList.length&&gd._fullData.length){return Lib.syncOrAsync([draw,annAutorange],gd);}};function annAutorange(gd){var fullLayout=gd._fullLayout;// find the bounding boxes for each of these annotations'\n// relative to their anchor points\n// use the arrow and the text bg rectangle,\n// as the whole anno may include hidden text in its bbox\nLib.filterVisible(fullLayout.annotations).forEach(function(ann){var xa=Axes.getFromId(gd,ann.xref);var ya=Axes.getFromId(gd,ann.yref);ann._extremes={};if(xa)calcAxisExpansion(ann,xa);if(ya)calcAxisExpansion(ann,ya);});}function calcAxisExpansion(ann,ax){var axId=ax._id;var letter=axId.charAt(0);var pos=ann[letter];var apos=ann['a'+letter];var ref=ann[letter+'ref'];var aref=ann['a'+letter+'ref'];var padplus=ann['_'+letter+'padplus'];var padminus=ann['_'+letter+'padminus'];var shift={x:1,y:-1}[letter]*ann[letter+'shift'];var headSize=3*ann.arrowsize*ann.arrowwidth||0;var headPlus=headSize+shift;var headMinus=headSize-shift;var startHeadSize=3*ann.startarrowsize*ann.arrowwidth||0;var startHeadPlus=startHeadSize+shift;var startHeadMinus=startHeadSize-shift;var extremes;if(aref===ref){// expand for the arrowhead (padded by arrowhead)\nvar extremeArrowHead=Axes.findExtremes(ax,[ax.r2c(pos)],{ppadplus:headPlus,ppadminus:headMinus});// again for the textbox (padded by textbox)\nvar extremeText=Axes.findExtremes(ax,[ax.r2c(apos)],{ppadplus:Math.max(padplus,startHeadPlus),ppadminus:Math.max(padminus,startHeadMinus)});extremes={min:[extremeArrowHead.min[0],extremeText.min[0]],max:[extremeArrowHead.max[0],extremeText.max[0]]};}else{startHeadPlus=apos?startHeadPlus+apos:startHeadPlus;startHeadMinus=apos?startHeadMinus-apos:startHeadMinus;extremes=Axes.findExtremes(ax,[ax.r2c(pos)],{ppadplus:Math.max(padplus,headPlus,startHeadPlus),ppadminus:Math.max(padminus,headMinus,startHeadMinus)});}ann._extremes[axId]=extremes;}},{\"../../lib\":159,\"../../plots/cartesian/axes\":203,\"./draw\":34}],30:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var Registry=_dereq_('../../registry');var arrayEditor=_dereq_('../../plot_api/plot_template').arrayEditor;module.exports={hasClickToShow:hasClickToShow,onClick:onClick};/*\n * hasClickToShow: does the given hoverData have ANY annotations which will\n * turn ON if we click here? (used by hover events to set cursor)\n *\n * gd: graphDiv\n * hoverData: a hoverData array, as included with the *plotly_hover* or\n *     *plotly_click* events in the `points` attribute\n *\n * returns: boolean\n */function hasClickToShow(gd,hoverData){var sets=getToggleSets(gd,hoverData);return sets.on.length>0||sets.explicitOff.length>0;}/*\n * onClick: perform the toggling (via Plotly.update) implied by clicking\n * at this hoverData\n *\n * gd: graphDiv\n * hoverData: a hoverData array, as included with the *plotly_hover* or\n *     *plotly_click* events in the `points` attribute\n *\n * returns: Promise that the update is complete\n */function onClick(gd,hoverData){var toggleSets=getToggleSets(gd,hoverData);var onSet=toggleSets.on;var offSet=toggleSets.off.concat(toggleSets.explicitOff);var update={};var annotationsOut=gd._fullLayout.annotations;var i,editHelpers;if(!(onSet.length||offSet.length))return;for(i=0;i<onSet.length;i++){editHelpers=arrayEditor(gd.layout,'annotations',annotationsOut[onSet[i]]);editHelpers.modifyItem('visible',true);Lib.extendFlat(update,editHelpers.getUpdateObj());}for(i=0;i<offSet.length;i++){editHelpers=arrayEditor(gd.layout,'annotations',annotationsOut[offSet[i]]);editHelpers.modifyItem('visible',false);Lib.extendFlat(update,editHelpers.getUpdateObj());}return Registry.call('update',gd,{},update);}/*\n * getToggleSets: find the annotations which will turn on or off at this\n * hoverData\n *\n * gd: graphDiv\n * hoverData: a hoverData array, as included with the *plotly_hover* or\n *     *plotly_click* events in the `points` attribute\n *\n * returns: {\n *   on: Array (indices of annotations to turn on),\n *   off: Array (indices to turn off because you're not hovering on them),\n *   explicitOff: Array (indices to turn off because you *are* hovering on them)\n * }\n */function getToggleSets(gd,hoverData){var annotations=gd._fullLayout.annotations;var onSet=[];var offSet=[];var explicitOffSet=[];var hoverLen=(hoverData||[]).length;var i,j,anni,showMode,pointj,xa,ya,toggleType;for(i=0;i<annotations.length;i++){anni=annotations[i];showMode=anni.clicktoshow;if(showMode){for(j=0;j<hoverLen;j++){pointj=hoverData[j];xa=pointj.xaxis;ya=pointj.yaxis;if(xa._id===anni.xref&&ya._id===anni.yref&&xa.d2r(pointj.x)===clickData2r(anni._xclick,xa)&&ya.d2r(pointj.y)===clickData2r(anni._yclick,ya)){// match! toggle this annotation\n// regardless of its clicktoshow mode\n// but if it's onout mode, off is implicit\nif(anni.visible){if(showMode==='onout')toggleType=offSet;else toggleType=explicitOffSet;}else{toggleType=onSet;}toggleType.push(i);break;}}if(j===hoverLen){// no match - only turn this annotation OFF, and only if\n// showmode is 'onout'\nif(anni.visible&&showMode==='onout')offSet.push(i);}}}return{on:onSet,off:offSet,explicitOff:explicitOffSet};}// to handle log axes until v2\nfunction clickData2r(d,ax){return ax.type==='log'?ax.l2r(d):ax.d2r(d);}},{\"../../lib\":159,\"../../plot_api/plot_template\":193,\"../../registry\":242}],31:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var Color=_dereq_('../color');// defaults common to 'annotations' and 'annotations3d'\nmodule.exports=function handleAnnotationCommonDefaults(annIn,annOut,fullLayout,coerce){coerce('opacity');var bgColor=coerce('bgcolor');var borderColor=coerce('bordercolor');var borderOpacity=Color.opacity(borderColor);coerce('borderpad');var borderWidth=coerce('borderwidth');var showArrow=coerce('showarrow');coerce('text',showArrow?' ':fullLayout._dfltTitle.annotation);coerce('textangle');Lib.coerceFont(coerce,'font',fullLayout.font);coerce('width');coerce('align');var h=coerce('height');if(h)coerce('valign');if(showArrow){var arrowside=coerce('arrowside');var arrowhead;var arrowsize;if(arrowside.indexOf('end')!==-1){arrowhead=coerce('arrowhead');arrowsize=coerce('arrowsize');}if(arrowside.indexOf('start')!==-1){coerce('startarrowhead',arrowhead);coerce('startarrowsize',arrowsize);}coerce('arrowcolor',borderOpacity?annOut.bordercolor:Color.defaultLine);coerce('arrowwidth',(borderOpacity&&borderWidth||1)*2);coerce('standoff');coerce('startstandoff');}var hoverText=coerce('hovertext');var globalHoverLabel=fullLayout.hoverlabel||{};if(hoverText){var hoverBG=coerce('hoverlabel.bgcolor',globalHoverLabel.bgcolor||(Color.opacity(bgColor)?Color.rgb(bgColor):Color.defaultLine));var hoverBorder=coerce('hoverlabel.bordercolor',globalHoverLabel.bordercolor||Color.contrast(hoverBG));Lib.coerceFont(coerce,'hoverlabel.font',{family:globalHoverLabel.font.family,size:globalHoverLabel.font.size,color:globalHoverLabel.font.color||hoverBorder});}coerce('captureevents',!!hoverText);};},{\"../../lib\":159,\"../color\":43}],32:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var isNumeric=_dereq_('fast-isnumeric');var toLogRange=_dereq_('../../lib/to_log_range');/*\n * convertCoords: when converting an axis between log and linear\n * you need to alter any annotations on that axis to keep them\n * pointing at the same data point.\n * In v2.0 this will become obsolete\n *\n * gd: the plot div\n * ax: the axis being changed\n * newType: the type it's getting\n * doExtra: function(attr, val) from inside relayout that sets the attribute.\n *     Use this to make the changes as it's aware if any other changes in the\n *     same relayout call should override this conversion.\n */module.exports=function convertCoords(gd,ax,newType,doExtra){ax=ax||{};var toLog=newType==='log'&&ax.type==='linear';var fromLog=newType==='linear'&&ax.type==='log';if(!(toLog||fromLog))return;var annotations=gd._fullLayout.annotations;var axLetter=ax._id.charAt(0);var ann;var attrPrefix;function convert(attr){var currentVal=ann[attr];var newVal=null;if(toLog)newVal=toLogRange(currentVal,ax.range);else newVal=Math.pow(10,currentVal);// if conversion failed, delete the value so it gets a default value\nif(!isNumeric(newVal))newVal=null;doExtra(attrPrefix+attr,newVal);}for(var i=0;i<annotations.length;i++){ann=annotations[i];attrPrefix='annotations['+i+'].';if(ann[axLetter+'ref']===ax._id)convert(axLetter);if(ann['a'+axLetter+'ref']===ax._id)convert('a'+axLetter);}};},{\"../../lib/to_log_range\":182,\"fast-isnumeric\":10}],33:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var Axes=_dereq_('../../plots/cartesian/axes');var handleArrayContainerDefaults=_dereq_('../../plots/array_container_defaults');var handleAnnotationCommonDefaults=_dereq_('./common_defaults');var attributes=_dereq_('./attributes');module.exports=function supplyLayoutDefaults(layoutIn,layoutOut){handleArrayContainerDefaults(layoutIn,layoutOut,{name:'annotations',handleItemDefaults:handleAnnotationDefaults});};function handleAnnotationDefaults(annIn,annOut,fullLayout){function coerce(attr,dflt){return Lib.coerce(annIn,annOut,attributes,attr,dflt);}var visible=coerce('visible');var clickToShow=coerce('clicktoshow');if(!(visible||clickToShow))return;handleAnnotationCommonDefaults(annIn,annOut,fullLayout,coerce);var showArrow=annOut.showarrow;// positioning\nvar axLetters=['x','y'];var arrowPosDflt=[-10,-30];var gdMock={_fullLayout:fullLayout};for(var i=0;i<2;i++){var axLetter=axLetters[i];// xref, yref\nvar axRef=Axes.coerceRef(annIn,annOut,gdMock,axLetter,'','paper');if(axRef!=='paper'){var ax=Axes.getFromId(gdMock,axRef);ax._annIndices.push(annOut._index);}// x, y\nAxes.coercePosition(annOut,gdMock,coerce,axRef,axLetter,0.5);if(showArrow){var arrowPosAttr='a'+axLetter;// axref, ayref\nvar aaxRef=Axes.coerceRef(annIn,annOut,gdMock,arrowPosAttr,'pixel');// for now the arrow can only be on the same axis or specified as pixels\n// TODO: sometime it might be interesting to allow it to be on *any* axis\n// but that would require updates to drawing & autorange code and maybe more\nif(aaxRef!=='pixel'&&aaxRef!==axRef){aaxRef=annOut[arrowPosAttr]='pixel';}// ax, ay\nvar aDflt=aaxRef==='pixel'?arrowPosDflt[i]:0.4;Axes.coercePosition(annOut,gdMock,coerce,aaxRef,arrowPosAttr,aDflt);}// xanchor, yanchor\ncoerce(axLetter+'anchor');// xshift, yshift\ncoerce(axLetter+'shift');}// if you have one coordinate you should have both\nLib.noneOrAll(annIn,annOut,['x','y']);// if you have one part of arrow length you should have both\nif(showArrow){Lib.noneOrAll(annIn,annOut,['ax','ay']);}if(clickToShow){var xClick=coerce('xclick');var yClick=coerce('yclick');// put the actual click data to bind to into private attributes\n// so we don't have to do this little bit of logic on every hover event\nannOut._xclick=xClick===undefined?annOut.x:Axes.cleanPosition(xClick,gdMock,annOut.xref);annOut._yclick=yClick===undefined?annOut.y:Axes.cleanPosition(yClick,gdMock,annOut.yref);}}},{\"../../lib\":159,\"../../plots/array_container_defaults\":199,\"../../plots/cartesian/axes\":203,\"./attributes\":28,\"./common_defaults\":31}],34:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var Registry=_dereq_('../../registry');var Plots=_dereq_('../../plots/plots');var Lib=_dereq_('../../lib');var Axes=_dereq_('../../plots/cartesian/axes');var Color=_dereq_('../color');var Drawing=_dereq_('../drawing');var Fx=_dereq_('../fx');var svgTextUtils=_dereq_('../../lib/svg_text_utils');var setCursor=_dereq_('../../lib/setcursor');var dragElement=_dereq_('../dragelement');var arrayEditor=_dereq_('../../plot_api/plot_template').arrayEditor;var drawArrowHead=_dereq_('./draw_arrow_head');// Annotations are stored in gd.layout.annotations, an array of objects\n// index can point to one item in this array,\n//  or non-numeric to simply add a new one\n//  or -1 to modify all existing\n// opt can be the full options object, or one key (to be set to value)\n//  or undefined to simply redraw\n// if opt is blank, val can be 'add' or a full options object to add a new\n//  annotation at that point in the array, or 'remove' to delete this one\nmodule.exports={draw:draw,drawOne:drawOne,drawRaw:drawRaw};/*\n * draw: draw all annotations without any new modifications\n */function draw(gd){var fullLayout=gd._fullLayout;fullLayout._infolayer.selectAll('.annotation').remove();for(var i=0;i<fullLayout.annotations.length;i++){if(fullLayout.annotations[i].visible){drawOne(gd,i);}}return Plots.previousPromises(gd);}/*\n * drawOne: draw a single cartesian or paper-ref annotation, potentially with modifications\n *\n * index (int): the annotation to draw\n */function drawOne(gd,index){var fullLayout=gd._fullLayout;var options=fullLayout.annotations[index]||{};var xa=Axes.getFromId(gd,options.xref);var ya=Axes.getFromId(gd,options.yref);if(xa)xa.setScale();if(ya)ya.setScale();drawRaw(gd,options,index,false,xa,ya);}/**\n * drawRaw: draw a single annotation, potentially with modifications\n *\n * @param {DOM element} gd\n * @param {object} options : this annotation's fullLayout options\n * @param {integer} index : index in 'annotations' container of the annotation to draw\n * @param {string} subplotId : id of the annotation's subplot\n *  - use false for 2d (i.e. cartesian or paper-ref) annotations\n * @param {object | undefined} xa : full x-axis object to compute subplot pos-to-px\n * @param {object | undefined} ya : ... y-axis\n */function drawRaw(gd,options,index,subplotId,xa,ya){var fullLayout=gd._fullLayout;var gs=gd._fullLayout._size;var edits=gd._context.edits;var className,containerStr;if(subplotId){className='annotation-'+subplotId;containerStr=subplotId+'.annotations';}else{className='annotation';containerStr='annotations';}var editHelpers=arrayEditor(gd.layout,containerStr,options);var modifyBase=editHelpers.modifyBase;var modifyItem=editHelpers.modifyItem;var getUpdateObj=editHelpers.getUpdateObj;// remove the existing annotation if there is one\nfullLayout._infolayer.selectAll('.'+className+'[data-index=\"'+index+'\"]').remove();var annClipID='clip'+fullLayout._uid+'_ann'+index;// this annotation is gone - quit now after deleting it\n// TODO: use d3 idioms instead of deleting and redrawing every time\nif(!options._input||options.visible===false){d3.selectAll('#'+annClipID).remove();return;}// calculated pixel positions\n// x & y each will get text, head, and tail as appropriate\nvar annPosPx={x:{},y:{}};var textangle=+options.textangle||0;// create the components\n// made a single group to contain all, so opacity can work right\n// with border/arrow together this could handle a whole bunch of\n// cleanup at this point, but works for now\nvar annGroup=fullLayout._infolayer.append('g').classed(className,true).attr('data-index',String(index)).style('opacity',options.opacity);// another group for text+background so that they can rotate together\nvar annTextGroup=annGroup.append('g').classed('annotation-text-g',true);var editTextPosition=edits[options.showarrow?'annotationTail':'annotationPosition'];var textEvents=options.captureevents||edits.annotationText||editTextPosition;var annTextGroupInner=annTextGroup.append('g').style('pointer-events',textEvents?'all':null).call(setCursor,'pointer').on('click',function(){gd._dragging=false;var eventData={index:index,annotation:options._input,fullAnnotation:options,event:d3.event};if(subplotId){eventData.subplotId=subplotId;}gd.emit('plotly_clickannotation',eventData);});if(options.hovertext){annTextGroupInner.on('mouseover',function(){var hoverOptions=options.hoverlabel;var hoverFont=hoverOptions.font;var bBox=this.getBoundingClientRect();var bBoxRef=gd.getBoundingClientRect();Fx.loneHover({x0:bBox.left-bBoxRef.left,x1:bBox.right-bBoxRef.left,y:(bBox.top+bBox.bottom)/2-bBoxRef.top,text:options.hovertext,color:hoverOptions.bgcolor,borderColor:hoverOptions.bordercolor,fontFamily:hoverFont.family,fontSize:hoverFont.size,fontColor:hoverFont.color},{container:fullLayout._hoverlayer.node(),outerContainer:fullLayout._paper.node(),gd:gd});}).on('mouseout',function(){Fx.loneUnhover(fullLayout._hoverlayer.node());});}var borderwidth=options.borderwidth;var borderpad=options.borderpad;var borderfull=borderwidth+borderpad;var annTextBG=annTextGroupInner.append('rect').attr('class','bg').style('stroke-width',borderwidth+'px').call(Color.stroke,options.bordercolor).call(Color.fill,options.bgcolor);var isSizeConstrained=options.width||options.height;var annTextClip=fullLayout._topclips.selectAll('#'+annClipID).data(isSizeConstrained?[0]:[]);annTextClip.enter().append('clipPath').classed('annclip',true).attr('id',annClipID).append('rect');annTextClip.exit().remove();var font=options.font;var text=fullLayout.meta?Lib.templateString(options.text,{meta:fullLayout.meta}):options.text;var annText=annTextGroupInner.append('text').classed('annotation-text',true).text(text);function textLayout(s){s.call(Drawing.font,font).attr({'text-anchor':{left:'start',right:'end'}[options.align]||'middle'});svgTextUtils.convertToTspans(s,gd,drawGraphicalElements);return s;}function drawGraphicalElements(){// if the text has *only* a link, make the whole box into a link\nvar anchor3=annText.selectAll('a');if(anchor3.size()===1&&anchor3.text()===annText.text()){var wholeLink=annTextGroupInner.insert('a',':first-child').attr({'xlink:xlink:href':anchor3.attr('xlink:href'),'xlink:xlink:show':anchor3.attr('xlink:show')}).style({cursor:'pointer'});wholeLink.node().appendChild(annTextBG.node());}var mathjaxGroup=annTextGroupInner.select('.annotation-text-math-group');var hasMathjax=!mathjaxGroup.empty();var anntextBB=Drawing.bBox((hasMathjax?mathjaxGroup:annText).node());var textWidth=anntextBB.width;var textHeight=anntextBB.height;var annWidth=options.width||textWidth;var annHeight=options.height||textHeight;var outerWidth=Math.round(annWidth+2*borderfull);var outerHeight=Math.round(annHeight+2*borderfull);function shiftFraction(v,anchor){if(anchor==='auto'){if(v<1/3)anchor='left';else if(v>2/3)anchor='right';else anchor='center';}return{center:0,middle:0,left:0.5,bottom:-0.5,right:-0.5,top:0.5}[anchor];}var annotationIsOffscreen=false;var letters=['x','y'];for(var i=0;i<letters.length;i++){var axLetter=letters[i];var axRef=options[axLetter+'ref']||axLetter;var tailRef=options['a'+axLetter+'ref'];var ax={x:xa,y:ya}[axLetter];var dimAngle=(textangle+(axLetter==='x'?0:-90))*Math.PI/180;// note that these two can be either positive or negative\nvar annSizeFromWidth=outerWidth*Math.cos(dimAngle);var annSizeFromHeight=outerHeight*Math.sin(dimAngle);// but this one is the positive total size\nvar annSize=Math.abs(annSizeFromWidth)+Math.abs(annSizeFromHeight);var anchor=options[axLetter+'anchor'];var overallShift=options[axLetter+'shift']*(axLetter==='x'?1:-1);var posPx=annPosPx[axLetter];var basePx;var textPadShift;var alignPosition;var autoAlignFraction;var textShift;/*\n             * calculate the *primary* pixel position\n             * which is the arrowhead if there is one,\n             * otherwise the text anchor point\n             */if(ax){// check if annotation is off screen, to bypass DOM manipulations\nvar posFraction=ax.r2fraction(options[axLetter]);if(posFraction<0||posFraction>1){if(tailRef===axRef){posFraction=ax.r2fraction(options['a'+axLetter]);if(posFraction<0||posFraction>1){annotationIsOffscreen=true;}}else{annotationIsOffscreen=true;}}basePx=ax._offset+ax.r2p(options[axLetter]);autoAlignFraction=0.5;}else{if(axLetter==='x'){alignPosition=options[axLetter];basePx=gs.l+gs.w*alignPosition;}else{alignPosition=1-options[axLetter];basePx=gs.t+gs.h*alignPosition;}autoAlignFraction=options.showarrow?0.5:alignPosition;}// now translate this into pixel positions of head, tail, and text\n// as well as paddings for autorange\nif(options.showarrow){posPx.head=basePx;var arrowLength=options['a'+axLetter];// with an arrow, the text rotates around the anchor point\ntextShift=annSizeFromWidth*shiftFraction(0.5,options.xanchor)-annSizeFromHeight*shiftFraction(0.5,options.yanchor);if(tailRef===axRef){posPx.tail=ax._offset+ax.r2p(arrowLength);// tail is data-referenced: autorange pads the text in px from the tail\ntextPadShift=textShift;}else{posPx.tail=basePx+arrowLength;// tail is specified in px from head, so autorange also pads vs head\ntextPadShift=textShift+arrowLength;}posPx.text=posPx.tail+textShift;// constrain pixel/paper referenced so the draggers are at least\n// partially visible\nvar maxPx=fullLayout[axLetter==='x'?'width':'height'];if(axRef==='paper'){posPx.head=Lib.constrain(posPx.head,1,maxPx-1);}if(tailRef==='pixel'){var shiftPlus=-Math.max(posPx.tail-3,posPx.text);var shiftMinus=Math.min(posPx.tail+3,posPx.text)-maxPx;if(shiftPlus>0){posPx.tail+=shiftPlus;posPx.text+=shiftPlus;}else if(shiftMinus>0){posPx.tail-=shiftMinus;posPx.text-=shiftMinus;}}posPx.tail+=overallShift;posPx.head+=overallShift;}else{// with no arrow, the text rotates and *then* we put the anchor\n// relative to the new bounding box\ntextShift=annSize*shiftFraction(autoAlignFraction,anchor);textPadShift=textShift;posPx.text=basePx+textShift;}posPx.text+=overallShift;textShift+=overallShift;textPadShift+=overallShift;// padplus/minus are used by autorange\noptions['_'+axLetter+'padplus']=annSize/2+textPadShift;options['_'+axLetter+'padminus']=annSize/2-textPadShift;// size/shift are used during dragging\noptions['_'+axLetter+'size']=annSize;options['_'+axLetter+'shift']=textShift;}// We have everything we need for calcAutorange at this point,\n// we can safely exit - unless we're currently dragging the plot\nif(!gd._dragging&&annotationIsOffscreen){annTextGroupInner.remove();return;}var xShift=0;var yShift=0;if(options.align!=='left'){xShift=(annWidth-textWidth)*(options.align==='center'?0.5:1);}if(options.valign!=='top'){yShift=(annHeight-textHeight)*(options.valign==='middle'?0.5:1);}if(hasMathjax){mathjaxGroup.select('svg').attr({x:borderfull+xShift-1,y:borderfull+yShift}).call(Drawing.setClipUrl,isSizeConstrained?annClipID:null,gd);}else{var texty=borderfull+yShift-anntextBB.top;var textx=borderfull+xShift-anntextBB.left;annText.call(svgTextUtils.positionText,textx,texty).call(Drawing.setClipUrl,isSizeConstrained?annClipID:null,gd);}annTextClip.select('rect').call(Drawing.setRect,borderfull,borderfull,annWidth,annHeight);annTextBG.call(Drawing.setRect,borderwidth/2,borderwidth/2,outerWidth-borderwidth,outerHeight-borderwidth);annTextGroupInner.call(Drawing.setTranslate,Math.round(annPosPx.x.text-outerWidth/2),Math.round(annPosPx.y.text-outerHeight/2));/*\n         * rotate text and background\n         * we already calculated the text center position *as rotated*\n         * because we needed that for autoranging anyway, so now whether\n         * we have an arrow or not, we rotate about the text center.\n         */annTextGroup.attr({transform:'rotate('+textangle+','+annPosPx.x.text+','+annPosPx.y.text+')'});/*\n         * add the arrow\n         * uses options[arrowwidth,arrowcolor,arrowhead] for styling\n         * dx and dy are normally zero, but when you are dragging the textbox\n         * while the head stays put, dx and dy are the pixel offsets\n         */var drawArrow=function drawArrow(dx,dy){annGroup.selectAll('.annotation-arrow-g').remove();var headX=annPosPx.x.head;var headY=annPosPx.y.head;var tailX=annPosPx.x.tail+dx;var tailY=annPosPx.y.tail+dy;var textX=annPosPx.x.text+dx;var textY=annPosPx.y.text+dy;// find the edge of the text box, where we'll start the arrow:\n// create transform matrix to rotate the text box corners\nvar transform=Lib.rotationXYMatrix(textangle,textX,textY);var applyTransform=Lib.apply2DTransform(transform);var applyTransform2=Lib.apply2DTransform2(transform);// calculate and transform bounding box\nvar width=+annTextBG.attr('width');var height=+annTextBG.attr('height');var xLeft=textX-0.5*width;var xRight=xLeft+width;var yTop=textY-0.5*height;var yBottom=yTop+height;var edges=[[xLeft,yTop,xLeft,yBottom],[xLeft,yBottom,xRight,yBottom],[xRight,yBottom,xRight,yTop],[xRight,yTop,xLeft,yTop]].map(applyTransform2);// Remove the line if it ends inside the box.  Use ray\n// casting for rotated boxes: see which edges intersect a\n// line from the arrowhead to far away and reduce with xor\n// to get the parity of the number of intersections.\nif(edges.reduce(function(a,x){return a^!!Lib.segmentsIntersect(headX,headY,headX+1e6,headY+1e6,x[0],x[1],x[2],x[3]);},false)){// no line or arrow - so quit drawArrow now\nreturn;}edges.forEach(function(x){var p=Lib.segmentsIntersect(tailX,tailY,headX,headY,x[0],x[1],x[2],x[3]);if(p){tailX=p.x;tailY=p.y;}});var strokewidth=options.arrowwidth;var arrowColor=options.arrowcolor;var arrowSide=options.arrowside;var arrowGroup=annGroup.append('g').style({opacity:Color.opacity(arrowColor)}).classed('annotation-arrow-g',true);var arrow=arrowGroup.append('path').attr('d','M'+tailX+','+tailY+'L'+headX+','+headY).style('stroke-width',strokewidth+'px').call(Color.stroke,Color.rgb(arrowColor));drawArrowHead(arrow,arrowSide,options);// the arrow dragger is a small square right at the head, then a line to the tail,\n// all expanded by a stroke width of 6px plus the arrow line width\nif(edits.annotationPosition&&arrow.node().parentNode&&!subplotId){var arrowDragHeadX=headX;var arrowDragHeadY=headY;if(options.standoff){var arrowLength=Math.sqrt(Math.pow(headX-tailX,2)+Math.pow(headY-tailY,2));arrowDragHeadX+=options.standoff*(tailX-headX)/arrowLength;arrowDragHeadY+=options.standoff*(tailY-headY)/arrowLength;}var arrowDrag=arrowGroup.append('path').classed('annotation-arrow',true).classed('anndrag',true).classed('cursor-move',true).attr({d:'M3,3H-3V-3H3ZM0,0L'+(tailX-arrowDragHeadX)+','+(tailY-arrowDragHeadY),transform:'translate('+arrowDragHeadX+','+arrowDragHeadY+')'}).style('stroke-width',strokewidth+6+'px').call(Color.stroke,'rgba(0,0,0,0)').call(Color.fill,'rgba(0,0,0,0)');var annx0,anny0;// dragger for the arrow & head: translates the whole thing\n// (head/tail/text) all together\ndragElement.init({element:arrowDrag.node(),gd:gd,prepFn:function prepFn(){var pos=Drawing.getTranslate(annTextGroupInner);annx0=pos.x;anny0=pos.y;if(xa&&xa.autorange){modifyBase(xa._name+'.autorange',true);}if(ya&&ya.autorange){modifyBase(ya._name+'.autorange',true);}},moveFn:function moveFn(dx,dy){var annxy0=applyTransform(annx0,anny0);var xcenter=annxy0[0]+dx;var ycenter=annxy0[1]+dy;annTextGroupInner.call(Drawing.setTranslate,xcenter,ycenter);modifyItem('x',xa?xa.p2r(xa.r2p(options.x)+dx):options.x+dx/gs.w);modifyItem('y',ya?ya.p2r(ya.r2p(options.y)+dy):options.y-dy/gs.h);if(options.axref===options.xref){modifyItem('ax',xa.p2r(xa.r2p(options.ax)+dx));}if(options.ayref===options.yref){modifyItem('ay',ya.p2r(ya.r2p(options.ay)+dy));}arrowGroup.attr('transform','translate('+dx+','+dy+')');annTextGroup.attr({transform:'rotate('+textangle+','+xcenter+','+ycenter+')'});},doneFn:function doneFn(){Registry.call('_guiRelayout',gd,getUpdateObj());var notesBox=document.querySelector('.js-notes-box-panel');if(notesBox)notesBox.redraw(notesBox.selectedObj);}});}};if(options.showarrow)drawArrow(0,0);// user dragging the annotation (text, not arrow)\nif(editTextPosition){var baseTextTransform;// dragger for the textbox: if there's an arrow, just drag the\n// textbox and tail, leave the head untouched\ndragElement.init({element:annTextGroupInner.node(),gd:gd,prepFn:function prepFn(){baseTextTransform=annTextGroup.attr('transform');},moveFn:function moveFn(dx,dy){var csr='pointer';if(options.showarrow){if(options.axref===options.xref){modifyItem('ax',xa.p2r(xa.r2p(options.ax)+dx));}else{modifyItem('ax',options.ax+dx);}if(options.ayref===options.yref){modifyItem('ay',ya.p2r(ya.r2p(options.ay)+dy));}else{modifyItem('ay',options.ay+dy);}drawArrow(dx,dy);}else if(!subplotId){var xUpdate,yUpdate;if(xa){xUpdate=xa.p2r(xa.r2p(options.x)+dx);}else{var widthFraction=options._xsize/gs.w;var xLeft=options.x+(options._xshift-options.xshift)/gs.w-widthFraction/2;xUpdate=dragElement.align(xLeft+dx/gs.w,widthFraction,0,1,options.xanchor);}if(ya){yUpdate=ya.p2r(ya.r2p(options.y)+dy);}else{var heightFraction=options._ysize/gs.h;var yBottom=options.y-(options._yshift+options.yshift)/gs.h-heightFraction/2;yUpdate=dragElement.align(yBottom-dy/gs.h,heightFraction,0,1,options.yanchor);}modifyItem('x',xUpdate);modifyItem('y',yUpdate);if(!xa||!ya){csr=dragElement.getCursor(xa?0.5:xUpdate,ya?0.5:yUpdate,options.xanchor,options.yanchor);}}else return;annTextGroup.attr({transform:'translate('+dx+','+dy+')'+baseTextTransform});setCursor(annTextGroupInner,csr);},doneFn:function doneFn(){setCursor(annTextGroupInner);Registry.call('_guiRelayout',gd,getUpdateObj());var notesBox=document.querySelector('.js-notes-box-panel');if(notesBox)notesBox.redraw(notesBox.selectedObj);}});}}if(edits.annotationText){annText.call(svgTextUtils.makeEditable,{delegate:annTextGroupInner,gd:gd}).call(textLayout).on('edit',function(_text){options.text=_text;this.call(textLayout);modifyItem('text',_text);if(xa&&xa.autorange){modifyBase(xa._name+'.autorange',true);}if(ya&&ya.autorange){modifyBase(ya._name+'.autorange',true);}Registry.call('_guiRelayout',gd,getUpdateObj());});}else annText.call(textLayout);}},{\"../../lib\":159,\"../../lib/setcursor\":178,\"../../lib/svg_text_utils\":180,\"../../plot_api/plot_template\":193,\"../../plots/cartesian/axes\":203,\"../../plots/plots\":235,\"../../registry\":242,\"../color\":43,\"../dragelement\":61,\"../drawing\":64,\"../fx\":82,\"./draw_arrow_head\":35,\"d3\":8}],35:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var Color=_dereq_('../color');var ARROWPATHS=_dereq_('./arrow_paths');/**\n * Add arrowhead(s) to a path or line element\n *\n * @param {d3.selection} el3: a d3-selected line or path element\n *\n * @param {string} ends: 'none', 'start', 'end', or 'start+end' for which ends get arrowheads\n *\n * @param {object} options: style information. Must have all the following:\n * @param {number} options.arrowhead: end head style - see ./arrow_paths\n * @param {number} options.startarrowhead: start head style - see ./arrow_paths\n * @param {number} options.arrowsize: relative size of the end head vs line width\n * @param {number} options.startarrowsize: relative size of the start head vs line width\n * @param {number} options.standoff: distance in px to move the end arrow point from its target\n * @param {number} options.startstandoff: distance in px to move the start arrow point from its target\n * @param {number} options.arrowwidth: width of the arrow line\n * @param {string} options.arrowcolor: color of the arrow line, for the head to match\n *     Note that the opacity of this color is ignored, as it's assumed the container\n *     of both the line and head has opacity applied to it so there isn't greater opacity\n *     where they overlap.\n */module.exports=function drawArrowHead(el3,ends,options){var el=el3.node();var headStyle=ARROWPATHS[options.arrowhead||0];var startHeadStyle=ARROWPATHS[options.startarrowhead||0];var scale=(options.arrowwidth||1)*(options.arrowsize||1);var startScale=(options.arrowwidth||1)*(options.startarrowsize||1);var doStart=ends.indexOf('start')>=0;var doEnd=ends.indexOf('end')>=0;var backOff=headStyle.backoff*scale+options.standoff;var startBackOff=startHeadStyle.backoff*startScale+options.startstandoff;var start,end,startRot,endRot;if(el.nodeName==='line'){start={x:+el3.attr('x1'),y:+el3.attr('y1')};end={x:+el3.attr('x2'),y:+el3.attr('y2')};var dx=start.x-end.x;var dy=start.y-end.y;startRot=Math.atan2(dy,dx);endRot=startRot+Math.PI;if(backOff&&startBackOff){if(backOff+startBackOff>Math.sqrt(dx*dx+dy*dy)){hideLine();return;}}if(backOff){if(backOff*backOff>dx*dx+dy*dy){hideLine();return;}var backOffX=backOff*Math.cos(startRot);var backOffY=backOff*Math.sin(startRot);end.x+=backOffX;end.y+=backOffY;el3.attr({x2:end.x,y2:end.y});}if(startBackOff){if(startBackOff*startBackOff>dx*dx+dy*dy){hideLine();return;}var startBackOffX=startBackOff*Math.cos(startRot);var startbackOffY=startBackOff*Math.sin(startRot);start.x-=startBackOffX;start.y-=startbackOffY;el3.attr({x1:start.x,y1:start.y});}}else if(el.nodeName==='path'){var pathlen=el.getTotalLength();// using dash to hide the backOff region of the path.\n// if we ever allow dash for the arrow we'll have to\n// do better than this hack... maybe just manually\n// combine the two\nvar dashArray='';if(pathlen<backOff+startBackOff){hideLine();return;}var start0=el.getPointAtLength(0);var dstart=el.getPointAtLength(0.1);startRot=Math.atan2(start0.y-dstart.y,start0.x-dstart.x);start=el.getPointAtLength(Math.min(startBackOff,pathlen));dashArray='0px,'+startBackOff+'px,';var end0=el.getPointAtLength(pathlen);var dend=el.getPointAtLength(pathlen-0.1);endRot=Math.atan2(end0.y-dend.y,end0.x-dend.x);end=el.getPointAtLength(Math.max(0,pathlen-backOff));var shortening=dashArray?startBackOff+backOff:backOff;dashArray+=pathlen-shortening+'px,'+pathlen+'px';el3.style('stroke-dasharray',dashArray);}function hideLine(){el3.style('stroke-dasharray','0px,100px');}function drawhead(arrowHeadStyle,p,rot,arrowScale){if(!arrowHeadStyle.path)return;if(arrowHeadStyle.noRotate)rot=0;d3.select(el.parentNode).append('path').attr({'class':el3.attr('class'),d:arrowHeadStyle.path,transform:'translate('+p.x+','+p.y+')'+(rot?'rotate('+rot*180/Math.PI+')':'')+'scale('+arrowScale+')'}).style({fill:Color.rgb(options.arrowcolor),'stroke-width':0});}if(doStart)drawhead(startHeadStyle,start,startRot,startScale);if(doEnd)drawhead(headStyle,end,endRot,scale);};},{\"../color\":43,\"./arrow_paths\":27,\"d3\":8}],36:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var drawModule=_dereq_('./draw');var clickModule=_dereq_('./click');module.exports={moduleType:'component',name:'annotations',layoutAttributes:_dereq_('./attributes'),supplyLayoutDefaults:_dereq_('./defaults'),includeBasePlot:_dereq_('../../plots/cartesian/include_components')('annotations'),calcAutorange:_dereq_('./calc_autorange'),draw:drawModule.draw,drawOne:drawModule.drawOne,drawRaw:drawModule.drawRaw,hasClickToShow:clickModule.hasClickToShow,onClick:clickModule.onClick,convertCoords:_dereq_('./convert_coords')};},{\"../../plots/cartesian/include_components\":213,\"./attributes\":28,\"./calc_autorange\":29,\"./click\":30,\"./convert_coords\":32,\"./defaults\":33,\"./draw\":34}],37:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var annAtts=_dereq_('../annotations/attributes');var overrideAll=_dereq_('../../plot_api/edit_types').overrideAll;var templatedArray=_dereq_('../../plot_api/plot_template').templatedArray;module.exports=overrideAll(templatedArray('annotation',{visible:annAtts.visible,x:{valType:'any'},y:{valType:'any'},z:{valType:'any'},ax:{valType:'number'},ay:{valType:'number'},xanchor:annAtts.xanchor,xshift:annAtts.xshift,yanchor:annAtts.yanchor,yshift:annAtts.yshift,text:annAtts.text,textangle:annAtts.textangle,font:annAtts.font,width:annAtts.width,height:annAtts.height,opacity:annAtts.opacity,align:annAtts.align,valign:annAtts.valign,bgcolor:annAtts.bgcolor,bordercolor:annAtts.bordercolor,borderpad:annAtts.borderpad,borderwidth:annAtts.borderwidth,showarrow:annAtts.showarrow,arrowcolor:annAtts.arrowcolor,arrowhead:annAtts.arrowhead,startarrowhead:annAtts.startarrowhead,arrowside:annAtts.arrowside,arrowsize:annAtts.arrowsize,startarrowsize:annAtts.startarrowsize,arrowwidth:annAtts.arrowwidth,standoff:annAtts.standoff,startstandoff:annAtts.startstandoff,hovertext:annAtts.hovertext,hoverlabel:annAtts.hoverlabel,captureevents:annAtts.captureevents// maybes later?\n// clicktoshow: annAtts.clicktoshow,\n// xclick: annAtts.xclick,\n// yclick: annAtts.yclick,\n// not needed!\n// axref: 'pixel'\n// ayref: 'pixel'\n// xref: 'x'\n// yref: 'y\n// zref: 'z'\n}),'calc','from-root');},{\"../../plot_api/edit_types\":186,\"../../plot_api/plot_template\":193,\"../annotations/attributes\":28}],38:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var Axes=_dereq_('../../plots/cartesian/axes');module.exports=function convert(scene){var fullSceneLayout=scene.fullSceneLayout;var anns=fullSceneLayout.annotations;for(var i=0;i<anns.length;i++){mockAnnAxes(anns[i],scene);}scene.fullLayout._infolayer.selectAll('.annotation-'+scene.id).remove();};function mockAnnAxes(ann,scene){var fullSceneLayout=scene.fullSceneLayout;var domain=fullSceneLayout.domain;var size=scene.fullLayout._size;var base={// this gets fill in on render\npdata:null,// to get setConvert to not execute cleanly\ntype:'linear',// don't try to update them on `editable: true`\nautorange:false,// set infinite range so that annotation draw routine\n// does not try to remove 'outside-range' annotations,\n// this case is handled in the render loop\nrange:[-Infinity,Infinity]};ann._xa={};Lib.extendFlat(ann._xa,base);Axes.setConvert(ann._xa);ann._xa._offset=size.l+domain.x[0]*size.w;ann._xa.l2p=function(){return 0.5*(1+ann._pdata[0]/ann._pdata[3])*size.w*(domain.x[1]-domain.x[0]);};ann._ya={};Lib.extendFlat(ann._ya,base);Axes.setConvert(ann._ya);ann._ya._offset=size.t+(1-domain.y[1])*size.h;ann._ya.l2p=function(){return 0.5*(1-ann._pdata[1]/ann._pdata[3])*size.h*(domain.y[1]-domain.y[0]);};}},{\"../../lib\":159,\"../../plots/cartesian/axes\":203}],39:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var Axes=_dereq_('../../plots/cartesian/axes');var handleArrayContainerDefaults=_dereq_('../../plots/array_container_defaults');var handleAnnotationCommonDefaults=_dereq_('../annotations/common_defaults');var attributes=_dereq_('./attributes');module.exports=function handleDefaults(sceneLayoutIn,sceneLayoutOut,opts){handleArrayContainerDefaults(sceneLayoutIn,sceneLayoutOut,{name:'annotations',handleItemDefaults:handleAnnotationDefaults,fullLayout:opts.fullLayout});};function handleAnnotationDefaults(annIn,annOut,sceneLayout,opts){function coerce(attr,dflt){return Lib.coerce(annIn,annOut,attributes,attr,dflt);}function coercePosition(axLetter){var axName=axLetter+'axis';// mock in such way that getFromId grabs correct 3D axis\nvar gdMock={_fullLayout:{}};gdMock._fullLayout[axName]=sceneLayout[axName];return Axes.coercePosition(annOut,gdMock,coerce,axLetter,axLetter,0.5);}var visible=coerce('visible');if(!visible)return;handleAnnotationCommonDefaults(annIn,annOut,opts.fullLayout,coerce);coercePosition('x');coercePosition('y');coercePosition('z');// if you have one coordinate you should all three\nLib.noneOrAll(annIn,annOut,['x','y','z']);// hard-set here for completeness\nannOut.xref='x';annOut.yref='y';annOut.zref='z';coerce('xanchor');coerce('yanchor');coerce('xshift');coerce('yshift');if(annOut.showarrow){annOut.axref='pixel';annOut.ayref='pixel';// TODO maybe default values should be bigger than the 2D case?\ncoerce('ax',-10);coerce('ay',-30);// if you have one part of arrow length you should have both\nLib.noneOrAll(annIn,annOut,['ax','ay']);}}},{\"../../lib\":159,\"../../plots/array_container_defaults\":199,\"../../plots/cartesian/axes\":203,\"../annotations/common_defaults\":31,\"./attributes\":37}],40:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var drawRaw=_dereq_('../annotations/draw').drawRaw;var project=_dereq_('../../plots/gl3d/project');var axLetters=['x','y','z'];module.exports=function draw(scene){var fullSceneLayout=scene.fullSceneLayout;var dataScale=scene.dataScale;var anns=fullSceneLayout.annotations;for(var i=0;i<anns.length;i++){var ann=anns[i];var annotationIsOffscreen=false;for(var j=0;j<3;j++){var axLetter=axLetters[j];var pos=ann[axLetter];var ax=fullSceneLayout[axLetter+'axis'];var posFraction=ax.r2fraction(pos);if(posFraction<0||posFraction>1){annotationIsOffscreen=true;break;}}if(annotationIsOffscreen){scene.fullLayout._infolayer.select('.annotation-'+scene.id+'[data-index=\"'+i+'\"]').remove();}else{ann._pdata=project(scene.glplot.cameraParams,[fullSceneLayout.xaxis.r2l(ann.x)*dataScale[0],fullSceneLayout.yaxis.r2l(ann.y)*dataScale[1],fullSceneLayout.zaxis.r2l(ann.z)*dataScale[2]]);drawRaw(scene.graphDiv,ann,i,scene.id,ann._xa,ann._ya);}}};},{\"../../plots/gl3d/project\":232,\"../annotations/draw\":34}],41:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Registry=_dereq_('../../registry');var Lib=_dereq_('../../lib');module.exports={moduleType:'component',name:'annotations3d',schema:{subplots:{scene:{annotations:_dereq_('./attributes')}}},layoutAttributes:_dereq_('./attributes'),handleDefaults:_dereq_('./defaults'),includeBasePlot:includeGL3D,convert:_dereq_('./convert'),draw:_dereq_('./draw')};function includeGL3D(layoutIn,layoutOut){var GL3D=Registry.subplotsRegistry.gl3d;if(!GL3D)return;var attrRegex=GL3D.attrRegex;var keys=Object.keys(layoutIn);for(var i=0;i<keys.length;i++){var k=keys[i];if(attrRegex.test(k)&&(layoutIn[k].annotations||[]).length){Lib.pushUnique(layoutOut._basePlotModules,GL3D);Lib.pushUnique(layoutOut._subplots.gl3d,k);}}}},{\"../../lib\":159,\"../../registry\":242,\"./attributes\":37,\"./convert\":38,\"./defaults\":39,\"./draw\":40}],42:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';// IMPORTANT - default colors should be in hex for compatibility\nexports.defaults=['#1f77b4',// muted blue\n'#ff7f0e',// safety orange\n'#2ca02c',// cooked asparagus green\n'#d62728',// brick red\n'#9467bd',// muted purple\n'#8c564b',// chestnut brown\n'#e377c2',// raspberry yogurt pink\n'#7f7f7f',// middle gray\n'#bcbd22',// curry yellow-green\n'#17becf'// blue-teal\n];exports.defaultLine='#444';exports.lightLine='#eee';exports.background='#fff';exports.borderLine='#BEC8D9';// with axis.color and Color.interp we aren't using lightLine\n// itself anymore, instead interpolating between axis.color\n// and the background color using tinycolor.mix. lightFraction\n// gives back exactly lightLine if the other colors are defaults.\nexports.lightFraction=100*(0xe-0x4)/(0xf-0x4);},{}],43:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var tinycolor=_dereq_('tinycolor2');var isNumeric=_dereq_('fast-isnumeric');var color=module.exports={};var colorAttrs=_dereq_('./attributes');color.defaults=colorAttrs.defaults;var defaultLine=color.defaultLine=colorAttrs.defaultLine;color.lightLine=colorAttrs.lightLine;var background=color.background=colorAttrs.background;/*\n * tinyRGB: turn a tinycolor into an rgb string, but\n * unlike the built-in tinycolor.toRgbString this never includes alpha\n */color.tinyRGB=function(tc){var c=tc.toRgb();return'rgb('+Math.round(c.r)+', '+Math.round(c.g)+', '+Math.round(c.b)+')';};color.rgb=function(cstr){return color.tinyRGB(tinycolor(cstr));};color.opacity=function(cstr){return cstr?tinycolor(cstr).getAlpha():0;};color.addOpacity=function(cstr,op){var c=tinycolor(cstr).toRgb();return'rgba('+Math.round(c.r)+', '+Math.round(c.g)+', '+Math.round(c.b)+', '+op+')';};// combine two colors into one apparent color\n// if back has transparency or is missing,\n// color.background is assumed behind it\ncolor.combine=function(front,back){var fc=tinycolor(front).toRgb();if(fc.a===1)return tinycolor(front).toRgbString();var bc=tinycolor(back||background).toRgb();var bcflat=bc.a===1?bc:{r:255*(1-bc.a)+bc.r*bc.a,g:255*(1-bc.a)+bc.g*bc.a,b:255*(1-bc.a)+bc.b*bc.a};var fcflat={r:bcflat.r*(1-fc.a)+fc.r*fc.a,g:bcflat.g*(1-fc.a)+fc.g*fc.a,b:bcflat.b*(1-fc.a)+fc.b*fc.a};return tinycolor(fcflat).toRgbString();};/*\n * Create a color that contrasts with cstr.\n *\n * If cstr is a dark color, we lighten it; if it's light, we darken.\n *\n * If lightAmount / darkAmount are used, we adjust by these percentages,\n * otherwise we go all the way to white or black.\n */color.contrast=function(cstr,lightAmount,darkAmount){var tc=tinycolor(cstr);if(tc.getAlpha()!==1)tc=tinycolor(color.combine(cstr,background));var newColor=tc.isDark()?lightAmount?tc.lighten(lightAmount):background:darkAmount?tc.darken(darkAmount):defaultLine;return newColor.toString();};color.stroke=function(s,c){var tc=tinycolor(c);s.style({'stroke':color.tinyRGB(tc),'stroke-opacity':tc.getAlpha()});};color.fill=function(s,c){var tc=tinycolor(c);s.style({'fill':color.tinyRGB(tc),'fill-opacity':tc.getAlpha()});};// search container for colors with the deprecated rgb(fractions) format\n// and convert them to rgb(0-255 values)\ncolor.clean=function(container){if(!container||_typeof(container)!=='object')return;var keys=Object.keys(container);var i,j,key,val;for(i=0;i<keys.length;i++){key=keys[i];val=container[key];if(key.substr(key.length-5)==='color'){// only sanitize keys that end in \"color\" or \"colorscale\"\nif(Array.isArray(val)){for(j=0;j<val.length;j++){val[j]=cleanOne(val[j]);}}else container[key]=cleanOne(val);}else if(key.substr(key.length-10)==='colorscale'&&Array.isArray(val)){// colorscales have the format [[0, color1], [frac, color2], ... [1, colorN]]\nfor(j=0;j<val.length;j++){if(Array.isArray(val[j]))val[j][1]=cleanOne(val[j][1]);}}else if(Array.isArray(val)){// recurse into arrays of objects, and plain objects\nvar el0=val[0];if(!Array.isArray(el0)&&el0&&_typeof(el0)==='object'){for(j=0;j<val.length;j++){color.clean(val[j]);}}}else if(val&&_typeof(val)==='object')color.clean(val);}};function cleanOne(val){if(isNumeric(val)||typeof val!=='string')return val;var valTrim=val.trim();if(valTrim.substr(0,3)!=='rgb')return val;var match=valTrim.match(/^rgba?\\s*\\(([^()]*)\\)$/);if(!match)return val;var parts=match[1].trim().split(/\\s*[\\s,]\\s*/);var rgba=valTrim.charAt(3)==='a'&&parts.length===4;if(!rgba&&parts.length!==3)return val;for(var i=0;i<parts.length;i++){if(!parts[i].length)return val;parts[i]=Number(parts[i]);if(!(parts[i]>=0)){// all parts must be non-negative numbers\nreturn val;}if(i===3){// alpha>1 gets clipped to 1\nif(parts[i]>1)parts[i]=1;}else if(parts[i]>=1){// r, g, b must be < 1 (ie 1 itself is not allowed)\nreturn val;}}var rgbStr=Math.round(parts[0]*255)+', '+Math.round(parts[1]*255)+', '+Math.round(parts[2]*255);if(rgba)return'rgba('+rgbStr+', '+parts[3]+')';return'rgb('+rgbStr+')';}},{\"./attributes\":42,\"fast-isnumeric\":10,\"tinycolor2\":26}],44:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var axesAttrs=_dereq_('../../plots/cartesian/layout_attributes');var fontAttrs=_dereq_('../../plots/font_attributes');var extendFlat=_dereq_('../../lib/extend').extendFlat;var overrideAll=_dereq_('../../plot_api/edit_types').overrideAll;module.exports=overrideAll({// TODO: only right is supported currently\n//     orient: {\n//         valType: 'enumerated',\n//         \n//         values: ['left', 'right', 'top', 'bottom'],\n//         dflt: 'right',\n//         \n//     },\nthicknessmode:{valType:'enumerated',values:['fraction','pixels'],dflt:'pixels'},thickness:{valType:'number',min:0,dflt:30},lenmode:{valType:'enumerated',values:['fraction','pixels'],dflt:'fraction'},len:{valType:'number',min:0,dflt:1},x:{valType:'number',dflt:1.02,min:-2,max:3},xanchor:{valType:'enumerated',values:['left','center','right'],dflt:'left'},xpad:{valType:'number',min:0,dflt:10},y:{valType:'number',dflt:0.5,min:-2,max:3},yanchor:{valType:'enumerated',values:['top','middle','bottom'],dflt:'middle'},ypad:{valType:'number',min:0,dflt:10},// a possible line around the bar itself\noutlinecolor:axesAttrs.linecolor,outlinewidth:axesAttrs.linewidth,// Should outlinewidth have {dflt: 0} ?\n// another possible line outside the padding and tick labels\nbordercolor:axesAttrs.linecolor,borderwidth:{valType:'number',min:0,dflt:0},bgcolor:{valType:'color',dflt:'rgba(0,0,0,0)'},// tick and title properties named and function exactly as in axes\ntickmode:axesAttrs.tickmode,nticks:axesAttrs.nticks,tick0:axesAttrs.tick0,dtick:axesAttrs.dtick,tickvals:axesAttrs.tickvals,ticktext:axesAttrs.ticktext,ticks:extendFlat({},axesAttrs.ticks,{dflt:''}),ticklen:axesAttrs.ticklen,tickwidth:axesAttrs.tickwidth,tickcolor:axesAttrs.tickcolor,showticklabels:axesAttrs.showticklabels,tickfont:fontAttrs({}),tickangle:axesAttrs.tickangle,tickformat:axesAttrs.tickformat,tickformatstops:axesAttrs.tickformatstops,tickprefix:axesAttrs.tickprefix,showtickprefix:axesAttrs.showtickprefix,ticksuffix:axesAttrs.ticksuffix,showticksuffix:axesAttrs.showticksuffix,separatethousands:axesAttrs.separatethousands,exponentformat:axesAttrs.exponentformat,showexponent:axesAttrs.showexponent,title:{text:{valType:'string'},font:fontAttrs({}),side:{valType:'enumerated',values:['right','top','bottom'],dflt:'top'}},_deprecated:{title:{valType:'string'},titlefont:fontAttrs({}),titleside:{valType:'enumerated',values:['right','top','bottom'],dflt:'top'}}},'colorbars','from-root');},{\"../../lib/extend\":153,\"../../plot_api/edit_types\":186,\"../../plots/cartesian/layout_attributes\":215,\"../../plots/font_attributes\":229}],45:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var drawColorbar=_dereq_('./draw');var flipScale=_dereq_('../colorscale/helpers').flipScale;/**\n * connectColorbar: create a colorbar from a trace, using its module to\n *   describe the connection.\n *\n * @param {DOM element} gd\n *\n * @param {Array} cd\n *   calcdata entry for this trace. cd[0].trace is the trace itself, and the\n *   colorbar object will be stashed in cd[0].t.cb\n *\n * @param {object|function} moduleOpts\n *   may be a function(gd, cd) to override the standard handling below. If\n *   an object, should have these keys:\n * @param {Optional(string)} moduleOpts.container\n *   name of the container inside the trace where the colorbar and colorscale\n *   attributes live (ie 'marker', 'line') - omit if they're at the trace root.\n * @param {string} moduleOpts.min\n *   name of the attribute holding the value of the minimum color\n * @param {string} moduleOpts.max\n *   name of the attribute holding the value of the maximum color\n * @param {Optional(string)} moduleOpts.vals\n *   name of the attribute holding the (numeric) color data\n *   used only if min/max fail. May be omitted if these are always\n *   pre-calculated.\n */module.exports=function connectColorbar(gd,cd,moduleOpts){if(typeof moduleOpts==='function')return moduleOpts(gd,cd);var trace=cd[0].trace;var cbId='cb'+trace.uid;moduleOpts=Array.isArray(moduleOpts)?moduleOpts:[moduleOpts];for(var i=0;i<moduleOpts.length;i++){var containerName=moduleOpts[i].container;var container=containerName?trace[containerName]:trace;gd._fullLayout._infolayer.selectAll('.'+cbId).remove();if(!container||!container.showscale)continue;var cb=cd[0].t.cb=drawColorbar(gd,cbId);var scl=container.reversescale?flipScale(container.colorscale):container.colorscale;cb.fillgradient(scl).zrange([container[moduleOpts[i].min],container[moduleOpts[i].max]]).options(container.colorbar)();return;}};},{\"../colorscale/helpers\":54,\"./draw\":48}],46:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports={cn:{colorbar:'colorbar',cbbg:'cbbg',cbfill:'cbfill',cbfills:'cbfills',cbline:'cbline',cblines:'cblines',cbaxis:'cbaxis',cbtitleunshift:'cbtitleunshift',cbtitle:'cbtitle',cboutline:'cboutline',crisp:'crisp',jsPlaceholder:'js-placeholder'}};},{}],47:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var Template=_dereq_('../../plot_api/plot_template');var handleTickValueDefaults=_dereq_('../../plots/cartesian/tick_value_defaults');var handleTickMarkDefaults=_dereq_('../../plots/cartesian/tick_mark_defaults');var handleTickLabelDefaults=_dereq_('../../plots/cartesian/tick_label_defaults');var attributes=_dereq_('./attributes');module.exports=function colorbarDefaults(containerIn,containerOut,layout){var colorbarOut=Template.newContainer(containerOut,'colorbar');var colorbarIn=containerIn.colorbar||{};function coerce(attr,dflt){return Lib.coerce(colorbarIn,colorbarOut,attributes,attr,dflt);}var thicknessmode=coerce('thicknessmode');coerce('thickness',thicknessmode==='fraction'?30/(layout.width-layout.margin.l-layout.margin.r):30);var lenmode=coerce('lenmode');coerce('len',lenmode==='fraction'?1:layout.height-layout.margin.t-layout.margin.b);coerce('x');coerce('xanchor');coerce('xpad');coerce('y');coerce('yanchor');coerce('ypad');Lib.noneOrAll(colorbarIn,colorbarOut,['x','y']);coerce('outlinecolor');coerce('outlinewidth');coerce('bordercolor');coerce('borderwidth');coerce('bgcolor');handleTickValueDefaults(colorbarIn,colorbarOut,coerce,'linear');var opts={outerTicks:false,font:layout.font};handleTickLabelDefaults(colorbarIn,colorbarOut,coerce,'linear',opts);handleTickMarkDefaults(colorbarIn,colorbarOut,coerce,'linear',opts);coerce('title.text',layout._dfltTitle.colorbar);Lib.coerceFont(coerce,'title.font',layout.font);coerce('title.side');};},{\"../../lib\":159,\"../../plot_api/plot_template\":193,\"../../plots/cartesian/tick_label_defaults\":222,\"../../plots/cartesian/tick_mark_defaults\":223,\"../../plots/cartesian/tick_value_defaults\":224,\"./attributes\":44}],48:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var tinycolor=_dereq_('tinycolor2');var Plots=_dereq_('../../plots/plots');var Registry=_dereq_('../../registry');var Axes=_dereq_('../../plots/cartesian/axes');var dragElement=_dereq_('../dragelement');var Lib=_dereq_('../../lib');var extendFlat=_dereq_('../../lib/extend').extendFlat;var setCursor=_dereq_('../../lib/setcursor');var Drawing=_dereq_('../drawing');var Color=_dereq_('../color');var Titles=_dereq_('../titles');var svgTextUtils=_dereq_('../../lib/svg_text_utils');var alignmentConstants=_dereq_('../../constants/alignment');var LINE_SPACING=alignmentConstants.LINE_SPACING;var FROM_TL=alignmentConstants.FROM_TL;var FROM_BR=alignmentConstants.FROM_BR;var handleAxisDefaults=_dereq_('../../plots/cartesian/axis_defaults');var handleAxisPositionDefaults=_dereq_('../../plots/cartesian/position_defaults');var axisLayoutAttrs=_dereq_('../../plots/cartesian/layout_attributes');var attributes=_dereq_('./attributes');var cn=_dereq_('./constants').cn;module.exports=function draw(gd,id){// opts: options object, containing everything from attributes\n// plus a few others that are the equivalent of the colorbar \"data\"\nvar opts={};for(var k in attributes){opts[k]=null;}// fillcolor can be a d3 scale, domain is z values, range is colors\n// or leave it out for no fill,\n// or set to a string constant for single-color fill\nopts.fillcolor=null;// line.color has the same options as fillcolor\nopts.line={color:null,width:null,dash:null};// levels of lines to draw.\n// note that this DOES NOT determine the extent of the bar\n// that's given by the domain of fillcolor\n// (or line.color if no fillcolor domain)\nopts.levels={start:null,end:null,size:null};// separate fill levels (for example, heatmap coloring of a\n// contour map) if this is omitted, fillcolors will be\n// evaluated halfway between levels\nopts.filllevels=null;// for continuous colorscales: fill with a gradient instead of explicit levels\n// value should be the colorscale [[0, c0], [v1, c1], ..., [1, cEnd]]\nopts.fillgradient=null;// when using a gradient, we need the data range specified separately\nopts.zrange=null;function component(){var fullLayout=gd._fullLayout;var gs=fullLayout._size;if(typeof opts.fillcolor!=='function'&&typeof opts.line.color!=='function'&&!opts.fillgradient){fullLayout._infolayer.selectAll('g.'+id).remove();return;}var zrange=opts.zrange||d3.extent((typeof opts.fillcolor==='function'?opts.fillcolor:opts.line.color).domain());var linelevels=[];var filllevels=[];var linecolormap=typeof opts.line.color==='function'?opts.line.color:function(){return opts.line.color;};var fillcolormap=typeof opts.fillcolor==='function'?opts.fillcolor:function(){return opts.fillcolor;};var l;var i;var l0=opts.levels.end+opts.levels.size/100;var ls=opts.levels.size;var zr0=1.001*zrange[0]-0.001*zrange[1];var zr1=1.001*zrange[1]-0.001*zrange[0];for(i=0;i<1e5;i++){l=opts.levels.start+i*ls;if(ls>0?l>=l0:l<=l0)break;if(l>zr0&&l<zr1)linelevels.push(l);}if(opts.fillgradient){filllevels=[0];}else if(typeof opts.fillcolor==='function'){if(opts.filllevels){l0=opts.filllevels.end+opts.filllevels.size/100;ls=opts.filllevels.size;for(i=0;i<1e5;i++){l=opts.filllevels.start+i*ls;if(ls>0?l>=l0:l<=l0)break;if(l>zrange[0]&&l<zrange[1])filllevels.push(l);}}else{filllevels=linelevels.map(function(v){return v-opts.levels.size/2;});filllevels.push(filllevels[filllevels.length-1]+opts.levels.size);}}else if(opts.fillcolor&&typeof opts.fillcolor==='string'){// doesn't matter what this value is, with a single value\n// we'll make a single fill rect covering the whole bar\nfilllevels=[0];}if(opts.levels.size<0){linelevels.reverse();filllevels.reverse();}// now make a Plotly Axes object to scale with and draw ticks\n// TODO: does not support orientation other than right\n// we calculate pixel sizes based on the specified graph size,\n// not the actual (in case something pushed the margins around)\n// which is a little odd but avoids an odd iterative effect\n// when the colorbar itself is pushing the margins.\n// but then the fractional size is calculated based on the\n// actual graph size, so that the axes will size correctly.\nvar plotHeight=gs.h;var plotWidth=gs.w;var thickPx=Math.round(opts.thickness*(opts.thicknessmode==='fraction'?plotWidth:1));var thickFrac=thickPx/gs.w;var lenPx=Math.round(opts.len*(opts.lenmode==='fraction'?plotHeight:1));var lenFrac=lenPx/gs.h;var xpadFrac=opts.xpad/gs.w;var yExtraPx=(opts.borderwidth+opts.outlinewidth)/2;var ypadFrac=opts.ypad/gs.h;// x positioning: do it initially just for left anchor,\n// then fix at the end (since we don't know the width yet)\nvar xLeft=Math.round(opts.x*gs.w+opts.xpad);// for dragging... this is getting a little muddled...\nvar xLeftFrac=opts.x-thickFrac*({middle:0.5,right:1}[opts.xanchor]||0);// y positioning we can do correctly from the start\nvar yBottomFrac=opts.y+lenFrac*(({top:-0.5,bottom:0.5}[opts.yanchor]||0)-0.5);var yBottomPx=Math.round(gs.h*(1-yBottomFrac));var yTopPx=yBottomPx-lenPx;var titleEl;var cbAxisIn={type:'linear',range:zrange,tickmode:opts.tickmode,nticks:opts.nticks,tick0:opts.tick0,dtick:opts.dtick,tickvals:opts.tickvals,ticktext:opts.ticktext,ticks:opts.ticks,ticklen:opts.ticklen,tickwidth:opts.tickwidth,tickcolor:opts.tickcolor,showticklabels:opts.showticklabels,tickfont:opts.tickfont,tickangle:opts.tickangle,tickformat:opts.tickformat,exponentformat:opts.exponentformat,separatethousands:opts.separatethousands,showexponent:opts.showexponent,showtickprefix:opts.showtickprefix,tickprefix:opts.tickprefix,showticksuffix:opts.showticksuffix,ticksuffix:opts.ticksuffix,title:opts.title,showline:true,anchor:'free',side:'right',position:1};var cbAxisOut={type:'linear',_id:'y'+id};var axisOptions={letter:'y',font:fullLayout.font,noHover:true,noTickson:true,calendar:fullLayout.calendar// not really necessary (yet?)\n};// Coerce w.r.t. Axes layoutAttributes:\n// re-use axes.js logic without updating _fullData\nfunction coerce(attr,dflt){return Lib.coerce(cbAxisIn,cbAxisOut,axisLayoutAttrs,attr,dflt);}// Prepare the Plotly axis object\nhandleAxisDefaults(cbAxisIn,cbAxisOut,coerce,axisOptions,fullLayout);handleAxisPositionDefaults(cbAxisIn,cbAxisOut,coerce,axisOptions);// position can't go in through supplyDefaults\n// because that restricts it to [0,1]\ncbAxisOut.position=opts.x+xpadFrac+thickFrac;// save for other callers to access this axis\ncomponent.axis=cbAxisOut;if(['top','bottom'].indexOf(opts.title.side)!==-1){cbAxisOut.title.side=opts.title.side;cbAxisOut.titlex=opts.x+xpadFrac;cbAxisOut.titley=yBottomFrac+(opts.title.side==='top'?lenFrac-ypadFrac:ypadFrac);}if(opts.line.color&&opts.tickmode==='auto'){cbAxisOut.tickmode='linear';cbAxisOut.tick0=opts.levels.start;var dtick=opts.levels.size;// expand if too many contours, so we don't get too many ticks\nvar autoNtick=Lib.constrain((yBottomPx-yTopPx)/50,4,15)+1;var dtFactor=(zrange[1]-zrange[0])/((opts.nticks||autoNtick)*dtick);if(dtFactor>1){var dtexp=Math.pow(10,Math.floor(Math.log(dtFactor)/Math.LN10));dtick*=dtexp*Lib.roundUp(dtFactor/dtexp,[2,5,10]);// if the contours are at round multiples, reset tick0\n// so they're still at round multiples. Otherwise,\n// keep the first label on the first contour level\nif((Math.abs(opts.levels.start)/opts.levels.size+1e-6)%1<2e-6){cbAxisOut.tick0=0;}}cbAxisOut.dtick=dtick;}// set domain after init, because we may want to\n// allow it outside [0,1]\ncbAxisOut.domain=[yBottomFrac+ypadFrac,yBottomFrac+lenFrac-ypadFrac];cbAxisOut.setScale();// now draw the elements\nvar container=Lib.ensureSingle(fullLayout._infolayer,'g',id,function(s){s.classed(cn.colorbar,true).each(function(){var s=d3.select(this);s.append('rect').classed(cn.cbbg,true);s.append('g').classed(cn.cbfills,true);s.append('g').classed(cn.cblines,true);s.append('g').classed(cn.cbaxis,true).classed(cn.crisp,true);s.append('g').classed(cn.cbtitleunshift,true).append('g').classed(cn.cbtitle,true);s.append('rect').classed(cn.cboutline,true);s.select('.cbtitle').datum(0);});});container.attr('transform','translate('+Math.round(gs.l)+','+Math.round(gs.t)+')');// TODO: this opposite transform is a hack until we make it\n// more rational which items get this offset\nvar titleCont=container.select('.cbtitleunshift').attr('transform','translate(-'+Math.round(gs.l)+',-'+Math.round(gs.t)+')');var axisLayer=container.select('.cbaxis');var titleHeight=0;if(['top','bottom'].indexOf(opts.title.side)!==-1){// draw the title so we know how much room it needs\n// when we squish the axis. This one only applies to\n// top or bottom titles, not right side.\nvar x=gs.l+(opts.x+xpadFrac)*gs.w;var fontSize=cbAxisOut.title.font.size;var y;if(opts.title.side==='top'){y=(1-(yBottomFrac+lenFrac-ypadFrac))*gs.h+gs.t+3+fontSize*0.75;}else{y=(1-(yBottomFrac+ypadFrac))*gs.h+gs.t-3-fontSize*0.25;}drawTitle(cbAxisOut._id+'title',{attributes:{x:x,y:y,'text-anchor':'start'}});}function drawAxis(){if(['top','bottom'].indexOf(opts.title.side)!==-1){// squish the axis top to make room for the title\nvar titleGroup=container.select('.cbtitle');var titleText=titleGroup.select('text');var titleTrans=[-opts.outlinewidth/2,opts.outlinewidth/2];var mathJaxNode=titleGroup.select('.h'+cbAxisOut._id+'title-math-group').node();var lineSize=15.6;if(titleText.node()){lineSize=parseInt(titleText.node().style.fontSize,10)*LINE_SPACING;}if(mathJaxNode){titleHeight=Drawing.bBox(mathJaxNode).height;if(titleHeight>lineSize){// not entirely sure how mathjax is doing\n// vertical alignment, but this seems to work.\ntitleTrans[1]-=(titleHeight-lineSize)/2;}}else if(titleText.node()&&!titleText.classed(cn.jsPlaceholder)){titleHeight=Drawing.bBox(titleText.node()).height;}if(titleHeight){// buffer btwn colorbar and title\n// TODO: configurable\ntitleHeight+=5;if(opts.title.side==='top'){cbAxisOut.domain[1]-=titleHeight/gs.h;titleTrans[1]*=-1;}else{cbAxisOut.domain[0]+=titleHeight/gs.h;var nlines=svgTextUtils.lineCount(titleText);titleTrans[1]+=(1-nlines)*lineSize;}titleGroup.attr('transform','translate('+titleTrans+')');cbAxisOut.setScale();}}container.selectAll('.cbfills,.cblines').attr('transform','translate(0,'+Math.round(gs.h*(1-cbAxisOut.domain[1]))+')');axisLayer.attr('transform','translate(0,'+Math.round(-gs.t)+')');var fills=container.select('.cbfills').selectAll('rect.cbfill').data(filllevels);fills.enter().append('rect').classed(cn.cbfill,true).style('stroke','none');fills.exit().remove();var zBounds=zrange.map(cbAxisOut.c2p).map(Math.round).sort(function(a,b){return a-b;});fills.each(function(d,i){var z=[i===0?zrange[0]:(filllevels[i]+filllevels[i-1])/2,i===filllevels.length-1?zrange[1]:(filllevels[i]+filllevels[i+1])/2].map(cbAxisOut.c2p).map(Math.round);// offset the side adjoining the next rectangle so they\n// overlap, to prevent antialiasing gaps\nz[1]=Lib.constrain(z[1]+(z[1]>z[0])?1:-1,zBounds[0],zBounds[1]);// Colorbar cannot currently support opacities so we\n// use an opaque fill even when alpha channels present\nvar fillEl=d3.select(this).attr({x:xLeft,width:Math.max(thickPx,2),y:d3.min(z),height:Math.max(d3.max(z)-d3.min(z),2)});if(opts.fillgradient){Drawing.gradient(fillEl,gd,id,'vertical',opts.fillgradient,'fill');}else{// Tinycolor can't handle exponents and\n// at this scale, removing it makes no difference.\nvar colorString=fillcolormap(d).replace('e-','');fillEl.attr('fill',tinycolor(colorString).toHexString());}});var lines=container.select('.cblines').selectAll('path.cbline').data(opts.line.color&&opts.line.width?linelevels:[]);lines.enter().append('path').classed(cn.cbline,true);lines.exit().remove();lines.each(function(d){d3.select(this).attr('d','M'+xLeft+','+(Math.round(cbAxisOut.c2p(d))+opts.line.width/2%1)+'h'+thickPx).call(Drawing.lineGroupStyle,opts.line.width,linecolormap(d),opts.line.dash);});// force full redraw of labels and ticks\naxisLayer.selectAll('g.'+cbAxisOut._id+'tick,path').remove();// separate out axis and title drawing,\n// so we don't need such complicated logic in Titles.draw\n// if title is on the top or bottom, we've already drawn it\n// this title call only handles side=right\nreturn Lib.syncOrAsync([function(){var shift=xLeft+thickPx+(opts.outlinewidth||0)/2-(opts.ticks==='outside'?1:0);var vals=Axes.calcTicks(cbAxisOut);var transFn=Axes.makeTransFn(cbAxisOut);var tickSign=Axes.getTickSigns(cbAxisOut)[2];Axes.drawTicks(gd,cbAxisOut,{vals:cbAxisOut.ticks==='inside'?Axes.clipEnds(cbAxisOut,vals):vals,layer:axisLayer,path:Axes.makeTickPath(cbAxisOut,shift,tickSign),transFn:transFn});return Axes.drawLabels(gd,cbAxisOut,{vals:vals,layer:axisLayer,transFn:transFn,labelFns:Axes.makeLabelFns(cbAxisOut,shift)});},function(){if(['top','bottom'].indexOf(opts.title.side)===-1){var fontSize=cbAxisOut.title.font.size;var y=cbAxisOut._offset+cbAxisOut._length/2;var x=gs.l+(cbAxisOut.position||0)*gs.w+(cbAxisOut.side==='right'?10+fontSize*(cbAxisOut.showticklabels?1:0.5):-10-fontSize*(cbAxisOut.showticklabels?0.5:0));// the 'h' + is a hack to get around the fact that\n// convertToTspans rotates any 'y...' class by 90 degrees.\n// TODO: find a better way to control this.\ndrawTitle('h'+cbAxisOut._id+'title',{avoid:{selection:d3.select(gd).selectAll('g.'+cbAxisOut._id+'tick'),side:opts.title.side,offsetLeft:gs.l,offsetTop:0,maxShift:fullLayout.width},attributes:{x:x,y:y,'text-anchor':'middle'},transform:{rotate:'-90',offset:0}});}}]);}function drawTitle(titleClass,titleOpts){var dfltTitleOpts={propContainer:cbAxisOut,propName:getPropName('title'),traceIndex:getTrace().index,placeholder:fullLayout._dfltTitle.colorbar,containerGroup:container.select('.cbtitle')};// this class-to-rotate thing with convertToTspans is\n// getting hackier and hackier... delete groups with the\n// wrong class (in case earlier the colorbar was drawn on\n// a different side, I think?)\nvar otherClass=titleClass.charAt(0)==='h'?titleClass.substr(1):'h'+titleClass;container.selectAll('.'+otherClass+',.'+otherClass+'-math-group').remove();Titles.draw(gd,titleClass,extendFlat(dfltTitleOpts,titleOpts||{}));}function positionCB(){// wait for the axis & title to finish rendering before\n// continuing positioning\n// TODO: why are we redrawing multiple times now with this?\n// I guess autoMargin doesn't like being post-promise?\nvar innerWidth=thickPx+opts.outlinewidth/2+Drawing.bBox(axisLayer.node()).width;titleEl=titleCont.select('text');if(titleEl.node()&&!titleEl.classed(cn.jsPlaceholder)){var mathJaxNode=titleCont.select('.h'+cbAxisOut._id+'title-math-group').node();var titleWidth;if(mathJaxNode&&['top','bottom'].indexOf(opts.title.side)!==-1){titleWidth=Drawing.bBox(mathJaxNode).width;}else{// note: the formula below works for all title sides,\n// (except for top/bottom mathjax, above)\n// but the weird gs.l is because the titleunshift\n// transform gets removed by Drawing.bBox\ntitleWidth=Drawing.bBox(titleCont.node()).right-xLeft-gs.l;}innerWidth=Math.max(innerWidth,titleWidth);}var outerwidth=2*opts.xpad+innerWidth+opts.borderwidth+opts.outlinewidth/2;var outerheight=yBottomPx-yTopPx;container.select('.cbbg').attr({x:xLeft-opts.xpad-(opts.borderwidth+opts.outlinewidth)/2,y:yTopPx-yExtraPx,width:Math.max(outerwidth,2),height:Math.max(outerheight+2*yExtraPx,2)}).call(Color.fill,opts.bgcolor).call(Color.stroke,opts.bordercolor).style({'stroke-width':opts.borderwidth});container.selectAll('.cboutline').attr({x:xLeft,y:yTopPx+opts.ypad+(opts.title.side==='top'?titleHeight:0),width:Math.max(thickPx,2),height:Math.max(outerheight-2*opts.ypad-titleHeight,2)}).call(Color.stroke,opts.outlinecolor).style({fill:'None','stroke-width':opts.outlinewidth});// fix positioning for xanchor!='left'\nvar xoffset=({center:0.5,right:1}[opts.xanchor]||0)*outerwidth;container.attr('transform','translate('+(gs.l-xoffset)+','+gs.t+')');// auto margin adjustment\nvar marginOpts={};var tFrac=FROM_TL[opts.yanchor];var bFrac=FROM_BR[opts.yanchor];if(opts.lenmode==='pixels'){marginOpts.y=opts.y;marginOpts.t=outerheight*tFrac;marginOpts.b=outerheight*bFrac;}else{marginOpts.t=marginOpts.b=0;marginOpts.yt=opts.y+opts.len*tFrac;marginOpts.yb=opts.y-opts.len*bFrac;}var lFrac=FROM_TL[opts.xanchor];var rFrac=FROM_BR[opts.xanchor];if(opts.thicknessmode==='pixels'){marginOpts.x=opts.x;marginOpts.l=outerwidth*lFrac;marginOpts.r=outerwidth*rFrac;}else{var extraThickness=outerwidth-thickPx;marginOpts.l=extraThickness*lFrac;marginOpts.r=extraThickness*rFrac;marginOpts.xl=opts.x-opts.thickness*lFrac;marginOpts.xr=opts.x+opts.thickness*rFrac;}Plots.autoMargin(gd,id,marginOpts);}var cbDone=Lib.syncOrAsync([Plots.previousPromises,drawAxis,Plots.previousPromises,positionCB],gd);if(cbDone&&cbDone.then)(gd._promises||[]).push(cbDone);// dragging...\nif(gd._context.edits.colorbarPosition){var t0,xf,yf;dragElement.init({element:container.node(),gd:gd,prepFn:function prepFn(){t0=container.attr('transform');setCursor(container);},moveFn:function moveFn(dx,dy){container.attr('transform',t0+' '+'translate('+dx+','+dy+')');xf=dragElement.align(xLeftFrac+dx/gs.w,thickFrac,0,1,opts.xanchor);yf=dragElement.align(yBottomFrac-dy/gs.h,lenFrac,0,1,opts.yanchor);var csr=dragElement.getCursor(xf,yf,opts.xanchor,opts.yanchor);setCursor(container,csr);},doneFn:function doneFn(){setCursor(container);if(xf!==undefined&&yf!==undefined){var update={};update[getPropName('x')]=xf;update[getPropName('y')]=yf;Registry.call('_guiRestyle',gd,update,getTrace().index);}}});}return cbDone;}function getTrace(){var idNum=id.substr(2);for(var i=0;i<gd._fullData.length;i++){var trace=gd._fullData[i];if(trace.uid===idNum)return trace;}}function getPropName(suffix){var trace=getTrace();var propName='colorbar.';var containerName=trace._module.colorbar.container;if(containerName)propName=containerName+'.'+propName;return propName+suffix;}// setter/getters for every item defined in opts\nObject.keys(opts).forEach(function(name){component[name]=function(v){// getter\nif(!arguments.length)return opts[name];// setter - for multi-part properties,\n// set only the parts that are provided\nopts[name]=Lib.isPlainObject(opts[name])?Lib.extendFlat(opts[name],v):v;return component;};});// or use .options to set multiple options at once via a dictionary\ncomponent.options=function(o){for(var name in o){// in case something random comes through\n// that's not an option, ignore it\nif(typeof component[name]==='function'){component[name](o[name]);}}return component;};component._opts=opts;return component;};},{\"../../constants/alignment\":138,\"../../lib\":159,\"../../lib/extend\":153,\"../../lib/setcursor\":178,\"../../lib/svg_text_utils\":180,\"../../plots/cartesian/axes\":203,\"../../plots/cartesian/axis_defaults\":205,\"../../plots/cartesian/layout_attributes\":215,\"../../plots/cartesian/position_defaults\":218,\"../../plots/plots\":235,\"../../registry\":242,\"../color\":43,\"../dragelement\":61,\"../drawing\":64,\"../titles\":131,\"./attributes\":44,\"./constants\":46,\"d3\":8,\"tinycolor2\":26}],49:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');module.exports=function hasColorbar(container){return Lib.isPlainObject(container.colorbar);};},{\"../../lib\":159}],50:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var palettes=_dereq_('./scales.js').scales;var paletteStr=Object.keys(palettes);function code(s){return'`'+s+'`';}/**\n * Make colorscale attribute declarations for\n *\n * - colorscale,\n * - (c|z)auto, (c|z)min, (c|z)max,\n * - autocolorscale, reversescale,\n * - showscale (optionally)\n * - color (optionally)\n *\n * @param {string} context (dflt: '', i.e. from trace root):\n *     the container this is in ('', *marker*, *marker.line* etc)\n *\n * @param {object} opts:\n *   - cLetter {string} (dflt: 'c'):\n *     leading letter for 'min', 'max and 'auto' attribute (either 'z' or 'c')\n *\n *   - colorAttr {string} (dflt: 'z' if `cLetter: 'z'`, 'color' if `cLetter: 'c'`):\n *     (for descriptions) sets the name of the color attribute that maps to the colorscale.\n *\n *     N.B. if `colorAttr: 'color'`, we include the `color` declaration here.\n *\n *   - onlyIfNumerical {string} (dflt: false' if `cLetter: 'z'`, true if `cLetter: 'c'`):\n *     (for descriptions) set to true if colorscale attribute only\n *\n *   - colorscaleDflt {string}:\n *     overrides the colorscale dflt\n *\n *   - autoColorDflt {boolean} (dflt true):\n *     normally autocolorscale.dflt is `true`, but pass `false` to override\n *\n *   - noScale {boolean} (dflt: true if `context: 'marker.line'`, false otherwise):\n *     set to `false` to not include showscale attribute (e.g. for 'marker.line')\n *\n *   - showScaleDflt {boolean} (dflt: true if `cLetter: 'z'`, false otherwise)\n *\n *   - editTypeOverride {boolean} (dflt: ''):\n *     most of these attributes already require a recalc, but the ones that do not\n *     have editType *style* or *plot* unless you override (presumably with *calc*)\n *\n *   - anim {boolean) (dflt: undefined): is 'color' animatable?\n *\n * @return {object}\n */module.exports=function colorScaleAttrs(context,opts){context=context||'';opts=opts||{};var cLetter=opts.cLetter||'c';var onlyIfNumerical='onlyIfNumerical'in opts?opts.onlyIfNumerical:Boolean(context);var noScale='noScale'in opts?opts.noScale:context==='marker.line';var showScaleDflt='showScaleDflt'in opts?opts.showScaleDflt:cLetter==='z';var colorscaleDflt=typeof opts.colorscaleDflt==='string'?palettes[opts.colorscaleDflt]:null;var editTypeOverride=opts.editTypeOverride||'';var contextHead=context?context+'.':'';var colorAttr,colorAttrFull;if('colorAttr'in opts){colorAttr=opts.colorAttr;colorAttrFull=opts.colorAttr;}else{colorAttr={z:'z',c:'color'}[cLetter];colorAttrFull='in '+code(contextHead+colorAttr);}var effectDesc=onlyIfNumerical?' Has an effect only if '+colorAttrFull+'is set to a numerical array.':'';var auto=cLetter+'auto';var min=cLetter+'min';var max=cLetter+'max';var mid=cLetter+'mid';var autoFull=code(contextHead+auto);var minFull=code(contextHead+min);var maxFull=code(contextHead+max);var minmaxFull=minFull+' and '+maxFull;var autoImpliedEdits={};autoImpliedEdits[min]=autoImpliedEdits[max]=undefined;var minmaxImpliedEdits={};minmaxImpliedEdits[auto]=false;var attrs={};if(colorAttr==='color'){attrs.color={valType:'color',arrayOk:true,editType:editTypeOverride||'style'};if(opts.anim){attrs.color.anim=true;}}attrs[auto]={valType:'boolean',dflt:true,editType:'calc',impliedEdits:autoImpliedEdits};attrs[min]={valType:'number',dflt:null,editType:editTypeOverride||'plot',impliedEdits:minmaxImpliedEdits};attrs[max]={valType:'number',dflt:null,editType:editTypeOverride||'plot',impliedEdits:minmaxImpliedEdits};attrs[mid]={valType:'number',dflt:null,editType:'calc',impliedEdits:autoImpliedEdits};attrs.colorscale={valType:'colorscale',editType:'calc',dflt:colorscaleDflt,impliedEdits:{autocolorscale:false}};attrs.autocolorscale={valType:'boolean',// gets overrode in 'heatmap' & 'surface' for backwards comp.\ndflt:opts.autoColorDflt===false?false:true,editType:'calc',impliedEdits:{colorscale:undefined}};attrs.reversescale={valType:'boolean',dflt:false,editType:'plot'};if(!noScale){attrs.showscale={valType:'boolean',dflt:showScaleDflt,editType:'calc'};}return attrs;};},{\"./scales.js\":58}],51:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');module.exports=function calc(gd,trace,opts){var fullLayout=gd._fullLayout;var vals=opts.vals;var containerStr=opts.containerStr;var cLetter=opts.cLetter;var container=containerStr?Lib.nestedProperty(trace,containerStr).get():trace;var autoAttr=cLetter+'auto';var minAttr=cLetter+'min';var maxAttr=cLetter+'max';var midAttr=cLetter+'mid';var auto=container[autoAttr];var min=container[minAttr];var max=container[maxAttr];var mid=container[midAttr];var scl=container.colorscale;if(auto!==false||min===undefined){min=Lib.aggNums(Math.min,null,vals);}if(auto!==false||max===undefined){max=Lib.aggNums(Math.max,null,vals);}if(auto!==false&&mid!==undefined){if(max-mid>mid-min){min=mid-(max-mid);}else if(max-mid<mid-min){max=mid+(mid-min);}}if(min===max){min-=0.5;max+=0.5;}container['_'+minAttr]=container[minAttr]=min;container['_'+maxAttr]=container[maxAttr]=max;if(container.autocolorscale){if(min*max<0)scl=fullLayout.colorscale.diverging;else if(min>=0)scl=fullLayout.colorscale.sequential;else scl=fullLayout.colorscale.sequentialminus;container._colorscale=container.colorscale=scl;}};},{\"../../lib\":159}],52:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var hasColorscale=_dereq_('./helpers').hasColorscale;module.exports=function crossTraceDefaults(fullData){function replace(cont,k){var val=cont['_'+k];if(val!==undefined){cont[k]=val;}}function relinkColorAtts(trace,cAttrs){var cont=cAttrs.container?Lib.nestedProperty(trace,cAttrs.container).get():trace;if(cont){var isAuto=cont.zauto||cont.cauto;var minAttr=cAttrs.min;var maxAttr=cAttrs.max;if(isAuto||cont[minAttr]===undefined){replace(cont,minAttr);}if(isAuto||cont[maxAttr]===undefined){replace(cont,maxAttr);}if(cont.autocolorscale){replace(cont,'colorscale');}}}for(var i=0;i<fullData.length;i++){var trace=fullData[i];var colorbar=trace._module.colorbar;if(colorbar){if(Array.isArray(colorbar)){for(var j=0;j<colorbar.length;j++){relinkColorAtts(trace,colorbar[j]);}}else{relinkColorAtts(trace,colorbar);}}// TODO could generalize _module.colorscale and use it here?\nif(hasColorscale(trace,'marker.line')){relinkColorAtts(trace,{container:'marker.line',min:'cmin',max:'cmax'});}if(hasColorscale(trace,'line')){relinkColorAtts(trace,{container:'line',min:'cmin',max:'cmax'});}}};},{\"../../lib\":159,\"./helpers\":54}],53:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var isNumeric=_dereq_('fast-isnumeric');var Lib=_dereq_('../../lib');var hasColorbar=_dereq_('../colorbar/has_colorbar');var colorbarDefaults=_dereq_('../colorbar/defaults');var isValidScale=_dereq_('./scales').isValid;function npMaybe(cont,prefix){var containerStr=prefix.slice(0,prefix.length-1);return prefix?Lib.nestedProperty(cont,containerStr).get()||{}:cont;}module.exports=function colorScaleDefaults(traceIn,traceOut,layout,coerce,opts){var prefix=opts.prefix;var cLetter=opts.cLetter;var containerIn=npMaybe(traceIn,prefix);var containerOut=npMaybe(traceOut,prefix);var template=npMaybe(traceOut._template||{},prefix)||{};var minIn=containerIn[cLetter+'min'];var maxIn=containerIn[cLetter+'max'];var validMinMax=isNumeric(minIn)&&isNumeric(maxIn)&&minIn<maxIn;var auto=coerce(prefix+cLetter+'auto',!validMinMax);if(auto){coerce(prefix+cLetter+'mid');}else{coerce(prefix+cLetter+'min');coerce(prefix+cLetter+'max');}// handles both the trace case (autocolorscale is false by default) and\n// the marker and marker.line case (autocolorscale is true by default)\nvar sclIn=containerIn.colorscale;var sclTemplate=template.colorscale;var autoColorscaleDflt;if(sclIn!==undefined)autoColorscaleDflt=!isValidScale(sclIn);if(sclTemplate!==undefined)autoColorscaleDflt=!isValidScale(sclTemplate);coerce(prefix+'autocolorscale',autoColorscaleDflt);coerce(prefix+'colorscale');coerce(prefix+'reversescale');if(!opts.noScale&&prefix!=='marker.line.'){// handles both the trace case where the dflt is listed in attributes and\n// the marker case where the dflt is determined by hasColorbar\nvar showScaleDflt;if(prefix)showScaleDflt=hasColorbar(containerIn);var showScale=coerce(prefix+'showscale',showScaleDflt);if(showScale)colorbarDefaults(containerIn,containerOut,layout);}};},{\"../../lib\":159,\"../colorbar/defaults\":47,\"../colorbar/has_colorbar\":49,\"./scales\":58,\"fast-isnumeric\":10}],54:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var tinycolor=_dereq_('tinycolor2');var isNumeric=_dereq_('fast-isnumeric');var Lib=_dereq_('../../lib');var Color=_dereq_('../color');var isValidScale=_dereq_('./scales').isValid;function hasColorscale(trace,containerStr){var container=containerStr?Lib.nestedProperty(trace,containerStr).get()||{}:trace;var color=container.color;var isArrayWithOneNumber=false;if(Lib.isArrayOrTypedArray(color)){for(var i=0;i<color.length;i++){if(isNumeric(color[i])){isArrayWithOneNumber=true;break;}}}return Lib.isPlainObject(container)&&(isArrayWithOneNumber||container.showscale===true||isNumeric(container.cmin)&&isNumeric(container.cmax)||isValidScale(container.colorscale)||Lib.isPlainObject(container.colorbar));}/**\n * Extract colorscale into numeric domain and color range.\n *\n * @param {object} cont colorscale container (e.g. trace, marker)\n *  - colorscale {array of arrays}\n *  - cmin/zmin {number}\n *  - cmax/zmax {number}\n *  - reversescale {boolean}\n * @param {object} opts\n *  - cLetter {string} 'c' (for cmin/cmax) or 'z' (for zmin/zmax)\n *\n * @return {object}\n *  - domain {array}\n *  - range {array}\n */function extractScale(cont,opts){var cLetter=opts.cLetter;var scl=cont.reversescale?flipScale(cont.colorscale):cont.colorscale;// minimum color value (used to clamp scale)\nvar cmin=cont[cLetter+'min'];// maximum color value (used to clamp scale)\nvar cmax=cont[cLetter+'max'];var N=scl.length;var domain=new Array(N);var range=new Array(N);for(var i=0;i<N;i++){var si=scl[i];domain[i]=cmin+si[0]*(cmax-cmin);range[i]=si[1];}return{domain:domain,range:range};}function flipScale(scl){var N=scl.length;var sclNew=new Array(N);for(var i=N-1,j=0;i>=0;i--,j++){var si=scl[i];sclNew[j]=[1-si[0],si[1]];}return sclNew;}/**\n * General colorscale function generator.\n *\n * @param {object} specs output of Colorscale.extractScale or precomputed domain, range.\n *  - domain {array}\n *  - range {array}\n *\n * @param {object} opts\n *  - noNumericCheck {boolean} if true, scale func bypasses numeric checks\n *  - returnArray {boolean} if true, scale func return 4-item array instead of color strings\n *\n * @return {function}\n */function makeColorScaleFunc(specs,opts){opts=opts||{};var domain=specs.domain;var range=specs.range;var N=range.length;var _range=new Array(N);for(var i=0;i<N;i++){var rgba=tinycolor(range[i]).toRgb();_range[i]=[rgba.r,rgba.g,rgba.b,rgba.a];}var _sclFunc=d3.scale.linear().domain(domain).range(_range).clamp(true);var noNumericCheck=opts.noNumericCheck;var returnArray=opts.returnArray;var sclFunc;if(noNumericCheck&&returnArray){sclFunc=_sclFunc;}else if(noNumericCheck){sclFunc=function sclFunc(v){return colorArray2rbga(_sclFunc(v));};}else if(returnArray){sclFunc=function sclFunc(v){if(isNumeric(v))return _sclFunc(v);else if(tinycolor(v).isValid())return v;else return Color.defaultLine;};}else{sclFunc=function sclFunc(v){if(isNumeric(v))return colorArray2rbga(_sclFunc(v));else if(tinycolor(v).isValid())return v;else return Color.defaultLine;};}// colorbar draw looks into the d3 scale closure for domain and range\nsclFunc.domain=_sclFunc.domain;sclFunc.range=function(){return range;};return sclFunc;}function colorArray2rbga(colorArray){var colorObj={r:colorArray[0],g:colorArray[1],b:colorArray[2],a:colorArray[3]};return tinycolor(colorObj).toRgbString();}module.exports={hasColorscale:hasColorscale,extractScale:extractScale,flipScale:flipScale,makeColorScaleFunc:makeColorScaleFunc};},{\"../../lib\":159,\"../color\":43,\"./scales\":58,\"d3\":8,\"fast-isnumeric\":10,\"tinycolor2\":26}],55:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var scales=_dereq_('./scales');var helpers=_dereq_('./helpers');module.exports={moduleType:'component',name:'colorscale',attributes:_dereq_('./attributes'),layoutAttributes:_dereq_('./layout_attributes'),supplyLayoutDefaults:_dereq_('./layout_defaults'),handleDefaults:_dereq_('./defaults'),crossTraceDefaults:_dereq_('./cross_trace_defaults'),calc:_dereq_('./calc'),// ./scales.js is required in lib/coerce.js ;\n// it needs to be a seperate module to avoid circular a dependency\nscales:scales.scales,defaultScale:scales.defaultScale,getScale:scales.get,isValidScale:scales.isValid,hasColorscale:helpers.hasColorscale,flipScale:helpers.flipScale,extractScale:helpers.extractScale,makeColorScaleFunc:helpers.makeColorScaleFunc};},{\"./attributes\":50,\"./calc\":51,\"./cross_trace_defaults\":52,\"./defaults\":53,\"./helpers\":54,\"./layout_attributes\":56,\"./layout_defaults\":57,\"./scales\":58}],56:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var scales=_dereq_('./scales').scales;var msg='Note that `autocolorscale` must be true for this attribute to work.';module.exports={editType:'calc',sequential:{valType:'colorscale',dflt:scales.Reds,editType:'calc'},sequentialminus:{valType:'colorscale',dflt:scales.Blues,editType:'calc'},diverging:{valType:'colorscale',dflt:scales.RdBu,editType:'calc'}};},{\"./scales\":58}],57:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var colorscaleAttrs=_dereq_('./layout_attributes');var Template=_dereq_('../../plot_api/plot_template');module.exports=function supplyLayoutDefaults(layoutIn,layoutOut){var colorscaleIn=layoutIn.colorscale;var colorscaleOut=Template.newContainer(layoutOut,'colorscale');function coerce(attr,dflt){return Lib.coerce(colorscaleIn,colorscaleOut,colorscaleAttrs,attr,dflt);}coerce('sequential');coerce('sequentialminus');coerce('diverging');};},{\"../../lib\":159,\"../../plot_api/plot_template\":193,\"./layout_attributes\":56}],58:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var tinycolor=_dereq_('tinycolor2');var scales={'Greys':[[0,'rgb(0,0,0)'],[1,'rgb(255,255,255)']],'YlGnBu':[[0,'rgb(8,29,88)'],[0.125,'rgb(37,52,148)'],[0.25,'rgb(34,94,168)'],[0.375,'rgb(29,145,192)'],[0.5,'rgb(65,182,196)'],[0.625,'rgb(127,205,187)'],[0.75,'rgb(199,233,180)'],[0.875,'rgb(237,248,217)'],[1,'rgb(255,255,217)']],'Greens':[[0,'rgb(0,68,27)'],[0.125,'rgb(0,109,44)'],[0.25,'rgb(35,139,69)'],[0.375,'rgb(65,171,93)'],[0.5,'rgb(116,196,118)'],[0.625,'rgb(161,217,155)'],[0.75,'rgb(199,233,192)'],[0.875,'rgb(229,245,224)'],[1,'rgb(247,252,245)']],'YlOrRd':[[0,'rgb(128,0,38)'],[0.125,'rgb(189,0,38)'],[0.25,'rgb(227,26,28)'],[0.375,'rgb(252,78,42)'],[0.5,'rgb(253,141,60)'],[0.625,'rgb(254,178,76)'],[0.75,'rgb(254,217,118)'],[0.875,'rgb(255,237,160)'],[1,'rgb(255,255,204)']],'Bluered':[[0,'rgb(0,0,255)'],[1,'rgb(255,0,0)']],// modified RdBu based on\n// http://www.kennethmoreland.com/color-maps/\n'RdBu':[[0,'rgb(5,10,172)'],[0.35,'rgb(106,137,247)'],[0.5,'rgb(190,190,190)'],[0.6,'rgb(220,170,132)'],[0.7,'rgb(230,145,90)'],[1,'rgb(178,10,28)']],// Scale for non-negative numeric values\n'Reds':[[0,'rgb(220,220,220)'],[0.2,'rgb(245,195,157)'],[0.4,'rgb(245,160,105)'],[1,'rgb(178,10,28)']],// Scale for non-positive numeric values\n'Blues':[[0,'rgb(5,10,172)'],[0.35,'rgb(40,60,190)'],[0.5,'rgb(70,100,245)'],[0.6,'rgb(90,120,245)'],[0.7,'rgb(106,137,247)'],[1,'rgb(220,220,220)']],'Picnic':[[0,'rgb(0,0,255)'],[0.1,'rgb(51,153,255)'],[0.2,'rgb(102,204,255)'],[0.3,'rgb(153,204,255)'],[0.4,'rgb(204,204,255)'],[0.5,'rgb(255,255,255)'],[0.6,'rgb(255,204,255)'],[0.7,'rgb(255,153,255)'],[0.8,'rgb(255,102,204)'],[0.9,'rgb(255,102,102)'],[1,'rgb(255,0,0)']],'Rainbow':[[0,'rgb(150,0,90)'],[0.125,'rgb(0,0,200)'],[0.25,'rgb(0,25,255)'],[0.375,'rgb(0,152,255)'],[0.5,'rgb(44,255,150)'],[0.625,'rgb(151,255,0)'],[0.75,'rgb(255,234,0)'],[0.875,'rgb(255,111,0)'],[1,'rgb(255,0,0)']],'Portland':[[0,'rgb(12,51,131)'],[0.25,'rgb(10,136,186)'],[0.5,'rgb(242,211,56)'],[0.75,'rgb(242,143,56)'],[1,'rgb(217,30,30)']],'Jet':[[0,'rgb(0,0,131)'],[0.125,'rgb(0,60,170)'],[0.375,'rgb(5,255,255)'],[0.625,'rgb(255,255,0)'],[0.875,'rgb(250,0,0)'],[1,'rgb(128,0,0)']],'Hot':[[0,'rgb(0,0,0)'],[0.3,'rgb(230,0,0)'],[0.6,'rgb(255,210,0)'],[1,'rgb(255,255,255)']],'Blackbody':[[0,'rgb(0,0,0)'],[0.2,'rgb(230,0,0)'],[0.4,'rgb(230,210,0)'],[0.7,'rgb(255,255,255)'],[1,'rgb(160,200,255)']],'Earth':[[0,'rgb(0,0,130)'],[0.1,'rgb(0,180,180)'],[0.2,'rgb(40,210,40)'],[0.4,'rgb(230,230,50)'],[0.6,'rgb(120,70,20)'],[1,'rgb(255,255,255)']],'Electric':[[0,'rgb(0,0,0)'],[0.15,'rgb(30,0,100)'],[0.4,'rgb(120,0,100)'],[0.6,'rgb(160,90,0)'],[0.8,'rgb(230,200,0)'],[1,'rgb(255,250,220)']],'Viridis':[[0,'#440154'],[0.06274509803921569,'#48186a'],[0.12549019607843137,'#472d7b'],[0.18823529411764706,'#424086'],[0.25098039215686274,'#3b528b'],[0.3137254901960784,'#33638d'],[0.3764705882352941,'#2c728e'],[0.4392156862745098,'#26828e'],[0.5019607843137255,'#21918c'],[0.5647058823529412,'#1fa088'],[0.6274509803921569,'#28ae80'],[0.6901960784313725,'#3fbc73'],[0.7529411764705882,'#5ec962'],[0.8156862745098039,'#84d44b'],[0.8784313725490196,'#addc30'],[0.9411764705882353,'#d8e219'],[1,'#fde725']],'Cividis':[[0.000000,'rgb(0,32,76)'],[0.058824,'rgb(0,42,102)'],[0.117647,'rgb(0,52,110)'],[0.176471,'rgb(39,63,108)'],[0.235294,'rgb(60,74,107)'],[0.294118,'rgb(76,85,107)'],[0.352941,'rgb(91,95,109)'],[0.411765,'rgb(104,106,112)'],[0.470588,'rgb(117,117,117)'],[0.529412,'rgb(131,129,120)'],[0.588235,'rgb(146,140,120)'],[0.647059,'rgb(161,152,118)'],[0.705882,'rgb(176,165,114)'],[0.764706,'rgb(192,177,109)'],[0.823529,'rgb(209,191,102)'],[0.882353,'rgb(225,204,92)'],[0.941176,'rgb(243,219,79)'],[1.000000,'rgb(255,233,69)']]};var defaultScale=scales.RdBu;function getScale(scl,dflt){if(!dflt)dflt=defaultScale;if(!scl)return dflt;function parseScale(){try{scl=scales[scl]||JSON.parse(scl);}catch(e){scl=dflt;}}if(typeof scl==='string'){parseScale();// occasionally scl is double-JSON encoded...\nif(typeof scl==='string')parseScale();}if(!isValidScaleArray(scl))return dflt;return scl;}function isValidScaleArray(scl){var highestVal=0;if(!Array.isArray(scl)||scl.length<2)return false;if(!scl[0]||!scl[scl.length-1])return false;if(+scl[0][0]!==0||+scl[scl.length-1][0]!==1)return false;for(var i=0;i<scl.length;i++){var si=scl[i];if(si.length!==2||+si[0]<highestVal||!tinycolor(si[1]).isValid()){return false;}highestVal=+si[0];}return true;}function isValidScale(scl){if(scales[scl]!==undefined)return true;else return isValidScaleArray(scl);}module.exports={scales:scales,defaultScale:defaultScale,get:getScale,isValid:isValidScale};},{\"tinycolor2\":26}],59:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';// for automatic alignment on dragging, <1/3 means left align,\n// >2/3 means right, and between is center. Pick the right fraction\n// based on where you are, and return the fraction corresponding to\n// that position on the object\nmodule.exports=function align(v,dv,v0,v1,anchor){var vmin=(v-v0)/(v1-v0);var vmax=vmin+dv/(v1-v0);var vc=(vmin+vmax)/2;// explicitly specified anchor\nif(anchor==='left'||anchor==='bottom')return vmin;if(anchor==='center'||anchor==='middle')return vc;if(anchor==='right'||anchor==='top')return vmax;// automatic based on position\nif(vmin<2/3-vc)return vmin;if(vmax>4/3-vc)return vmax;return vc;};},{}],60:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');// set cursors pointing toward the closest corner/side,\n// to indicate alignment\n// x and y are 0-1, fractions of the plot area\nvar cursorset=[['sw-resize','s-resize','se-resize'],['w-resize','move','e-resize'],['nw-resize','n-resize','ne-resize']];module.exports=function getCursor(x,y,xanchor,yanchor){if(xanchor==='left')x=0;else if(xanchor==='center')x=1;else if(xanchor==='right')x=2;else x=Lib.constrain(Math.floor(x*3),0,2);if(yanchor==='bottom')y=0;else if(yanchor==='middle')y=1;else if(yanchor==='top')y=2;else y=Lib.constrain(Math.floor(y*3),0,2);return cursorset[y][x];};},{\"../../lib\":159}],61:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var mouseOffset=_dereq_('mouse-event-offset');var hasHover=_dereq_('has-hover');var supportsPassive=_dereq_('has-passive-events');var removeElement=_dereq_('../../lib').removeElement;var constants=_dereq_('../../plots/cartesian/constants');var interactConstants=_dereq_('../../constants/interactions');var dragElement=module.exports={};dragElement.align=_dereq_('./align');dragElement.getCursor=_dereq_('./cursor');var unhover=_dereq_('./unhover');dragElement.unhover=unhover.wrapped;dragElement.unhoverRaw=unhover.raw;/**\n * Abstracts click & drag interactions\n *\n * During the interaction, a \"coverSlip\" element - a transparent\n * div covering the whole page - is created, which has two key effects:\n * - Lets you drag beyond the boundaries of the plot itself without\n *   dropping (but if you drag all the way out of the browser window the\n *   interaction will end)\n * - Freezes the cursor: whatever mouse cursor the drag element had when the\n *   interaction started gets copied to the coverSlip for use until mouseup\n *\n * If the user executes a drag bigger than MINDRAG, callbacks will fire as:\n *      prepFn, moveFn (1 or more times), doneFn\n * If the user does not drag enough, prepFn and clickFn will fire.\n *\n * Note: If you cancel contextmenu, clickFn will fire even with a right click\n * (unlike native events) so you'll get a `plotly_click` event. Cancel context eg:\n *    gd.addEventListener('contextmenu', function(e) { e.preventDefault(); });\n * TODO: we should probably turn this into a `config` parameter, so we can fix it\n * such that if you *don't* cancel contextmenu, we can prevent partial drags, which\n * put you in a weird state.\n *\n * If the user clicks multiple times quickly, clickFn will fire each time\n * but numClicks will increase to help you recognize doubleclicks.\n *\n * @param {object} options with keys:\n *      element (required) the DOM element to drag\n *      prepFn (optional) function(event, startX, startY)\n *          executed on mousedown\n *          startX and startY are the clientX and clientY pixel position\n *          of the mousedown event\n *      moveFn (optional) function(dx, dy)\n *          executed on move, ONLY after we've exceeded MINDRAG\n *          (we keep executing moveFn if you move back to where you started)\n *          dx and dy are the net pixel offset of the drag,\n *          dragged is true/false, has the mouse moved enough to\n *          constitute a drag\n *      doneFn (optional) function(e)\n *          executed on mouseup, ONLY if we exceeded MINDRAG (so you can be\n *          sure that moveFn has been called at least once)\n *          numClicks is how many clicks we've registered within\n *          a doubleclick time\n *          e is the original mouseup event\n *      clickFn (optional) function(numClicks, e)\n *          executed on mouseup if we have NOT exceeded MINDRAG (ie moveFn\n *          has not been called at all)\n *          numClicks is how many clicks we've registered within\n *          a doubleclick time\n *          e is the original mousedown event\n *      clampFn (optional, function(dx, dy) return [dx2, dy2])\n *          Provide custom clamping function for small displacements.\n *          By default, clamping is done using `minDrag` to x and y displacements\n *          independently.\n */dragElement.init=function init(options){var gd=options.gd;var numClicks=1;var DBLCLICKDELAY=interactConstants.DBLCLICKDELAY;var element=options.element;var startX,startY,newMouseDownTime,cursor,dragCover,initialEvent,initialTarget,rightClick;if(!gd._mouseDownTime)gd._mouseDownTime=0;element.style.pointerEvents='all';element.onmousedown=onStart;if(!supportsPassive){element.ontouchstart=onStart;}else{if(element._ontouchstart){element.removeEventListener('touchstart',element._ontouchstart);}element._ontouchstart=onStart;element.addEventListener('touchstart',onStart,{passive:false});}function _clampFn(dx,dy,minDrag){if(Math.abs(dx)<minDrag)dx=0;if(Math.abs(dy)<minDrag)dy=0;return[dx,dy];}var clampFn=options.clampFn||_clampFn;function onStart(e){// make dragging and dragged into properties of gd\n// so that others can look at and modify them\ngd._dragged=false;gd._dragging=true;var offset=pointerOffset(e);startX=offset[0];startY=offset[1];initialTarget=e.target;initialEvent=e;rightClick=e.buttons===2||e.ctrlKey;// fix Fx.hover for touch events\nif(typeof e.clientX==='undefined'&&typeof e.clientY==='undefined'){e.clientX=startX;e.clientY=startY;}newMouseDownTime=new Date().getTime();if(newMouseDownTime-gd._mouseDownTime<DBLCLICKDELAY){// in a click train\nnumClicks+=1;}else{// new click train\nnumClicks=1;gd._mouseDownTime=newMouseDownTime;}if(options.prepFn)options.prepFn(e,startX,startY);if(hasHover&&!rightClick){dragCover=coverSlip();dragCover.style.cursor=window.getComputedStyle(element).cursor;}else if(!hasHover){// document acts as a dragcover for mobile, bc we can't create dragcover dynamically\ndragCover=document;cursor=window.getComputedStyle(document.documentElement).cursor;document.documentElement.style.cursor=window.getComputedStyle(element).cursor;}document.addEventListener('mouseup',onDone);document.addEventListener('touchend',onDone);if(options.dragmode!==false){e.preventDefault();document.addEventListener('mousemove',onMove);document.addEventListener('touchmove',onMove);}return;}function onMove(e){e.preventDefault();var offset=pointerOffset(e);var minDrag=options.minDrag||constants.MINDRAG;var dxdy=clampFn(offset[0]-startX,offset[1]-startY,minDrag);var dx=dxdy[0];var dy=dxdy[1];if(dx||dy){gd._dragged=true;dragElement.unhover(gd);}if(gd._dragged&&options.moveFn&&!rightClick){gd._dragdata={element:element,dx:dx,dy:dy};options.moveFn(dx,dy);}return;}function onDone(e){delete gd._dragdata;if(options.dragmode!==false){e.preventDefault();document.removeEventListener('mousemove',onMove);document.removeEventListener('touchmove',onMove);}document.removeEventListener('mouseup',onDone);document.removeEventListener('touchend',onDone);if(hasHover){removeElement(dragCover);}else if(cursor){dragCover.documentElement.style.cursor=cursor;cursor=null;}if(!gd._dragging){gd._dragged=false;return;}gd._dragging=false;// don't count as a dblClick unless the mouseUp is also within\n// the dblclick delay\nif(new Date().getTime()-gd._mouseDownTime>DBLCLICKDELAY){numClicks=Math.max(numClicks-1,1);}if(gd._dragged){if(options.doneFn)options.doneFn();}else{if(options.clickFn)options.clickFn(numClicks,initialEvent);// If we haven't dragged, this should be a click. But because of the\n// coverSlip changing the element, the natural system might not generate one,\n// so we need to make our own. But right clicks don't normally generate\n// click events, only contextmenu events, which happen on mousedown.\nif(!rightClick){var e2;try{e2=new MouseEvent('click',e);}catch(err){var offset=pointerOffset(e);e2=document.createEvent('MouseEvents');e2.initMouseEvent('click',e.bubbles,e.cancelable,e.view,e.detail,e.screenX,e.screenY,offset[0],offset[1],e.ctrlKey,e.altKey,e.shiftKey,e.metaKey,e.button,e.relatedTarget);}initialTarget.dispatchEvent(e2);}}gd._dragging=false;gd._dragged=false;return;}};function coverSlip(){var cover=document.createElement('div');cover.className='dragcover';var cStyle=cover.style;cStyle.position='fixed';cStyle.left=0;cStyle.right=0;cStyle.top=0;cStyle.bottom=0;cStyle.zIndex=999999999;cStyle.background='none';document.body.appendChild(cover);return cover;}dragElement.coverSlip=coverSlip;function pointerOffset(e){return mouseOffset(e.changedTouches?e.changedTouches[0]:e,document.body);}},{\"../../constants/interactions\":139,\"../../lib\":159,\"../../plots/cartesian/constants\":209,\"./align\":59,\"./cursor\":60,\"./unhover\":62,\"has-hover\":12,\"has-passive-events\":13,\"mouse-event-offset\":16}],62:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Events=_dereq_('../../lib/events');var throttle=_dereq_('../../lib/throttle');var getGraphDiv=_dereq_('../../lib/get_graph_div');var hoverConstants=_dereq_('../fx/constants');var unhover=module.exports={};unhover.wrapped=function(gd,evt,subplot){gd=getGraphDiv(gd);// Important, clear any queued hovers\nif(gd._fullLayout){throttle.clear(gd._fullLayout._uid+hoverConstants.HOVERID);}unhover.raw(gd,evt,subplot);};// remove hover effects on mouse out, and emit unhover event\nunhover.raw=function raw(gd,evt){var fullLayout=gd._fullLayout;var oldhoverdata=gd._hoverdata;if(!evt)evt={};if(evt.target&&Events.triggerHandler(gd,'plotly_beforehover',evt)===false){return;}fullLayout._hoverlayer.selectAll('g').remove();fullLayout._hoverlayer.selectAll('line').remove();fullLayout._hoverlayer.selectAll('circle').remove();gd._hoverdata=undefined;if(evt.target&&oldhoverdata){gd.emit('plotly_unhover',{event:evt,points:oldhoverdata});}};},{\"../../lib/events\":152,\"../../lib/get_graph_div\":157,\"../../lib/throttle\":181,\"../fx/constants\":76}],63:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';exports.dash={valType:'string',// string type usually doesn't take values... this one should really be\n// a special type or at least a special coercion function, from the GUI\n// you only get these values but elsewhere the user can supply a list of\n// dash lengths in px, and it will be honored\nvalues:['solid','dot','dash','longdash','dashdot','longdashdot'],dflt:'solid',editType:'style'};},{}],64:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var isNumeric=_dereq_('fast-isnumeric');var tinycolor=_dereq_('tinycolor2');var Registry=_dereq_('../../registry');var Color=_dereq_('../color');var Colorscale=_dereq_('../colorscale');var Lib=_dereq_('../../lib');var svgTextUtils=_dereq_('../../lib/svg_text_utils');var xmlnsNamespaces=_dereq_('../../constants/xmlns_namespaces');var alignment=_dereq_('../../constants/alignment');var LINE_SPACING=alignment.LINE_SPACING;var DESELECTDIM=_dereq_('../../constants/interactions').DESELECTDIM;var subTypes=_dereq_('../../traces/scatter/subtypes');var makeBubbleSizeFn=_dereq_('../../traces/scatter/make_bubble_size_func');var drawing=module.exports={};// -----------------------------------------------------\n// styling functions for plot elements\n// -----------------------------------------------------\ndrawing.font=function(s,family,size,color){// also allow the form font(s, {family, size, color})\nif(Lib.isPlainObject(family)){color=family.color;size=family.size;family=family.family;}if(family)s.style('font-family',family);if(size+1)s.style('font-size',size+'px');if(color)s.call(Color.fill,color);};/*\n * Positioning helpers\n * Note: do not use `setPosition` with <text> nodes modified by\n * `svgTextUtils.convertToTspans`. Use `svgTextUtils.positionText`\n * instead, so that <tspan.line> elements get updated to match.\n */drawing.setPosition=function(s,x,y){s.attr('x',x).attr('y',y);};drawing.setSize=function(s,w,h){s.attr('width',w).attr('height',h);};drawing.setRect=function(s,x,y,w,h){s.call(drawing.setPosition,x,y).call(drawing.setSize,w,h);};/** Translate node\n *\n * @param {object} d : calcdata point item\n * @param {sel} sel : d3 selction of node to translate\n * @param {object} xa : corresponding full xaxis object\n * @param {object} ya : corresponding full yaxis object\n *\n * @return {boolean} :\n *  true if selection got translated\n *  false if selection could not get translated\n */drawing.translatePoint=function(d,sel,xa,ya){var x=xa.c2p(d.x);var y=ya.c2p(d.y);if(isNumeric(x)&&isNumeric(y)&&sel.node()){// for multiline text this works better\nif(sel.node().nodeName==='text'){sel.attr('x',x).attr('y',y);}else{sel.attr('transform','translate('+x+','+y+')');}}else{return false;}return true;};drawing.translatePoints=function(s,xa,ya){s.each(function(d){var sel=d3.select(this);drawing.translatePoint(d,sel,xa,ya);});};drawing.hideOutsideRangePoint=function(d,sel,xa,ya,xcalendar,ycalendar){sel.attr('display',xa.isPtWithinRange(d,xcalendar)&&ya.isPtWithinRange(d,ycalendar)?null:'none');};drawing.hideOutsideRangePoints=function(traceGroups,subplot){if(!subplot._hasClipOnAxisFalse)return;var xa=subplot.xaxis;var ya=subplot.yaxis;traceGroups.each(function(d){var trace=d[0].trace;var xcalendar=trace.xcalendar;var ycalendar=trace.ycalendar;var selector=trace.type==='bar'?'.bartext':trace.type==='waterfall'?'.bartext,.line':'.point,.textpoint';traceGroups.selectAll(selector).each(function(d){drawing.hideOutsideRangePoint(d,d3.select(this),xa,ya,xcalendar,ycalendar);});});};drawing.crispRound=function(gd,lineWidth,dflt){// for lines that disable antialiasing we want to\n// make sure the width is an integer, and at least 1 if it's nonzero\nif(!lineWidth||!isNumeric(lineWidth))return dflt||0;// but not for static plots - these don't get antialiased anyway.\nif(gd._context.staticPlot)return lineWidth;if(lineWidth<1)return 1;return Math.round(lineWidth);};drawing.singleLineStyle=function(d,s,lw,lc,ld){s.style('fill','none');var line=(((d||[])[0]||{}).trace||{}).line||{};var lw1=lw||line.width||0;var dash=ld||line.dash||'';Color.stroke(s,lc||line.color);drawing.dashLine(s,dash,lw1);};drawing.lineGroupStyle=function(s,lw,lc,ld){s.style('fill','none').each(function(d){var line=(((d||[])[0]||{}).trace||{}).line||{};var lw1=lw||line.width||0;var dash=ld||line.dash||'';d3.select(this).call(Color.stroke,lc||line.color).call(drawing.dashLine,dash,lw1);});};drawing.dashLine=function(s,dash,lineWidth){lineWidth=+lineWidth||0;dash=drawing.dashStyle(dash,lineWidth);s.style({'stroke-dasharray':dash,'stroke-width':lineWidth+'px'});};drawing.dashStyle=function(dash,lineWidth){lineWidth=+lineWidth||1;var dlw=Math.max(lineWidth,3);if(dash==='solid')dash='';else if(dash==='dot')dash=dlw+'px,'+dlw+'px';else if(dash==='dash')dash=3*dlw+'px,'+3*dlw+'px';else if(dash==='longdash')dash=5*dlw+'px,'+5*dlw+'px';else if(dash==='dashdot'){dash=3*dlw+'px,'+dlw+'px,'+dlw+'px,'+dlw+'px';}else if(dash==='longdashdot'){dash=5*dlw+'px,'+2*dlw+'px,'+dlw+'px,'+2*dlw+'px';}// otherwise user wrote the dasharray themselves - leave it be\nreturn dash;};// Same as fillGroupStyle, except in this case the selection may be a transition\ndrawing.singleFillStyle=function(sel){var node=d3.select(sel.node());var data=node.data();var fillcolor=(((data[0]||[])[0]||{}).trace||{}).fillcolor;if(fillcolor){sel.call(Color.fill,fillcolor);}};drawing.fillGroupStyle=function(s){s.style('stroke-width',0).each(function(d){var shape=d3.select(this);// N.B. 'd' won't be a calcdata item when\n// fill !== 'none' on a segment-less and marker-less trace\nif(d[0].trace){shape.call(Color.fill,d[0].trace.fillcolor);}});};var SYMBOLDEFS=_dereq_('./symbol_defs');drawing.symbolNames=[];drawing.symbolFuncs=[];drawing.symbolNeedLines={};drawing.symbolNoDot={};drawing.symbolNoFill={};drawing.symbolList=[];Object.keys(SYMBOLDEFS).forEach(function(k){var symDef=SYMBOLDEFS[k];drawing.symbolList=drawing.symbolList.concat([symDef.n,k,symDef.n+100,k+'-open']);drawing.symbolNames[symDef.n]=k;drawing.symbolFuncs[symDef.n]=symDef.f;if(symDef.needLine){drawing.symbolNeedLines[symDef.n]=true;}if(symDef.noDot){drawing.symbolNoDot[symDef.n]=true;}else{drawing.symbolList=drawing.symbolList.concat([symDef.n+200,k+'-dot',symDef.n+300,k+'-open-dot']);}if(symDef.noFill){drawing.symbolNoFill[symDef.n]=true;}});var MAXSYMBOL=drawing.symbolNames.length;// add a dot in the middle of the symbol\nvar DOTPATH='M0,0.5L0.5,0L0,-0.5L-0.5,0Z';drawing.symbolNumber=function(v){if(typeof v==='string'){var vbase=0;if(v.indexOf('-open')>0){vbase=100;v=v.replace('-open','');}if(v.indexOf('-dot')>0){vbase+=200;v=v.replace('-dot','');}v=drawing.symbolNames.indexOf(v);if(v>=0){v+=vbase;}}if(v%100>=MAXSYMBOL||v>=400){return 0;}return Math.floor(Math.max(v,0));};function makePointPath(symbolNumber,r){var base=symbolNumber%100;return drawing.symbolFuncs[base](r)+(symbolNumber>=200?DOTPATH:'');}var HORZGRADIENT={x1:1,x2:0,y1:0,y2:0};var VERTGRADIENT={x1:0,x2:0,y1:1,y2:0};var stopFormatter=d3.format('~.1f');var gradientInfo={radial:{node:'radialGradient'},radialreversed:{node:'radialGradient',reversed:true},horizontal:{node:'linearGradient',attrs:HORZGRADIENT},horizontalreversed:{node:'linearGradient',attrs:HORZGRADIENT,reversed:true},vertical:{node:'linearGradient',attrs:VERTGRADIENT},verticalreversed:{node:'linearGradient',attrs:VERTGRADIENT,reversed:true}};/**\n * gradient: create and apply a gradient fill\n *\n * @param {object} sel: d3 selection to apply this gradient to\n *     You can use `selection.call(Drawing.gradient, ...)`\n * @param {DOM element} gd: the graph div `sel` is part of\n * @param {string} gradientID: a unique (within this plot) identifier\n *     for this gradient, so that we don't create unnecessary definitions\n * @param {string} type: 'radial', 'horizontal', or 'vertical', optionally with\n *     'reversed' at the end. Normally radial goes center to edge,\n *     horizontal goes right to left, and vertical goes bottom to top\n * @param {array} colorscale: as in attribute values, [[fraction, color], ...]\n * @param {string} prop: the property to apply to, 'fill' or 'stroke'\n */drawing.gradient=function(sel,gd,gradientID,type,colorscale,prop){var len=colorscale.length;var info=gradientInfo[type];var colorStops=new Array(len);for(var i=0;i<len;i++){if(info.reversed){colorStops[len-1-i]=[stopFormatter((1-colorscale[i][0])*100),colorscale[i][1]];}else{colorStops[i]=[stopFormatter(colorscale[i][0]*100),colorscale[i][1]];}}var fullID='g'+gd._fullLayout._uid+'-'+gradientID;var gradient=gd._fullLayout._defs.select('.gradients').selectAll('#'+fullID).data([type+colorStops.join(';')],Lib.identity);gradient.exit().remove();gradient.enter().append(info.node).each(function(){var el=d3.select(this);if(info.attrs)el.attr(info.attrs);el.attr('id',fullID);var stops=el.selectAll('stop').data(colorStops);stops.exit().remove();stops.enter().append('stop');stops.each(function(d){var tc=tinycolor(d[1]);d3.select(this).attr({offset:d[0]+'%','stop-color':Color.tinyRGB(tc),'stop-opacity':tc.getAlpha()});});});sel.style(prop,getFullUrl(fullID,gd)).style(prop+'-opacity',null);};/*\n * Make the gradients container and clear out any previous gradients.\n * We never collect all the gradients we need in one place,\n * so we can't ever remove gradients that have stopped being useful,\n * except all at once before a full redraw.\n * The upside of this is arbitrary points can share gradient defs\n */drawing.initGradients=function(gd){var gradientsGroup=Lib.ensureSingle(gd._fullLayout._defs,'g','gradients');gradientsGroup.selectAll('linearGradient,radialGradient').remove();};drawing.pointStyle=function(s,trace,gd){if(!s.size())return;var fns=drawing.makePointStyleFns(trace);s.each(function(d){drawing.singlePointStyle(d,d3.select(this),trace,fns,gd);});};drawing.singlePointStyle=function(d,sel,trace,fns,gd){var marker=trace.marker;var markerLine=marker.line;sel.style('opacity',fns.selectedOpacityFn?fns.selectedOpacityFn(d):d.mo===undefined?marker.opacity:d.mo);if(fns.ms2mrc){var r;// handle multi-trace graph edit case\nif(d.ms==='various'||marker.size==='various'){r=3;}else{r=fns.ms2mrc(d.ms);}// store the calculated size so hover can use it\nd.mrc=r;if(fns.selectedSizeFn){r=d.mrc=fns.selectedSizeFn(d);}// turn the symbol into a sanitized number\nvar x=drawing.symbolNumber(d.mx||marker.symbol)||0;// save if this marker is open\n// because that impacts how to handle colors\nd.om=x%200>=100;sel.attr('d',makePointPath(x,r));}var perPointGradient=false;var fillColor,lineColor,lineWidth;// 'so' is suspected outliers, for box plots\nif(d.so){lineWidth=markerLine.outlierwidth;lineColor=markerLine.outliercolor;fillColor=marker.outliercolor;}else{var markerLineWidth=(markerLine||{}).width;lineWidth=(d.mlw+1||markerLineWidth+1||// TODO: we need the latter for legends... can we get rid of it?\n(d.trace?(d.trace.marker.line||{}).width:0)+1)-1||0;if('mlc'in d)lineColor=d.mlcc=fns.lineScale(d.mlc);// weird case: array wasn't long enough to apply to every point\nelse if(Lib.isArrayOrTypedArray(markerLine.color))lineColor=Color.defaultLine;else lineColor=markerLine.color;if(Lib.isArrayOrTypedArray(marker.color)){fillColor=Color.defaultLine;perPointGradient=true;}if('mc'in d){fillColor=d.mcc=fns.markerScale(d.mc);}else{fillColor=marker.color||'rgba(0,0,0,0)';}if(fns.selectedColorFn){fillColor=fns.selectedColorFn(d);}}if(d.om){// open markers can't have zero linewidth, default to 1px,\n// and use fill color as stroke color\nsel.call(Color.stroke,fillColor).style({'stroke-width':(lineWidth||1)+'px',fill:'none'});}else{sel.style('stroke-width',lineWidth+'px');var markerGradient=marker.gradient;var gradientType=d.mgt;if(gradientType)perPointGradient=true;else gradientType=markerGradient&&markerGradient.type;// for legend - arrays will propagate through here, but we don't need\n// to treat it as per-point.\nif(Array.isArray(gradientType)){gradientType=gradientType[0];if(!gradientInfo[gradientType])gradientType=0;}if(gradientType&&gradientType!=='none'){var gradientColor=d.mgc;if(gradientColor)perPointGradient=true;else gradientColor=markerGradient.color;var gradientID=trace.uid;if(perPointGradient)gradientID+='-'+d.i;drawing.gradient(sel,gd,gradientID,gradientType,[[0,gradientColor],[1,fillColor]],'fill');}else{Color.fill(sel,fillColor);}if(lineWidth){Color.stroke(sel,lineColor);}}};drawing.makePointStyleFns=function(trace){var out={};var marker=trace.marker;// allow array marker and marker line colors to be\n// scaled by given max and min to colorscales\nout.markerScale=drawing.tryColorscale(marker,'');out.lineScale=drawing.tryColorscale(marker,'line');if(Registry.traceIs(trace,'symbols')){out.ms2mrc=subTypes.isBubble(trace)?makeBubbleSizeFn(trace):function(){return(marker.size||6)/2;};}if(trace.selectedpoints){Lib.extendFlat(out,drawing.makeSelectedPointStyleFns(trace));}return out;};drawing.makeSelectedPointStyleFns=function(trace){var out={};var selectedAttrs=trace.selected||{};var unselectedAttrs=trace.unselected||{};var marker=trace.marker||{};var selectedMarker=selectedAttrs.marker||{};var unselectedMarker=unselectedAttrs.marker||{};var mo=marker.opacity;var smo=selectedMarker.opacity;var usmo=unselectedMarker.opacity;var smoIsDefined=smo!==undefined;var usmoIsDefined=usmo!==undefined;if(Lib.isArrayOrTypedArray(mo)||smoIsDefined||usmoIsDefined){out.selectedOpacityFn=function(d){var base=d.mo===undefined?marker.opacity:d.mo;if(d.selected){return smoIsDefined?smo:base;}else{return usmoIsDefined?usmo:DESELECTDIM*base;}};}var mc=marker.color;var smc=selectedMarker.color;var usmc=unselectedMarker.color;if(smc||usmc){out.selectedColorFn=function(d){var base=d.mcc||mc;if(d.selected){return smc||base;}else{return usmc||base;}};}var ms=marker.size;var sms=selectedMarker.size;var usms=unselectedMarker.size;var smsIsDefined=sms!==undefined;var usmsIsDefined=usms!==undefined;if(Registry.traceIs(trace,'symbols')&&(smsIsDefined||usmsIsDefined)){out.selectedSizeFn=function(d){var base=d.mrc||ms/2;if(d.selected){return smsIsDefined?sms/2:base;}else{return usmsIsDefined?usms/2:base;}};}return out;};drawing.makeSelectedTextStyleFns=function(trace){var out={};var selectedAttrs=trace.selected||{};var unselectedAttrs=trace.unselected||{};var textFont=trace.textfont||{};var selectedTextFont=selectedAttrs.textfont||{};var unselectedTextFont=unselectedAttrs.textfont||{};var tc=textFont.color;var stc=selectedTextFont.color;var utc=unselectedTextFont.color;out.selectedTextColorFn=function(d){var base=d.tc||tc;if(d.selected){return stc||base;}else{if(utc)return utc;else return stc?base:Color.addOpacity(base,DESELECTDIM);}};return out;};drawing.selectedPointStyle=function(s,trace){if(!s.size()||!trace.selectedpoints)return;var fns=drawing.makeSelectedPointStyleFns(trace);var marker=trace.marker||{};var seq=[];if(fns.selectedOpacityFn){seq.push(function(pt,d){pt.style('opacity',fns.selectedOpacityFn(d));});}if(fns.selectedColorFn){seq.push(function(pt,d){Color.fill(pt,fns.selectedColorFn(d));});}if(fns.selectedSizeFn){seq.push(function(pt,d){var mx=d.mx||marker.symbol||0;var mrc2=fns.selectedSizeFn(d);pt.attr('d',makePointPath(drawing.symbolNumber(mx),mrc2));// save for Drawing.selectedTextStyle\nd.mrc2=mrc2;});}if(seq.length){s.each(function(d){var pt=d3.select(this);for(var i=0;i<seq.length;i++){seq[i](pt,d);}});}};drawing.tryColorscale=function(marker,prefix){var cont=prefix?Lib.nestedProperty(marker,prefix).get():marker;if(cont){var scl=cont.colorscale;var colorArray=cont.color;if(scl&&Lib.isArrayOrTypedArray(colorArray)){return Colorscale.makeColorScaleFunc(Colorscale.extractScale(cont,{cLetter:'c'}));}}return Lib.identity;};var TEXTOFFSETSIGN={start:1,end:-1,middle:0,bottom:1,top:-1};function textPointPosition(s,textPosition,fontSize,markerRadius){var group=d3.select(s.node().parentNode);var v=textPosition.indexOf('top')!==-1?'top':textPosition.indexOf('bottom')!==-1?'bottom':'middle';var h=textPosition.indexOf('left')!==-1?'end':textPosition.indexOf('right')!==-1?'start':'middle';// if markers are shown, offset a little more than\n// the nominal marker size\n// ie 2/1.6 * nominal, bcs some markers are a bit bigger\nvar r=markerRadius?markerRadius/0.8+1:0;var numLines=(svgTextUtils.lineCount(s)-1)*LINE_SPACING+1;var dx=TEXTOFFSETSIGN[h]*r;var dy=fontSize*0.75+TEXTOFFSETSIGN[v]*r+(TEXTOFFSETSIGN[v]-1)*numLines*fontSize/2;// fix the overall text group position\ns.attr('text-anchor',h);group.attr('transform','translate('+dx+','+dy+')');}function extracTextFontSize(d,trace){var fontSize=d.ts||trace.textfont.size;return isNumeric(fontSize)&&fontSize>0?fontSize:0;}// draw text at points\ndrawing.textPointStyle=function(s,trace,gd){if(!s.size())return;var selectedTextColorFn;if(trace.selectedpoints){var fns=drawing.makeSelectedTextStyleFns(trace);selectedTextColorFn=fns.selectedTextColorFn;}s.each(function(d){var p=d3.select(this);var text=Lib.extractOption(d,trace,'tx','text');if(!text&&text!==0){p.remove();return;}var pos=d.tp||trace.textposition;var fontSize=extracTextFontSize(d,trace);var fontColor=selectedTextColorFn?selectedTextColorFn(d):d.tc||trace.textfont.color;p.call(drawing.font,d.tf||trace.textfont.family,fontSize,fontColor).text(text).call(svgTextUtils.convertToTspans,gd).call(textPointPosition,pos,fontSize,d.mrc);});};drawing.selectedTextStyle=function(s,trace){if(!s.size()||!trace.selectedpoints)return;var fns=drawing.makeSelectedTextStyleFns(trace);s.each(function(d){var tx=d3.select(this);var tc=fns.selectedTextColorFn(d);var tp=d.tp||trace.textposition;var fontSize=extracTextFontSize(d,trace);Color.fill(tx,tc);textPointPosition(tx,tp,fontSize,d.mrc2||d.mrc);});};// generalized Catmull-Rom splines, per\n// http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\nvar CatmullRomExp=0.5;drawing.smoothopen=function(pts,smoothness){if(pts.length<3){return'M'+pts.join('L');}var path='M'+pts[0];var tangents=[];var i;for(i=1;i<pts.length-1;i++){tangents.push(makeTangent(pts[i-1],pts[i],pts[i+1],smoothness));}path+='Q'+tangents[0][0]+' '+pts[1];for(i=2;i<pts.length-1;i++){path+='C'+tangents[i-2][1]+' '+tangents[i-1][0]+' '+pts[i];}path+='Q'+tangents[pts.length-3][1]+' '+pts[pts.length-1];return path;};drawing.smoothclosed=function(pts,smoothness){if(pts.length<3){return'M'+pts.join('L')+'Z';}var path='M'+pts[0];var pLast=pts.length-1;var tangents=[makeTangent(pts[pLast],pts[0],pts[1],smoothness)];var i;for(i=1;i<pLast;i++){tangents.push(makeTangent(pts[i-1],pts[i],pts[i+1],smoothness));}tangents.push(makeTangent(pts[pLast-1],pts[pLast],pts[0],smoothness));for(i=1;i<=pLast;i++){path+='C'+tangents[i-1][1]+' '+tangents[i][0]+' '+pts[i];}path+='C'+tangents[pLast][1]+' '+tangents[0][0]+' '+pts[0]+'Z';return path;};function makeTangent(prevpt,thispt,nextpt,smoothness){var d1x=prevpt[0]-thispt[0];var d1y=prevpt[1]-thispt[1];var d2x=nextpt[0]-thispt[0];var d2y=nextpt[1]-thispt[1];var d1a=Math.pow(d1x*d1x+d1y*d1y,CatmullRomExp/2);var d2a=Math.pow(d2x*d2x+d2y*d2y,CatmullRomExp/2);var numx=(d2a*d2a*d1x-d1a*d1a*d2x)*smoothness;var numy=(d2a*d2a*d1y-d1a*d1a*d2y)*smoothness;var denom1=3*d2a*(d1a+d2a);var denom2=3*d1a*(d1a+d2a);return[[d3.round(thispt[0]+(denom1&&numx/denom1),2),d3.round(thispt[1]+(denom1&&numy/denom1),2)],[d3.round(thispt[0]-(denom2&&numx/denom2),2),d3.round(thispt[1]-(denom2&&numy/denom2),2)]];}// step paths - returns a generator function for paths\n// with the given step shape\nvar STEPPATH={hv:function hv(p0,p1){return'H'+d3.round(p1[0],2)+'V'+d3.round(p1[1],2);},vh:function vh(p0,p1){return'V'+d3.round(p1[1],2)+'H'+d3.round(p1[0],2);},hvh:function hvh(p0,p1){return'H'+d3.round((p0[0]+p1[0])/2,2)+'V'+d3.round(p1[1],2)+'H'+d3.round(p1[0],2);},vhv:function vhv(p0,p1){return'V'+d3.round((p0[1]+p1[1])/2,2)+'H'+d3.round(p1[0],2)+'V'+d3.round(p1[1],2);}};var STEPLINEAR=function STEPLINEAR(p0,p1){return'L'+d3.round(p1[0],2)+','+d3.round(p1[1],2);};drawing.steps=function(shape){var onestep=STEPPATH[shape]||STEPLINEAR;return function(pts){var path='M'+d3.round(pts[0][0],2)+','+d3.round(pts[0][1],2);for(var i=1;i<pts.length;i++){path+=onestep(pts[i-1],pts[i]);}return path;};};// off-screen svg render testing element, shared by the whole page\n// uses the id 'js-plotly-tester' and stores it in drawing.tester\ndrawing.makeTester=function(){var tester=Lib.ensureSingleById(d3.select('body'),'svg','js-plotly-tester',function(s){s.attr(xmlnsNamespaces.svgAttrs).style({position:'absolute',left:'-10000px',top:'-10000px',width:'9000px',height:'9000px','z-index':'1'});});// browsers differ on how they describe the bounding rect of\n// the svg if its contents spill over... so make a 1x1px\n// reference point we can measure off of.\nvar testref=Lib.ensureSingle(tester,'path','js-reference-point',function(s){s.attr('d','M0,0H1V1H0Z').style({'stroke-width':0,fill:'black'});});drawing.tester=tester;drawing.testref=testref;};/*\n * use our offscreen tester to get a clientRect for an element,\n * in a reference frame where it isn't translated (or transformed) and\n * its anchor point is at (0,0)\n * always returns a copy of the bbox, so the caller can modify it safely\n *\n * @param {SVGElement} node: the element to measure. If possible this should be\n *   a <text> or MathJax <g> element that's already passed through\n *   `convertToTspans` because in that case we can cache the results, but it's\n *   possible to pass in any svg element.\n *\n * @param {boolean} inTester: is this element already in `drawing.tester`?\n *   If you are measuring a dummy element, rather than one you really intend\n *   to use on the plot, making it in `drawing.tester` in the first place\n *   allows us to test faster because it cuts out cloning and appending it.\n *\n * @param {string} hash: for internal use only, if we already know the cache key\n *   for this element beforehand.\n *\n * @return {object}: a plain object containing the width, height, left, right,\n *   top, and bottom of `node`\n */drawing.savedBBoxes={};var savedBBoxesCount=0;var maxSavedBBoxes=10000;drawing.bBox=function(node,inTester,hash){/*\n     * Cache elements we've already measured so we don't have to\n     * remeasure the same thing many times\n     * We have a few bBox callers though who pass a node larger than\n     * a <text> or a MathJax <g>, such as an axis group containing many labels.\n     * These will not generate a hash (unless we figure out an appropriate\n     * hash key for them) and thus we will not hash them.\n     */if(!hash)hash=nodeHash(node);var out;if(hash){out=drawing.savedBBoxes[hash];if(out)return Lib.extendFlat({},out);}else if(node.childNodes.length===1){/*\n         * If we have only one child element, which is itself hashable, make\n         * a new hash from this element plus its x,y,transform\n         * These bounding boxes *include* x,y,transform - mostly for use by\n         * callers trying to avoid overlaps (ie titles)\n         */var innerNode=node.childNodes[0];hash=nodeHash(innerNode);if(hash){var x=+innerNode.getAttribute('x')||0;var y=+innerNode.getAttribute('y')||0;var transform=innerNode.getAttribute('transform');if(!transform){// in this case, just varying x and y, don't bother caching\n// the final bBox because the alteration is quick.\nvar innerBB=drawing.bBox(innerNode,false,hash);if(x){innerBB.left+=x;innerBB.right+=x;}if(y){innerBB.top+=y;innerBB.bottom+=y;}return innerBB;}/*\n             * else we have a transform - rather than make a complicated\n             * (and error-prone and probably slow) transform parser/calculator,\n             * just continue on calculating the boundingClientRect of the group\n             * and use the new composite hash to cache it.\n             * That said, `innerNode.transform.baseVal` is an array of\n             * `SVGTransform` objects, that *do* seem to have a nice matrix\n             * multiplication interface that we could use to avoid making\n             * another getBoundingClientRect call...\n             */hash+='~'+x+'~'+y+'~'+transform;out=drawing.savedBBoxes[hash];if(out)return Lib.extendFlat({},out);}}var testNode,tester;if(inTester){testNode=node;}else{tester=drawing.tester.node();// copy the node to test into the tester\ntestNode=node.cloneNode(true);tester.appendChild(testNode);}// standardize its position (and newline tspans if any)\nd3.select(testNode).attr('transform',null).call(svgTextUtils.positionText,0,0);var testRect=testNode.getBoundingClientRect();var refRect=drawing.testref.node().getBoundingClientRect();if(!inTester)tester.removeChild(testNode);var bb={height:testRect.height,width:testRect.width,left:testRect.left-refRect.left,top:testRect.top-refRect.top,right:testRect.right-refRect.left,bottom:testRect.bottom-refRect.top};// make sure we don't have too many saved boxes,\n// or a long session could overload on memory\n// by saving boxes for long-gone elements\nif(savedBBoxesCount>=maxSavedBBoxes){drawing.savedBBoxes={};savedBBoxesCount=0;}// cache this bbox\nif(hash)drawing.savedBBoxes[hash]=bb;savedBBoxesCount++;return Lib.extendFlat({},bb);};// capture everything about a node (at least in our usage) that\n// impacts its bounding box, given that bBox clears x, y, and transform\nfunction nodeHash(node){var inputText=node.getAttribute('data-unformatted');if(inputText===null)return;return inputText+node.getAttribute('data-math')+node.getAttribute('text-anchor')+node.getAttribute('style');}/**\n * Set clipPath URL in a way that work for all situations.\n *\n * In details, graphs on pages with <base> HTML tags need to prepend\n * the clip path ids with the page's base url EXCEPT during toImage exports.\n *\n * @param {d3 selection} s : node to add clip-path attribute\n * @param {string} localId : local clip-path (w/o base url) id\n * @param {DOM element || object} gd\n * - context._baseUrl {string}\n * - context._exportedPlot {boolean}\n */drawing.setClipUrl=function(s,localId,gd){s.attr('clip-path',getFullUrl(localId,gd));};function getFullUrl(localId,gd){if(!localId)return null;var context=gd._context;var baseUrl=context._exportedPlot?'':context._baseUrl||'';return'url(\\''+baseUrl+'#'+localId+'\\')';}drawing.getTranslate=function(element){// Note the separator [^\\d] between x and y in this regex\n// We generally use ',' but IE will convert it to ' '\nvar re=/.*\\btranslate\\((-?\\d*\\.?\\d*)[^-\\d]*(-?\\d*\\.?\\d*)[^\\d].*/;var getter=element.attr?'attr':'getAttribute';var transform=element[getter]('transform')||'';var translate=transform.replace(re,function(match,p1,p2){return[p1,p2].join(' ');}).split(' ');return{x:+translate[0]||0,y:+translate[1]||0};};drawing.setTranslate=function(element,x,y){var re=/(\\btranslate\\(.*?\\);?)/;var getter=element.attr?'attr':'getAttribute';var setter=element.attr?'attr':'setAttribute';var transform=element[getter]('transform')||'';x=x||0;y=y||0;transform=transform.replace(re,'').trim();transform+=' translate('+x+', '+y+')';transform=transform.trim();element[setter]('transform',transform);return transform;};drawing.getScale=function(element){var re=/.*\\bscale\\((\\d*\\.?\\d*)[^\\d]*(\\d*\\.?\\d*)[^\\d].*/;var getter=element.attr?'attr':'getAttribute';var transform=element[getter]('transform')||'';var translate=transform.replace(re,function(match,p1,p2){return[p1,p2].join(' ');}).split(' ');return{x:+translate[0]||1,y:+translate[1]||1};};drawing.setScale=function(element,x,y){var re=/(\\bscale\\(.*?\\);?)/;var getter=element.attr?'attr':'getAttribute';var setter=element.attr?'attr':'setAttribute';var transform=element[getter]('transform')||'';x=x||1;y=y||1;transform=transform.replace(re,'').trim();transform+=' scale('+x+', '+y+')';transform=transform.trim();element[setter]('transform',transform);return transform;};var SCALE_RE=/\\s*sc.*/;drawing.setPointGroupScale=function(selection,xScale,yScale){xScale=xScale||1;yScale=yScale||1;if(!selection)return;// The same scale transform for every point:\nvar scale=xScale===1&&yScale===1?'':' scale('+xScale+','+yScale+')';selection.each(function(){var t=(this.getAttribute('transform')||'').replace(SCALE_RE,'');t+=scale;t=t.trim();this.setAttribute('transform',t);});};var TEXT_POINT_LAST_TRANSLATION_RE=/translate\\([^)]*\\)\\s*$/;drawing.setTextPointsScale=function(selection,xScale,yScale){if(!selection)return;selection.each(function(){var transforms;var el=d3.select(this);var text=el.select('text');if(!text.node())return;var x=parseFloat(text.attr('x')||0);var y=parseFloat(text.attr('y')||0);var existingTransform=(el.attr('transform')||'').match(TEXT_POINT_LAST_TRANSLATION_RE);if(xScale===1&&yScale===1){transforms=[];}else{transforms=['translate('+x+','+y+')','scale('+xScale+','+yScale+')','translate('+-x+','+-y+')'];}if(existingTransform){transforms.push(existingTransform);}el.attr('transform',transforms.join(' '));});};},{\"../../constants/alignment\":138,\"../../constants/interactions\":139,\"../../constants/xmlns_namespaces\":141,\"../../lib\":159,\"../../lib/svg_text_utils\":180,\"../../registry\":242,\"../../traces/scatter/make_bubble_size_func\":297,\"../../traces/scatter/subtypes\":304,\"../color\":43,\"../colorscale\":55,\"./symbol_defs\":65,\"d3\":8,\"fast-isnumeric\":10,\"tinycolor2\":26}],65:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');/** Marker symbol definitions\n * users can specify markers either by number or name\n * add 100 (or '-open') and you get an open marker\n *  open markers have no fill and use line color as the stroke color\n * add 200 (or '-dot') and you get a dot in the middle\n * add both and you get both\n */module.exports={circle:{n:0,f:function f(r){var rs=d3.round(r,2);return'M'+rs+',0A'+rs+','+rs+' 0 1,1 0,-'+rs+'A'+rs+','+rs+' 0 0,1 '+rs+',0Z';}},square:{n:1,f:function f(r){var rs=d3.round(r,2);return'M'+rs+','+rs+'H-'+rs+'V-'+rs+'H'+rs+'Z';}},diamond:{n:2,f:function f(r){var rd=d3.round(r*1.3,2);return'M'+rd+',0L0,'+rd+'L-'+rd+',0L0,-'+rd+'Z';}},cross:{n:3,f:function f(r){var rc=d3.round(r*0.4,2);var rc2=d3.round(r*1.2,2);return'M'+rc2+','+rc+'H'+rc+'V'+rc2+'H-'+rc+'V'+rc+'H-'+rc2+'V-'+rc+'H-'+rc+'V-'+rc2+'H'+rc+'V-'+rc+'H'+rc2+'Z';}},x:{n:4,f:function f(r){var rx=d3.round(r*0.8/Math.sqrt(2),2);var ne='l'+rx+','+rx;var se='l'+rx+',-'+rx;var sw='l-'+rx+',-'+rx;var nw='l-'+rx+','+rx;return'M0,'+rx+ne+se+sw+se+sw+nw+sw+nw+ne+nw+ne+'Z';}},'triangle-up':{n:5,f:function f(r){var rt=d3.round(r*2/Math.sqrt(3),2);var r2=d3.round(r/2,2);var rs=d3.round(r,2);return'M-'+rt+','+r2+'H'+rt+'L0,-'+rs+'Z';}},'triangle-down':{n:6,f:function f(r){var rt=d3.round(r*2/Math.sqrt(3),2);var r2=d3.round(r/2,2);var rs=d3.round(r,2);return'M-'+rt+',-'+r2+'H'+rt+'L0,'+rs+'Z';}},'triangle-left':{n:7,f:function f(r){var rt=d3.round(r*2/Math.sqrt(3),2);var r2=d3.round(r/2,2);var rs=d3.round(r,2);return'M'+r2+',-'+rt+'V'+rt+'L-'+rs+',0Z';}},'triangle-right':{n:8,f:function f(r){var rt=d3.round(r*2/Math.sqrt(3),2);var r2=d3.round(r/2,2);var rs=d3.round(r,2);return'M-'+r2+',-'+rt+'V'+rt+'L'+rs+',0Z';}},'triangle-ne':{n:9,f:function f(r){var r1=d3.round(r*0.6,2);var r2=d3.round(r*1.2,2);return'M-'+r2+',-'+r1+'H'+r1+'V'+r2+'Z';}},'triangle-se':{n:10,f:function f(r){var r1=d3.round(r*0.6,2);var r2=d3.round(r*1.2,2);return'M'+r1+',-'+r2+'V'+r1+'H-'+r2+'Z';}},'triangle-sw':{n:11,f:function f(r){var r1=d3.round(r*0.6,2);var r2=d3.round(r*1.2,2);return'M'+r2+','+r1+'H-'+r1+'V-'+r2+'Z';}},'triangle-nw':{n:12,f:function f(r){var r1=d3.round(r*0.6,2);var r2=d3.round(r*1.2,2);return'M-'+r1+','+r2+'V-'+r1+'H'+r2+'Z';}},pentagon:{n:13,f:function f(r){var x1=d3.round(r*0.951,2);var x2=d3.round(r*0.588,2);var y0=d3.round(-r,2);var y1=d3.round(r*-0.309,2);var y2=d3.round(r*0.809,2);return'M'+x1+','+y1+'L'+x2+','+y2+'H-'+x2+'L-'+x1+','+y1+'L0,'+y0+'Z';}},hexagon:{n:14,f:function f(r){var y0=d3.round(r,2);var y1=d3.round(r/2,2);var x=d3.round(r*Math.sqrt(3)/2,2);return'M'+x+',-'+y1+'V'+y1+'L0,'+y0+'L-'+x+','+y1+'V-'+y1+'L0,-'+y0+'Z';}},hexagon2:{n:15,f:function f(r){var x0=d3.round(r,2);var x1=d3.round(r/2,2);var y=d3.round(r*Math.sqrt(3)/2,2);return'M-'+x1+','+y+'H'+x1+'L'+x0+',0L'+x1+',-'+y+'H-'+x1+'L-'+x0+',0Z';}},octagon:{n:16,f:function f(r){var a=d3.round(r*0.924,2);var b=d3.round(r*0.383,2);return'M-'+b+',-'+a+'H'+b+'L'+a+',-'+b+'V'+b+'L'+b+','+a+'H-'+b+'L-'+a+','+b+'V-'+b+'Z';}},star:{n:17,f:function f(r){var rs=r*1.4;var x1=d3.round(rs*0.225,2);var x2=d3.round(rs*0.951,2);var x3=d3.round(rs*0.363,2);var x4=d3.round(rs*0.588,2);var y0=d3.round(-rs,2);var y1=d3.round(rs*-0.309,2);var y3=d3.round(rs*0.118,2);var y4=d3.round(rs*0.809,2);var y5=d3.round(rs*0.382,2);return'M'+x1+','+y1+'H'+x2+'L'+x3+','+y3+'L'+x4+','+y4+'L0,'+y5+'L-'+x4+','+y4+'L-'+x3+','+y3+'L-'+x2+','+y1+'H-'+x1+'L0,'+y0+'Z';}},hexagram:{n:18,f:function f(r){var y=d3.round(r*0.66,2);var x1=d3.round(r*0.38,2);var x2=d3.round(r*0.76,2);return'M-'+x2+',0l-'+x1+',-'+y+'h'+x2+'l'+x1+',-'+y+'l'+x1+','+y+'h'+x2+'l-'+x1+','+y+'l'+x1+','+y+'h-'+x2+'l-'+x1+','+y+'l-'+x1+',-'+y+'h-'+x2+'Z';}},'star-triangle-up':{n:19,f:function f(r){var x=d3.round(r*Math.sqrt(3)*0.8,2);var y1=d3.round(r*0.8,2);var y2=d3.round(r*1.6,2);var rc=d3.round(r*4,2);var aPart='A '+rc+','+rc+' 0 0 1 ';return'M-'+x+','+y1+aPart+x+','+y1+aPart+'0,-'+y2+aPart+'-'+x+','+y1+'Z';}},'star-triangle-down':{n:20,f:function f(r){var x=d3.round(r*Math.sqrt(3)*0.8,2);var y1=d3.round(r*0.8,2);var y2=d3.round(r*1.6,2);var rc=d3.round(r*4,2);var aPart='A '+rc+','+rc+' 0 0 1 ';return'M'+x+',-'+y1+aPart+'-'+x+',-'+y1+aPart+'0,'+y2+aPart+x+',-'+y1+'Z';}},'star-square':{n:21,f:function f(r){var rp=d3.round(r*1.1,2);var rc=d3.round(r*2,2);var aPart='A '+rc+','+rc+' 0 0 1 ';return'M-'+rp+',-'+rp+aPart+'-'+rp+','+rp+aPart+rp+','+rp+aPart+rp+',-'+rp+aPart+'-'+rp+',-'+rp+'Z';}},'star-diamond':{n:22,f:function f(r){var rp=d3.round(r*1.4,2);var rc=d3.round(r*1.9,2);var aPart='A '+rc+','+rc+' 0 0 1 ';return'M-'+rp+',0'+aPart+'0,'+rp+aPart+rp+',0'+aPart+'0,-'+rp+aPart+'-'+rp+',0'+'Z';}},'diamond-tall':{n:23,f:function f(r){var x=d3.round(r*0.7,2);var y=d3.round(r*1.4,2);return'M0,'+y+'L'+x+',0L0,-'+y+'L-'+x+',0Z';}},'diamond-wide':{n:24,f:function f(r){var x=d3.round(r*1.4,2);var y=d3.round(r*0.7,2);return'M0,'+y+'L'+x+',0L0,-'+y+'L-'+x+',0Z';}},hourglass:{n:25,f:function f(r){var rs=d3.round(r,2);return'M'+rs+','+rs+'H-'+rs+'L'+rs+',-'+rs+'H-'+rs+'Z';},noDot:true},bowtie:{n:26,f:function f(r){var rs=d3.round(r,2);return'M'+rs+','+rs+'V-'+rs+'L-'+rs+','+rs+'V-'+rs+'Z';},noDot:true},'circle-cross':{n:27,f:function f(r){var rs=d3.round(r,2);return'M0,'+rs+'V-'+rs+'M'+rs+',0H-'+rs+'M'+rs+',0A'+rs+','+rs+' 0 1,1 0,-'+rs+'A'+rs+','+rs+' 0 0,1 '+rs+',0Z';},needLine:true,noDot:true},'circle-x':{n:28,f:function f(r){var rs=d3.round(r,2);var rc=d3.round(r/Math.sqrt(2),2);return'M'+rc+','+rc+'L-'+rc+',-'+rc+'M'+rc+',-'+rc+'L-'+rc+','+rc+'M'+rs+',0A'+rs+','+rs+' 0 1,1 0,-'+rs+'A'+rs+','+rs+' 0 0,1 '+rs+',0Z';},needLine:true,noDot:true},'square-cross':{n:29,f:function f(r){var rs=d3.round(r,2);return'M0,'+rs+'V-'+rs+'M'+rs+',0H-'+rs+'M'+rs+','+rs+'H-'+rs+'V-'+rs+'H'+rs+'Z';},needLine:true,noDot:true},'square-x':{n:30,f:function f(r){var rs=d3.round(r,2);return'M'+rs+','+rs+'L-'+rs+',-'+rs+'M'+rs+',-'+rs+'L-'+rs+','+rs+'M'+rs+','+rs+'H-'+rs+'V-'+rs+'H'+rs+'Z';},needLine:true,noDot:true},'diamond-cross':{n:31,f:function f(r){var rd=d3.round(r*1.3,2);return'M'+rd+',0L0,'+rd+'L-'+rd+',0L0,-'+rd+'Z'+'M0,-'+rd+'V'+rd+'M-'+rd+',0H'+rd;},needLine:true,noDot:true},'diamond-x':{n:32,f:function f(r){var rd=d3.round(r*1.3,2);var r2=d3.round(r*0.65,2);return'M'+rd+',0L0,'+rd+'L-'+rd+',0L0,-'+rd+'Z'+'M-'+r2+',-'+r2+'L'+r2+','+r2+'M-'+r2+','+r2+'L'+r2+',-'+r2;},needLine:true,noDot:true},'cross-thin':{n:33,f:function f(r){var rc=d3.round(r*1.4,2);return'M0,'+rc+'V-'+rc+'M'+rc+',0H-'+rc;},needLine:true,noDot:true,noFill:true},'x-thin':{n:34,f:function f(r){var rx=d3.round(r,2);return'M'+rx+','+rx+'L-'+rx+',-'+rx+'M'+rx+',-'+rx+'L-'+rx+','+rx;},needLine:true,noDot:true,noFill:true},asterisk:{n:35,f:function f(r){var rc=d3.round(r*1.2,2);var rs=d3.round(r*0.85,2);return'M0,'+rc+'V-'+rc+'M'+rc+',0H-'+rc+'M'+rs+','+rs+'L-'+rs+',-'+rs+'M'+rs+',-'+rs+'L-'+rs+','+rs;},needLine:true,noDot:true,noFill:true},hash:{n:36,f:function f(r){var r1=d3.round(r/2,2);var r2=d3.round(r,2);return'M'+r1+','+r2+'V-'+r2+'m-'+r2+',0V'+r2+'M'+r2+','+r1+'H-'+r2+'m0,-'+r2+'H'+r2;},needLine:true,noFill:true},'y-up':{n:37,f:function f(r){var x=d3.round(r*1.2,2);var y0=d3.round(r*1.6,2);var y1=d3.round(r*0.8,2);return'M-'+x+','+y1+'L0,0M'+x+','+y1+'L0,0M0,-'+y0+'L0,0';},needLine:true,noDot:true,noFill:true},'y-down':{n:38,f:function f(r){var x=d3.round(r*1.2,2);var y0=d3.round(r*1.6,2);var y1=d3.round(r*0.8,2);return'M-'+x+',-'+y1+'L0,0M'+x+',-'+y1+'L0,0M0,'+y0+'L0,0';},needLine:true,noDot:true,noFill:true},'y-left':{n:39,f:function f(r){var y=d3.round(r*1.2,2);var x0=d3.round(r*1.6,2);var x1=d3.round(r*0.8,2);return'M'+x1+','+y+'L0,0M'+x1+',-'+y+'L0,0M-'+x0+',0L0,0';},needLine:true,noDot:true,noFill:true},'y-right':{n:40,f:function f(r){var y=d3.round(r*1.2,2);var x0=d3.round(r*1.6,2);var x1=d3.round(r*0.8,2);return'M-'+x1+','+y+'L0,0M-'+x1+',-'+y+'L0,0M'+x0+',0L0,0';},needLine:true,noDot:true,noFill:true},'line-ew':{n:41,f:function f(r){var rc=d3.round(r*1.4,2);return'M'+rc+',0H-'+rc;},needLine:true,noDot:true,noFill:true},'line-ns':{n:42,f:function f(r){var rc=d3.round(r*1.4,2);return'M0,'+rc+'V-'+rc;},needLine:true,noDot:true,noFill:true},'line-ne':{n:43,f:function f(r){var rx=d3.round(r,2);return'M'+rx+',-'+rx+'L-'+rx+','+rx;},needLine:true,noDot:true,noFill:true},'line-nw':{n:44,f:function f(r){var rx=d3.round(r,2);return'M'+rx+','+rx+'L-'+rx+',-'+rx;},needLine:true,noDot:true,noFill:true}};},{\"d3\":8}],66:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports={visible:{valType:'boolean',editType:'calc'},type:{valType:'enumerated',values:['percent','constant','sqrt','data'],editType:'calc'},symmetric:{valType:'boolean',editType:'calc'},array:{valType:'data_array',editType:'calc'},arrayminus:{valType:'data_array',editType:'calc'},value:{valType:'number',min:0,dflt:10,editType:'calc'},valueminus:{valType:'number',min:0,dflt:10,editType:'calc'},traceref:{valType:'integer',min:0,dflt:0,editType:'style'},tracerefminus:{valType:'integer',min:0,dflt:0,editType:'style'},copy_ystyle:{valType:'boolean',editType:'plot'},copy_zstyle:{valType:'boolean',editType:'style'},color:{valType:'color',editType:'style'},thickness:{valType:'number',min:0,dflt:2,editType:'style'},width:{valType:'number',min:0,editType:'plot'},editType:'calc',_deprecated:{opacity:{valType:'number',editType:'style'}}};},{}],67:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var isNumeric=_dereq_('fast-isnumeric');var Registry=_dereq_('../../registry');var Axes=_dereq_('../../plots/cartesian/axes');var Lib=_dereq_('../../lib');var makeComputeError=_dereq_('./compute_error');module.exports=function calc(gd){var calcdata=gd.calcdata;for(var i=0;i<calcdata.length;i++){var calcTrace=calcdata[i];var trace=calcTrace[0].trace;if(trace.visible===true&&Registry.traceIs(trace,'errorBarsOK')){var xa=Axes.getFromId(gd,trace.xaxis);var ya=Axes.getFromId(gd,trace.yaxis);calcOneAxis(calcTrace,trace,xa,'x');calcOneAxis(calcTrace,trace,ya,'y');}}};function calcOneAxis(calcTrace,trace,axis,coord){var opts=trace['error_'+coord]||{};var isVisible=opts.visible&&['linear','log'].indexOf(axis.type)!==-1;var vals=[];if(!isVisible)return;var computeError=makeComputeError(opts);for(var i=0;i<calcTrace.length;i++){var calcPt=calcTrace[i];var iIn=calcPt.i;// for types that don't include `i` in each calcdata point\nif(iIn===undefined)iIn=i;// for stacked area inserted points\n// TODO: errorbars have been tested cursorily with stacked area,\n// but not thoroughly. It's not even really clear what you want to do:\n// Should it just be calculated based on that trace's size data?\n// Should you add errors from below in quadrature?\n// And what about normalization, where in principle the errors shrink\n// again when you get up to the top end?\n// One option would be to forbid errorbars with stacking until we\n// decide how to handle these questions.\nelse if(iIn===null)continue;var calcCoord=calcPt[coord];if(!isNumeric(axis.c2l(calcCoord)))continue;var errors=computeError(calcCoord,iIn);if(isNumeric(errors[0])&&isNumeric(errors[1])){var shoe=calcPt[coord+'s']=calcCoord-errors[0];var hat=calcPt[coord+'h']=calcCoord+errors[1];vals.push(shoe,hat);}}var axId=axis._id;var baseExtremes=trace._extremes[axId];var extremes=Axes.findExtremes(axis,vals,Lib.extendFlat({tozero:baseExtremes.opts.tozero},{padded:true}));baseExtremes.min=baseExtremes.min.concat(extremes.min);baseExtremes.max=baseExtremes.max.concat(extremes.max);}},{\"../../lib\":159,\"../../plots/cartesian/axes\":203,\"../../registry\":242,\"./compute_error\":68,\"fast-isnumeric\":10}],68:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';/**\n * Error bar computing function generator\n *\n * N.B. The generated function does not clean the dataPt entries. Non-numeric\n * entries result in undefined error magnitudes.\n *\n * @param {object} opts error bar attributes\n *\n * @return {function} :\n *      @param {numeric} dataPt data point from where to compute the error magnitude\n *      @param {number} index index of dataPt in its corresponding data array\n *      @return {array}\n *        - error[0] : error magnitude in the negative direction\n *        - error[1] : \" \" \" \" positive \"\n */module.exports=function makeComputeError(opts){var type=opts.type;var symmetric=opts.symmetric;if(type==='data'){var array=opts.array||[];if(symmetric){return function computeError(dataPt,index){var val=+array[index];return[val,val];};}else{var arrayminus=opts.arrayminus||[];return function computeError(dataPt,index){var val=+array[index];var valMinus=+arrayminus[index];// in case one is present and the other is missing, fill in 0\n// so we still see the present one. Mostly useful during manual\n// data entry.\nif(!isNaN(val)||!isNaN(valMinus)){return[valMinus||0,val||0];}return[NaN,NaN];};}}else{var computeErrorValue=makeComputeErrorValue(type,opts.value);var computeErrorValueMinus=makeComputeErrorValue(type,opts.valueminus);if(symmetric||opts.valueminus===undefined){return function computeError(dataPt){var val=computeErrorValue(dataPt);return[val,val];};}else{return function computeError(dataPt){return[computeErrorValueMinus(dataPt),computeErrorValue(dataPt)];};}}};/**\n * Compute error bar magnitude (for all types except data)\n *\n * @param {string} type error bar type\n * @param {numeric} value error bar value\n *\n * @return {function} :\n *      @param {numeric} dataPt\n */function makeComputeErrorValue(type,value){if(type==='percent'){return function(dataPt){return Math.abs(dataPt*value/100);};}if(type==='constant'){return function(){return Math.abs(value);};}if(type==='sqrt'){return function(dataPt){return Math.sqrt(Math.abs(dataPt));};}}},{}],69:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var isNumeric=_dereq_('fast-isnumeric');var Registry=_dereq_('../../registry');var Lib=_dereq_('../../lib');var Template=_dereq_('../../plot_api/plot_template');var attributes=_dereq_('./attributes');module.exports=function(traceIn,traceOut,defaultColor,opts){var objName='error_'+opts.axis;var containerOut=Template.newContainer(traceOut,objName);var containerIn=traceIn[objName]||{};function coerce(attr,dflt){return Lib.coerce(containerIn,containerOut,attributes,attr,dflt);}var hasErrorBars=containerIn.array!==undefined||containerIn.value!==undefined||containerIn.type==='sqrt';var visible=coerce('visible',hasErrorBars);if(visible===false)return;var type=coerce('type','array'in containerIn?'data':'percent');var symmetric=true;if(type!=='sqrt'){symmetric=coerce('symmetric',!((type==='data'?'arrayminus':'valueminus')in containerIn));}if(type==='data'){coerce('array');coerce('traceref');if(!symmetric){coerce('arrayminus');coerce('tracerefminus');}}else if(type==='percent'||type==='constant'){coerce('value');if(!symmetric)coerce('valueminus');}var copyAttr='copy_'+opts.inherit+'style';if(opts.inherit){var inheritObj=traceOut['error_'+opts.inherit];if((inheritObj||{}).visible){coerce(copyAttr,!(containerIn.color||isNumeric(containerIn.thickness)||isNumeric(containerIn.width)));}}if(!opts.inherit||!containerOut[copyAttr]){coerce('color',defaultColor);coerce('thickness');coerce('width',Registry.traceIs(traceOut,'gl3d')?0:4);}};},{\"../../lib\":159,\"../../plot_api/plot_template\":193,\"../../registry\":242,\"./attributes\":66,\"fast-isnumeric\":10}],70:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var overrideAll=_dereq_('../../plot_api/edit_types').overrideAll;var attributes=_dereq_('./attributes');var xyAttrs={error_x:Lib.extendFlat({},attributes),error_y:Lib.extendFlat({},attributes)};delete xyAttrs.error_x.copy_zstyle;delete xyAttrs.error_y.copy_zstyle;delete xyAttrs.error_y.copy_ystyle;var xyzAttrs={error_x:Lib.extendFlat({},attributes),error_y:Lib.extendFlat({},attributes),error_z:Lib.extendFlat({},attributes)};delete xyzAttrs.error_x.copy_ystyle;delete xyzAttrs.error_y.copy_ystyle;delete xyzAttrs.error_z.copy_ystyle;delete xyzAttrs.error_z.copy_zstyle;module.exports={moduleType:'component',name:'errorbars',schema:{traces:{scatter:xyAttrs,bar:xyAttrs,histogram:xyAttrs,scatter3d:overrideAll(xyzAttrs,'calc','nested'),scattergl:overrideAll(xyAttrs,'calc','nested')}},supplyDefaults:_dereq_('./defaults'),calc:_dereq_('./calc'),makeComputeError:_dereq_('./compute_error'),plot:_dereq_('./plot'),style:_dereq_('./style'),hoverInfo:hoverInfo};function hoverInfo(calcPoint,trace,hoverPoint){if((trace.error_y||{}).visible){hoverPoint.yerr=calcPoint.yh-calcPoint.y;if(!trace.error_y.symmetric)hoverPoint.yerrneg=calcPoint.y-calcPoint.ys;}if((trace.error_x||{}).visible){hoverPoint.xerr=calcPoint.xh-calcPoint.x;if(!trace.error_x.symmetric)hoverPoint.xerrneg=calcPoint.x-calcPoint.xs;}}},{\"../../lib\":159,\"../../plot_api/edit_types\":186,\"./attributes\":66,\"./calc\":67,\"./compute_error\":68,\"./defaults\":69,\"./plot\":71,\"./style\":72}],71:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var isNumeric=_dereq_('fast-isnumeric');var Drawing=_dereq_('../drawing');var subTypes=_dereq_('../../traces/scatter/subtypes');module.exports=function plot(gd,traces,plotinfo,transitionOpts){var isNew;var xa=plotinfo.xaxis;var ya=plotinfo.yaxis;var hasAnimation=transitionOpts&&transitionOpts.duration>0;traces.each(function(d){var trace=d[0].trace;// || {} is in case the trace (specifically scatterternary)\n// doesn't support error bars at all, but does go through\n// the scatter.plot mechanics, which calls ErrorBars.plot\n// internally\nvar xObj=trace.error_x||{};var yObj=trace.error_y||{};var keyFunc;if(trace.ids){keyFunc=function keyFunc(d){return d.id;};}var sparse=subTypes.hasMarkers(trace)&&trace.marker.maxdisplayed>0;if(!yObj.visible&&!xObj.visible)d=[];var errorbars=d3.select(this).selectAll('g.errorbar').data(d,keyFunc);errorbars.exit().remove();if(!d.length)return;if(!xObj.visible)errorbars.selectAll('path.xerror').remove();if(!yObj.visible)errorbars.selectAll('path.yerror').remove();errorbars.style('opacity',1);var enter=errorbars.enter().append('g').classed('errorbar',true);if(hasAnimation){enter.style('opacity',0).transition().duration(transitionOpts.duration).style('opacity',1);}Drawing.setClipUrl(errorbars,plotinfo.layerClipId,gd);errorbars.each(function(d){var errorbar=d3.select(this);var coords=errorCoords(d,xa,ya);if(sparse&&!d.vis)return;var path;var yerror=errorbar.select('path.yerror');if(yObj.visible&&isNumeric(coords.x)&&isNumeric(coords.yh)&&isNumeric(coords.ys)){var yw=yObj.width;path='M'+(coords.x-yw)+','+coords.yh+'h'+2*yw+// hat\n'm-'+yw+',0V'+coords.ys;// bar\nif(!coords.noYS)path+='m-'+yw+',0h'+2*yw;// shoe\nisNew=!yerror.size();if(isNew){yerror=errorbar.append('path').style('vector-effect','non-scaling-stroke').classed('yerror',true);}else if(hasAnimation){yerror=yerror.transition().duration(transitionOpts.duration).ease(transitionOpts.easing);}yerror.attr('d',path);}else yerror.remove();var xerror=errorbar.select('path.xerror');if(xObj.visible&&isNumeric(coords.y)&&isNumeric(coords.xh)&&isNumeric(coords.xs)){var xw=(xObj.copy_ystyle?yObj:xObj).width;path='M'+coords.xh+','+(coords.y-xw)+'v'+2*xw+// hat\n'm0,-'+xw+'H'+coords.xs;// bar\nif(!coords.noXS)path+='m0,-'+xw+'v'+2*xw;// shoe\nisNew=!xerror.size();if(isNew){xerror=errorbar.append('path').style('vector-effect','non-scaling-stroke').classed('xerror',true);}else if(hasAnimation){xerror=xerror.transition().duration(transitionOpts.duration).ease(transitionOpts.easing);}xerror.attr('d',path);}else xerror.remove();});});};// compute the coordinates of the error-bar objects\nfunction errorCoords(d,xa,ya){var out={x:xa.c2p(d.x),y:ya.c2p(d.y)};// calculate the error bar size and hat and shoe locations\nif(d.yh!==undefined){out.yh=ya.c2p(d.yh);out.ys=ya.c2p(d.ys);// if the shoes go off-scale (ie log scale, error bars past zero)\n// clip the bar and hide the shoes\nif(!isNumeric(out.ys)){out.noYS=true;out.ys=ya.c2p(d.ys,true);}}if(d.xh!==undefined){out.xh=xa.c2p(d.xh);out.xs=xa.c2p(d.xs);if(!isNumeric(out.xs)){out.noXS=true;out.xs=xa.c2p(d.xs,true);}}return out;}},{\"../../traces/scatter/subtypes\":304,\"../drawing\":64,\"d3\":8,\"fast-isnumeric\":10}],72:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var Color=_dereq_('../color');module.exports=function style(traces){traces.each(function(d){var trace=d[0].trace;var yObj=trace.error_y||{};var xObj=trace.error_x||{};var s=d3.select(this);s.selectAll('path.yerror').style('stroke-width',yObj.thickness+'px').call(Color.stroke,yObj.color);if(xObj.copy_ystyle)xObj=yObj;s.selectAll('path.xerror').style('stroke-width',xObj.thickness+'px').call(Color.stroke,xObj.color);});};},{\"../color\":43,\"d3\":8}],73:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var fontAttrs=_dereq_('../../plots/font_attributes');var hoverLabelAttrs=_dereq_('./layout_attributes').hoverlabel;var extendFlat=_dereq_('../../lib/extend').extendFlat;module.exports={hoverlabel:{bgcolor:extendFlat({},hoverLabelAttrs.bgcolor,{arrayOk:true}),bordercolor:extendFlat({},hoverLabelAttrs.bordercolor,{arrayOk:true}),font:fontAttrs({arrayOk:true,editType:'none'}),align:extendFlat({},hoverLabelAttrs.align,{arrayOk:true}),namelength:extendFlat({},hoverLabelAttrs.namelength,{arrayOk:true}),editType:'none'}};},{\"../../lib/extend\":153,\"../../plots/font_attributes\":229,\"./layout_attributes\":83}],74:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var Registry=_dereq_('../../registry');module.exports=function calc(gd){var calcdata=gd.calcdata;var fullLayout=gd._fullLayout;function makeCoerceHoverInfo(trace){return function(val){return Lib.coerceHoverinfo({hoverinfo:val},{_module:trace._module},fullLayout);};}for(var i=0;i<calcdata.length;i++){var cd=calcdata[i];var trace=cd[0].trace;// don't include hover calc fields for pie traces\n// as calcdata items might be sorted by value and\n// won't match the data array order.\nif(Registry.traceIs(trace,'pie'))continue;var fillFn=Registry.traceIs(trace,'2dMap')?paste:Lib.fillArray;fillFn(trace.hoverinfo,cd,'hi',makeCoerceHoverInfo(trace));if(trace.hovertemplate)fillFn(trace.hovertemplate,cd,'ht');if(!trace.hoverlabel)continue;fillFn(trace.hoverlabel.bgcolor,cd,'hbg');fillFn(trace.hoverlabel.bordercolor,cd,'hbc');fillFn(trace.hoverlabel.font.size,cd,'hts');fillFn(trace.hoverlabel.font.color,cd,'htc');fillFn(trace.hoverlabel.font.family,cd,'htf');fillFn(trace.hoverlabel.namelength,cd,'hnl');fillFn(trace.hoverlabel.align,cd,'hta');}};function paste(traceAttr,cd,cdAttr,fn){fn=fn||Lib.identity;if(Array.isArray(traceAttr)){cd[0][cdAttr]=fn(traceAttr);}}},{\"../../lib\":159,\"../../registry\":242}],75:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Registry=_dereq_('../../registry');var hover=_dereq_('./hover').hover;module.exports=function click(gd,evt,subplot){var annotationsDone=Registry.getComponentMethod('annotations','onClick')(gd,gd._hoverdata);// fallback to fail-safe in case the plot type's hover method doesn't pass the subplot.\n// Ternary, for example, didn't, but it was caught because tested.\nif(subplot!==undefined){// The true flag at the end causes it to re-run the hover computation to figure out *which*\n// point is being clicked. Without this, clicking is somewhat unreliable.\nhover(gd,evt,subplot,true);}function emitClick(){gd.emit('plotly_click',{points:gd._hoverdata,event:evt});}if(gd._hoverdata&&evt&&evt.target){if(annotationsDone&&annotationsDone.then){annotationsDone.then(emitClick);}else emitClick();// why do we get a double event without this???\nif(evt.stopImmediatePropagation)evt.stopImmediatePropagation();}};},{\"../../registry\":242,\"./hover\":79}],76:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports={// hover labels for multiple horizontal bars get tilted by this angle\nYANGLE:60,// size and display constants for hover text\n// pixel size of hover arrows\nHOVERARROWSIZE:6,// pixels padding around text\nHOVERTEXTPAD:3,// hover font\nHOVERFONTSIZE:13,HOVERFONT:'Arial, sans-serif',// minimum time (msec) between hover calls\nHOVERMINTIME:50,// ID suffix (with fullLayout._uid) for hover events in the throttle cache\nHOVERID:'-hover'};},{}],77:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var attributes=_dereq_('./attributes');var handleHoverLabelDefaults=_dereq_('./hoverlabel_defaults');module.exports=function supplyDefaults(traceIn,traceOut,defaultColor,layout){function coerce(attr,dflt){return Lib.coerce(traceIn,traceOut,attributes,attr,dflt);}var opts=Lib.extendFlat({},layout.hoverlabel);if(traceOut.hovertemplate)opts.namelength=-1;handleHoverLabelDefaults(traceIn,traceOut,coerce,opts);};},{\"../../lib\":159,\"./attributes\":73,\"./hoverlabel_defaults\":80}],78:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');// look for either subplot or xaxis and yaxis attributes\n// does not handle splom case\nexports.getSubplot=function getSubplot(trace){return trace.subplot||trace.xaxis+trace.yaxis||trace.geo;};// is trace in given list of subplots?\n// does handle splom case\nexports.isTraceInSubplots=function isTraceInSubplots(trace,subplots){if(trace.type==='splom'){var xaxes=trace.xaxes||[];var yaxes=trace.yaxes||[];for(var i=0;i<xaxes.length;i++){for(var j=0;j<yaxes.length;j++){if(subplots.indexOf(xaxes[i]+yaxes[j])!==-1){return true;}}}return false;}return subplots.indexOf(exports.getSubplot(trace))!==-1;};// convenience functions for mapping all relevant axes\nexports.flat=function flat(subplots,v){var out=new Array(subplots.length);for(var i=0;i<subplots.length;i++){out[i]=v;}return out;};exports.p2c=function p2c(axArray,v){var out=new Array(axArray.length);for(var i=0;i<axArray.length;i++){out[i]=axArray[i].p2c(v);}return out;};exports.getDistanceFunction=function getDistanceFunction(mode,dx,dy,dxy){if(mode==='closest')return dxy||exports.quadrature(dx,dy);return mode==='x'?dx:dy;};exports.getClosest=function getClosest(cd,distfn,pointData){// do we already have a point number? (array mode only)\nif(pointData.index!==false){if(pointData.index>=0&&pointData.index<cd.length){pointData.distance=0;}else pointData.index=false;}else{// apply the distance function to each data point\n// this is the longest loop... if this bogs down, we may need\n// to create pre-sorted data (by x or y), not sure how to\n// do this for 'closest'\nfor(var i=0;i<cd.length;i++){var newDistance=distfn(cd[i]);if(newDistance<=pointData.distance){pointData.index=i;pointData.distance=newDistance;}}}return pointData;};/*\n * pseudo-distance function for hover effects on areas: inside the region\n * distance is finite (`passVal`), outside it's Infinity.\n *\n * @param {number} v0: signed difference between the current position and the left edge\n * @param {number} v1: signed difference between the current position and the right edge\n * @param {number} passVal: the value to return on success\n */exports.inbox=function inbox(v0,v1,passVal){return v0*v1<0||v0===0?passVal:Infinity;};exports.quadrature=function quadrature(dx,dy){return function(di){var x=dx(di);var y=dy(di);return Math.sqrt(x*x+y*y);};};/** Fill event data point object for hover and selection.\n *  Invokes _module.eventData if present.\n *\n * N.B. note that point 'index' corresponds to input data array index\n *  whereas 'number' is its post-transform version.\n *\n * If the hovered/selected pt corresponds to an multiple input points\n * (e.g. for histogram and transformed traces), 'pointNumbers` and 'pointIndices'\n * are include in the event data.\n *\n * @param {object} pt\n * @param {object} trace\n * @param {object} cd\n * @return {object}\n */exports.makeEventData=function makeEventData(pt,trace,cd){// hover uses 'index', select uses 'pointNumber'\nvar pointNumber='index'in pt?pt.index:pt.pointNumber;var out={data:trace._input,fullData:trace,curveNumber:trace.index,pointNumber:pointNumber};if(trace._indexToPoints){var pointIndices=trace._indexToPoints[pointNumber];if(pointIndices.length===1){out.pointIndex=pointIndices[0];}else{out.pointIndices=pointIndices;}}else{out.pointIndex=pointNumber;}if(trace._module.eventData){out=trace._module.eventData(out,pt,trace,cd,pointNumber);}else{if('xVal'in pt)out.x=pt.xVal;else if('x'in pt)out.x=pt.x;if('yVal'in pt)out.y=pt.yVal;else if('y'in pt)out.y=pt.y;if(pt.xa)out.xaxis=pt.xa;if(pt.ya)out.yaxis=pt.ya;if(pt.zLabelVal!==undefined)out.z=pt.zLabelVal;}exports.appendArrayPointValue(out,trace,pointNumber);return out;};/** Appends values inside array attributes corresponding to given point number\n *\n * @param {object} pointData : point data object (gets mutated here)\n * @param {object} trace : full trace object\n * @param {number|Array(number)} pointNumber : point number. May be a length-2 array\n *     [row, col] to dig into 2D arrays\n */exports.appendArrayPointValue=function(pointData,trace,pointNumber){var arrayAttrs=trace._arrayAttrs;if(!arrayAttrs){return;}for(var i=0;i<arrayAttrs.length;i++){var astr=arrayAttrs[i];var key=getPointKey(astr);if(pointData[key]===undefined){var val=Lib.nestedProperty(trace,astr).get();var pointVal=getPointData(val,pointNumber);if(pointVal!==undefined)pointData[key]=pointVal;}}};/**\n * Appends values inside array attributes corresponding to given point number array\n * For use when pointData references a plot entity that arose (or potentially arose)\n * from multiple points in the input data\n *\n * @param {object} pointData : point data object (gets mutated here)\n * @param {object} trace : full trace object\n * @param {Array(number)|Array(Array(number))} pointNumbers : Array of point numbers.\n *     Each entry in the array may itself be a length-2 array [row, col] to dig into 2D arrays\n */exports.appendArrayMultiPointValues=function(pointData,trace,pointNumbers){var arrayAttrs=trace._arrayAttrs;if(!arrayAttrs){return;}for(var i=0;i<arrayAttrs.length;i++){var astr=arrayAttrs[i];var key=getPointKey(astr);if(pointData[key]===undefined){var val=Lib.nestedProperty(trace,astr).get();var keyVal=new Array(pointNumbers.length);for(var j=0;j<pointNumbers.length;j++){keyVal[j]=getPointData(val,pointNumbers[j]);}pointData[key]=keyVal;}}};var pointKeyMap={ids:'id',locations:'location',labels:'label',values:'value','marker.colors':'color',parents:'parent'};function getPointKey(astr){return pointKeyMap[astr]||astr;}function getPointData(val,pointNumber){if(Array.isArray(pointNumber)){if(Array.isArray(val)&&Array.isArray(val[pointNumber[0]])){return val[pointNumber[0]][pointNumber[1]];}}else{return val[pointNumber];}}},{\"../../lib\":159}],79:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var isNumeric=_dereq_('fast-isnumeric');var tinycolor=_dereq_('tinycolor2');var Lib=_dereq_('../../lib');var Events=_dereq_('../../lib/events');var svgTextUtils=_dereq_('../../lib/svg_text_utils');var overrideCursor=_dereq_('../../lib/override_cursor');var Drawing=_dereq_('../drawing');var Color=_dereq_('../color');var dragElement=_dereq_('../dragelement');var Axes=_dereq_('../../plots/cartesian/axes');var Registry=_dereq_('../../registry');var helpers=_dereq_('./helpers');var constants=_dereq_('./constants');// hover labels for multiple horizontal bars get tilted by some angle,\n// then need to be offset differently if they overlap\nvar YANGLE=constants.YANGLE;var YA_RADIANS=Math.PI*YANGLE/180;// expansion of projected height\nvar YFACTOR=1/Math.sin(YA_RADIANS);// to make the appropriate post-rotation x offset,\n// you need both x and y offsets\nvar YSHIFTX=Math.cos(YA_RADIANS);var YSHIFTY=Math.sin(YA_RADIANS);// size and display constants for hover text\nvar HOVERARROWSIZE=constants.HOVERARROWSIZE;var HOVERTEXTPAD=constants.HOVERTEXTPAD;// fx.hover: highlight data on hover\n// evt can be a mousemove event, or an object with data about what points\n//   to hover on\n//      {xpx,ypx[,hovermode]} - pixel locations from top left\n//          (with optional overriding hovermode)\n//      {xval,yval[,hovermode]} - data values\n//      [{curveNumber,(pointNumber|xval and/or yval)}] -\n//              array of specific points to highlight\n//          pointNumber is a single integer if gd.data[curveNumber] is 1D,\n//              or a two-element array if it's 2D\n//          xval and yval are data values,\n//              1D data may specify either or both,\n//              2D data must specify both\n// subplot is an id string (default \"xy\")\n// makes use of gl.hovermode, which can be:\n//      x (find the points with the closest x values, ie a column),\n//      closest (find the single closest point)\n//    internally there are two more that occasionally get used:\n//      y (pick out a row - only used for multiple horizontal bar charts)\n//      array (used when the user specifies an explicit\n//          array of points to hover on)\n//\n// We wrap the hovers in a timer, to limit their frequency.\n// The actual rendering is done by private function _hover.\nexports.hover=function hover(gd,evt,subplot,noHoverEvent){gd=Lib.getGraphDiv(gd);Lib.throttle(gd._fullLayout._uid+constants.HOVERID,constants.HOVERMINTIME,function(){_hover(gd,evt,subplot,noHoverEvent);});};/*\n * Draw a single hover item or an array of hover item in a pre-existing svg container somewhere\n * hoverItem should have keys:\n *    - x and y (or x0, x1, y0, and y1):\n *      the pixel position to mark, relative to opts.container\n *    - xLabel, yLabel, zLabel, text, and name:\n *      info to go in the label\n *    - color:\n *      the background color for the label.\n *    - idealAlign (optional):\n *      'left' or 'right' for which side of the x/y box to try to put this on first\n *    - borderColor (optional):\n *      color for the border, defaults to strongest contrast with color\n *    - fontFamily (optional):\n *      string, the font for this label, defaults to constants.HOVERFONT\n *    - fontSize (optional):\n *      the label font size, defaults to constants.HOVERFONTSIZE\n *    - fontColor (optional):\n *      defaults to borderColor\n * opts should have keys:\n *    - bgColor:\n *      the background color this is against, used if the trace is\n *      non-opaque, and for the name, which goes outside the box\n *    - container:\n *      a <svg> or <g> element to add the hover label to\n *    - outerContainer:\n *      normally a parent of `container`, sets the bounding box to use to\n *      constrain the hover label and determine whether to show it on the left or right\n * opts can have optional keys:\n *    - anchorIndex:\n        the index of the hover item used as an anchor for positioning.\n        The other hover items will be pushed up or down to prevent overlap.\n */exports.loneHover=function loneHover(hoverItems,opts){var multiHover=true;if(!Array.isArray(hoverItems)){multiHover=false;hoverItems=[hoverItems];}var pointsData=hoverItems.map(function(hoverItem){return{color:hoverItem.color||Color.defaultLine,x0:hoverItem.x0||hoverItem.x||0,x1:hoverItem.x1||hoverItem.x||0,y0:hoverItem.y0||hoverItem.y||0,y1:hoverItem.y1||hoverItem.y||0,xLabel:hoverItem.xLabel,yLabel:hoverItem.yLabel,zLabel:hoverItem.zLabel,text:hoverItem.text,name:hoverItem.name,idealAlign:hoverItem.idealAlign,// optional extra bits of styling\nborderColor:hoverItem.borderColor,fontFamily:hoverItem.fontFamily,fontSize:hoverItem.fontSize,fontColor:hoverItem.fontColor,nameLength:hoverItem.nameLength,textAlign:hoverItem.textAlign,// filler to make createHoverText happy\ntrace:hoverItem.trace||{index:0,hoverinfo:''},xa:{_offset:0},ya:{_offset:0},index:0,hovertemplate:hoverItem.hovertemplate||false,eventData:hoverItem.eventData||false,hovertemplateLabels:hoverItem.hovertemplateLabels||false};});var container3=d3.select(opts.container);var outerContainer3=opts.outerContainer?d3.select(opts.outerContainer):container3;var fullOpts={hovermode:'closest',rotateLabels:false,bgColor:opts.bgColor||Color.background,container:container3,outerContainer:outerContainer3};var hoverLabel=createHoverText(pointsData,fullOpts,opts.gd);// Fix vertical overlap\nvar tooltipSpacing=5;var lastBottomY=0;var anchor=0;hoverLabel.sort(function(a,b){return a.y0-b.y0;}).each(function(d,i){var topY=d.y0-d.by/2;if(topY-tooltipSpacing<lastBottomY){d.offset=lastBottomY-topY+tooltipSpacing;}else{d.offset=0;}lastBottomY=topY+d.by+d.offset;if(i===opts.anchorIndex||0)anchor=d.offset;}).each(function(d){d.offset-=anchor;});alignHoverText(hoverLabel,fullOpts.rotateLabels);return multiHover?hoverLabel:hoverLabel.node();};// The actual implementation is here:\nfunction _hover(gd,evt,subplot,noHoverEvent){if(!subplot)subplot='xy';// if the user passed in an array of subplots,\n// use those instead of finding overlayed plots\nvar subplots=Array.isArray(subplot)?subplot:[subplot];var fullLayout=gd._fullLayout;var plots=fullLayout._plots||[];var plotinfo=plots[subplot];var hasCartesian=fullLayout._has('cartesian');// list of all overlaid subplots to look at\nif(plotinfo){var overlayedSubplots=plotinfo.overlays.map(function(pi){return pi.id;});subplots=subplots.concat(overlayedSubplots);}var len=subplots.length;var xaArray=new Array(len);var yaArray=new Array(len);var supportsCompare=false;for(var i=0;i<len;i++){var spId=subplots[i];// 'cartesian' case\nvar plotObj=plots[spId];if(plotObj){supportsCompare=true;// TODO make sure that fullLayout_plots axis refs\n// get updated properly so that we don't have\n// to use Axes.getFromId in general.\nxaArray[i]=Axes.getFromId(gd,plotObj.xaxis._id);yaArray[i]=Axes.getFromId(gd,plotObj.yaxis._id);continue;}// other subplot types\nvar _subplot=fullLayout[spId]._subplot;xaArray[i]=_subplot.xaxis;yaArray[i]=_subplot.yaxis;}var hovermode=evt.hovermode||fullLayout.hovermode;if(hovermode&&!supportsCompare)hovermode='closest';if(['x','y','closest'].indexOf(hovermode)===-1||!gd.calcdata||gd.querySelector('.zoombox')||gd._dragging){return dragElement.unhoverRaw(gd,evt);}var hoverdistance=fullLayout.hoverdistance===-1?Infinity:fullLayout.hoverdistance;var spikedistance=fullLayout.spikedistance===-1?Infinity:fullLayout.spikedistance;// hoverData: the set of candidate points we've found to highlight\nvar hoverData=[];// searchData: the data to search in. Mostly this is just a copy of\n// gd.calcdata, filtered to the subplot and overlays we're on\n// but if a point array is supplied it will be a mapping\n// of indicated curves\nvar searchData=[];// [x|y]valArray: the axis values of the hover event\n// mapped onto each of the currently selected overlaid subplots\nvar xvalArray,yvalArray;var itemnum,curvenum,cd,trace,subplotId,subploti,mode,xval,yval,pointData,closedataPreviousLength;// spikePoints: the set of candidate points we've found to draw spikes to\nvar spikePoints={hLinePoint:null,vLinePoint:null};// does subplot have one (or more) horizontal traces?\n// This is used to determine whether we rotate the labels or not\nvar hasOneHorizontalTrace=false;// Figure out what we're hovering on:\n// mouse location or user-supplied data\nif(Array.isArray(evt)){// user specified an array of points to highlight\nhovermode='array';for(itemnum=0;itemnum<evt.length;itemnum++){cd=gd.calcdata[evt[itemnum].curveNumber||0];if(cd){trace=cd[0].trace;if(cd[0].trace.hoverinfo!=='skip'){searchData.push(cd);if(trace.orientation==='h'){hasOneHorizontalTrace=true;}}}}}else{for(curvenum=0;curvenum<gd.calcdata.length;curvenum++){cd=gd.calcdata[curvenum];trace=cd[0].trace;if(trace.hoverinfo!=='skip'&&helpers.isTraceInSubplots(trace,subplots)){searchData.push(cd);if(trace.orientation==='h'){hasOneHorizontalTrace=true;}}}// [x|y]px: the pixels (from top left) of the mouse location\n// on the currently selected plot area\n// add pointerX|Y property for drawing the spikes in spikesnap 'cursor' situation\nvar hasUserCalledHover=!evt.target;var xpx,ypx;if(hasUserCalledHover){if('xpx'in evt)xpx=evt.xpx;else xpx=xaArray[0]._length/2;if('ypx'in evt)ypx=evt.ypx;else ypx=yaArray[0]._length/2;}else{// fire the beforehover event and quit if it returns false\n// note that we're only calling this on real mouse events, so\n// manual calls to fx.hover will always run.\nif(Events.triggerHandler(gd,'plotly_beforehover',evt)===false){return;}var dbb=evt.target.getBoundingClientRect();xpx=evt.clientX-dbb.left;ypx=evt.clientY-dbb.top;// in case hover was called from mouseout into hovertext,\n// it's possible you're not actually over the plot anymore\nif(xpx<0||xpx>xaArray[0]._length||ypx<0||ypx>yaArray[0]._length){return dragElement.unhoverRaw(gd,evt);}}evt.pointerX=xpx+xaArray[0]._offset;evt.pointerY=ypx+yaArray[0]._offset;if('xval'in evt)xvalArray=helpers.flat(subplots,evt.xval);else xvalArray=helpers.p2c(xaArray,xpx);if('yval'in evt)yvalArray=helpers.flat(subplots,evt.yval);else yvalArray=helpers.p2c(yaArray,ypx);if(!isNumeric(xvalArray[0])||!isNumeric(yvalArray[0])){Lib.warn('Fx.hover failed',evt,gd);return dragElement.unhoverRaw(gd,evt);}}// the pixel distance to beat as a matching point\n// in 'x' or 'y' mode this resets for each trace\nvar distance=Infinity;// find the closest point in each trace\n// this is minimum dx and/or dy, depending on mode\n// and the pixel position for the label (labelXpx, labelYpx)\nfor(curvenum=0;curvenum<searchData.length;curvenum++){cd=searchData[curvenum];// filter out invisible or broken data\nif(!cd||!cd[0]||!cd[0].trace||cd[0].trace.visible!==true)continue;trace=cd[0].trace;// Explicitly bail out for these two. I don't know how to otherwise prevent\n// the rest of this function from running and failing\nif(['carpet','contourcarpet'].indexOf(trace._module.name)!==-1)continue;if(trace.type==='splom'){// splom traces do not generate overlay subplots,\n// it is safe to assume here splom traces correspond to the 0th subplot\nsubploti=0;subplotId=subplots[subploti];}else{subplotId=helpers.getSubplot(trace);subploti=subplots.indexOf(subplotId);}// within one trace mode can sometimes be overridden\nmode=hovermode;// container for new point, also used to pass info into module.hoverPoints\npointData={// trace properties\ncd:cd,trace:trace,xa:xaArray[subploti],ya:yaArray[subploti],// max distances for hover and spikes - for points that want to show but do not\n// want to override other points, set distance/spikeDistance equal to max*Distance\n// and it will not get filtered out but it will be guaranteed to have a greater\n// distance than any point that calculated a real distance.\nmaxHoverDistance:hoverdistance,maxSpikeDistance:spikedistance,// point properties - override all of these\nindex:false,// point index in trace - only used by plotly.js hoverdata consumers\ndistance:Math.min(distance,hoverdistance),// pixel distance or pseudo-distance\n// distance/pseudo-distance for spikes. This distance should always be calculated\n// as if in \"closest\" mode, and should only be set if this point should\n// generate a spike.\nspikeDistance:Infinity,// in some cases the spikes have different positioning from the hover label\n// they don't need x0/x1, just one position\nxSpike:undefined,ySpike:undefined,// where and how to display the hover label\ncolor:Color.defaultLine,// trace color\nname:trace.name,x0:undefined,x1:undefined,y0:undefined,y1:undefined,xLabelVal:undefined,yLabelVal:undefined,zLabelVal:undefined,text:undefined};// add ref to subplot object (non-cartesian case)\nif(fullLayout[subplotId]){pointData.subplot=fullLayout[subplotId]._subplot;}// add ref to splom scene\nif(fullLayout._splomScenes&&fullLayout._splomScenes[trace.uid]){pointData.scene=fullLayout._splomScenes[trace.uid];}closedataPreviousLength=hoverData.length;// for a highlighting array, figure out what\n// we're searching for with this element\nif(mode==='array'){var selection=evt[curvenum];if('pointNumber'in selection){pointData.index=selection.pointNumber;mode='closest';}else{mode='';if('xval'in selection){xval=selection.xval;mode='x';}if('yval'in selection){yval=selection.yval;mode=mode?'closest':'y';}}}else{xval=xvalArray[subploti];yval=yvalArray[subploti];}// Now if there is range to look in, find the points to hover.\nif(hoverdistance!==0){if(trace._module&&trace._module.hoverPoints){var newPoints=trace._module.hoverPoints(pointData,xval,yval,mode,fullLayout._hoverlayer);if(newPoints){var newPoint;for(var newPointNum=0;newPointNum<newPoints.length;newPointNum++){newPoint=newPoints[newPointNum];if(isNumeric(newPoint.x0)&&isNumeric(newPoint.y0)){hoverData.push(cleanPoint(newPoint,hovermode));}}}}else{Lib.log('Unrecognized trace type in hover:',trace);}}// in closest mode, remove any existing (farther) points\n// and don't look any farther than this latest point (or points, some\n// traces like box & violin make multiple hover labels at once)\nif(hovermode==='closest'&&hoverData.length>closedataPreviousLength){hoverData.splice(0,closedataPreviousLength);distance=hoverData[0].distance;}// Now if there is range to look in, find the points to draw the spikelines\n// Do it only if there is no hoverData\nif(hasCartesian&&spikedistance!==0){if(hoverData.length===0){pointData.distance=spikedistance;pointData.index=false;var closestPoints=trace._module.hoverPoints(pointData,xval,yval,'closest',fullLayout._hoverlayer);if(closestPoints){closestPoints=closestPoints.filter(function(point){// some hover points, like scatter fills, do not allow spikes,\n// so will generate a hover point but without a valid spikeDistance\nreturn point.spikeDistance<=spikedistance;});}if(closestPoints&&closestPoints.length){var tmpPoint;var closestVPoints=closestPoints.filter(function(point){return point.xa.showspikes;});if(closestVPoints.length){var closestVPt=closestVPoints[0];if(isNumeric(closestVPt.x0)&&isNumeric(closestVPt.y0)){tmpPoint=fillSpikePoint(closestVPt);if(!spikePoints.vLinePoint||spikePoints.vLinePoint.spikeDistance>tmpPoint.spikeDistance){spikePoints.vLinePoint=tmpPoint;}}}var closestHPoints=closestPoints.filter(function(point){return point.ya.showspikes;});if(closestHPoints.length){var closestHPt=closestHPoints[0];if(isNumeric(closestHPt.x0)&&isNumeric(closestHPt.y0)){tmpPoint=fillSpikePoint(closestHPt);if(!spikePoints.hLinePoint||spikePoints.hLinePoint.spikeDistance>tmpPoint.spikeDistance){spikePoints.hLinePoint=tmpPoint;}}}}}}}function selectClosestPoint(pointsData,spikedistance){var resultPoint=null;var minDistance=Infinity;var thisSpikeDistance;for(var i=0;i<pointsData.length;i++){thisSpikeDistance=pointsData[i].spikeDistance;if(thisSpikeDistance<minDistance&&thisSpikeDistance<=spikedistance){resultPoint=pointsData[i];minDistance=thisSpikeDistance;}}return resultPoint;}function fillSpikePoint(point){if(!point)return null;return{xa:point.xa,ya:point.ya,x:point.xSpike!==undefined?point.xSpike:(point.x0+point.x1)/2,y:point.ySpike!==undefined?point.ySpike:(point.y0+point.y1)/2,distance:point.distance,spikeDistance:point.spikeDistance,curveNumber:point.trace.index,color:point.color,pointNumber:point.index};}var spikelineOpts={fullLayout:fullLayout,container:fullLayout._hoverlayer,outerContainer:fullLayout._paperdiv,event:evt};var oldspikepoints=gd._spikepoints;var newspikepoints={vLinePoint:spikePoints.vLinePoint,hLinePoint:spikePoints.hLinePoint};gd._spikepoints=newspikepoints;// Now if it is not restricted by spikedistance option, set the points to draw the spikelines\nif(hasCartesian&&spikedistance!==0){if(hoverData.length!==0){var tmpHPointData=hoverData.filter(function(point){return point.ya.showspikes;});var tmpHPoint=selectClosestPoint(tmpHPointData,spikedistance);spikePoints.hLinePoint=fillSpikePoint(tmpHPoint);var tmpVPointData=hoverData.filter(function(point){return point.xa.showspikes;});var tmpVPoint=selectClosestPoint(tmpVPointData,spikedistance);spikePoints.vLinePoint=fillSpikePoint(tmpVPoint);}}// if hoverData is empty check for the spikes to draw and quit if there are none\nif(hoverData.length===0){var result=dragElement.unhoverRaw(gd,evt);if(hasCartesian&&(spikePoints.hLinePoint!==null||spikePoints.vLinePoint!==null)){if(spikesChanged(oldspikepoints)){createSpikelines(spikePoints,spikelineOpts);}}return result;}if(hasCartesian){if(spikesChanged(oldspikepoints)){createSpikelines(spikePoints,spikelineOpts);}}hoverData.sort(function(d1,d2){return d1.distance-d2.distance;});// lastly, emit custom hover/unhover events\nvar oldhoverdata=gd._hoverdata;var newhoverdata=[];// pull out just the data that's useful to\n// other people and send it to the event\nfor(itemnum=0;itemnum<hoverData.length;itemnum++){var pt=hoverData[itemnum];var eventData=helpers.makeEventData(pt,pt.trace,pt.cd);if(pt.hovertemplate!==false){var ht=false;if(pt.cd[pt.index]&&pt.cd[pt.index].ht){ht=pt.cd[pt.index].ht;}pt.hovertemplate=ht||pt.trace.hovertemplate||false;}pt.eventData=[eventData];newhoverdata.push(eventData);}gd._hoverdata=newhoverdata;var rotateLabels=hovermode==='y'&&(searchData.length>1||hoverData.length>1)||hovermode==='closest'&&hasOneHorizontalTrace&&hoverData.length>1;var bgColor=Color.combine(fullLayout.plot_bgcolor||Color.background,fullLayout.paper_bgcolor);var labelOpts={hovermode:hovermode,rotateLabels:rotateLabels,bgColor:bgColor,container:fullLayout._hoverlayer,outerContainer:fullLayout._paperdiv,commonLabelOpts:fullLayout.hoverlabel,hoverdistance:fullLayout.hoverdistance};var hoverLabels=createHoverText(hoverData,labelOpts,gd);hoverAvoidOverlaps(hoverLabels,rotateLabels?'xa':'ya',fullLayout);alignHoverText(hoverLabels,rotateLabels);// TODO: tagName hack is needed to appease geo.js's hack of using evt.target=true\n// we should improve the \"fx\" API so other plots can use it without these hack.\nif(evt.target&&evt.target.tagName){var hasClickToShow=Registry.getComponentMethod('annotations','hasClickToShow')(gd,newhoverdata);overrideCursor(d3.select(evt.target),hasClickToShow?'pointer':'');}// don't emit events if called manually\nif(!evt.target||noHoverEvent||!hoverChanged(gd,evt,oldhoverdata))return;if(oldhoverdata){gd.emit('plotly_unhover',{event:evt,points:oldhoverdata});}gd.emit('plotly_hover',{event:evt,points:gd._hoverdata,xaxes:xaArray,yaxes:yaArray,xvals:xvalArray,yvals:yvalArray});}var EXTRA_STRING_REGEX=/<extra>([\\s\\S]*)<\\/extra>/;function createHoverText(hoverData,opts,gd){var fullLayout=gd._fullLayout;var hovermode=opts.hovermode;var rotateLabels=opts.rotateLabels;var bgColor=opts.bgColor;var container=opts.container;var outerContainer=opts.outerContainer;var commonLabelOpts=opts.commonLabelOpts||{};// opts.fontFamily/Size are used for the common label\n// and as defaults for each hover label, though the individual labels\n// can override this.\nvar fontFamily=opts.fontFamily||constants.HOVERFONT;var fontSize=opts.fontSize||constants.HOVERFONTSIZE;var c0=hoverData[0];var xa=c0.xa;var ya=c0.ya;var commonAttr=hovermode==='y'?'yLabel':'xLabel';var t0=c0[commonAttr];var t00=(String(t0)||'').split(' ')[0];var outerContainerBB=outerContainer.node().getBoundingClientRect();var outerTop=outerContainerBB.top;var outerWidth=outerContainerBB.width;var outerHeight=outerContainerBB.height;// show the common label, if any, on the axis\n// never show a common label in array mode,\n// even if sometimes there could be one\nvar showCommonLabel=t0!==undefined&&c0.distance<=opts.hoverdistance&&(hovermode==='x'||hovermode==='y');// all hover traces hoverinfo must contain the hovermode\n// to have common labels\nif(showCommonLabel){var allHaveZ=true;var i,traceHoverinfo;for(i=0;i<hoverData.length;i++){if(allHaveZ&&hoverData[i].zLabel===undefined)allHaveZ=false;traceHoverinfo=hoverData[i].hoverinfo||hoverData[i].trace.hoverinfo;if(traceHoverinfo){var parts=Array.isArray(traceHoverinfo)?traceHoverinfo:traceHoverinfo.split('+');if(parts.indexOf('all')===-1&&parts.indexOf(hovermode)===-1){showCommonLabel=false;break;}}}// xyz labels put all info in their main label, so have no need of a common label\nif(allHaveZ)showCommonLabel=false;}var commonLabel=container.selectAll('g.axistext').data(showCommonLabel?[0]:[]);commonLabel.enter().append('g').classed('axistext',true);commonLabel.exit().remove();commonLabel.each(function(){var label=d3.select(this);var lpath=Lib.ensureSingle(label,'path','',function(s){s.style({'stroke-width':'1px'});});var ltext=Lib.ensureSingle(label,'text','',function(s){// prohibit tex interpretation until we can handle\n// tex and regular text together\ns.attr('data-notex',1);});var commonBgColor=commonLabelOpts.bgcolor||Color.defaultLine;var commonStroke=commonLabelOpts.bordercolor||Color.contrast(commonBgColor);var contrastColor=Color.contrast(commonBgColor);lpath.style({fill:commonBgColor,stroke:commonStroke});ltext.text(t0).call(Drawing.font,commonLabelOpts.font.family||fontFamily,commonLabelOpts.font.size||fontSize,commonLabelOpts.font.color||contrastColor).call(svgTextUtils.positionText,0,0).call(svgTextUtils.convertToTspans,gd);label.attr('transform','');var tbb=ltext.node().getBoundingClientRect();if(hovermode==='x'){ltext.attr('text-anchor','middle').call(svgTextUtils.positionText,0,xa.side==='top'?outerTop-tbb.bottom-HOVERARROWSIZE-HOVERTEXTPAD:outerTop-tbb.top+HOVERARROWSIZE+HOVERTEXTPAD);var topsign=xa.side==='top'?'-':'';lpath.attr('d','M0,0'+'L'+HOVERARROWSIZE+','+topsign+HOVERARROWSIZE+'H'+(HOVERTEXTPAD+tbb.width/2)+'v'+topsign+(HOVERTEXTPAD*2+tbb.height)+'H-'+(HOVERTEXTPAD+tbb.width/2)+'V'+topsign+HOVERARROWSIZE+'H-'+HOVERARROWSIZE+'Z');label.attr('transform','translate('+(xa._offset+(c0.x0+c0.x1)/2)+','+(ya._offset+(xa.side==='top'?0:ya._length))+')');}else{ltext.attr('text-anchor',ya.side==='right'?'start':'end').call(svgTextUtils.positionText,(ya.side==='right'?1:-1)*(HOVERTEXTPAD+HOVERARROWSIZE),outerTop-tbb.top-tbb.height/2);var leftsign=ya.side==='right'?'':'-';lpath.attr('d','M0,0'+'L'+leftsign+HOVERARROWSIZE+','+HOVERARROWSIZE+'V'+(HOVERTEXTPAD+tbb.height/2)+'h'+leftsign+(HOVERTEXTPAD*2+tbb.width)+'V-'+(HOVERTEXTPAD+tbb.height/2)+'H'+leftsign+HOVERARROWSIZE+'V-'+HOVERARROWSIZE+'Z');label.attr('transform','translate('+(xa._offset+(ya.side==='right'?xa._length:0))+','+(ya._offset+(c0.y0+c0.y1)/2)+')');}// remove the \"close but not quite\" points\n// because of error bars, only take up to a space\nhoverData=hoverData.filter(function(d){return d.zLabelVal!==undefined||(d[commonAttr]||'').split(' ')[0]===t00;});});// show all the individual labels\n// first create the objects\nvar hoverLabels=container.selectAll('g.hovertext').data(hoverData,function(d){return[d.trace.index,d.index,d.x0,d.y0,d.name,d.attr,d.xa,d.ya||''].join(',');});hoverLabels.enter().append('g').classed('hovertext',true).each(function(){var g=d3.select(this);// trace name label (rect and text.name)\ng.append('rect').call(Color.fill,Color.addOpacity(bgColor,0.8));g.append('text').classed('name',true);// trace data label (path and text.nums)\ng.append('path').style('stroke-width','1px');g.append('text').classed('nums',true).call(Drawing.font,fontFamily,fontSize);});hoverLabels.exit().remove();// then put the text in, position the pointer to the data,\n// and figure out sizes\nhoverLabels.each(function(d){var g=d3.select(this).attr('transform','');var name='';var text='';// combine possible non-opaque trace color with bgColor\nvar color0=d.bgcolor||d.color;// color for 'nums' part of the label\nvar numsColor=Color.combine(Color.opacity(color0)?color0:Color.defaultLine,bgColor);// color for 'name' part of the label\nvar nameColor=Color.combine(Color.opacity(d.color)?d.color:Color.defaultLine,bgColor);// find a contrasting color for border and text\nvar contrastColor=d.borderColor||Color.contrast(numsColor);// to get custom 'name' labels pass cleanPoint\nif(d.nameOverride!==undefined)d.name=d.nameOverride;if(d.name){if(fullLayout.meta){d.name=Lib.templateString(d.name,{meta:fullLayout.meta});}name=plainText(d.name,d.nameLength);}if(d.zLabel!==undefined){if(d.xLabel!==undefined)text+='x: '+d.xLabel+'<br>';if(d.yLabel!==undefined)text+='y: '+d.yLabel+'<br>';text+=(text?'z: ':'')+d.zLabel;}else if(showCommonLabel&&d[hovermode+'Label']===t0){text=d[(hovermode==='x'?'y':'x')+'Label']||'';}else if(d.xLabel===undefined){if(d.yLabel!==undefined&&d.trace.type!=='scattercarpet')text=d.yLabel;}else if(d.yLabel===undefined)text=d.xLabel;else text='('+d.xLabel+', '+d.yLabel+')';if((d.text||d.text===0)&&!Array.isArray(d.text)){text+=(text?'<br>':'')+d.text;}// used by other modules (initially just ternary) that\n// manage their own hoverinfo independent of cleanPoint\n// the rest of this will still apply, so such modules\n// can still put things in (x|y|z)Label, text, and name\n// and hoverinfo will still determine their visibility\nif(d.extraText!==undefined)text+=(text?'<br>':'')+d.extraText;// if 'text' is empty at this point,\n// and hovertemplate is not defined,\n// put 'name' in main label and don't show secondary label\nif(text===''&&!d.hovertemplate){// if 'name' is also empty, remove entire label\nif(name==='')g.remove();text=name;}// hovertemplate\nvar d3locale=gd._fullLayout._d3locale;var hovertemplate=d.hovertemplate||false;var hovertemplateLabels=d.hovertemplateLabels||d;var eventData=d.eventData[0]||{};if(hovertemplate){text=Lib.hovertemplateString(hovertemplate,hovertemplateLabels,d3locale,eventData,{meta:fullLayout.meta});text=text.replace(EXTRA_STRING_REGEX,function(match,extra){// assign name for secondary text label\nname=plainText(extra,d.nameLength);// remove from main text label\nreturn'';});}// main label\nvar tx=g.select('text.nums').call(Drawing.font,d.fontFamily||fontFamily,d.fontSize||fontSize,d.fontColor||contrastColor).text(text).attr('data-notex',1).call(svgTextUtils.positionText,0,0).call(svgTextUtils.convertToTspans,gd);var tx2=g.select('text.name');var tx2width=0;var tx2height=0;// secondary label for non-empty 'name'\nif(name&&name!==text){tx2.call(Drawing.font,d.fontFamily||fontFamily,d.fontSize||fontSize,nameColor).text(name).attr('data-notex',1).call(svgTextUtils.positionText,0,0).call(svgTextUtils.convertToTspans,gd);var t2bb=tx2.node().getBoundingClientRect();tx2width=t2bb.width+2*HOVERTEXTPAD;tx2height=t2bb.height+2*HOVERTEXTPAD;}else{tx2.remove();g.select('rect').remove();}g.select('path').style({fill:numsColor,stroke:contrastColor});var tbb=tx.node().getBoundingClientRect();var htx=d.xa._offset+(d.x0+d.x1)/2;var hty=d.ya._offset+(d.y0+d.y1)/2;var dx=Math.abs(d.x1-d.x0);var dy=Math.abs(d.y1-d.y0);var txTotalWidth=tbb.width+HOVERARROWSIZE+HOVERTEXTPAD+tx2width;var anchorStartOK,anchorEndOK;d.ty0=outerTop-tbb.top;d.bx=tbb.width+2*HOVERTEXTPAD;d.by=Math.max(tbb.height+2*HOVERTEXTPAD,tx2height);d.anchor='start';d.txwidth=tbb.width;d.tx2width=tx2width;d.offset=0;if(rotateLabels){d.pos=htx;anchorStartOK=hty+dy/2+txTotalWidth<=outerHeight;anchorEndOK=hty-dy/2-txTotalWidth>=0;if((d.idealAlign==='top'||!anchorStartOK)&&anchorEndOK){hty-=dy/2;d.anchor='end';}else if(anchorStartOK){hty+=dy/2;d.anchor='start';}else d.anchor='middle';}else{d.pos=hty;anchorStartOK=htx+dx/2+txTotalWidth<=outerWidth;anchorEndOK=htx-dx/2-txTotalWidth>=0;if((d.idealAlign==='left'||!anchorStartOK)&&anchorEndOK){htx-=dx/2;d.anchor='end';}else if(anchorStartOK){htx+=dx/2;d.anchor='start';}else{d.anchor='middle';var txHalfWidth=txTotalWidth/2;var overflowR=htx+txHalfWidth-outerWidth;var overflowL=htx-txHalfWidth;if(overflowR>0)htx-=overflowR;if(overflowL<0)htx+=-overflowL;}}tx.attr('text-anchor',d.anchor);if(tx2width)tx2.attr('text-anchor',d.anchor);g.attr('transform','translate('+htx+','+hty+')'+(rotateLabels?'rotate('+YANGLE+')':''));});return hoverLabels;}// Make groups of touching points, and within each group\n// move each point so that no labels overlap, but the average\n// label position is the same as it was before moving. Indicentally,\n// this is equivalent to saying all the labels are on equal linear\n// springs about their initial position. Initially, each point is\n// its own group, but as we find overlaps we will clump the points.\n//\n// Also, there are hard constraints at the edges of the graphs,\n// that push all groups to the middle so they are visible. I don't\n// know what happens if the group spans all the way from one edge to\n// the other, though it hardly matters - there's just too much\n// information then.\nfunction hoverAvoidOverlaps(hoverLabels,ax,fullLayout){var nummoves=0;var axSign=1;var nLabels=hoverLabels.size();// make groups of touching points\nvar pointgroups=new Array(nLabels);hoverLabels.each(function(d,i){var axis=d[ax];var axIsX=axis._id.charAt(0)==='x';var rng=axis.range;if(!i&&rng&&rng[0]>rng[1]!==axIsX)axSign=-1;pointgroups[i]=[{datum:d,i:i,traceIndex:d.trace.index,dp:0,pos:d.pos,posref:d.posref,size:d.by*(axIsX?YFACTOR:1)/2,pmin:0,pmax:axIsX?fullLayout.width:fullLayout.height}];});pointgroups.sort(function(a,b){return a[0].posref-b[0].posref||// for equal positions, sort trace indices increasing or decreasing\n// depending on whether the axis is reversed or not... so stacked\n// traces will generally keep their order even if one trace adds\n// nothing to the stack.\naxSign*(b[0].traceIndex-a[0].traceIndex);});var donepositioning,topOverlap,bottomOverlap,i,j,pti,sumdp;function constrainGroup(grp){var minPt=grp[0];var maxPt=grp[grp.length-1];// overlap with the top - positive vals are overlaps\ntopOverlap=minPt.pmin-minPt.pos-minPt.dp+minPt.size;// overlap with the bottom - positive vals are overlaps\nbottomOverlap=maxPt.pos+maxPt.dp+maxPt.size-minPt.pmax;// check for min overlap first, so that we always\n// see the largest labels\n// allow for .01px overlap, so we don't get an\n// infinite loop from rounding errors\nif(topOverlap>0.01){for(j=grp.length-1;j>=0;j--){grp[j].dp+=topOverlap;}donepositioning=false;}if(bottomOverlap<0.01)return;if(topOverlap<-0.01){// make sure we're not pushing back and forth\nfor(j=grp.length-1;j>=0;j--){grp[j].dp-=bottomOverlap;}donepositioning=false;}if(!donepositioning)return;// no room to fix positioning, delete off-screen points\n// first see how many points we need to delete\nvar deleteCount=0;for(i=0;i<grp.length;i++){pti=grp[i];if(pti.pos+pti.dp+pti.size>minPt.pmax)deleteCount++;}// start by deleting points whose data is off screen\nfor(i=grp.length-1;i>=0;i--){if(deleteCount<=0)break;pti=grp[i];// pos has already been constrained to [pmin,pmax]\n// so look for points close to that to delete\nif(pti.pos>minPt.pmax-1){pti.del=true;deleteCount--;}}for(i=0;i<grp.length;i++){if(deleteCount<=0)break;pti=grp[i];// pos has already been constrained to [pmin,pmax]\n// so look for points close to that to delete\nif(pti.pos<minPt.pmin+1){pti.del=true;deleteCount--;// shift the whole group minus into this new space\nbottomOverlap=pti.size*2;for(j=grp.length-1;j>=0;j--){grp[j].dp-=bottomOverlap;}}}// then delete points that go off the bottom\nfor(i=grp.length-1;i>=0;i--){if(deleteCount<=0)break;pti=grp[i];if(pti.pos+pti.dp+pti.size>minPt.pmax){pti.del=true;deleteCount--;}}}// loop through groups, combining them if they overlap,\n// until nothing moves\nwhile(!donepositioning&&nummoves<=nLabels){// to avoid infinite loops, don't move more times\n// than there are traces\nnummoves++;// assume nothing will move in this iteration,\n// reverse this if it does\ndonepositioning=true;i=0;while(i<pointgroups.length-1){// the higher (g0) and lower (g1) point group\nvar g0=pointgroups[i];var g1=pointgroups[i+1];// the lowest point in the higher group (p0)\n// the highest point in the lower group (p1)\nvar p0=g0[g0.length-1];var p1=g1[0];topOverlap=p0.pos+p0.dp+p0.size-p1.pos-p1.dp+p1.size;// Only group points that lie on the same axes\nif(topOverlap>0.01&&p0.pmin===p1.pmin&&p0.pmax===p1.pmax){// push the new point(s) added to this group out of the way\nfor(j=g1.length-1;j>=0;j--){g1[j].dp+=topOverlap;}// add them to the group\ng0.push.apply(g0,g1);pointgroups.splice(i+1,1);// adjust for minimum average movement\nsumdp=0;for(j=g0.length-1;j>=0;j--){sumdp+=g0[j].dp;}bottomOverlap=sumdp/g0.length;for(j=g0.length-1;j>=0;j--){g0[j].dp-=bottomOverlap;}donepositioning=false;}else i++;}// check if we're going off the plot on either side and fix\npointgroups.forEach(constrainGroup);}// now put these offsets into hoverData\nfor(i=pointgroups.length-1;i>=0;i--){var grp=pointgroups[i];for(j=grp.length-1;j>=0;j--){var pt=grp[j];var hoverPt=pt.datum;hoverPt.offset=pt.dp;hoverPt.del=pt.del;}}}function alignHoverText(hoverLabels,rotateLabels){// finally set the text positioning relative to the data and draw the\n// box around it\nhoverLabels.each(function(d){var g=d3.select(this);if(d.del)return g.remove();var tx=g.select('text.nums');var anchor=d.anchor;var horzSign=anchor==='end'?-1:1;var alignShift={start:1,end:-1,middle:0}[anchor];var txx=alignShift*(HOVERARROWSIZE+HOVERTEXTPAD);var tx2x=txx+alignShift*(d.txwidth+HOVERTEXTPAD);var offsetX=0;var offsetY=d.offset;if(anchor==='middle'){txx-=d.tx2width/2;tx2x+=d.txwidth/2+HOVERTEXTPAD;}if(rotateLabels){offsetY*=-YSHIFTY;offsetX=d.offset*YSHIFTX;}g.select('path').attr('d',anchor==='middle'?// middle aligned: rect centered on data\n'M-'+(d.bx/2+d.tx2width/2)+','+(offsetY-d.by/2)+'h'+d.bx+'v'+d.by+'h-'+d.bx+'Z':// left or right aligned: side rect with arrow to data\n'M0,0L'+(horzSign*HOVERARROWSIZE+offsetX)+','+(HOVERARROWSIZE+offsetY)+'v'+(d.by/2-HOVERARROWSIZE)+'h'+horzSign*d.bx+'v-'+d.by+'H'+(horzSign*HOVERARROWSIZE+offsetX)+'V'+(offsetY-HOVERARROWSIZE)+'Z');var posX=txx+offsetX;var posY=offsetY+d.ty0-d.by/2+HOVERTEXTPAD;var textAlign=d.textAlign||'auto';if(textAlign!=='auto'){if(textAlign==='left'&&anchor!=='start'){tx.attr('text-anchor','start');posX=anchor==='middle'?-d.bx/2-d.tx2width/2+HOVERTEXTPAD:-d.bx-HOVERTEXTPAD;}else if(textAlign==='right'&&anchor!=='end'){tx.attr('text-anchor','end');posX=anchor==='middle'?d.bx/2-d.tx2width/2-HOVERTEXTPAD:d.bx+HOVERTEXTPAD;}}tx.call(svgTextUtils.positionText,posX,posY);if(d.tx2width){g.select('text.name').call(svgTextUtils.positionText,tx2x+alignShift*HOVERTEXTPAD+offsetX,offsetY+d.ty0-d.by/2+HOVERTEXTPAD);g.select('rect').call(Drawing.setRect,tx2x+(alignShift-1)*d.tx2width/2+offsetX,offsetY-d.by/2-1,d.tx2width,d.by+2);}});}function cleanPoint(d,hovermode){var index=d.index;var trace=d.trace||{};var cd0=d.cd[0];var cd=d.cd[index]||{};function pass(v){return v||isNumeric(v)&&v===0;}var getVal=Array.isArray(index)?function(calcKey,traceKey){var v=Lib.castOption(cd0,index,calcKey);return pass(v)?v:Lib.extractOption({},trace,'',traceKey);}:function(calcKey,traceKey){return Lib.extractOption(cd,trace,calcKey,traceKey);};function fill(key,calcKey,traceKey){var val=getVal(calcKey,traceKey);if(pass(val))d[key]=val;}fill('hoverinfo','hi','hoverinfo');fill('bgcolor','hbg','hoverlabel.bgcolor');fill('borderColor','hbc','hoverlabel.bordercolor');fill('fontFamily','htf','hoverlabel.font.family');fill('fontSize','hts','hoverlabel.font.size');fill('fontColor','htc','hoverlabel.font.color');fill('nameLength','hnl','hoverlabel.namelength');fill('textAlign','hta','hoverlabel.align');d.posref=hovermode==='y'||hovermode==='closest'&&trace.orientation==='h'?d.xa._offset+(d.x0+d.x1)/2:d.ya._offset+(d.y0+d.y1)/2;// then constrain all the positions to be on the plot\nd.x0=Lib.constrain(d.x0,0,d.xa._length);d.x1=Lib.constrain(d.x1,0,d.xa._length);d.y0=Lib.constrain(d.y0,0,d.ya._length);d.y1=Lib.constrain(d.y1,0,d.ya._length);// and convert the x and y label values into formatted text\nif(d.xLabelVal!==undefined){d.xLabel='xLabel'in d?d.xLabel:Axes.hoverLabelText(d.xa,d.xLabelVal);d.xVal=d.xa.c2d(d.xLabelVal);}if(d.yLabelVal!==undefined){d.yLabel='yLabel'in d?d.yLabel:Axes.hoverLabelText(d.ya,d.yLabelVal);d.yVal=d.ya.c2d(d.yLabelVal);}// Traces like heatmaps generate the zLabel in their hoverPoints function\nif(d.zLabelVal!==undefined&&d.zLabel===undefined){d.zLabel=String(d.zLabelVal);}// for box means and error bars, add the range to the label\nif(!isNaN(d.xerr)&&!(d.xa.type==='log'&&d.xerr<=0)){var xeText=Axes.tickText(d.xa,d.xa.c2l(d.xerr),'hover').text;if(d.xerrneg!==undefined){d.xLabel+=' +'+xeText+' / -'+Axes.tickText(d.xa,d.xa.c2l(d.xerrneg),'hover').text;}else d.xLabel+='  '+xeText;// small distance penalty for error bars, so that if there are\n// traces with errors and some without, the error bar label will\n// hoist up to the point\nif(hovermode==='x')d.distance+=1;}if(!isNaN(d.yerr)&&!(d.ya.type==='log'&&d.yerr<=0)){var yeText=Axes.tickText(d.ya,d.ya.c2l(d.yerr),'hover').text;if(d.yerrneg!==undefined){d.yLabel+=' +'+yeText+' / -'+Axes.tickText(d.ya,d.ya.c2l(d.yerrneg),'hover').text;}else d.yLabel+='  '+yeText;if(hovermode==='y')d.distance+=1;}var infomode=d.hoverinfo||d.trace.hoverinfo;if(infomode&&infomode!=='all'){infomode=Array.isArray(infomode)?infomode:infomode.split('+');if(infomode.indexOf('x')===-1)d.xLabel=undefined;if(infomode.indexOf('y')===-1)d.yLabel=undefined;if(infomode.indexOf('z')===-1)d.zLabel=undefined;if(infomode.indexOf('text')===-1)d.text=undefined;if(infomode.indexOf('name')===-1)d.name=undefined;}return d;}function createSpikelines(closestPoints,opts){var container=opts.container;var fullLayout=opts.fullLayout;var evt=opts.event;var showY=!!closestPoints.hLinePoint;var showX=!!closestPoints.vLinePoint;var xa,ya;// Remove old spikeline items\ncontainer.selectAll('.spikeline').remove();if(!(showX||showY))return;var contrastColor=Color.combine(fullLayout.plot_bgcolor,fullLayout.paper_bgcolor);// Horizontal line (to y-axis)\nif(showY){var hLinePoint=closestPoints.hLinePoint;var hLinePointX,hLinePointY;xa=hLinePoint&&hLinePoint.xa;ya=hLinePoint&&hLinePoint.ya;var ySnap=ya.spikesnap;if(ySnap==='cursor'){hLinePointX=evt.pointerX;hLinePointY=evt.pointerY;}else{hLinePointX=xa._offset+hLinePoint.x;hLinePointY=ya._offset+hLinePoint.y;}var dfltHLineColor=tinycolor.readability(hLinePoint.color,contrastColor)<1.5?Color.contrast(contrastColor):hLinePoint.color;var yMode=ya.spikemode;var yThickness=ya.spikethickness;var yColor=ya.spikecolor||dfltHLineColor;var yBB=ya._boundingBox;var xEdge=(yBB.left+yBB.right)/2<hLinePointX?yBB.right:yBB.left;var xBase,xEndSpike;if(yMode.indexOf('toaxis')!==-1||yMode.indexOf('across')!==-1){if(yMode.indexOf('toaxis')!==-1){xBase=xEdge;xEndSpike=hLinePointX;}if(yMode.indexOf('across')!==-1){xBase=ya._counterSpan[0];xEndSpike=ya._counterSpan[1];}// Foreground horizontal line (to y-axis)\ncontainer.insert('line',':first-child').attr({x1:xBase,x2:xEndSpike,y1:hLinePointY,y2:hLinePointY,'stroke-width':yThickness,stroke:yColor,'stroke-dasharray':Drawing.dashStyle(ya.spikedash,yThickness)}).classed('spikeline',true).classed('crisp',true);// Background horizontal Line (to y-axis)\ncontainer.insert('line',':first-child').attr({x1:xBase,x2:xEndSpike,y1:hLinePointY,y2:hLinePointY,'stroke-width':yThickness+2,stroke:contrastColor}).classed('spikeline',true).classed('crisp',true);}// Y axis marker\nif(yMode.indexOf('marker')!==-1){container.insert('circle',':first-child').attr({cx:xEdge+(ya.side!=='right'?yThickness:-yThickness),cy:hLinePointY,r:yThickness,fill:yColor}).classed('spikeline',true);}}if(showX){var vLinePoint=closestPoints.vLinePoint;var vLinePointX,vLinePointY;xa=vLinePoint&&vLinePoint.xa;ya=vLinePoint&&vLinePoint.ya;var xSnap=xa.spikesnap;if(xSnap==='cursor'){vLinePointX=evt.pointerX;vLinePointY=evt.pointerY;}else{vLinePointX=xa._offset+vLinePoint.x;vLinePointY=ya._offset+vLinePoint.y;}var dfltVLineColor=tinycolor.readability(vLinePoint.color,contrastColor)<1.5?Color.contrast(contrastColor):vLinePoint.color;var xMode=xa.spikemode;var xThickness=xa.spikethickness;var xColor=xa.spikecolor||dfltVLineColor;var xBB=xa._boundingBox;var yEdge=(xBB.top+xBB.bottom)/2<vLinePointY?xBB.bottom:xBB.top;var yBase,yEndSpike;if(xMode.indexOf('toaxis')!==-1||xMode.indexOf('across')!==-1){if(xMode.indexOf('toaxis')!==-1){yBase=yEdge;yEndSpike=vLinePointY;}if(xMode.indexOf('across')!==-1){yBase=xa._counterSpan[0];yEndSpike=xa._counterSpan[1];}// Foreground vertical line (to x-axis)\ncontainer.insert('line',':first-child').attr({x1:vLinePointX,x2:vLinePointX,y1:yBase,y2:yEndSpike,'stroke-width':xThickness,stroke:xColor,'stroke-dasharray':Drawing.dashStyle(xa.spikedash,xThickness)}).classed('spikeline',true).classed('crisp',true);// Background vertical line (to x-axis)\ncontainer.insert('line',':first-child').attr({x1:vLinePointX,x2:vLinePointX,y1:yBase,y2:yEndSpike,'stroke-width':xThickness+2,stroke:contrastColor}).classed('spikeline',true).classed('crisp',true);}// X axis marker\nif(xMode.indexOf('marker')!==-1){container.insert('circle',':first-child').attr({cx:vLinePointX,cy:yEdge-(xa.side!=='top'?xThickness:-xThickness),r:xThickness,fill:xColor}).classed('spikeline',true);}}}function hoverChanged(gd,evt,oldhoverdata){// don't emit any events if nothing changed\nif(!oldhoverdata||oldhoverdata.length!==gd._hoverdata.length)return true;for(var i=oldhoverdata.length-1;i>=0;i--){var oldPt=oldhoverdata[i];var newPt=gd._hoverdata[i];if(oldPt.curveNumber!==newPt.curveNumber||String(oldPt.pointNumber)!==String(newPt.pointNumber)||String(oldPt.pointNumbers)!==String(newPt.pointNumbers)){return true;}}return false;}function spikesChanged(gd,oldspikepoints){// don't relayout the plot because of new spikelines if spikelines points didn't change\nif(!oldspikepoints)return true;if(oldspikepoints.vLinePoint!==gd._spikepoints.vLinePoint||oldspikepoints.hLinePoint!==gd._spikepoints.hLinePoint)return true;return false;}function plainText(s,len){return svgTextUtils.plainText(s||'',{len:len,allowedTags:['br','sub','sup','b','i','em']});}},{\"../../lib\":159,\"../../lib/events\":152,\"../../lib/override_cursor\":170,\"../../lib/svg_text_utils\":180,\"../../plots/cartesian/axes\":203,\"../../registry\":242,\"../color\":43,\"../dragelement\":61,\"../drawing\":64,\"./constants\":76,\"./helpers\":78,\"d3\":8,\"fast-isnumeric\":10,\"tinycolor2\":26}],80:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');module.exports=function handleHoverLabelDefaults(contIn,contOut,coerce,opts){opts=opts||{};coerce('hoverlabel.bgcolor',opts.bgcolor);coerce('hoverlabel.bordercolor',opts.bordercolor);coerce('hoverlabel.namelength',opts.namelength);Lib.coerceFont(coerce,'hoverlabel.font',opts.font);coerce('hoverlabel.align',opts.align);};},{\"../../lib\":159}],81:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports=function(opts,extra){opts=opts||{};extra=extra||{};var descPart=extra.description?' '+extra.description:'';var keys=extra.keys||[];if(keys.length>0){var quotedKeys=[];for(var i=0;i<keys.length;i++){quotedKeys[i]='`'+keys[i]+'`';}descPart=descPart+'Finally, the template string has access to ';if(keys.length===1){descPart='variable '+quotedKeys[0];}else{descPart='variables '+quotedKeys.slice(0,-1).join(', ')+' and '+quotedKeys.slice(-1)+'.';}}var hovertemplate={valType:'string',dflt:'',editType:opts.editType||'none'};if(opts.arrayOk!==false){hovertemplate.arrayOk=true;}return hovertemplate;};},{}],82:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var Lib=_dereq_('../../lib');var dragElement=_dereq_('../dragelement');var helpers=_dereq_('./helpers');var layoutAttributes=_dereq_('./layout_attributes');var hoverModule=_dereq_('./hover');module.exports={moduleType:'component',name:'fx',constants:_dereq_('./constants'),schema:{layout:layoutAttributes},attributes:_dereq_('./attributes'),layoutAttributes:layoutAttributes,supplyLayoutGlobalDefaults:_dereq_('./layout_global_defaults'),supplyDefaults:_dereq_('./defaults'),supplyLayoutDefaults:_dereq_('./layout_defaults'),calc:_dereq_('./calc'),getDistanceFunction:helpers.getDistanceFunction,getClosest:helpers.getClosest,inbox:helpers.inbox,quadrature:helpers.quadrature,appendArrayPointValue:helpers.appendArrayPointValue,castHoverOption:castHoverOption,castHoverinfo:castHoverinfo,hover:hoverModule.hover,unhover:dragElement.unhover,loneHover:hoverModule.loneHover,loneUnhover:loneUnhover,click:_dereq_('./click')};function loneUnhover(containerOrSelection){// duck type whether the arg is a d3 selection because ie9 doesn't\n// handle instanceof like modern browsers do.\nvar selection=Lib.isD3Selection(containerOrSelection)?containerOrSelection:d3.select(containerOrSelection);selection.selectAll('g.hovertext').remove();selection.selectAll('.spikeline').remove();}// helpers for traces that use Fx.loneHover\nfunction castHoverOption(trace,ptNumber,attr){return Lib.castOption(trace,ptNumber,'hoverlabel.'+attr);}function castHoverinfo(trace,fullLayout,ptNumber){function _coerce(val){return Lib.coerceHoverinfo({hoverinfo:val},{_module:trace._module},fullLayout);}return Lib.castOption(trace,ptNumber,'hoverinfo',_coerce);}},{\"../../lib\":159,\"../dragelement\":61,\"./attributes\":73,\"./calc\":74,\"./click\":75,\"./constants\":76,\"./defaults\":77,\"./helpers\":78,\"./hover\":79,\"./layout_attributes\":83,\"./layout_defaults\":84,\"./layout_global_defaults\":85,\"d3\":8}],83:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var constants=_dereq_('./constants');var fontAttrs=_dereq_('../../plots/font_attributes')({editType:'none'});fontAttrs.family.dflt=constants.HOVERFONT;fontAttrs.size.dflt=constants.HOVERFONTSIZE;module.exports={clickmode:{valType:'flaglist',flags:['event','select'],dflt:'event',editType:'plot',extras:['none']},dragmode:{valType:'enumerated',values:['zoom','pan','select','lasso','orbit','turntable',false],dflt:'zoom',editType:'modebar'},hovermode:{valType:'enumerated',values:['x','y','closest',false],editType:'modebar'},hoverdistance:{valType:'integer',min:-1,dflt:20,editType:'none'},spikedistance:{valType:'integer',min:-1,dflt:20,editType:'none'},hoverlabel:{bgcolor:{valType:'color',editType:'none'},bordercolor:{valType:'color',editType:'none'},font:fontAttrs,align:{valType:'enumerated',values:['left','right','auto'],dflt:'auto',editType:'none'},namelength:{valType:'integer',min:-1,dflt:15,editType:'none'},editType:'none'},selectdirection:{valType:'enumerated',values:['h','v','d','any'],dflt:'any',editType:'none'}};},{\"../../plots/font_attributes\":229,\"./constants\":76}],84:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var layoutAttributes=_dereq_('./layout_attributes');module.exports=function supplyLayoutDefaults(layoutIn,layoutOut,fullData){function coerce(attr,dflt){return Lib.coerce(layoutIn,layoutOut,layoutAttributes,attr,dflt);}var clickmode=coerce('clickmode');var dragMode=coerce('dragmode');if(dragMode==='select')coerce('selectdirection');var hovermodeDflt;if(layoutOut._has('cartesian')){if(clickmode.indexOf('select')>-1){hovermodeDflt='closest';}else{// flag for 'horizontal' plots:\n// determines the state of the mode bar 'compare' hovermode button\nlayoutOut._isHoriz=isHoriz(fullData,layoutOut);hovermodeDflt=layoutOut._isHoriz?'y':'x';}}else hovermodeDflt='closest';var hoverMode=coerce('hovermode',hovermodeDflt);if(hoverMode){coerce('hoverdistance');coerce('spikedistance');}// if only mapbox or geo subplots is present on graph,\n// reset 'zoom' dragmode to 'pan' until 'zoom' is implemented,\n// so that the correct modebar button is active\nvar hasMapbox=layoutOut._has('mapbox');var hasGeo=layoutOut._has('geo');var len=layoutOut._basePlotModules.length;if(layoutOut.dragmode==='zoom'&&((hasMapbox||hasGeo)&&len===1||hasMapbox&&hasGeo&&len===2)){layoutOut.dragmode='pan';}};function isHoriz(fullData,fullLayout){var stackOpts=fullLayout._scatterStackOpts||{};for(var i=0;i<fullData.length;i++){var trace=fullData[i];var subplot=trace.xaxis+trace.yaxis;var subplotStackOpts=stackOpts[subplot]||{};var groupOpts=subplotStackOpts[trace.stackgroup]||{};if(trace.orientation!=='h'&&groupOpts.orientation!=='h'){return false;}}return true;}},{\"../../lib\":159,\"./layout_attributes\":83}],85:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var handleHoverLabelDefaults=_dereq_('./hoverlabel_defaults');var layoutAttributes=_dereq_('./layout_attributes');module.exports=function supplyLayoutGlobalDefaults(layoutIn,layoutOut){function coerce(attr,dflt){return Lib.coerce(layoutIn,layoutOut,layoutAttributes,attr,dflt);}handleHoverLabelDefaults(layoutIn,layoutOut,coerce);};},{\"../../lib\":159,\"./hoverlabel_defaults\":80,\"./layout_attributes\":83}],86:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var counterRegex=_dereq_('../../lib/regex').counter;var domainAttrs=_dereq_('../../plots/domain').attributes;var cartesianIdRegex=_dereq_('../../plots/cartesian/constants').idRegex;var Template=_dereq_('../../plot_api/plot_template');var gridAttrs={rows:{valType:'integer',min:1,editType:'plot'},roworder:{valType:'enumerated',values:['top to bottom','bottom to top'],dflt:'top to bottom',editType:'plot'},columns:{valType:'integer',min:1,editType:'plot'},subplots:{valType:'info_array',freeLength:true,dimensions:2,items:{valType:'enumerated',values:[counterRegex('xy').toString(),''],editType:'plot'},editType:'plot'},xaxes:{valType:'info_array',freeLength:true,items:{valType:'enumerated',values:[cartesianIdRegex.x.toString(),''],editType:'plot'},editType:'plot'},yaxes:{valType:'info_array',freeLength:true,items:{valType:'enumerated',values:[cartesianIdRegex.y.toString(),''],editType:'plot'},editType:'plot'},pattern:{valType:'enumerated',values:['independent','coupled'],dflt:'coupled',editType:'plot'},xgap:{valType:'number',min:0,max:1,editType:'plot'},ygap:{valType:'number',min:0,max:1,editType:'plot'},domain:domainAttrs({name:'grid',editType:'plot',noGridCell:true},{}),xside:{valType:'enumerated',values:['bottom','bottom plot','top plot','top'],dflt:'bottom plot',editType:'plot'},yside:{valType:'enumerated',values:['left','left plot','right plot','right'],dflt:'left plot',editType:'plot'},editType:'plot'};function getAxes(layout,grid,axLetter){var gridVal=grid[axLetter+'axes'];var splomVal=Object.keys((layout._splomAxes||{})[axLetter]||{});if(Array.isArray(gridVal))return gridVal;if(splomVal.length)return splomVal;}// the shape of the grid - this needs to be done BEFORE supplyDataDefaults\n// so that non-subplot traces can place themselves in the grid\nfunction sizeDefaults(layoutIn,layoutOut){var gridIn=layoutIn.grid||{};var xAxes=getAxes(layoutOut,gridIn,'x');var yAxes=getAxes(layoutOut,gridIn,'y');if(!layoutIn.grid&&!xAxes&&!yAxes)return;var hasSubplotGrid=Array.isArray(gridIn.subplots)&&Array.isArray(gridIn.subplots[0]);var hasXaxes=Array.isArray(xAxes);var hasYaxes=Array.isArray(yAxes);var isSplomGenerated=hasXaxes&&xAxes!==gridIn.xaxes&&hasYaxes&&yAxes!==gridIn.yaxes;var dfltRows,dfltColumns;if(hasSubplotGrid){dfltRows=gridIn.subplots.length;dfltColumns=gridIn.subplots[0].length;}else{if(hasYaxes)dfltRows=yAxes.length;if(hasXaxes)dfltColumns=xAxes.length;}var gridOut=Template.newContainer(layoutOut,'grid');function coerce(attr,dflt){return Lib.coerce(gridIn,gridOut,gridAttrs,attr,dflt);}var rows=coerce('rows',dfltRows);var columns=coerce('columns',dfltColumns);if(!(rows*columns>1)){delete layoutOut.grid;return;}if(!hasSubplotGrid&&!hasXaxes&&!hasYaxes){var useDefaultSubplots=coerce('pattern')==='independent';if(useDefaultSubplots)hasSubplotGrid=true;}gridOut._hasSubplotGrid=hasSubplotGrid;var rowOrder=coerce('roworder');var reversed=rowOrder==='top to bottom';var dfltGapX=hasSubplotGrid?0.2:0.1;var dfltGapY=hasSubplotGrid?0.3:0.1;var dfltSideX,dfltSideY;if(isSplomGenerated&&layoutOut._splomGridDflt){dfltSideX=layoutOut._splomGridDflt.xside;dfltSideY=layoutOut._splomGridDflt.yside;}gridOut._domains={x:fillGridPositions('x',coerce,dfltGapX,dfltSideX,columns),y:fillGridPositions('y',coerce,dfltGapY,dfltSideY,rows,reversed)};}// coerce x or y sizing attributes and return an array of domains for this direction\nfunction fillGridPositions(axLetter,coerce,dfltGap,dfltSide,len,reversed){var dirGap=coerce(axLetter+'gap',dfltGap);var domain=coerce('domain.'+axLetter);coerce(axLetter+'side',dfltSide);var out=new Array(len);var start=domain[0];var step=(domain[1]-start)/(len-dirGap);var cellDomain=step*(1-dirGap);for(var i=0;i<len;i++){var cellStart=start+step*i;out[reversed?len-1-i:i]=[cellStart,cellStart+cellDomain];}return out;}// the (cartesian) contents of the grid - this needs to happen AFTER supplyDataDefaults\n// so that we know what cartesian subplots are available\nfunction contentDefaults(layoutIn,layoutOut){var gridOut=layoutOut.grid;// make sure we got to the end of handleGridSizing\nif(!gridOut||!gridOut._domains)return;var gridIn=layoutIn.grid||{};var subplots=layoutOut._subplots;var hasSubplotGrid=gridOut._hasSubplotGrid;var rows=gridOut.rows;var columns=gridOut.columns;var useDefaultSubplots=gridOut.pattern==='independent';var i,j,xId,yId,subplotId,subplotsOut,yPos;var axisMap=gridOut._axisMap={};if(hasSubplotGrid){var subplotsIn=gridIn.subplots||[];subplotsOut=gridOut.subplots=new Array(rows);var index=1;for(i=0;i<rows;i++){var rowOut=subplotsOut[i]=new Array(columns);var rowIn=subplotsIn[i]||[];for(j=0;j<columns;j++){if(useDefaultSubplots){subplotId=index===1?'xy':'x'+index+'y'+index;index++;}else subplotId=rowIn[j];rowOut[j]='';if(subplots.cartesian.indexOf(subplotId)!==-1){yPos=subplotId.indexOf('y');xId=subplotId.slice(0,yPos);yId=subplotId.slice(yPos);if(axisMap[xId]!==undefined&&axisMap[xId]!==j||axisMap[yId]!==undefined&&axisMap[yId]!==i){continue;}rowOut[j]=subplotId;axisMap[xId]=j;axisMap[yId]=i;}}}}else{var xAxes=getAxes(layoutOut,gridIn,'x');var yAxes=getAxes(layoutOut,gridIn,'y');gridOut.xaxes=fillGridAxes(xAxes,subplots.xaxis,columns,axisMap,'x');gridOut.yaxes=fillGridAxes(yAxes,subplots.yaxis,rows,axisMap,'y');}var anchors=gridOut._anchors={};var reversed=gridOut.roworder==='top to bottom';for(var axisId in axisMap){var axLetter=axisId.charAt(0);var side=gridOut[axLetter+'side'];var i0,inc,iFinal;if(side.length<8){// grid edge -  ie not \"* plot\" - make these as free axes\n// since we're not guaranteed to have a subplot there at all\nanchors[axisId]='free';}else if(axLetter==='x'){if(side.charAt(0)==='t'===reversed){i0=0;inc=1;iFinal=rows;}else{i0=rows-1;inc=-1;iFinal=-1;}if(hasSubplotGrid){var column=axisMap[axisId];for(i=i0;i!==iFinal;i+=inc){subplotId=subplotsOut[i][column];if(!subplotId)continue;yPos=subplotId.indexOf('y');if(subplotId.slice(0,yPos)===axisId){anchors[axisId]=subplotId.slice(yPos);break;}}}else{for(i=i0;i!==iFinal;i+=inc){yId=gridOut.yaxes[i];if(subplots.cartesian.indexOf(axisId+yId)!==-1){anchors[axisId]=yId;break;}}}}else{if(side.charAt(0)==='l'){i0=0;inc=1;iFinal=columns;}else{i0=columns-1;inc=-1;iFinal=-1;}if(hasSubplotGrid){var row=axisMap[axisId];for(i=i0;i!==iFinal;i+=inc){subplotId=subplotsOut[row][i];if(!subplotId)continue;yPos=subplotId.indexOf('y');if(subplotId.slice(yPos)===axisId){anchors[axisId]=subplotId.slice(0,yPos);break;}}}else{for(i=i0;i!==iFinal;i+=inc){xId=gridOut.xaxes[i];if(subplots.cartesian.indexOf(xId+axisId)!==-1){anchors[axisId]=xId;break;}}}}}}function fillGridAxes(axesIn,axesAllowed,len,axisMap,axLetter){var out=new Array(len);var i;function fillOneAxis(i,axisId){if(axesAllowed.indexOf(axisId)!==-1&&axisMap[axisId]===undefined){out[i]=axisId;axisMap[axisId]=i;}else out[i]='';}if(Array.isArray(axesIn)){for(i=0;i<len;i++){fillOneAxis(i,axesIn[i]);}}else{// default axis list is the first `len` axis ids\nfillOneAxis(0,axLetter);for(i=1;i<len;i++){fillOneAxis(i,axLetter+(i+1));}}return out;}module.exports={moduleType:'component',name:'grid',schema:{layout:{grid:gridAttrs}},layoutAttributes:gridAttrs,sizeDefaults:sizeDefaults,contentDefaults:contentDefaults};},{\"../../lib\":159,\"../../lib/regex\":174,\"../../plot_api/plot_template\":193,\"../../plots/cartesian/constants\":209,\"../../plots/domain\":228}],87:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var cartesianConstants=_dereq_('../../plots/cartesian/constants');var templatedArray=_dereq_('../../plot_api/plot_template').templatedArray;module.exports=templatedArray('image',{visible:{valType:'boolean',dflt:true,editType:'arraydraw'},source:{valType:'string',editType:'arraydraw'},layer:{valType:'enumerated',values:['below','above'],dflt:'above',editType:'arraydraw'},sizex:{valType:'number',dflt:0,editType:'arraydraw'},sizey:{valType:'number',dflt:0,editType:'arraydraw'},sizing:{valType:'enumerated',values:['fill','contain','stretch'],dflt:'contain',editType:'arraydraw'},opacity:{valType:'number',min:0,max:1,dflt:1,editType:'arraydraw'},x:{valType:'any',dflt:0,editType:'arraydraw'},y:{valType:'any',dflt:0,editType:'arraydraw'},xanchor:{valType:'enumerated',values:['left','center','right'],dflt:'left',editType:'arraydraw'},yanchor:{valType:'enumerated',values:['top','middle','bottom'],dflt:'top',editType:'arraydraw'},xref:{valType:'enumerated',values:['paper',cartesianConstants.idRegex.x.toString()],dflt:'paper',editType:'arraydraw'},yref:{valType:'enumerated',values:['paper',cartesianConstants.idRegex.y.toString()],dflt:'paper',editType:'arraydraw'},editType:'arraydraw'});},{\"../../plot_api/plot_template\":193,\"../../plots/cartesian/constants\":209}],88:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var isNumeric=_dereq_('fast-isnumeric');var toLogRange=_dereq_('../../lib/to_log_range');/*\n * convertCoords: when converting an axis between log and linear\n * you need to alter any images on that axis to keep them\n * pointing at the same data point.\n * In v2.0 this will become obsolete (or perhaps size will still need conversion?)\n * we convert size by declaring that the maximum extent *in data units* should be\n * the same, assuming the image is anchored by its center (could remove that restriction\n * if we think it's important) even though the actual left and right values will not be\n * quite the same since the scale becomes nonlinear (and central anchor means the pixel\n * center of the image, not the data units center)\n *\n * gd: the plot div\n * ax: the axis being changed\n * newType: the type it's getting\n * doExtra: function(attr, val) from inside relayout that sets the attribute.\n *     Use this to make the changes as it's aware if any other changes in the\n *     same relayout call should override this conversion.\n */module.exports=function convertCoords(gd,ax,newType,doExtra){ax=ax||{};var toLog=newType==='log'&&ax.type==='linear';var fromLog=newType==='linear'&&ax.type==='log';if(!(toLog||fromLog))return;var images=gd._fullLayout.images;var axLetter=ax._id.charAt(0);var image;var attrPrefix;for(var i=0;i<images.length;i++){image=images[i];attrPrefix='images['+i+'].';if(image[axLetter+'ref']===ax._id){var currentPos=image[axLetter];var currentSize=image['size'+axLetter];var newPos=null;var newSize=null;if(toLog){newPos=toLogRange(currentPos,ax.range);// this is the inverse of the conversion we do in fromLog below\n// so that the conversion is reversible (notice the fromLog conversion\n// is like sinh, and this one looks like arcsinh)\nvar dx=currentSize/Math.pow(10,newPos)/2;newSize=2*Math.log(dx+Math.sqrt(1+dx*dx))/Math.LN10;}else{newPos=Math.pow(10,currentPos);newSize=newPos*(Math.pow(10,currentSize/2)-Math.pow(10,-currentSize/2));}// if conversion failed, delete the value so it can get a default later on\nif(!isNumeric(newPos)){newPos=null;newSize=null;}else if(!isNumeric(newSize))newSize=null;doExtra(attrPrefix+axLetter,newPos);doExtra(attrPrefix+'size'+axLetter,newSize);}}};},{\"../../lib/to_log_range\":182,\"fast-isnumeric\":10}],89:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var Axes=_dereq_('../../plots/cartesian/axes');var handleArrayContainerDefaults=_dereq_('../../plots/array_container_defaults');var attributes=_dereq_('./attributes');var name='images';module.exports=function supplyLayoutDefaults(layoutIn,layoutOut){var opts={name:name,handleItemDefaults:imageDefaults};handleArrayContainerDefaults(layoutIn,layoutOut,opts);};function imageDefaults(imageIn,imageOut,fullLayout){function coerce(attr,dflt){return Lib.coerce(imageIn,imageOut,attributes,attr,dflt);}var source=coerce('source');var visible=coerce('visible',!!source);if(!visible)return imageOut;coerce('layer');coerce('xanchor');coerce('yanchor');coerce('sizex');coerce('sizey');coerce('sizing');coerce('opacity');var gdMock={_fullLayout:fullLayout};var axLetters=['x','y'];for(var i=0;i<2;i++){// 'paper' is the fallback axref\nvar axLetter=axLetters[i];var axRef=Axes.coerceRef(imageIn,imageOut,gdMock,axLetter,'paper');if(axRef!=='paper'){var ax=Axes.getFromId(gdMock,axRef);ax._imgIndices.push(imageOut._index);}Axes.coercePosition(imageOut,gdMock,coerce,axRef,axLetter,0);}return imageOut;}},{\"../../lib\":159,\"../../plots/array_container_defaults\":199,\"../../plots/cartesian/axes\":203,\"./attributes\":87}],90:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var Drawing=_dereq_('../drawing');var Axes=_dereq_('../../plots/cartesian/axes');var xmlnsNamespaces=_dereq_('../../constants/xmlns_namespaces');module.exports=function draw(gd){var fullLayout=gd._fullLayout;var imageDataAbove=[];var imageDataSubplot={};var imageDataBelow=[];var subplot;var i;// Sort into top, subplot, and bottom layers\nfor(i=0;i<fullLayout.images.length;i++){var img=fullLayout.images[i];if(img.visible){if(img.layer==='below'&&img.xref!=='paper'&&img.yref!=='paper'){subplot=img.xref+img.yref;var plotinfo=fullLayout._plots[subplot];if(!plotinfo){// Fall back to _imageLowerLayer in case the requested subplot doesn't exist.\n// This can happen if you reference the image to an x / y axis combination\n// that doesn't have any data on it (and layer is below)\nimageDataBelow.push(img);continue;}if(plotinfo.mainplot){subplot=plotinfo.mainplot.id;}if(!imageDataSubplot[subplot]){imageDataSubplot[subplot]=[];}imageDataSubplot[subplot].push(img);}else if(img.layer==='above'){imageDataAbove.push(img);}else{imageDataBelow.push(img);}}}var anchors={x:{left:{sizing:'xMin',offset:0},center:{sizing:'xMid',offset:-1/2},right:{sizing:'xMax',offset:-1}},y:{top:{sizing:'YMin',offset:0},middle:{sizing:'YMid',offset:-1/2},bottom:{sizing:'YMax',offset:-1}}};// Images must be converted to dataURL's for exporting.\nfunction setImage(d){var thisImage=d3.select(this);if(this.img&&this.img.src===d.source){return;}thisImage.attr('xmlns',xmlnsNamespaces.svg);var imagePromise=new Promise(function(resolve){var img=new Image();this.img=img;// If not set, a `tainted canvas` error is thrown\nimg.setAttribute('crossOrigin','anonymous');img.onerror=errorHandler;img.onload=function(){var canvas=document.createElement('canvas');canvas.width=this.width;canvas.height=this.height;var ctx=canvas.getContext('2d');ctx.drawImage(this,0,0);var dataURL=canvas.toDataURL('image/png');thisImage.attr('xlink:href',dataURL);// resolve promise in onload handler instead of on 'load' to support IE11\n// see https://github.com/plotly/plotly.js/issues/1685\n// for more details\nresolve();};thisImage.on('error',errorHandler);img.src=d.source;function errorHandler(){thisImage.remove();resolve();}}.bind(this));gd._promises.push(imagePromise);}function applyAttributes(d){var thisImage=d3.select(this);// Axes if specified\nvar xa=Axes.getFromId(gd,d.xref);var ya=Axes.getFromId(gd,d.yref);var size=fullLayout._size;var width=xa?Math.abs(xa.l2p(d.sizex)-xa.l2p(0)):d.sizex*size.w;var height=ya?Math.abs(ya.l2p(d.sizey)-ya.l2p(0)):d.sizey*size.h;// Offsets for anchor positioning\nvar xOffset=width*anchors.x[d.xanchor].offset;var yOffset=height*anchors.y[d.yanchor].offset;var sizing=anchors.x[d.xanchor].sizing+anchors.y[d.yanchor].sizing;// Final positions\nvar xPos=(xa?xa.r2p(d.x)+xa._offset:d.x*size.w+size.l)+xOffset;var yPos=(ya?ya.r2p(d.y)+ya._offset:size.h-d.y*size.h+size.t)+yOffset;// Construct the proper aspectRatio attribute\nswitch(d.sizing){case'fill':sizing+=' slice';break;case'stretch':sizing='none';break;}thisImage.attr({x:xPos,y:yPos,width:width,height:height,preserveAspectRatio:sizing,opacity:d.opacity});// Set proper clipping on images\nvar xId=xa?xa._id:'';var yId=ya?ya._id:'';var clipAxes=xId+yId;Drawing.setClipUrl(thisImage,clipAxes?'clip'+fullLayout._uid+clipAxes:null,gd);}var imagesBelow=fullLayout._imageLowerLayer.selectAll('image').data(imageDataBelow);var imagesAbove=fullLayout._imageUpperLayer.selectAll('image').data(imageDataAbove);imagesBelow.enter().append('image');imagesAbove.enter().append('image');imagesBelow.exit().remove();imagesAbove.exit().remove();imagesBelow.each(function(d){setImage.bind(this)(d);applyAttributes.bind(this)(d);});imagesAbove.each(function(d){setImage.bind(this)(d);applyAttributes.bind(this)(d);});var allSubplots=Object.keys(fullLayout._plots);for(i=0;i<allSubplots.length;i++){subplot=allSubplots[i];var subplotObj=fullLayout._plots[subplot];// filter out overlaid plots (which havd their images on the main plot)\n// and gl2d plots (which don't support below images, at least not yet)\nif(!subplotObj.imagelayer)continue;var imagesOnSubplot=subplotObj.imagelayer.selectAll('image')// even if there are no images on this subplot, we need to run\n// enter and exit in case there were previously\n.data(imageDataSubplot[subplot]||[]);imagesOnSubplot.enter().append('image');imagesOnSubplot.exit().remove();imagesOnSubplot.each(function(d){setImage.bind(this)(d);applyAttributes.bind(this)(d);});}};},{\"../../constants/xmlns_namespaces\":141,\"../../plots/cartesian/axes\":203,\"../drawing\":64,\"d3\":8}],91:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports={moduleType:'component',name:'images',layoutAttributes:_dereq_('./attributes'),supplyLayoutDefaults:_dereq_('./defaults'),includeBasePlot:_dereq_('../../plots/cartesian/include_components')('images'),draw:_dereq_('./draw'),convertCoords:_dereq_('./convert_coords')};},{\"../../plots/cartesian/include_components\":213,\"./attributes\":87,\"./convert_coords\":88,\"./defaults\":89,\"./draw\":90}],92:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var fontAttrs=_dereq_('../../plots/font_attributes');var colorAttrs=_dereq_('../color/attributes');module.exports={bgcolor:{valType:'color',editType:'legend'},bordercolor:{valType:'color',dflt:colorAttrs.defaultLine,editType:'legend'},borderwidth:{valType:'number',min:0,dflt:0,editType:'legend'},font:fontAttrs({editType:'legend'}),orientation:{valType:'enumerated',values:['v','h'],dflt:'v',editType:'legend'},traceorder:{valType:'flaglist',flags:['reversed','grouped'],extras:['normal'],editType:'legend'},tracegroupgap:{valType:'number',min:0,dflt:10,editType:'legend'},itemsizing:{valType:'enumerated',values:['trace','constant'],dflt:'trace',editType:'legend'},x:{valType:'number',min:-2,max:3,dflt:1.02,editType:'legend'},xanchor:{valType:'enumerated',values:['auto','left','center','right'],dflt:'left',editType:'legend'},y:{valType:'number',min:-2,max:3,dflt:1,editType:'legend'},yanchor:{valType:'enumerated',values:['auto','top','middle','bottom'],dflt:'auto',editType:'legend'},uirevision:{valType:'any',editType:'none'},valign:{valType:'enumerated',values:['top','middle','bottom'],dflt:'middle',editType:'legend'},editType:'legend'};},{\"../../plots/font_attributes\":229,\"../color/attributes\":42}],93:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports={scrollBarWidth:6,scrollBarMinHeight:20,scrollBarColor:'#808BA4',scrollBarMargin:4,textOffsetX:40};},{}],94:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Registry=_dereq_('../../registry');var Lib=_dereq_('../../lib');var Template=_dereq_('../../plot_api/plot_template');var attributes=_dereq_('./attributes');var basePlotLayoutAttributes=_dereq_('../../plots/layout_attributes');var helpers=_dereq_('./helpers');module.exports=function legendDefaults(layoutIn,layoutOut,fullData){var containerIn=layoutIn.legend||{};var legendTraceCount=0;var legendReallyHasATrace=false;var defaultOrder='normal';var defaultX,defaultY,defaultXAnchor,defaultYAnchor;for(var i=0;i<fullData.length;i++){var trace=fullData[i];if(!trace.visible)continue;// Note that we explicitly count any trace that is either shown or\n// *would* be shown by default, toward the two traces you need to\n// ensure the legend is shown by default, because this can still help\n// disambiguate.\nif(trace.showlegend||trace._dfltShowLegend){legendTraceCount++;if(trace.showlegend){legendReallyHasATrace=true;// Always show the legend by default if there's a pie,\n// or if there's only one trace but it's explicitly shown\nif(Registry.traceIs(trace,'pie')||trace._input.showlegend===true){legendTraceCount++;}}}if(Registry.traceIs(trace,'bar')&&layoutOut.barmode==='stack'||['tonextx','tonexty'].indexOf(trace.fill)!==-1){defaultOrder=helpers.isGrouped({traceorder:defaultOrder})?'grouped+reversed':'reversed';}if(trace.legendgroup!==undefined&&trace.legendgroup!==''){defaultOrder=helpers.isReversed({traceorder:defaultOrder})?'reversed+grouped':'grouped';}}var showLegend=Lib.coerce(layoutIn,layoutOut,basePlotLayoutAttributes,'showlegend',legendReallyHasATrace&&legendTraceCount>1);if(showLegend===false&&!containerIn.uirevision)return;var containerOut=Template.newContainer(layoutOut,'legend');function coerce(attr,dflt){return Lib.coerce(containerIn,containerOut,attributes,attr,dflt);}coerce('uirevision',layoutOut.uirevision);if(showLegend===false)return;coerce('bgcolor',layoutOut.paper_bgcolor);coerce('bordercolor');coerce('borderwidth');Lib.coerceFont(coerce,'font',layoutOut.font);coerce('orientation');if(containerOut.orientation==='h'){var xaxis=layoutIn.xaxis;if(Registry.getComponentMethod('rangeslider','isVisible')(xaxis)){defaultX=0;defaultXAnchor='left';defaultY=1.1;defaultYAnchor='bottom';}else{defaultX=0;defaultXAnchor='left';defaultY=-0.1;defaultYAnchor='top';}}coerce('traceorder',defaultOrder);if(helpers.isGrouped(layoutOut.legend))coerce('tracegroupgap');coerce('itemsizing');coerce('x',defaultX);coerce('xanchor',defaultXAnchor);coerce('y',defaultY);coerce('yanchor',defaultYAnchor);coerce('valign');Lib.noneOrAll(containerIn,containerOut,['x','y']);};},{\"../../lib\":159,\"../../plot_api/plot_template\":193,\"../../plots/layout_attributes\":233,\"../../registry\":242,\"./attributes\":92,\"./helpers\":98}],95:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var Lib=_dereq_('../../lib');var Plots=_dereq_('../../plots/plots');var Registry=_dereq_('../../registry');var Events=_dereq_('../../lib/events');var dragElement=_dereq_('../dragelement');var Drawing=_dereq_('../drawing');var Color=_dereq_('../color');var svgTextUtils=_dereq_('../../lib/svg_text_utils');var handleClick=_dereq_('./handle_click');var constants=_dereq_('./constants');var interactConstants=_dereq_('../../constants/interactions');var alignmentConstants=_dereq_('../../constants/alignment');var LINE_SPACING=alignmentConstants.LINE_SPACING;var FROM_TL=alignmentConstants.FROM_TL;var FROM_BR=alignmentConstants.FROM_BR;var getLegendData=_dereq_('./get_legend_data');var style=_dereq_('./style');var helpers=_dereq_('./helpers');var DBLCLICKDELAY=interactConstants.DBLCLICKDELAY;module.exports=function draw(gd){var fullLayout=gd._fullLayout;var clipId='legend'+fullLayout._uid;if(!fullLayout._infolayer||!gd.calcdata)return;if(!gd._legendMouseDownTime)gd._legendMouseDownTime=0;var opts=fullLayout.legend;var legendData=fullLayout.showlegend&&getLegendData(gd.calcdata,opts);var hiddenSlices=fullLayout.hiddenlabels||[];if(!fullLayout.showlegend||!legendData.length){fullLayout._infolayer.selectAll('.legend').remove();fullLayout._topdefs.select('#'+clipId).remove();Plots.autoMargin(gd,'legend');return;}var maxLength=0;for(var i=0;i<legendData.length;i++){for(var j=0;j<legendData[i].length;j++){var item=legendData[i][j][0];var trace=item.trace;var isPie=Registry.traceIs(trace,'pie');var name=isPie?item.label:trace.name;maxLength=Math.max(maxLength,name&&name.length||0);}}var firstRender=false;var legend=Lib.ensureSingle(fullLayout._infolayer,'g','legend',function(s){s.attr('pointer-events','all');firstRender=true;});var clipPath=Lib.ensureSingleById(fullLayout._topdefs,'clipPath',clipId,function(s){s.append('rect');});var bg=Lib.ensureSingle(legend,'rect','bg',function(s){s.attr('shape-rendering','crispEdges');});bg.call(Color.stroke,opts.bordercolor).call(Color.fill,opts.bgcolor).style('stroke-width',opts.borderwidth+'px');var scrollBox=Lib.ensureSingle(legend,'g','scrollbox');var scrollBar=Lib.ensureSingle(legend,'rect','scrollbar',function(s){s.attr({rx:20,ry:3,width:0,height:0}).call(Color.fill,'#808BA4');});var groups=scrollBox.selectAll('g.groups').data(legendData);groups.enter().append('g').attr('class','groups');groups.exit().remove();var traces=groups.selectAll('g.traces').data(Lib.identity);traces.enter().append('g').attr('class','traces');traces.exit().remove();traces.style('opacity',function(d){var trace=d[0].trace;if(Registry.traceIs(trace,'pie')){return hiddenSlices.indexOf(d[0].label)!==-1?0.5:1;}else{return trace.visible==='legendonly'?0.5:1;}}).each(function(){d3.select(this).call(drawTexts,gd,maxLength);}).call(style,gd).each(function(){d3.select(this).call(setupTraceToggle,gd);});Lib.syncOrAsync([Plots.previousPromises,function(){if(firstRender){computeLegendDimensions(gd,groups,traces);expandMargin(gd);}// Position and size the legend\nvar lxMin=0;var lxMax=fullLayout.width;var lyMin=0;var lyMax=fullLayout.height;computeLegendDimensions(gd,groups,traces);if(opts._height>lyMax){// If the legend doesn't fit in the plot area,\n// do not expand the vertical margins.\nexpandHorizontalMargin(gd);}else{expandMargin(gd);}// Scroll section must be executed after repositionLegend.\n// It requires the legend width, height, x and y to position the scrollbox\n// and these values are mutated in repositionLegend.\nvar gs=fullLayout._size;var lx=gs.l+gs.w*opts.x;var ly=gs.t+gs.h*(1-opts.y);if(Lib.isRightAnchor(opts)){lx-=opts._width;}else if(Lib.isCenterAnchor(opts)){lx-=opts._width/2;}if(Lib.isBottomAnchor(opts)){ly-=opts._height;}else if(Lib.isMiddleAnchor(opts)){ly-=opts._height/2;}// Make sure the legend left and right sides are visible\nvar legendWidth=opts._width;var legendWidthMax=gs.w;if(legendWidth>legendWidthMax){lx=gs.l;legendWidth=legendWidthMax;}else{if(lx+legendWidth>lxMax)lx=lxMax-legendWidth;if(lx<lxMin)lx=lxMin;legendWidth=Math.min(lxMax-lx,opts._width);}// Make sure the legend top and bottom are visible\n// (legends with a scroll bar are not allowed to stretch beyond the extended\n// margins)\nvar legendHeight=opts._height;var legendHeightMax=gs.h;if(legendHeight>legendHeightMax){ly=gs.t;legendHeight=legendHeightMax;}else{if(ly+legendHeight>lyMax)ly=lyMax-legendHeight;if(ly<lyMin)ly=lyMin;legendHeight=Math.min(lyMax-ly,opts._height);}// Set size and position of all the elements that make up a legend:\n// legend, background and border, scroll box and scroll bar\nDrawing.setTranslate(legend,lx,ly);// to be safe, remove previous listeners\nscrollBar.on('.drag',null);legend.on('wheel',null);if(opts._height<=legendHeight||gd._context.staticPlot){// if scrollbar should not be shown.\nbg.attr({width:legendWidth-opts.borderwidth,height:legendHeight-opts.borderwidth,x:opts.borderwidth/2,y:opts.borderwidth/2});Drawing.setTranslate(scrollBox,0,0);clipPath.select('rect').attr({width:legendWidth-2*opts.borderwidth,height:legendHeight-2*opts.borderwidth,x:opts.borderwidth,y:opts.borderwidth});Drawing.setClipUrl(scrollBox,clipId,gd);Drawing.setRect(scrollBar,0,0,0,0);delete opts._scrollY;}else{var scrollBarHeight=Math.max(constants.scrollBarMinHeight,legendHeight*legendHeight/opts._height);var scrollBarYMax=legendHeight-scrollBarHeight-2*constants.scrollBarMargin;var scrollBoxYMax=opts._height-legendHeight;var scrollRatio=scrollBarYMax/scrollBoxYMax;var scrollBoxY=Math.min(opts._scrollY||0,scrollBoxYMax);// increase the background and clip-path width\n// by the scrollbar width and margin\nbg.attr({width:legendWidth-2*opts.borderwidth+constants.scrollBarWidth+constants.scrollBarMargin,height:legendHeight-opts.borderwidth,x:opts.borderwidth/2,y:opts.borderwidth/2});clipPath.select('rect').attr({width:legendWidth-2*opts.borderwidth+constants.scrollBarWidth+constants.scrollBarMargin,height:legendHeight-2*opts.borderwidth,x:opts.borderwidth,y:opts.borderwidth+scrollBoxY});Drawing.setClipUrl(scrollBox,clipId,gd);scrollHandler(scrollBoxY,scrollBarHeight,scrollRatio);legend.on('wheel',function(){scrollBoxY=Lib.constrain(opts._scrollY+d3.event.deltaY/scrollBarYMax*scrollBoxYMax,0,scrollBoxYMax);scrollHandler(scrollBoxY,scrollBarHeight,scrollRatio);if(scrollBoxY!==0&&scrollBoxY!==scrollBoxYMax){d3.event.preventDefault();}});var eventY0,scrollBoxY0;var drag=d3.behavior.drag().on('dragstart',function(){eventY0=d3.event.sourceEvent.clientY;scrollBoxY0=scrollBoxY;}).on('drag',function(){var e=d3.event.sourceEvent;if(e.buttons===2||e.ctrlKey)return;scrollBoxY=Lib.constrain((e.clientY-eventY0)/scrollRatio+scrollBoxY0,0,scrollBoxYMax);scrollHandler(scrollBoxY,scrollBarHeight,scrollRatio);});scrollBar.call(drag);}function scrollHandler(scrollBoxY,scrollBarHeight,scrollRatio){opts._scrollY=gd._fullLayout.legend._scrollY=scrollBoxY;Drawing.setTranslate(scrollBox,0,-scrollBoxY);Drawing.setRect(scrollBar,legendWidth,constants.scrollBarMargin+scrollBoxY*scrollRatio,constants.scrollBarWidth,scrollBarHeight);clipPath.select('rect').attr({y:opts.borderwidth+scrollBoxY});}if(gd._context.edits.legendPosition){var xf,yf,x0,y0;legend.classed('cursor-move',true);dragElement.init({element:legend.node(),gd:gd,prepFn:function prepFn(){var transform=Drawing.getTranslate(legend);x0=transform.x;y0=transform.y;},moveFn:function moveFn(dx,dy){var newX=x0+dx;var newY=y0+dy;Drawing.setTranslate(legend,newX,newY);xf=dragElement.align(newX,0,gs.l,gs.l+gs.w,opts.xanchor);yf=dragElement.align(newY,0,gs.t+gs.h,gs.t,opts.yanchor);},doneFn:function doneFn(){if(xf!==undefined&&yf!==undefined){Registry.call('_guiRelayout',gd,{'legend.x':xf,'legend.y':yf});}},clickFn:function clickFn(numClicks,e){var clickedTrace=fullLayout._infolayer.selectAll('g.traces').filter(function(){var bbox=this.getBoundingClientRect();return e.clientX>=bbox.left&&e.clientX<=bbox.right&&e.clientY>=bbox.top&&e.clientY<=bbox.bottom;});if(clickedTrace.size()>0){clickOrDoubleClick(gd,legend,clickedTrace,numClicks,e);}}});}}],gd);};function clickOrDoubleClick(gd,legend,legendItem,numClicks,evt){var trace=legendItem.data()[0][0].trace;var evtData={event:evt,node:legendItem.node(),curveNumber:trace.index,expandedIndex:trace._expandedIndex,data:gd.data,layout:gd.layout,frames:gd._transitionData._frames,config:gd._context,fullData:gd._fullData,fullLayout:gd._fullLayout};if(trace._group){evtData.group=trace._group;}if(trace.type==='pie'){evtData.label=legendItem.datum()[0].label;}var clickVal=Events.triggerHandler(gd,'plotly_legendclick',evtData);if(clickVal===false)return;if(numClicks===1){legend._clickTimeout=setTimeout(function(){handleClick(legendItem,gd,numClicks);},DBLCLICKDELAY);}else if(numClicks===2){if(legend._clickTimeout)clearTimeout(legend._clickTimeout);gd._legendMouseDownTime=0;var dblClickVal=Events.triggerHandler(gd,'plotly_legenddoubleclick',evtData);if(dblClickVal!==false)handleClick(legendItem,gd,numClicks);}}function drawTexts(g,gd,maxLength){var legendItem=g.data()[0][0];var fullLayout=gd._fullLayout;var trace=legendItem.trace;var isPie=Registry.traceIs(trace,'pie');var traceIndex=trace.index;var isEditable=gd._context.edits.legendText&&!isPie;var name=isPie?legendItem.label:trace.name;if(fullLayout.meta){name=Lib.templateString(name,{meta:fullLayout.meta});}var textEl=Lib.ensureSingle(g,'text','legendtext');textEl.attr('text-anchor','start').classed('user-select-none',true).call(Drawing.font,fullLayout.legend.font).text(isEditable?ensureLength(name,maxLength):name);svgTextUtils.positionText(textEl,constants.textOffsetX,0);function textLayout(s){svgTextUtils.convertToTspans(s,gd,function(){computeTextDimensions(g,gd);});}if(isEditable){textEl.call(svgTextUtils.makeEditable,{gd:gd,text:name}).call(textLayout).on('edit',function(newName){this.text(ensureLength(newName,maxLength)).call(textLayout);var fullInput=legendItem.trace._fullInput||{};var update={};if(Registry.hasTransform(fullInput,'groupby')){var groupbyIndices=Registry.getTransformIndices(fullInput,'groupby');var index=groupbyIndices[groupbyIndices.length-1];var kcont=Lib.keyedContainer(fullInput,'transforms['+index+'].styles','target','value.name');kcont.set(legendItem.trace._group,newName);update=kcont.constructUpdate();}else{update.name=newName;}return Registry.call('_guiRestyle',gd,update,traceIndex);});}else{textLayout(textEl);}}/*\n * Make sure we have a reasonably clickable region.\n * If this string is missing or very short, pad it with spaces out to at least\n * 4 characters, up to the max length of other labels, on the assumption that\n * most characters are wider than spaces so a string of spaces will usually be\n * no wider than the real labels.\n */function ensureLength(str,maxLength){var targetLength=Math.max(4,maxLength);if(str&&str.trim().length>=targetLength/2)return str;str=str||'';for(var i=targetLength-str.length;i>0;i--){str+=' ';}return str;}function setupTraceToggle(g,gd){var newMouseDownTime;var numClicks=1;var traceToggle=Lib.ensureSingle(g,'rect','legendtoggle',function(s){s.style('cursor','pointer').attr('pointer-events','all').call(Color.fill,'rgba(0,0,0,0)');});traceToggle.on('mousedown',function(){newMouseDownTime=new Date().getTime();if(newMouseDownTime-gd._legendMouseDownTime<DBLCLICKDELAY){// in a click train\nnumClicks+=1;}else{// new click train\nnumClicks=1;gd._legendMouseDownTime=newMouseDownTime;}});traceToggle.on('mouseup',function(){if(gd._dragged||gd._editing)return;var legend=gd._fullLayout.legend;if(new Date().getTime()-gd._legendMouseDownTime>DBLCLICKDELAY){numClicks=Math.max(numClicks-1,1);}clickOrDoubleClick(gd,legend,g,numClicks,d3.event);});}function computeTextDimensions(g,gd){var legendItem=g.data()[0][0];if(!legendItem.trace.showlegend){g.remove();return;}var mathjaxGroup=g.select('g[class*=math-group]');var mathjaxNode=mathjaxGroup.node();var opts=gd._fullLayout.legend;var lineHeight=opts.font.size*LINE_SPACING;var height,width;if(mathjaxNode){var mathjaxBB=Drawing.bBox(mathjaxNode);height=mathjaxBB.height;width=mathjaxBB.width;Drawing.setTranslate(mathjaxGroup,0,height/4);}else{var text=g.select('.legendtext');var textLines=svgTextUtils.lineCount(text);var textNode=text.node();height=lineHeight*textLines;width=textNode?Drawing.bBox(textNode).width:0;// approximation to height offset to center the font\n// to avoid getBoundingClientRect\nvar textY=lineHeight*(0.3+(1-textLines)/2);svgTextUtils.positionText(text,constants.textOffsetX,textY);}legendItem.lineHeight=lineHeight;legendItem.height=Math.max(height,16)+3;legendItem.width=width;}function computeLegendDimensions(gd,groups,traces){var fullLayout=gd._fullLayout;var opts=fullLayout.legend;var borderwidth=opts.borderwidth;var isGrouped=helpers.isGrouped(opts);var extraWidth=0;var traceGap=5;opts._width=0;opts._height=0;if(helpers.isVertical(opts)){if(isGrouped){groups.each(function(d,i){Drawing.setTranslate(this,0,i*opts.tracegroupgap);});}traces.each(function(d){var legendItem=d[0];var textHeight=legendItem.height;var textWidth=legendItem.width;Drawing.setTranslate(this,borderwidth,5+borderwidth+opts._height+textHeight/2);opts._height+=textHeight;opts._width=Math.max(opts._width,textWidth);});opts._width+=45+borderwidth*2;opts._height+=10+borderwidth*2;if(isGrouped){opts._height+=(opts._lgroupsLength-1)*opts.tracegroupgap;}extraWidth=40;}else if(isGrouped){var maxHeight=0;var maxWidth=0;var groupData=groups.data();var maxItems=0;var i;for(i=0;i<groupData.length;i++){var group=groupData[i];var groupWidths=group.map(function(legendItemArray){return legendItemArray[0].width;});var groupWidth=Lib.aggNums(Math.max,null,groupWidths);var groupHeight=group.reduce(function(a,b){return a+b[0].height;},0);maxWidth=Math.max(maxWidth,groupWidth);maxHeight=Math.max(maxHeight,groupHeight);maxItems=Math.max(maxItems,group.length);}maxWidth+=traceGap;maxWidth+=40;var groupXOffsets=[opts._width];var groupYOffsets=[];var rowNum=0;for(i=0;i<groupData.length;i++){if(fullLayout._size.w<borderwidth+opts._width+traceGap+maxWidth){groupXOffsets[groupXOffsets.length-1]=groupXOffsets[0];opts._width=maxWidth;rowNum++;}else{opts._width+=maxWidth+borderwidth;}var rowYOffset=rowNum*maxHeight;rowYOffset+=rowNum>0?opts.tracegroupgap:0;groupYOffsets.push(rowYOffset);groupXOffsets.push(opts._width);}groups.each(function(d,i){Drawing.setTranslate(this,groupXOffsets[i],groupYOffsets[i]);});groups.each(function(){var group=d3.select(this);var groupTraces=group.selectAll('g.traces');var groupHeight=0;groupTraces.each(function(d){var legendItem=d[0];var textHeight=legendItem.height;Drawing.setTranslate(this,0,5+borderwidth+groupHeight+textHeight/2);groupHeight+=textHeight;});});var maxYLegend=groupYOffsets[groupYOffsets.length-1]+maxHeight;opts._height=10+borderwidth*2+maxYLegend;var maxOffset=Math.max.apply(null,groupXOffsets);opts._width=maxOffset+maxWidth+40;opts._width+=borderwidth*2;}else{var rowHeight=0;var maxTraceHeight=0;var maxTraceWidth=0;var offsetX=0;var fullTracesWidth=0;// calculate largest width for traces and use for width of all legend items\ntraces.each(function(d){maxTraceWidth=Math.max(40+d[0].width,maxTraceWidth);fullTracesWidth+=40+d[0].width+traceGap;});// check if legend fits in one row\nvar oneRowLegend=fullLayout._size.w>borderwidth+fullTracesWidth-traceGap;traces.each(function(d){var legendItem=d[0];var traceWidth=oneRowLegend?40+d[0].width:maxTraceWidth;if(borderwidth+offsetX+traceGap+traceWidth>fullLayout._size.w){offsetX=0;rowHeight+=maxTraceHeight;opts._height+=maxTraceHeight;// reset for next row\nmaxTraceHeight=0;}Drawing.setTranslate(this,borderwidth+offsetX,5+borderwidth+legendItem.height/2+rowHeight);opts._width+=traceGap+traceWidth;// keep track of tallest trace in group\noffsetX+=traceGap+traceWidth;maxTraceHeight=Math.max(legendItem.height,maxTraceHeight);});if(oneRowLegend){opts._height=maxTraceHeight;}else{opts._height+=maxTraceHeight;}opts._width+=borderwidth*2;opts._height+=10+borderwidth*2;}// make sure we're only getting full pixels\nopts._width=Math.ceil(opts._width);opts._height=Math.ceil(opts._height);var isEditable=gd._context.edits.legendText||gd._context.edits.legendPosition;traces.each(function(d){var legendItem=d[0];var bg=d3.select(this).select('.legendtoggle');Drawing.setRect(bg,0,-legendItem.height/2,(isEditable?0:opts._width)+extraWidth,legendItem.height);});}function expandMargin(gd){var fullLayout=gd._fullLayout;var opts=fullLayout.legend;var xanchor='left';if(Lib.isRightAnchor(opts)){xanchor='right';}else if(Lib.isCenterAnchor(opts)){xanchor='center';}var yanchor='top';if(Lib.isBottomAnchor(opts)){yanchor='bottom';}else if(Lib.isMiddleAnchor(opts)){yanchor='middle';}// lastly check if the margin auto-expand has changed\nPlots.autoMargin(gd,'legend',{x:opts.x,y:opts.y,l:opts._width*FROM_TL[xanchor],r:opts._width*FROM_BR[xanchor],b:opts._height*FROM_BR[yanchor],t:opts._height*FROM_TL[yanchor]});}function expandHorizontalMargin(gd){var fullLayout=gd._fullLayout;var opts=fullLayout.legend;var xanchor='left';if(Lib.isRightAnchor(opts)){xanchor='right';}else if(Lib.isCenterAnchor(opts)){xanchor='center';}// lastly check if the margin auto-expand has changed\nPlots.autoMargin(gd,'legend',{x:opts.x,y:0.5,l:opts._width*FROM_TL[xanchor],r:opts._width*FROM_BR[xanchor],b:0,t:0});}},{\"../../constants/alignment\":138,\"../../constants/interactions\":139,\"../../lib\":159,\"../../lib/events\":152,\"../../lib/svg_text_utils\":180,\"../../plots/plots\":235,\"../../registry\":242,\"../color\":43,\"../dragelement\":61,\"../drawing\":64,\"./constants\":93,\"./get_legend_data\":96,\"./handle_click\":97,\"./helpers\":98,\"./style\":100,\"d3\":8}],96:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Registry=_dereq_('../../registry');var helpers=_dereq_('./helpers');module.exports=function getLegendData(calcdata,opts){var lgroupToTraces={};var lgroups=[];var hasOneNonBlankGroup=false;var slicesShown={};var lgroupi=0;var i,j;function addOneItem(legendGroup,legendItem){// each '' legend group is treated as a separate group\nif(legendGroup===''||!helpers.isGrouped(opts)){var uniqueGroup='~~i'+lgroupi;// TODO: check this against fullData legendgroups?\nlgroups.push(uniqueGroup);lgroupToTraces[uniqueGroup]=[[legendItem]];lgroupi++;}else if(lgroups.indexOf(legendGroup)===-1){lgroups.push(legendGroup);hasOneNonBlankGroup=true;lgroupToTraces[legendGroup]=[[legendItem]];}else lgroupToTraces[legendGroup].push([legendItem]);}// build an { legendgroup: [cd0, cd0], ... } object\nfor(i=0;i<calcdata.length;i++){var cd=calcdata[i];var cd0=cd[0];var trace=cd0.trace;var lgroup=trace.legendgroup;if(!trace.visible||!trace.showlegend)continue;if(Registry.traceIs(trace,'pie')){if(!slicesShown[lgroup])slicesShown[lgroup]={};for(j=0;j<cd.length;j++){var labelj=cd[j].label;if(!slicesShown[lgroup][labelj]){addOneItem(lgroup,{label:labelj,color:cd[j].color,i:cd[j].i,trace:trace,pts:cd[j].pts});slicesShown[lgroup][labelj]=true;}}}else addOneItem(lgroup,cd0);}// won't draw a legend in this case\nif(!lgroups.length)return[];// rearrange lgroupToTraces into a d3-friendly array of arrays\nvar lgroupsLength=lgroups.length;var ltraces;var legendData;if(hasOneNonBlankGroup&&helpers.isGrouped(opts)){legendData=new Array(lgroupsLength);for(i=0;i<lgroupsLength;i++){ltraces=lgroupToTraces[lgroups[i]];legendData[i]=helpers.isReversed(opts)?ltraces.reverse():ltraces;}}else{// collapse all groups into one if all groups are blank\nlegendData=[new Array(lgroupsLength)];for(i=0;i<lgroupsLength;i++){ltraces=lgroupToTraces[lgroups[i]][0];legendData[0][helpers.isReversed(opts)?lgroupsLength-i-1:i]=ltraces;}lgroupsLength=1;}// needed in repositionLegend\nopts._lgroupsLength=lgroupsLength;return legendData;};},{\"../../registry\":242,\"./helpers\":98}],97:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var Registry=_dereq_('../../registry');var SHOWISOLATETIP=true;module.exports=function handleClick(g,gd,numClicks){if(gd._dragged||gd._editing)return;var hiddenSlices=gd._fullLayout.hiddenlabels?gd._fullLayout.hiddenlabels.slice():[];var legendItem=g.data()[0][0];var fullData=gd._fullData;var fullTrace=legendItem.trace;var legendgroup=fullTrace.legendgroup;var i,j,kcont,key,keys,val;var attrUpdate={};var attrIndices=[];var carrs=[];var carrIdx=[];function insertUpdate(traceIndex,key,value){var attrIndex=attrIndices.indexOf(traceIndex);var valueArray=attrUpdate[key];if(!valueArray){valueArray=attrUpdate[key]=[];}if(attrIndices.indexOf(traceIndex)===-1){attrIndices.push(traceIndex);attrIndex=attrIndices.length-1;}valueArray[attrIndex]=value;return attrIndex;}function setVisibility(fullTrace,visibility){var fullInput=fullTrace._fullInput;if(Registry.hasTransform(fullInput,'groupby')){var kcont=carrs[fullInput.index];if(!kcont){var groupbyIndices=Registry.getTransformIndices(fullInput,'groupby');var lastGroupbyIndex=groupbyIndices[groupbyIndices.length-1];kcont=Lib.keyedContainer(fullInput,'transforms['+lastGroupbyIndex+'].styles','target','value.visible');carrs[fullInput.index]=kcont;}var curState=kcont.get(fullTrace._group);// If not specified, assume visible. This happens if there are other style\n// properties set for a group but not the visibility. There are many similar\n// ways to do this (e.g. why not just `curState = fullTrace.visible`??? The\n// answer is: because it breaks other things like groupby trace names in\n// subtle ways.)\nif(curState===undefined){curState=true;}if(curState!==false){// true -> legendonly. All others toggle to true:\nkcont.set(fullTrace._group,visibility);}carrIdx[fullInput.index]=insertUpdate(fullInput.index,'visible',fullInput.visible===false?false:true);}else{// false -> false (not possible since will not be visible in legend)\n// true -> legendonly\n// legendonly -> true\nvar nextVisibility=fullInput.visible===false?false:visibility;insertUpdate(fullInput.index,'visible',nextVisibility);}}if(numClicks===1&&SHOWISOLATETIP&&gd.data&&gd._context.showTips){Lib.notifier(Lib._(gd,'Double-click on legend to isolate one trace'),'long');SHOWISOLATETIP=false;}else{SHOWISOLATETIP=false;}if(Registry.traceIs(fullTrace,'pie')){var thisLabel=legendItem.label;var thisLabelIndex=hiddenSlices.indexOf(thisLabel);if(numClicks===1){if(thisLabelIndex===-1)hiddenSlices.push(thisLabel);else hiddenSlices.splice(thisLabelIndex,1);}else if(numClicks===2){hiddenSlices=[];gd.calcdata[0].forEach(function(d){if(thisLabel!==d.label){hiddenSlices.push(d.label);}});if(gd._fullLayout.hiddenlabels&&gd._fullLayout.hiddenlabels.length===hiddenSlices.length&&thisLabelIndex===-1){hiddenSlices=[];}}Registry.call('_guiRelayout',gd,'hiddenlabels',hiddenSlices);}else{var hasLegendgroup=legendgroup&&legendgroup.length;var traceIndicesInGroup=[];var tracei;if(hasLegendgroup){for(i=0;i<fullData.length;i++){tracei=fullData[i];if(!tracei.visible)continue;if(tracei.legendgroup===legendgroup){traceIndicesInGroup.push(i);}}}if(numClicks===1){var nextVisibility;switch(fullTrace.visible){case true:nextVisibility='legendonly';break;case false:nextVisibility=false;break;case'legendonly':nextVisibility=true;break;}if(hasLegendgroup){for(i=0;i<fullData.length;i++){if(fullData[i].visible!==false&&fullData[i].legendgroup===legendgroup){setVisibility(fullData[i],nextVisibility);}}}else{setVisibility(fullTrace,nextVisibility);}}else if(numClicks===2){// Compute the clicked index. expandedIndex does what we want for expanded traces\n// but also culls hidden traces. That means we have some work to do.\nvar isClicked,isInGroup,otherState;var isIsolated=true;for(i=0;i<fullData.length;i++){isClicked=fullData[i]===fullTrace;if(isClicked)continue;isInGroup=hasLegendgroup&&fullData[i].legendgroup===legendgroup;if(!isInGroup&&fullData[i].visible===true&&!Registry.traceIs(fullData[i],'notLegendIsolatable')){isIsolated=false;break;}}for(i=0;i<fullData.length;i++){// False is sticky; we don't change it.\nif(fullData[i].visible===false)continue;if(Registry.traceIs(fullData[i],'notLegendIsolatable')){continue;}switch(fullTrace.visible){case'legendonly':setVisibility(fullData[i],true);break;case true:otherState=isIsolated?true:'legendonly';isClicked=fullData[i]===fullTrace;isInGroup=isClicked||hasLegendgroup&&fullData[i].legendgroup===legendgroup;setVisibility(fullData[i],isInGroup?true:otherState);break;}}}for(i=0;i<carrs.length;i++){kcont=carrs[i];if(!kcont)continue;var update=kcont.constructUpdate();var updateKeys=Object.keys(update);for(j=0;j<updateKeys.length;j++){key=updateKeys[j];val=attrUpdate[key]=attrUpdate[key]||[];val[carrIdx[i]]=update[key];}}// The length of the value arrays should be equal and any unspecified\n// values should be explicitly undefined for them to get properly culled\n// as updates and not accidentally reset to the default value. This fills\n// out sparse arrays with the required number of undefined values:\nkeys=Object.keys(attrUpdate);for(i=0;i<keys.length;i++){key=keys[i];for(j=0;j<attrIndices.length;j++){// Use hasOwnPropety to protect against falsey values:\nif(!attrUpdate[key].hasOwnProperty(j)){attrUpdate[key][j]=undefined;}}}Registry.call('_guiRestyle',gd,attrUpdate,attrIndices);}};},{\"../../lib\":159,\"../../registry\":242}],98:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';exports.isGrouped=function isGrouped(legendLayout){return(legendLayout.traceorder||'').indexOf('grouped')!==-1;};exports.isVertical=function isVertical(legendLayout){return legendLayout.orientation!=='h';};exports.isReversed=function isReversed(legendLayout){return(legendLayout.traceorder||'').indexOf('reversed')!==-1;};},{}],99:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports={moduleType:'component',name:'legend',layoutAttributes:_dereq_('./attributes'),supplyLayoutDefaults:_dereq_('./defaults'),draw:_dereq_('./draw'),style:_dereq_('./style')};},{\"./attributes\":92,\"./defaults\":94,\"./draw\":95,\"./style\":100}],100:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var Registry=_dereq_('../../registry');var Lib=_dereq_('../../lib');var Drawing=_dereq_('../drawing');var Color=_dereq_('../color');var subTypes=_dereq_('../../traces/scatter/subtypes');var stylePie=_dereq_('../../traces/pie/style_one');var pieCastOption=_dereq_('../../traces/pie/helpers').castOption;var CST_MARKER_SIZE=12;var CST_LINE_WIDTH=5;var CST_MARKER_LINE_WIDTH=2;var MAX_LINE_WIDTH=10;var MAX_MARKER_LINE_WIDTH=5;module.exports=function style(s,gd){var fullLayout=gd._fullLayout;var legend=fullLayout.legend;var constantItemSizing=legend.itemsizing==='constant';function boundLineWidth(mlw,cont,max,cst){var v;if(mlw+1){v=mlw;}else if(cont&&cont.width>0){v=cont.width;}else{return 0;}return constantItemSizing?cst:Math.min(v,max);}s.each(function(d){var traceGroup=d3.select(this);var layers=Lib.ensureSingle(traceGroup,'g','layers');layers.style('opacity',d[0].trace.opacity);var valign=legend.valign;var lineHeight=d[0].lineHeight;var height=d[0].height;if(valign==='middle'||!lineHeight||!height){layers.attr('transform',null);}else{var factor={top:1,bottom:-1}[valign];var markerOffsetY=factor*(0.5*(lineHeight-height+3));layers.attr('transform','translate(0,'+markerOffsetY+')');}var fill=layers.selectAll('g.legendfill').data([d]);fill.enter().append('g').classed('legendfill',true);var line=layers.selectAll('g.legendlines').data([d]);line.enter().append('g').classed('legendlines',true);var symbol=layers.selectAll('g.legendsymbols').data([d]);symbol.enter().append('g').classed('legendsymbols',true);symbol.selectAll('g.legendpoints').data([d]).enter().append('g').classed('legendpoints',true);}).each(styleWaterfalls).each(styleBars).each(styleBoxes).each(stylePies).each(styleLines).each(stylePoints).each(styleCandles).each(styleOHLC);function styleLines(d){var d0=d[0];var trace=d0.trace;var showFill=trace.visible&&trace.fill&&trace.fill!=='none';var showLine=subTypes.hasLines(trace);var contours=trace.contours;var showGradientLine=false;var showGradientFill=false;var dMod,tMod;if(contours){var coloring=contours.coloring;if(coloring==='lines'){showGradientLine=true;}else{showLine=coloring==='none'||coloring==='heatmap'||contours.showlines;}if(contours.type==='constraint'){showFill=contours._operation!=='=';}else if(coloring==='fill'||coloring==='heatmap'){showGradientFill=true;}}// with fill and no markers or text, move the line and fill up a bit\n// so it's more centered\nvar markersOrText=subTypes.hasMarkers(trace)||subTypes.hasText(trace);var anyFill=showFill||showGradientFill;var anyLine=showLine||showGradientLine;var pathStart=markersOrText||!anyFill?'M5,0':// with a line leave it slightly below center, to leave room for the\n// line thickness and because the line is usually more prominent\nanyLine?'M5,-2':'M5,-3';var this3=d3.select(this);var fill=this3.select('.legendfill').selectAll('path').data(showFill||showGradientFill?[d]:[]);fill.enter().append('path').classed('js-fill',true);fill.exit().remove();fill.attr('d',pathStart+'h30v6h-30z').call(showFill?Drawing.fillGroupStyle:fillGradient);if(showLine||showGradientLine){var lw=boundLineWidth(undefined,trace.line,MAX_LINE_WIDTH,CST_LINE_WIDTH);tMod=Lib.minExtend(trace,{line:{width:lw}});dMod=[Lib.minExtend(d0,{trace:tMod})];}var line=this3.select('.legendlines').selectAll('path').data(showLine||showGradientLine?[dMod]:[]);line.enter().append('path').classed('js-line',true);line.exit().remove();// this is ugly... but you can't apply a gradient to a perfectly\n// horizontal or vertical line. Presumably because then\n// the system doesn't know how to scale vertical variation, even\n// though there *is* no vertical variation in this case.\n// so add an invisibly small angle to the line\n// This issue (and workaround) exist across (Mac) Chrome, FF, and Safari\nline.attr('d',pathStart+(showGradientLine?'l30,0.0001':'h30')).call(showLine?Drawing.lineGroupStyle:lineGradient);function fillGradient(s){if(s.size()){var gradientID='legendfill-'+trace.uid;Drawing.gradient(s,gd,gradientID,'horizontalreversed',trace.colorscale,'fill');}}function lineGradient(s){if(s.size()){var gradientID='legendline-'+trace.uid;Drawing.lineGroupStyle(s);Drawing.gradient(s,gd,gradientID,'horizontalreversed',trace.colorscale,'stroke');}}}function stylePoints(d){var d0=d[0];var trace=d0.trace;var showMarkers=subTypes.hasMarkers(trace);var showText=subTypes.hasText(trace);var showLines=subTypes.hasLines(trace);var dMod,tMod;// 'scatter3d' don't use gd.calcdata,\n// use d0.trace to infer arrayOk attributes\nfunction boundVal(attrIn,arrayToValFn,bounds,cst){var valIn=Lib.nestedProperty(trace,attrIn).get();var valToBound=Lib.isArrayOrTypedArray(valIn)&&arrayToValFn?arrayToValFn(valIn):valIn;if(constantItemSizing&&valToBound&&cst!==undefined){valToBound=cst;}if(bounds){if(valToBound<bounds[0])return bounds[0];else if(valToBound>bounds[1])return bounds[1];}return valToBound;}function pickFirst(array){return array[0];}// constrain text, markers, etc so they'll fit on the legend\nif(showMarkers||showText||showLines){var dEdit={};var tEdit={};if(showMarkers){dEdit.mc=boundVal('marker.color',pickFirst);dEdit.mx=boundVal('marker.symbol',pickFirst);dEdit.mo=boundVal('marker.opacity',Lib.mean,[0.2,1]);dEdit.mlc=boundVal('marker.line.color',pickFirst);dEdit.mlw=boundVal('marker.line.width',Lib.mean,[0,5],CST_MARKER_LINE_WIDTH);tEdit.marker={sizeref:1,sizemin:1,sizemode:'diameter'};var ms=boundVal('marker.size',Lib.mean,[2,16],CST_MARKER_SIZE);dEdit.ms=ms;tEdit.marker.size=ms;}if(showLines){tEdit.line={width:boundVal('line.width',pickFirst,[0,10],CST_LINE_WIDTH)};}if(showText){dEdit.tx='Aa';dEdit.tp=boundVal('textposition',pickFirst);dEdit.ts=10;dEdit.tc=boundVal('textfont.color',pickFirst);dEdit.tf=boundVal('textfont.family',pickFirst);}dMod=[Lib.minExtend(d0,dEdit)];tMod=Lib.minExtend(trace,tEdit);// always show legend items in base state\ntMod.selectedpoints=null;}var ptgroup=d3.select(this).select('g.legendpoints');var pts=ptgroup.selectAll('path.scatterpts').data(showMarkers?dMod:[]);// make sure marker is on the bottom, in case it enters after text\npts.enter().insert('path',':first-child').classed('scatterpts',true).attr('transform','translate(20,0)');pts.exit().remove();pts.call(Drawing.pointStyle,tMod,gd);// 'mrc' is set in pointStyle and used in textPointStyle:\n// constrain it here\nif(showMarkers)dMod[0].mrc=3;var txt=ptgroup.selectAll('g.pointtext').data(showText?dMod:[]);txt.enter().append('g').classed('pointtext',true).append('text').attr('transform','translate(20,0)');txt.exit().remove();txt.selectAll('text').call(Drawing.textPointStyle,tMod,gd);}function styleWaterfalls(d){var trace=d[0].trace;var ptsData=[];if(trace.type==='waterfall'&&trace.visible){ptsData=d[0].hasTotals?[['increasing','M-6,-6V6H0Z'],['totals','M6,6H0L-6,-6H-0Z'],['decreasing','M6,6V-6H0Z']]:[['increasing','M-6,-6V6H6Z'],['decreasing','M6,6V-6H-6Z']];}var pts=d3.select(this).select('g.legendpoints').selectAll('path.legendwaterfall').data(ptsData);pts.enter().append('path').classed('legendwaterfall',true).attr('transform','translate(20,0)').style('stroke-miterlimit',1);pts.exit().remove();pts.each(function(dd){var pt=d3.select(this);var cont=trace[dd[0]].marker;var lw=boundLineWidth(undefined,cont.line,MAX_MARKER_LINE_WIDTH,CST_MARKER_LINE_WIDTH);pt.attr('d',dd[1]).style('stroke-width',lw+'px').call(Color.fill,cont.color);if(lw){pt.call(Color.stroke,cont.line.color);}});}function styleBars(d){var trace=d[0].trace;var marker=trace.marker||{};var markerLine=marker.line||{};var barpath=d3.select(this).select('g.legendpoints').selectAll('path.legendbar').data(Registry.traceIs(trace,'bar')?[d]:[]);barpath.enter().append('path').classed('legendbar',true).attr('d','M6,6H-6V-6H6Z').attr('transform','translate(20,0)');barpath.exit().remove();barpath.each(function(d){var p=d3.select(this);var d0=d[0];var w=boundLineWidth(d0.mlw,marker.line,MAX_MARKER_LINE_WIDTH,CST_MARKER_LINE_WIDTH);p.style('stroke-width',w+'px').call(Color.fill,d0.mc||marker.color);if(w)Color.stroke(p,d0.mlc||markerLine.color);});}function styleBoxes(d){var trace=d[0].trace;var pts=d3.select(this).select('g.legendpoints').selectAll('path.legendbox').data(Registry.traceIs(trace,'box-violin')&&trace.visible?[d]:[]);pts.enter().append('path').classed('legendbox',true)// if we want the median bar, prepend M6,0H-6\n.attr('d','M6,6H-6V-6H6Z').attr('transform','translate(20,0)');pts.exit().remove();pts.each(function(){var p=d3.select(this);var w=boundLineWidth(undefined,trace.line,MAX_MARKER_LINE_WIDTH,CST_MARKER_LINE_WIDTH);p.style('stroke-width',w+'px').call(Color.fill,trace.fillcolor);if(w)Color.stroke(p,trace.line.color);});}function styleCandles(d){var trace=d[0].trace;var pts=d3.select(this).select('g.legendpoints').selectAll('path.legendcandle').data(trace.type==='candlestick'&&trace.visible?[d,d]:[]);pts.enter().append('path').classed('legendcandle',true).attr('d',function(_,i){if(i)return'M-15,0H-8M-8,6V-6H8Z';// increasing\nreturn'M15,0H8M8,-6V6H-8Z';// decreasing\n}).attr('transform','translate(20,0)').style('stroke-miterlimit',1);pts.exit().remove();pts.each(function(_,i){var p=d3.select(this);var cont=trace[i?'increasing':'decreasing'];var w=boundLineWidth(undefined,cont.line,MAX_MARKER_LINE_WIDTH,CST_MARKER_LINE_WIDTH);p.style('stroke-width',w+'px').call(Color.fill,cont.fillcolor);if(w)Color.stroke(p,cont.line.color);});}function styleOHLC(d){var trace=d[0].trace;var pts=d3.select(this).select('g.legendpoints').selectAll('path.legendohlc').data(trace.type==='ohlc'&&trace.visible?[d,d]:[]);pts.enter().append('path').classed('legendohlc',true).attr('d',function(_,i){if(i)return'M-15,0H0M-8,-6V0';// increasing\nreturn'M15,0H0M8,6V0';// decreasing\n}).attr('transform','translate(20,0)').style('stroke-miterlimit',1);pts.exit().remove();pts.each(function(_,i){var p=d3.select(this);var cont=trace[i?'increasing':'decreasing'];var w=boundLineWidth(undefined,cont.line,MAX_MARKER_LINE_WIDTH,CST_MARKER_LINE_WIDTH);p.style('fill','none').call(Drawing.dashLine,cont.line.dash,w);if(w)Color.stroke(p,cont.line.color);});}function stylePies(d){var d0=d[0];var trace=d0.trace;var pts=d3.select(this).select('g.legendpoints').selectAll('path.legendpie').data(Registry.traceIs(trace,'pie')&&trace.visible?[d]:[]);pts.enter().append('path').classed('legendpie',true).attr('d','M6,6H-6V-6H6Z').attr('transform','translate(20,0)');pts.exit().remove();if(pts.size()){var cont=(trace.marker||{}).line;var lw=boundLineWidth(pieCastOption(cont.width,d0.pts),cont,MAX_MARKER_LINE_WIDTH,CST_MARKER_LINE_WIDTH);var tMod=Lib.minExtend(trace,{marker:{line:{width:lw}}});var d0Mod=Lib.minExtend(d0,{trace:tMod});stylePie(pts,d0Mod,tMod);}}};},{\"../../lib\":159,\"../../registry\":242,\"../../traces/pie/helpers\":272,\"../../traces/pie/style_one\":278,\"../../traces/scatter/subtypes\":304,\"../color\":43,\"../drawing\":64,\"d3\":8}],101:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Registry=_dereq_('../../registry');var Plots=_dereq_('../../plots/plots');var axisIds=_dereq_('../../plots/cartesian/axis_ids');var Lib=_dereq_('../../lib');var Icons=_dereq_('../../../build/ploticon');var _=Lib._;var modeBarButtons=module.exports={};/**\n * ModeBar buttons configuration\n *\n * @param {string} name\n *      name / id of the buttons (for tracking)\n * @param {string} title\n *      text that appears while hovering over the button,\n *      enter null, false or '' for no hover text\n * @param {string} icon\n *      svg icon object associated with the button\n *      can be linked to Plotly.Icons to use the default plotly icons\n * @param {string} [gravity]\n *      icon positioning\n * @param {function} click\n *      click handler associated with the button, a function of\n *      'gd' (the main graph object) and\n *      'ev' (the event object)\n * @param {string} [attr]\n *      attribute associated with button,\n *      use this with 'val' to keep track of the state\n * @param {*} [val]\n *      initial 'attr' value, can be a function of gd\n * @param {boolean} [toggle]\n *      is the button a toggle button?\n */modeBarButtons.toImage={name:'toImage',title:function title(gd){var opts=gd._context.toImageButtonOptions||{};var format=opts.format||'png';return format==='png'?_(gd,'Download plot as a png'):// legacy text\n_(gd,'Download plot');// generic non-PNG text\n},icon:Icons.camera,click:function click(gd){var toImageButtonOptions=gd._context.toImageButtonOptions;var opts={format:toImageButtonOptions.format||'png'};Lib.notifier(_(gd,'Taking snapshot - this may take a few seconds'),'long');if(opts.format!=='svg'&&Lib.isIE()){Lib.notifier(_(gd,'IE only supports svg.  Changing format to svg.'),'long');opts.format='svg';}['filename','width','height','scale'].forEach(function(key){if(key in toImageButtonOptions){opts[key]=toImageButtonOptions[key];}});Registry.call('downloadImage',gd,opts).then(function(filename){Lib.notifier(_(gd,'Snapshot succeeded')+' - '+filename,'long');})[\"catch\"](function(){Lib.notifier(_(gd,'Sorry, there was a problem downloading your snapshot!'),'long');});}};modeBarButtons.sendDataToCloud={name:'sendDataToCloud',title:function title(gd){return _(gd,'Edit in Chart Studio');},icon:Icons.disk,click:function click(gd){Plots.sendDataToCloud(gd);}};modeBarButtons.zoom2d={name:'zoom2d',title:function title(gd){return _(gd,'Zoom');},attr:'dragmode',val:'zoom',icon:Icons.zoombox,click:handleCartesian};modeBarButtons.pan2d={name:'pan2d',title:function title(gd){return _(gd,'Pan');},attr:'dragmode',val:'pan',icon:Icons.pan,click:handleCartesian};modeBarButtons.select2d={name:'select2d',title:function title(gd){return _(gd,'Box Select');},attr:'dragmode',val:'select',icon:Icons.selectbox,click:handleCartesian};modeBarButtons.lasso2d={name:'lasso2d',title:function title(gd){return _(gd,'Lasso Select');},attr:'dragmode',val:'lasso',icon:Icons.lasso,click:handleCartesian};modeBarButtons.zoomIn2d={name:'zoomIn2d',title:function title(gd){return _(gd,'Zoom in');},attr:'zoom',val:'in',icon:Icons.zoom_plus,click:handleCartesian};modeBarButtons.zoomOut2d={name:'zoomOut2d',title:function title(gd){return _(gd,'Zoom out');},attr:'zoom',val:'out',icon:Icons.zoom_minus,click:handleCartesian};modeBarButtons.autoScale2d={name:'autoScale2d',title:function title(gd){return _(gd,'Autoscale');},attr:'zoom',val:'auto',icon:Icons.autoscale,click:handleCartesian};modeBarButtons.resetScale2d={name:'resetScale2d',title:function title(gd){return _(gd,'Reset axes');},attr:'zoom',val:'reset',icon:Icons.home,click:handleCartesian};modeBarButtons.hoverClosestCartesian={name:'hoverClosestCartesian',title:function title(gd){return _(gd,'Show closest data on hover');},attr:'hovermode',val:'closest',icon:Icons.tooltip_basic,gravity:'ne',click:handleCartesian};modeBarButtons.hoverCompareCartesian={name:'hoverCompareCartesian',title:function title(gd){return _(gd,'Compare data on hover');},attr:'hovermode',val:function val(gd){return gd._fullLayout._isHoriz?'y':'x';},icon:Icons.tooltip_compare,gravity:'ne',click:handleCartesian};function handleCartesian(gd,ev){var button=ev.currentTarget;var astr=button.getAttribute('data-attr');var val=button.getAttribute('data-val')||true;var fullLayout=gd._fullLayout;var aobj={};var axList=axisIds.list(gd,null,true);var allSpikesEnabled='on';var ax,i;if(astr==='zoom'){var mag=val==='in'?0.5:2;var r0=(1+mag)/2;var r1=(1-mag)/2;var axName;for(i=0;i<axList.length;i++){ax=axList[i];if(!ax.fixedrange){axName=ax._name;if(val==='auto')aobj[axName+'.autorange']=true;else if(val==='reset'){if(ax._rangeInitial===undefined){aobj[axName+'.autorange']=true;}else{var rangeInitial=ax._rangeInitial.slice();aobj[axName+'.range[0]']=rangeInitial[0];aobj[axName+'.range[1]']=rangeInitial[1];}if(ax._showSpikeInitial!==undefined){aobj[axName+'.showspikes']=ax._showSpikeInitial;if(allSpikesEnabled==='on'&&!ax._showSpikeInitial){allSpikesEnabled='off';}}}else{var rangeNow=[ax.r2l(ax.range[0]),ax.r2l(ax.range[1])];var rangeNew=[r0*rangeNow[0]+r1*rangeNow[1],r0*rangeNow[1]+r1*rangeNow[0]];aobj[axName+'.range[0]']=ax.l2r(rangeNew[0]);aobj[axName+'.range[1]']=ax.l2r(rangeNew[1]);}}}fullLayout._cartesianSpikesEnabled=allSpikesEnabled;}else{// if ALL traces have orientation 'h', 'hovermode': 'x' otherwise: 'y'\nif(astr==='hovermode'&&(val==='x'||val==='y')){val=fullLayout._isHoriz?'y':'x';button.setAttribute('data-val',val);}else if(astr==='hovermode'&&val==='closest'){for(i=0;i<axList.length;i++){ax=axList[i];if(allSpikesEnabled==='on'&&!ax.showspikes){allSpikesEnabled='off';}}fullLayout._cartesianSpikesEnabled=allSpikesEnabled;}aobj[astr]=val;}Registry.call('_guiRelayout',gd,aobj);}modeBarButtons.zoom3d={name:'zoom3d',title:function title(gd){return _(gd,'Zoom');},attr:'scene.dragmode',val:'zoom',icon:Icons.zoombox,click:handleDrag3d};modeBarButtons.pan3d={name:'pan3d',title:function title(gd){return _(gd,'Pan');},attr:'scene.dragmode',val:'pan',icon:Icons.pan,click:handleDrag3d};modeBarButtons.orbitRotation={name:'orbitRotation',title:function title(gd){return _(gd,'Orbital rotation');},attr:'scene.dragmode',val:'orbit',icon:Icons['3d_rotate'],click:handleDrag3d};modeBarButtons.tableRotation={name:'tableRotation',title:function title(gd){return _(gd,'Turntable rotation');},attr:'scene.dragmode',val:'turntable',icon:Icons['z-axis'],click:handleDrag3d};function handleDrag3d(gd,ev){var button=ev.currentTarget;var attr=button.getAttribute('data-attr');var val=button.getAttribute('data-val')||true;var sceneIds=gd._fullLayout._subplots.gl3d;var layoutUpdate={};var parts=attr.split('.');for(var i=0;i<sceneIds.length;i++){layoutUpdate[sceneIds[i]+'.'+parts[1]]=val;}// for multi-type subplots\nvar val2d=val==='pan'?val:'zoom';layoutUpdate.dragmode=val2d;Registry.call('_guiRelayout',gd,layoutUpdate);}modeBarButtons.resetCameraDefault3d={name:'resetCameraDefault3d',title:function title(gd){return _(gd,'Reset camera to default');},attr:'resetDefault',icon:Icons.home,click:handleCamera3d};modeBarButtons.resetCameraLastSave3d={name:'resetCameraLastSave3d',title:function title(gd){return _(gd,'Reset camera to last save');},attr:'resetLastSave',icon:Icons.movie,click:handleCamera3d};function handleCamera3d(gd,ev){var button=ev.currentTarget;var attr=button.getAttribute('data-attr');var fullLayout=gd._fullLayout;var sceneIds=fullLayout._subplots.gl3d;var aobj={};for(var i=0;i<sceneIds.length;i++){var sceneId=sceneIds[i];var key=sceneId+'.camera';var scene=fullLayout[sceneId]._scene;if(attr==='resetLastSave'){aobj[key+'.up']=scene.viewInitial.up;aobj[key+'.eye']=scene.viewInitial.eye;aobj[key+'.center']=scene.viewInitial.center;}else if(attr==='resetDefault'){aobj[key+'.up']=null;aobj[key+'.eye']=null;aobj[key+'.center']=null;}}Registry.call('_guiRelayout',gd,aobj);}modeBarButtons.hoverClosest3d={name:'hoverClosest3d',title:function title(gd){return _(gd,'Toggle show closest data on hover');},attr:'hovermode',val:null,toggle:true,icon:Icons.tooltip_basic,gravity:'ne',click:handleHover3d};function getNextHover3d(gd,ev){var button=ev.currentTarget;var val=button._previousVal;var fullLayout=gd._fullLayout;var sceneIds=fullLayout._subplots.gl3d;var axes=['xaxis','yaxis','zaxis'];// initialize 'current spike' object to be stored in the DOM\nvar currentSpikes={};var layoutUpdate={};if(val){layoutUpdate=val;button._previousVal=null;}else{for(var i=0;i<sceneIds.length;i++){var sceneId=sceneIds[i];var sceneLayout=fullLayout[sceneId];var hovermodeAStr=sceneId+'.hovermode';currentSpikes[hovermodeAStr]=sceneLayout.hovermode;layoutUpdate[hovermodeAStr]=false;// copy all the current spike attrs\nfor(var j=0;j<3;j++){var axis=axes[j];var spikeAStr=sceneId+'.'+axis+'.showspikes';layoutUpdate[spikeAStr]=false;currentSpikes[spikeAStr]=sceneLayout[axis].showspikes;}}button._previousVal=currentSpikes;}return layoutUpdate;}function handleHover3d(gd,ev){var layoutUpdate=getNextHover3d(gd,ev);Registry.call('_guiRelayout',gd,layoutUpdate);}modeBarButtons.zoomInGeo={name:'zoomInGeo',title:function title(gd){return _(gd,'Zoom in');},attr:'zoom',val:'in',icon:Icons.zoom_plus,click:handleGeo};modeBarButtons.zoomOutGeo={name:'zoomOutGeo',title:function title(gd){return _(gd,'Zoom out');},attr:'zoom',val:'out',icon:Icons.zoom_minus,click:handleGeo};modeBarButtons.resetGeo={name:'resetGeo',title:function title(gd){return _(gd,'Reset');},attr:'reset',val:null,icon:Icons.autoscale,click:handleGeo};modeBarButtons.hoverClosestGeo={name:'hoverClosestGeo',title:function title(gd){return _(gd,'Toggle show closest data on hover');},attr:'hovermode',val:null,toggle:true,icon:Icons.tooltip_basic,gravity:'ne',click:toggleHover};function handleGeo(gd,ev){var button=ev.currentTarget;var attr=button.getAttribute('data-attr');var val=button.getAttribute('data-val')||true;var fullLayout=gd._fullLayout;var geoIds=fullLayout._subplots.geo;for(var i=0;i<geoIds.length;i++){var id=geoIds[i];var geoLayout=fullLayout[id];if(attr==='zoom'){var scale=geoLayout.projection.scale;var newScale=val==='in'?2*scale:0.5*scale;Registry.call('_guiRelayout',gd,id+'.projection.scale',newScale);}else if(attr==='reset'){resetView(gd,'geo');}}}modeBarButtons.hoverClosestGl2d={name:'hoverClosestGl2d',title:function title(gd){return _(gd,'Toggle show closest data on hover');},attr:'hovermode',val:null,toggle:true,icon:Icons.tooltip_basic,gravity:'ne',click:toggleHover};modeBarButtons.hoverClosestPie={name:'hoverClosestPie',title:function title(gd){return _(gd,'Toggle show closest data on hover');},attr:'hovermode',val:'closest',icon:Icons.tooltip_basic,gravity:'ne',click:toggleHover};function getNextHover(gd){var fullLayout=gd._fullLayout;if(fullLayout.hovermode)return false;if(fullLayout._has('cartesian')){return fullLayout._isHoriz?'y':'x';}return'closest';}function toggleHover(gd){var newHover=getNextHover(gd);Registry.call('_guiRelayout',gd,'hovermode',newHover);}modeBarButtons.resetViewSankey={name:'resetSankeyGroup',title:function title(gd){return _(gd,'Reset view');},icon:Icons.home,click:function click(gd){var aObj={'node.groups':[],'node.x':[],'node.y':[]};for(var i=0;i<gd._fullData.length;i++){var viewInitial=gd._fullData[i]._viewInitial;aObj['node.groups'].push(viewInitial.node.groups.slice());aObj['node.x'].push(viewInitial.node.x.slice());aObj['node.y'].push(viewInitial.node.y.slice());}Registry.call('restyle',gd,aObj);}};// buttons when more then one plot types are present\nmodeBarButtons.toggleHover={name:'toggleHover',title:function title(gd){return _(gd,'Toggle show closest data on hover');},attr:'hovermode',val:null,toggle:true,icon:Icons.tooltip_basic,gravity:'ne',click:function click(gd,ev){var layoutUpdate=getNextHover3d(gd,ev);layoutUpdate.hovermode=getNextHover(gd);Registry.call('_guiRelayout',gd,layoutUpdate);}};modeBarButtons.resetViews={name:'resetViews',title:function title(gd){return _(gd,'Reset views');},icon:Icons.home,click:function click(gd,ev){var button=ev.currentTarget;button.setAttribute('data-attr','zoom');button.setAttribute('data-val','reset');handleCartesian(gd,ev);button.setAttribute('data-attr','resetLastSave');handleCamera3d(gd,ev);resetView(gd,'geo');resetView(gd,'mapbox');}};modeBarButtons.toggleSpikelines={name:'toggleSpikelines',title:function title(gd){return _(gd,'Toggle Spike Lines');},icon:Icons.spikeline,attr:'_cartesianSpikesEnabled',val:'on',click:function click(gd){var fullLayout=gd._fullLayout;fullLayout._cartesianSpikesEnabled=fullLayout._cartesianSpikesEnabled==='on'?'off':'on';var aobj=setSpikelineVisibility(gd);Registry.call('_guiRelayout',gd,aobj);}};function setSpikelineVisibility(gd){var fullLayout=gd._fullLayout;var axList=axisIds.list(gd,null,true);var aobj={};var ax,axName;for(var i=0;i<axList.length;i++){ax=axList[i];axName=ax._name;aobj[axName+'.showspikes']=fullLayout._cartesianSpikesEnabled==='on'?true:ax._showSpikeInitial;}return aobj;}modeBarButtons.resetViewMapbox={name:'resetViewMapbox',title:function title(gd){return _(gd,'Reset view');},attr:'reset',icon:Icons.home,click:function click(gd){resetView(gd,'mapbox');}};function resetView(gd,subplotType){var fullLayout=gd._fullLayout;var subplotIds=fullLayout._subplots[subplotType];var aObj={};for(var i=0;i<subplotIds.length;i++){var id=subplotIds[i];var subplotObj=fullLayout[id]._subplot;var viewInitial=subplotObj.viewInitial;var viewKeys=Object.keys(viewInitial);for(var j=0;j<viewKeys.length;j++){var key=viewKeys[j];aObj[id+'.'+key]=viewInitial[key];}}Registry.call('_guiRelayout',gd,aObj);}},{\"../../../build/ploticon\":2,\"../../lib\":159,\"../../plots/cartesian/axis_ids\":206,\"../../plots/plots\":235,\"../../registry\":242}],102:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';exports.manage=_dereq_('./manage');},{\"./manage\":103}],103:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var axisIds=_dereq_('../../plots/cartesian/axis_ids');var scatterSubTypes=_dereq_('../../traces/scatter/subtypes');var Registry=_dereq_('../../registry');var createModeBar=_dereq_('./modebar');var modeBarButtons=_dereq_('./buttons');/**\n * ModeBar wrapper around 'create' and 'update',\n * chooses buttons to pass to ModeBar constructor based on\n * plot type and plot config.\n *\n * @param {object} gd main plot object\n *\n */module.exports=function manageModeBar(gd){var fullLayout=gd._fullLayout;var context=gd._context;var modeBar=fullLayout._modeBar;if(!context.displayModeBar&&!context.watermark){if(modeBar){modeBar.destroy();delete fullLayout._modeBar;}return;}if(!Array.isArray(context.modeBarButtonsToRemove)){throw new Error(['*modeBarButtonsToRemove* configuration options','must be an array.'].join(' '));}if(!Array.isArray(context.modeBarButtonsToAdd)){throw new Error(['*modeBarButtonsToAdd* configuration options','must be an array.'].join(' '));}var customButtons=context.modeBarButtons;var buttonGroups;if(Array.isArray(customButtons)&&customButtons.length){buttonGroups=fillCustomButton(customButtons);}else if(!context.displayModeBar&&context.watermark){buttonGroups=[];}else{buttonGroups=getButtonGroups(gd,context.modeBarButtonsToRemove,context.modeBarButtonsToAdd,context.showSendToCloud);}if(modeBar)modeBar.update(gd,buttonGroups);else fullLayout._modeBar=createModeBar(gd,buttonGroups);};// logic behind which buttons are displayed by default\nfunction getButtonGroups(gd,buttonsToRemove,buttonsToAdd,showSendToCloud){var fullLayout=gd._fullLayout;var fullData=gd._fullData;var hasCartesian=fullLayout._has('cartesian');var hasGL3D=fullLayout._has('gl3d');var hasGeo=fullLayout._has('geo');var hasPie=fullLayout._has('pie');var hasGL2D=fullLayout._has('gl2d');var hasTernary=fullLayout._has('ternary');var hasMapbox=fullLayout._has('mapbox');var hasPolar=fullLayout._has('polar');var hasSankey=fullLayout._has('sankey');var allAxesFixed=areAllAxesFixed(fullLayout);var groups=[];function addGroup(newGroup){if(!newGroup.length)return;var out=[];for(var i=0;i<newGroup.length;i++){var button=newGroup[i];if(buttonsToRemove.indexOf(button)!==-1)continue;out.push(modeBarButtons[button]);}groups.push(out);}// buttons common to all plot types\nvar commonGroup=['toImage'];if(showSendToCloud)commonGroup.push('sendDataToCloud');addGroup(commonGroup);var zoomGroup=[];var hoverGroup=[];var resetGroup=[];var dragModeGroup=[];if((hasCartesian||hasGL2D||hasPie||hasTernary)+hasGeo+hasGL3D+hasMapbox+hasPolar>1){// graphs with more than one plot types get 'union buttons'\n// which reset the view or toggle hover labels across all subplots.\nhoverGroup=['toggleHover'];resetGroup=['resetViews'];}else if(hasGeo){zoomGroup=['zoomInGeo','zoomOutGeo'];hoverGroup=['hoverClosestGeo'];resetGroup=['resetGeo'];}else if(hasGL3D){hoverGroup=['hoverClosest3d'];resetGroup=['resetCameraDefault3d','resetCameraLastSave3d'];}else if(hasMapbox){hoverGroup=['toggleHover'];resetGroup=['resetViewMapbox'];}else if(hasGL2D){hoverGroup=['hoverClosestGl2d'];}else if(hasPie){hoverGroup=['hoverClosestPie'];}else if(hasSankey){hoverGroup=['hoverClosestCartesian','hoverCompareCartesian'];resetGroup=['resetViewSankey'];}else{// hasPolar, hasTernary\n// always show at least one hover icon.\nhoverGroup=['toggleHover'];}// if we have cartesian, allow switching between closest and compare\n// regardless of what other types are on the plot, since they'll all\n// just treat any truthy hovermode as 'closest'\nif(hasCartesian){hoverGroup=['toggleSpikelines','hoverClosestCartesian','hoverCompareCartesian'];}if((hasCartesian||hasGL2D)&&!allAxesFixed){zoomGroup=['zoomIn2d','zoomOut2d','autoScale2d'];if(resetGroup[0]!=='resetViews')resetGroup=['resetScale2d'];}if(hasGL3D){dragModeGroup=['zoom3d','pan3d','orbitRotation','tableRotation'];}else if((hasCartesian||hasGL2D)&&!allAxesFixed||hasTernary){dragModeGroup=['zoom2d','pan2d'];}else if(hasMapbox||hasGeo){dragModeGroup=['pan2d'];}else if(hasPolar){dragModeGroup=['zoom2d'];}if(isSelectable(fullData)){dragModeGroup.push('select2d','lasso2d');}addGroup(dragModeGroup);addGroup(zoomGroup.concat(resetGroup));addGroup(hoverGroup);return appendButtonsToGroups(groups,buttonsToAdd);}function areAllAxesFixed(fullLayout){var axList=axisIds.list({_fullLayout:fullLayout},null,true);for(var i=0;i<axList.length;i++){if(!axList[i].fixedrange){return false;}}return true;}// look for traces that support selection\n// to be updated as we add more selectPoints handlers\nfunction isSelectable(fullData){var selectable=false;for(var i=0;i<fullData.length;i++){if(selectable)break;var trace=fullData[i];if(!trace._module||!trace._module.selectPoints)continue;if(Registry.traceIs(trace,'scatter-like')){if(scatterSubTypes.hasMarkers(trace)||scatterSubTypes.hasText(trace)){selectable=true;}}else if(Registry.traceIs(trace,'box-violin')){if(trace.boxpoints==='all'||trace.points==='all'){selectable=true;}}else{// assume that in general if the trace module has selectPoints,\n// then it's selectable. Scatter is an exception to this because it must\n// have markers or text, not just be a scatter type.\nselectable=true;}}return selectable;}function appendButtonsToGroups(groups,buttons){if(buttons.length){if(Array.isArray(buttons[0])){for(var i=0;i<buttons.length;i++){groups.push(buttons[i]);}}else groups.push(buttons);}return groups;}// fill in custom buttons referring to default mode bar buttons\nfunction fillCustomButton(customButtons){for(var i=0;i<customButtons.length;i++){var buttonGroup=customButtons[i];for(var j=0;j<buttonGroup.length;j++){var button=buttonGroup[j];if(typeof button==='string'){if(modeBarButtons[button]!==undefined){customButtons[i][j]=modeBarButtons[button];}else{throw new Error(['*modeBarButtons* configuration options','invalid button name'].join(' '));}}}}return customButtons;}},{\"../../plots/cartesian/axis_ids\":206,\"../../registry\":242,\"../../traces/scatter/subtypes\":304,\"./buttons\":101,\"./modebar\":104}],104:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var isNumeric=_dereq_('fast-isnumeric');var Lib=_dereq_('../../lib');var Icons=_dereq_('../../../build/ploticon');var Parser=new DOMParser();/**\n * UI controller for interactive plots\n * @Class\n * @Param {object} opts\n * @Param {object} opts.buttons    nested arrays of grouped buttons config objects\n * @Param {object} opts.container  container div to append modeBar\n * @Param {object} opts.graphInfo  primary plot object containing data and layout\n */function ModeBar(opts){this.container=opts.container;this.element=document.createElement('div');this.update(opts.graphInfo,opts.buttons);this.container.appendChild(this.element);}var proto=ModeBar.prototype;/**\n * Update modeBar (buttons and logo)\n *\n * @param {object} graphInfo  primary plot object containing data and layout\n * @param {array of arrays} buttons nested arrays of grouped buttons to initialize\n *\n */proto.update=function(graphInfo,buttons){this.graphInfo=graphInfo;var context=this.graphInfo._context;var fullLayout=this.graphInfo._fullLayout;var modeBarId='modebar-'+fullLayout._uid;this.element.setAttribute('id',modeBarId);this._uid=modeBarId;this.element.className='modebar';if(context.displayModeBar==='hover')this.element.className+=' modebar--hover ease-bg';if(fullLayout.modebar.orientation==='v'){this.element.className+=' vertical';buttons=buttons.reverse();}var style=fullLayout.modebar;var bgSelector=context.displayModeBar==='hover'?'.js-plotly-plot .plotly:hover ':'';Lib.deleteRelatedStyleRule(modeBarId);Lib.addRelatedStyleRule(modeBarId,bgSelector+'#'+modeBarId+' .modebar-group','background-color: '+style.bgcolor);Lib.addRelatedStyleRule(modeBarId,'#'+modeBarId+' .modebar-btn .icon path','fill: '+style.color);Lib.addRelatedStyleRule(modeBarId,'#'+modeBarId+' .modebar-btn:hover .icon path','fill: '+style.activecolor);Lib.addRelatedStyleRule(modeBarId,'#'+modeBarId+' .modebar-btn.active .icon path','fill: '+style.activecolor);// if buttons or logo have changed, redraw modebar interior\nvar needsNewButtons=!this.hasButtons(buttons);var needsNewLogo=this.hasLogo!==context.displaylogo;var needsNewLocale=this.locale!==context.locale;this.locale=context.locale;if(needsNewButtons||needsNewLogo||needsNewLocale){this.removeAllButtons();this.updateButtons(buttons);if(context.watermark||context.displaylogo){var logoGroup=this.getLogo();if(context.watermark){logoGroup.className=logoGroup.className+' watermark';}if(fullLayout.modebar.orientation==='v'){this.element.insertBefore(logoGroup,this.element.childNodes[0]);}else{this.element.appendChild(logoGroup);}this.hasLogo=true;}}this.updateActiveButton();};proto.updateButtons=function(buttons){var _this=this;this.buttons=buttons;this.buttonElements=[];this.buttonsNames=[];this.buttons.forEach(function(buttonGroup){var group=_this.createGroup();buttonGroup.forEach(function(buttonConfig){var buttonName=buttonConfig.name;if(!buttonName){throw new Error('must provide button \\'name\\' in button config');}if(_this.buttonsNames.indexOf(buttonName)!==-1){throw new Error('button name \\''+buttonName+'\\' is taken');}_this.buttonsNames.push(buttonName);var button=_this.createButton(buttonConfig);_this.buttonElements.push(button);group.appendChild(button);});_this.element.appendChild(group);});};/**\n * Empty div for containing a group of buttons\n * @Return {HTMLelement}\n */proto.createGroup=function(){var group=document.createElement('div');group.className='modebar-group';return group;};/**\n * Create a new button div and set constant and configurable attributes\n * @Param {object} config (see ./buttons.js for more info)\n * @Return {HTMLelement}\n */proto.createButton=function(config){var _this=this;var button=document.createElement('a');button.setAttribute('rel','tooltip');button.className='modebar-btn';var title=config.title;if(title===undefined)title=config.name;// for localization: allow title to be a callable that takes gd as arg\nelse if(typeof title==='function')title=title(this.graphInfo);if(title||title===0)button.setAttribute('data-title',title);if(config.attr!==undefined)button.setAttribute('data-attr',config.attr);var val=config.val;if(val!==undefined){if(typeof val==='function')val=val(this.graphInfo);button.setAttribute('data-val',val);}var click=config.click;if(typeof click!=='function'){throw new Error('must provide button \\'click\\' function in button config');}else{button.addEventListener('click',function(ev){config.click(_this.graphInfo,ev);// only needed for 'hoverClosestGeo' which does not call relayout\n_this.updateActiveButton(ev.currentTarget);});}button.setAttribute('data-toggle',config.toggle||false);if(config.toggle)d3.select(button).classed('active',true);var icon=config.icon;if(typeof icon==='function'){button.appendChild(icon());}else{button.appendChild(this.createIcon(icon||Icons.question));}button.setAttribute('data-gravity',config.gravity||'n');return button;};/**\n * Add an icon to a button\n * @Param {object} thisIcon\n * @Param {number} thisIcon.width\n * @Param {string} thisIcon.path\n * @Param {string} thisIcon.color\n * @Return {HTMLelement}\n */proto.createIcon=function(thisIcon){var iconHeight=isNumeric(thisIcon.height)?Number(thisIcon.height):thisIcon.ascent-thisIcon.descent;var svgNS='http://www.w3.org/2000/svg';var icon;if(thisIcon.path){icon=document.createElementNS(svgNS,'svg');icon.setAttribute('viewBox',[0,0,thisIcon.width,iconHeight].join(' '));icon.setAttribute('class','icon');var path=document.createElementNS(svgNS,'path');path.setAttribute('d',thisIcon.path);if(thisIcon.transform){path.setAttribute('transform',thisIcon.transform);}else if(thisIcon.ascent!==undefined){// Legacy icon transform calculation\npath.setAttribute('transform','matrix(1 0 0 -1 0 '+thisIcon.ascent+')');}icon.appendChild(path);}if(thisIcon.svg){var svgDoc=Parser.parseFromString(thisIcon.svg,'application/xml');icon=svgDoc.childNodes[0];}icon.setAttribute('height','1em');icon.setAttribute('width','1em');return icon;};/**\n * Updates active button with attribute specified in layout\n * @Param {object} graphInfo plot object containing data and layout\n * @Return {HTMLelement}\n */proto.updateActiveButton=function(buttonClicked){var fullLayout=this.graphInfo._fullLayout;var dataAttrClicked=buttonClicked!==undefined?buttonClicked.getAttribute('data-attr'):null;this.buttonElements.forEach(function(button){var thisval=button.getAttribute('data-val')||true;var dataAttr=button.getAttribute('data-attr');var isToggleButton=button.getAttribute('data-toggle')==='true';var button3=d3.select(button);// Use 'data-toggle' and 'buttonClicked' to toggle buttons\n// that have no one-to-one equivalent in fullLayout\nif(isToggleButton){if(dataAttr===dataAttrClicked){button3.classed('active',!button3.classed('active'));}}else{var val=dataAttr===null?dataAttr:Lib.nestedProperty(fullLayout,dataAttr).get();button3.classed('active',val===thisval);}});};/**\n * Check if modeBar is configured as button configuration argument\n *\n * @Param {object} buttons 2d array of grouped button config objects\n * @Return {boolean}\n */proto.hasButtons=function(buttons){var currentButtons=this.buttons;if(!currentButtons)return false;if(buttons.length!==currentButtons.length)return false;for(var i=0;i<buttons.length;++i){if(buttons[i].length!==currentButtons[i].length)return false;for(var j=0;j<buttons[i].length;j++){if(buttons[i][j].name!==currentButtons[i][j].name)return false;}}return true;};/**\n * @return {HTMLDivElement} The logo image wrapped in a group\n */proto.getLogo=function(){var group=this.createGroup();var a=document.createElement('a');a.href='https://plot.ly/';a.target='_blank';a.setAttribute('data-title',Lib._(this.graphInfo,'Produced with Plotly'));a.className='modebar-btn plotlyjsicon modebar-btn--logo';a.appendChild(this.createIcon(Icons.newplotlylogo));group.appendChild(a);return group;};proto.removeAllButtons=function(){while(this.element.firstChild){this.element.removeChild(this.element.firstChild);}this.hasLogo=false;};proto.destroy=function(){Lib.removeElement(this.container.querySelector('.modebar'));Lib.deleteRelatedStyleRule(this._uid);};function createModeBar(gd,buttons){var fullLayout=gd._fullLayout;var modeBar=new ModeBar({graphInfo:gd,container:fullLayout._modebardiv.node(),buttons:buttons});if(fullLayout._privateplot){d3.select(modeBar.element).append('span').classed('badge-private float--left',true).text('PRIVATE');}return modeBar;}module.exports=createModeBar;},{\"../../../build/ploticon\":2,\"../../lib\":159,\"d3\":8,\"fast-isnumeric\":10}],105:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var fontAttrs=_dereq_('../../plots/font_attributes');var colorAttrs=_dereq_('../color/attributes');var templatedArray=_dereq_('../../plot_api/plot_template').templatedArray;var buttonAttrs=templatedArray('button',{visible:{valType:'boolean',dflt:true,editType:'plot'},step:{valType:'enumerated',values:['month','year','day','hour','minute','second','all'],dflt:'month',editType:'plot'},stepmode:{valType:'enumerated',values:['backward','todate'],dflt:'backward',editType:'plot'},count:{valType:'number',min:0,dflt:1,editType:'plot'},label:{valType:'string',editType:'plot'},editType:'plot'});module.exports={visible:{valType:'boolean',editType:'plot'},buttons:buttonAttrs,x:{valType:'number',min:-2,max:3,editType:'plot'},xanchor:{valType:'enumerated',values:['auto','left','center','right'],dflt:'left',editType:'plot'},y:{valType:'number',min:-2,max:3,editType:'plot'},yanchor:{valType:'enumerated',values:['auto','top','middle','bottom'],dflt:'bottom',editType:'plot'},font:fontAttrs({editType:'plot'}),bgcolor:{valType:'color',dflt:colorAttrs.lightLine,editType:'plot'},activecolor:{valType:'color',editType:'plot'},bordercolor:{valType:'color',dflt:colorAttrs.defaultLine,editType:'plot'},borderwidth:{valType:'number',min:0,dflt:0,editType:'plot'},editType:'plot'};},{\"../../plot_api/plot_template\":193,\"../../plots/font_attributes\":229,\"../color/attributes\":42}],106:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports={// 'y' position pad above counter axis domain\nyPad:0.02,// minimum button width (regardless of text size)\nminButtonWidth:30,// buttons rect radii\nrx:3,ry:3,// light fraction used to compute the 'activecolor' default\nlightAmount:25,darkAmount:10};},{}],107:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var Color=_dereq_('../color');var Template=_dereq_('../../plot_api/plot_template');var handleArrayContainerDefaults=_dereq_('../../plots/array_container_defaults');var attributes=_dereq_('./attributes');var constants=_dereq_('./constants');module.exports=function handleDefaults(containerIn,containerOut,layout,counterAxes,calendar){var selectorIn=containerIn.rangeselector||{};var selectorOut=Template.newContainer(containerOut,'rangeselector');function coerce(attr,dflt){return Lib.coerce(selectorIn,selectorOut,attributes,attr,dflt);}var buttons=handleArrayContainerDefaults(selectorIn,selectorOut,{name:'buttons',handleItemDefaults:buttonDefaults,calendar:calendar});var visible=coerce('visible',buttons.length>0);if(visible){var posDflt=getPosDflt(containerOut,layout,counterAxes);coerce('x',posDflt[0]);coerce('y',posDflt[1]);Lib.noneOrAll(containerIn,containerOut,['x','y']);coerce('xanchor');coerce('yanchor');Lib.coerceFont(coerce,'font',layout.font);var bgColor=coerce('bgcolor');coerce('activecolor',Color.contrast(bgColor,constants.lightAmount,constants.darkAmount));coerce('bordercolor');coerce('borderwidth');}};function buttonDefaults(buttonIn,buttonOut,selectorOut,opts){var calendar=opts.calendar;function coerce(attr,dflt){return Lib.coerce(buttonIn,buttonOut,attributes.buttons,attr,dflt);}var visible=coerce('visible');if(visible){var step=coerce('step');if(step!=='all'){if(calendar&&calendar!=='gregorian'&&(step==='month'||step==='year')){buttonOut.stepmode='backward';}else{coerce('stepmode');}coerce('count');}coerce('label');}}function getPosDflt(containerOut,layout,counterAxes){var anchoredList=counterAxes.filter(function(ax){return layout[ax].anchor===containerOut._id;});var posY=0;for(var i=0;i<anchoredList.length;i++){var domain=layout[anchoredList[i]].domain;if(domain)posY=Math.max(domain[1],posY);}return[containerOut.domain[0],posY+constants.yPad];}},{\"../../lib\":159,\"../../plot_api/plot_template\":193,\"../../plots/array_container_defaults\":199,\"../color\":43,\"./attributes\":105,\"./constants\":106}],108:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var Registry=_dereq_('../../registry');var Plots=_dereq_('../../plots/plots');var Color=_dereq_('../color');var Drawing=_dereq_('../drawing');var Lib=_dereq_('../../lib');var svgTextUtils=_dereq_('../../lib/svg_text_utils');var axisIds=_dereq_('../../plots/cartesian/axis_ids');var alignmentConstants=_dereq_('../../constants/alignment');var LINE_SPACING=alignmentConstants.LINE_SPACING;var FROM_TL=alignmentConstants.FROM_TL;var FROM_BR=alignmentConstants.FROM_BR;var constants=_dereq_('./constants');var getUpdateObject=_dereq_('./get_update_object');module.exports=function draw(gd){var fullLayout=gd._fullLayout;var selectors=fullLayout._infolayer.selectAll('.rangeselector').data(makeSelectorData(gd),selectorKeyFunc);selectors.enter().append('g').classed('rangeselector',true);selectors.exit().remove();selectors.style({cursor:'pointer','pointer-events':'all'});selectors.each(function(d){var selector=d3.select(this);var axisLayout=d;var selectorLayout=axisLayout.rangeselector;var buttons=selector.selectAll('g.button').data(Lib.filterVisible(selectorLayout.buttons));buttons.enter().append('g').classed('button',true);buttons.exit().remove();buttons.each(function(d){var button=d3.select(this);var update=getUpdateObject(axisLayout,d);d._isActive=isActive(axisLayout,d,update);button.call(drawButtonRect,selectorLayout,d);button.call(drawButtonText,selectorLayout,d,gd);button.on('click',function(){if(gd._dragged)return;Registry.call('_guiRelayout',gd,update);});button.on('mouseover',function(){d._isHovered=true;button.call(drawButtonRect,selectorLayout,d);});button.on('mouseout',function(){d._isHovered=false;button.call(drawButtonRect,selectorLayout,d);});});reposition(gd,buttons,selectorLayout,axisLayout._name,selector);});};function makeSelectorData(gd){var axes=axisIds.list(gd,'x',true);var data=[];for(var i=0;i<axes.length;i++){var axis=axes[i];if(axis.rangeselector&&axis.rangeselector.visible){data.push(axis);}}return data;}function selectorKeyFunc(d){return d._id;}function isActive(axisLayout,opts,update){if(opts.step==='all'){return axisLayout.autorange===true;}else{var keys=Object.keys(update);return axisLayout.range[0]===update[keys[0]]&&axisLayout.range[1]===update[keys[1]];}}function drawButtonRect(button,selectorLayout,d){var rect=Lib.ensureSingle(button,'rect','selector-rect',function(s){s.attr('shape-rendering','crispEdges');});rect.attr({'rx':constants.rx,'ry':constants.ry});rect.call(Color.stroke,selectorLayout.bordercolor).call(Color.fill,getFillColor(selectorLayout,d)).style('stroke-width',selectorLayout.borderwidth+'px');}function getFillColor(selectorLayout,d){return d._isActive||d._isHovered?selectorLayout.activecolor:selectorLayout.bgcolor;}function drawButtonText(button,selectorLayout,d,gd){function textLayout(s){svgTextUtils.convertToTspans(s,gd);}var text=Lib.ensureSingle(button,'text','selector-text',function(s){s.classed('user-select-none',true).attr('text-anchor','middle');});text.call(Drawing.font,selectorLayout.font).text(getLabel(d,gd._fullLayout.meta)).call(textLayout);}function getLabel(opts,meta){if(opts.label){return meta?Lib.templateString(opts.label,{meta:meta}):opts.label;}if(opts.step==='all')return'all';return opts.count+opts.step.charAt(0);}function reposition(gd,buttons,opts,axName,selector){var width=0;var height=0;var borderWidth=opts.borderwidth;buttons.each(function(){var button=d3.select(this);var text=button.select('.selector-text');var tHeight=opts.font.size*LINE_SPACING;var hEff=Math.max(tHeight*svgTextUtils.lineCount(text),16)+3;height=Math.max(height,hEff);});buttons.each(function(){var button=d3.select(this);var rect=button.select('.selector-rect');var text=button.select('.selector-text');var tWidth=text.node()&&Drawing.bBox(text.node()).width;var tHeight=opts.font.size*LINE_SPACING;var tLines=svgTextUtils.lineCount(text);var wEff=Math.max(tWidth+10,constants.minButtonWidth);// TODO add MathJax support\n// TODO add buttongap attribute\nbutton.attr('transform','translate('+(borderWidth+width)+','+borderWidth+')');rect.attr({x:0,y:0,width:wEff,height:height});svgTextUtils.positionText(text,wEff/2,height/2-(tLines-1)*tHeight/2+3);width+=wEff+5;});var graphSize=gd._fullLayout._size;var lx=graphSize.l+graphSize.w*opts.x;var ly=graphSize.t+graphSize.h*(1-opts.y);var xanchor='left';if(Lib.isRightAnchor(opts)){lx-=width;xanchor='right';}if(Lib.isCenterAnchor(opts)){lx-=width/2;xanchor='center';}var yanchor='top';if(Lib.isBottomAnchor(opts)){ly-=height;yanchor='bottom';}if(Lib.isMiddleAnchor(opts)){ly-=height/2;yanchor='middle';}width=Math.ceil(width);height=Math.ceil(height);lx=Math.round(lx);ly=Math.round(ly);Plots.autoMargin(gd,axName+'-range-selector',{x:opts.x,y:opts.y,l:width*FROM_TL[xanchor],r:width*FROM_BR[xanchor],b:height*FROM_BR[yanchor],t:height*FROM_TL[yanchor]});selector.attr('transform','translate('+lx+','+ly+')');}},{\"../../constants/alignment\":138,\"../../lib\":159,\"../../lib/svg_text_utils\":180,\"../../plots/cartesian/axis_ids\":206,\"../../plots/plots\":235,\"../../registry\":242,\"../color\":43,\"../drawing\":64,\"./constants\":106,\"./get_update_object\":109,\"d3\":8}],109:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');module.exports=function getUpdateObject(axisLayout,buttonLayout){var axName=axisLayout._name;var update={};if(buttonLayout.step==='all'){update[axName+'.autorange']=true;}else{var xrange=getXRange(axisLayout,buttonLayout);update[axName+'.range[0]']=xrange[0];update[axName+'.range[1]']=xrange[1];}return update;};function getXRange(axisLayout,buttonLayout){var currentRange=axisLayout.range;var base=new Date(axisLayout.r2l(currentRange[1]));var step=buttonLayout.step;var count=buttonLayout.count;var range0;switch(buttonLayout.stepmode){case'backward':range0=axisLayout.l2r(+d3.time[step].utc.offset(base,-count));break;case'todate':var base2=d3.time[step].utc.offset(base,-count);range0=axisLayout.l2r(+d3.time[step].utc.ceil(base2));break;}var range1=currentRange[1];return[range0,range1];}},{\"d3\":8}],110:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports={moduleType:'component',name:'rangeselector',schema:{subplots:{xaxis:{rangeselector:_dereq_('./attributes')}}},layoutAttributes:_dereq_('./attributes'),handleDefaults:_dereq_('./defaults'),draw:_dereq_('./draw')};},{\"./attributes\":105,\"./defaults\":107,\"./draw\":108}],111:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var colorAttributes=_dereq_('../color/attributes');module.exports={bgcolor:{valType:'color',dflt:colorAttributes.background,editType:'plot'},bordercolor:{valType:'color',dflt:colorAttributes.defaultLine,editType:'plot'},borderwidth:{valType:'integer',dflt:0,min:0,editType:'plot'},autorange:{valType:'boolean',dflt:true,editType:'calc',impliedEdits:{'range[0]':undefined,'range[1]':undefined}},range:{valType:'info_array',items:[{valType:'any',editType:'calc',impliedEdits:{'^autorange':false}},{valType:'any',editType:'calc',impliedEdits:{'^autorange':false}}],editType:'calc',impliedEdits:{'autorange':false}},thickness:{valType:'number',dflt:0.15,min:0,max:1,editType:'plot'},visible:{valType:'boolean',dflt:true,editType:'calc'},editType:'calc'};},{\"../color/attributes\":42}],112:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var listAxes=_dereq_('../../plots/cartesian/axis_ids').list;var getAutoRange=_dereq_('../../plots/cartesian/autorange').getAutoRange;var constants=_dereq_('./constants');module.exports=function calcAutorange(gd){var axes=listAxes(gd,'x',true);// Compute new slider range using axis autorange if necessary.\n//\n// Copy back range to input range slider container to skip\n// this step in subsequent draw calls.\nfor(var i=0;i<axes.length;i++){var ax=axes[i];var opts=ax[constants.name];if(opts&&opts.visible&&opts.autorange){opts._input.autorange=true;opts._input.range=opts.range=getAutoRange(gd,ax);}}};},{\"../../plots/cartesian/autorange\":202,\"../../plots/cartesian/axis_ids\":206,\"./constants\":113}],113:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports={// attribute container name\nname:'rangeslider',// class names\ncontainerClassName:'rangeslider-container',bgClassName:'rangeslider-bg',rangePlotClassName:'rangeslider-rangeplot',maskMinClassName:'rangeslider-mask-min',maskMaxClassName:'rangeslider-mask-max',slideBoxClassName:'rangeslider-slidebox',grabberMinClassName:'rangeslider-grabber-min',grabAreaMinClassName:'rangeslider-grabarea-min',handleMinClassName:'rangeslider-handle-min',grabberMaxClassName:'rangeslider-grabber-max',grabAreaMaxClassName:'rangeslider-grabarea-max',handleMaxClassName:'rangeslider-handle-max',maskMinOppAxisClassName:'rangeslider-mask-min-opp-axis',maskMaxOppAxisClassName:'rangeslider-mask-max-opp-axis',// style constants\nmaskColor:'rgba(0,0,0,0.4)',maskOppAxisColor:'rgba(0,0,0,0.2)',slideBoxFill:'transparent',slideBoxCursor:'ew-resize',grabAreaFill:'transparent',grabAreaCursor:'col-resize',grabAreaWidth:10,handleWidth:4,handleRadius:1,handleStrokeWidth:1,extraPad:15};},{}],114:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var Template=_dereq_('../../plot_api/plot_template');var axisIds=_dereq_('../../plots/cartesian/axis_ids');var attributes=_dereq_('./attributes');var oppAxisAttrs=_dereq_('./oppaxis_attributes');module.exports=function handleDefaults(layoutIn,layoutOut,axName){var axIn=layoutIn[axName];var axOut=layoutOut[axName];if(!(axIn.rangeslider||layoutOut._requestRangeslider[axOut._id]))return;// not super proud of this (maybe store _ in axis object instead\nif(!Lib.isPlainObject(axIn.rangeslider)){axIn.rangeslider={};}var containerIn=axIn.rangeslider;var containerOut=Template.newContainer(axOut,'rangeslider');function coerce(attr,dflt){return Lib.coerce(containerIn,containerOut,attributes,attr,dflt);}var rangeContainerIn,rangeContainerOut;function coerceRange(attr,dflt){return Lib.coerce(rangeContainerIn,rangeContainerOut,oppAxisAttrs,attr,dflt);}var visible=coerce('visible');if(!visible)return;coerce('bgcolor',layoutOut.plot_bgcolor);coerce('bordercolor');coerce('borderwidth');coerce('thickness');coerce('autorange',!axOut.isValidRange(containerIn.range));coerce('range');var subplots=layoutOut._subplots;if(subplots){var yIds=subplots.cartesian.filter(function(subplotId){return subplotId.substr(0,subplotId.indexOf('y'))===axisIds.name2id(axName);}).map(function(subplotId){return subplotId.substr(subplotId.indexOf('y'),subplotId.length);});var yNames=Lib.simpleMap(yIds,axisIds.id2name);for(var i=0;i<yNames.length;i++){var yName=yNames[i];rangeContainerIn=containerIn[yName]||{};rangeContainerOut=Template.newContainer(containerOut,yName,'yaxis');var yAxOut=layoutOut[yName];var rangemodeDflt;if(rangeContainerIn.range&&yAxOut.isValidRange(rangeContainerIn.range)){rangemodeDflt='fixed';}var rangeMode=coerceRange('rangemode',rangemodeDflt);if(rangeMode!=='match'){coerceRange('range',yAxOut.range.slice());}}}// to map back range slider (auto) range\ncontainerOut._input=containerIn;};},{\"../../lib\":159,\"../../plot_api/plot_template\":193,\"../../plots/cartesian/axis_ids\":206,\"./attributes\":111,\"./oppaxis_attributes\":118}],115:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var Registry=_dereq_('../../registry');var Plots=_dereq_('../../plots/plots');var Lib=_dereq_('../../lib');var Drawing=_dereq_('../drawing');var Color=_dereq_('../color');var Titles=_dereq_('../titles');var Cartesian=_dereq_('../../plots/cartesian');var axisIDs=_dereq_('../../plots/cartesian/axis_ids');var dragElement=_dereq_('../dragelement');var setCursor=_dereq_('../../lib/setcursor');var constants=_dereq_('./constants');module.exports=function(gd){var fullLayout=gd._fullLayout;var rangeSliderData=fullLayout._rangeSliderData;for(var i=0;i<rangeSliderData.length;i++){var opts=rangeSliderData[i][constants.name];// fullLayout._uid may not exist when we call makeData\nopts._clipId=opts._id+'-'+fullLayout._uid;}/*\n     * <g container />\n     *  <rect bg />\n     *  < .... range plot />\n     *  <rect mask-min />\n     *  <rect mask-max />\n     *  <rect slidebox />\n     *  <g grabber-min />\n     *      <rect handle-min />\n     *      <rect grabare-min />\n     *  <g grabber-max />\n     *      <rect handle-max />\n     *      <rect grabare-max />\n     *\n     *  ...\n     */function keyFunction(axisOpts){return axisOpts._name;}var rangeSliders=fullLayout._infolayer.selectAll('g.'+constants.containerClassName).data(rangeSliderData,keyFunction);// remove exiting sliders and their corresponding clip paths\nrangeSliders.exit().each(function(axisOpts){var opts=axisOpts[constants.name];fullLayout._topdefs.select('#'+opts._clipId).remove();}).remove();// return early if no range slider is visible\nif(rangeSliderData.length===0)return;rangeSliders.enter().append('g').classed(constants.containerClassName,true).attr('pointer-events','all');// for all present range sliders\nrangeSliders.each(function(axisOpts){var rangeSlider=d3.select(this);var opts=axisOpts[constants.name];var oppAxisOpts=fullLayout[axisIDs.id2name(axisOpts.anchor)];var oppAxisRangeOpts=opts[axisIDs.id2name(axisOpts.anchor)];// update range\n// Expand slider range to the axis range\nif(opts.range){var rng=Lib.simpleMap(opts.range,axisOpts.r2l);var axRng=Lib.simpleMap(axisOpts.range,axisOpts.r2l);var newRng;if(axRng[0]<axRng[1]){newRng=[Math.min(rng[0],axRng[0]),Math.max(rng[1],axRng[1])];}else{newRng=[Math.max(rng[0],axRng[0]),Math.min(rng[1],axRng[1])];}opts.range=opts._input.range=Lib.simpleMap(newRng,axisOpts.l2r);}axisOpts.cleanRange('rangeslider.range');// update range slider dimensions\nvar margin=fullLayout.margin;var graphSize=fullLayout._size;var domain=axisOpts.domain;var tickHeight=opts._tickHeight;var oppBottom=opts._oppBottom;opts._width=graphSize.w*(domain[1]-domain[0]);var x=Math.round(margin.l+graphSize.w*domain[0]);var y=Math.round(graphSize.t+graphSize.h*(1-oppBottom)+tickHeight+opts._offsetShift+constants.extraPad);rangeSlider.attr('transform','translate('+x+','+y+')');// update data <--> pixel coordinate conversion methods\nvar range0=axisOpts.r2l(opts.range[0]);var range1=axisOpts.r2l(opts.range[1]);var dist=range1-range0;opts.p2d=function(v){return v/opts._width*dist+range0;};opts.d2p=function(v){return(v-range0)/dist*opts._width;};opts._rl=[range0,range1];if(oppAxisRangeOpts.rangemode!=='match'){var range0OppAxis=oppAxisOpts.r2l(oppAxisRangeOpts.range[0]);var range1OppAxis=oppAxisOpts.r2l(oppAxisRangeOpts.range[1]);var distOppAxis=range1OppAxis-range0OppAxis;opts.d2pOppAxis=function(v){return(v-range0OppAxis)/distOppAxis*opts._height;};}// update inner nodes\nrangeSlider.call(drawBg,gd,axisOpts,opts).call(addClipPath,gd,axisOpts,opts).call(drawRangePlot,gd,axisOpts,opts).call(drawMasks,gd,axisOpts,opts,oppAxisRangeOpts).call(drawSlideBox,gd,axisOpts,opts).call(drawGrabbers,gd,axisOpts,opts);// setup drag element\nsetupDragElement(rangeSlider,gd,axisOpts,opts);// update current range\nsetPixelRange(rangeSlider,gd,axisOpts,opts,oppAxisOpts,oppAxisRangeOpts);// title goes next to range slider instead of tick labels, so\n// just take it over and draw it from here\nif(axisOpts.side==='bottom'){Titles.draw(gd,axisOpts._id+'title',{propContainer:axisOpts,propName:axisOpts._name+'.title',placeholder:fullLayout._dfltTitle.x,attributes:{x:axisOpts._offset+axisOpts._length/2,y:y+opts._height+opts._offsetShift+10+1.5*axisOpts.title.font.size,'text-anchor':'middle'}});}});};function setupDragElement(rangeSlider,gd,axisOpts,opts){var slideBox=rangeSlider.select('rect.'+constants.slideBoxClassName).node();var grabAreaMin=rangeSlider.select('rect.'+constants.grabAreaMinClassName).node();var grabAreaMax=rangeSlider.select('rect.'+constants.grabAreaMaxClassName).node();rangeSlider.on('mousedown',function(){var event=d3.event;var target=event.target;var startX=event.clientX;var offsetX=startX-rangeSlider.node().getBoundingClientRect().left;var minVal=opts.d2p(axisOpts._rl[0]);var maxVal=opts.d2p(axisOpts._rl[1]);var dragCover=dragElement.coverSlip();dragCover.addEventListener('mousemove',mouseMove);dragCover.addEventListener('mouseup',mouseUp);function mouseMove(e){var delta=+e.clientX-startX;var pixelMin,pixelMax,cursor;switch(target){case slideBox:cursor='ew-resize';pixelMin=minVal+delta;pixelMax=maxVal+delta;break;case grabAreaMin:cursor='col-resize';pixelMin=minVal+delta;pixelMax=maxVal;break;case grabAreaMax:cursor='col-resize';pixelMin=minVal;pixelMax=maxVal+delta;break;default:cursor='ew-resize';pixelMin=offsetX;pixelMax=offsetX+delta;break;}if(pixelMax<pixelMin){var tmp=pixelMax;pixelMax=pixelMin;pixelMin=tmp;}opts._pixelMin=pixelMin;opts._pixelMax=pixelMax;setCursor(d3.select(dragCover),cursor);setDataRange(rangeSlider,gd,axisOpts,opts);}function mouseUp(){dragCover.removeEventListener('mousemove',mouseMove);dragCover.removeEventListener('mouseup',mouseUp);Lib.removeElement(dragCover);}});}function setDataRange(rangeSlider,gd,axisOpts,opts){function clamp(v){return axisOpts.l2r(Lib.constrain(v,opts._rl[0],opts._rl[1]));}var dataMin=clamp(opts.p2d(opts._pixelMin));var dataMax=clamp(opts.p2d(opts._pixelMax));window.requestAnimationFrame(function(){Registry.call('_guiRelayout',gd,axisOpts._name+'.range',[dataMin,dataMax]);});}function setPixelRange(rangeSlider,gd,axisOpts,opts,oppAxisOpts,oppAxisRangeOpts){var hw2=constants.handleWidth/2;function clamp(v){return Lib.constrain(v,0,opts._width);}function clampOppAxis(v){return Lib.constrain(v,0,opts._height);}function clampHandle(v){return Lib.constrain(v,-hw2,opts._width+hw2);}var pixelMin=clamp(opts.d2p(axisOpts._rl[0]));var pixelMax=clamp(opts.d2p(axisOpts._rl[1]));rangeSlider.select('rect.'+constants.slideBoxClassName).attr('x',pixelMin).attr('width',pixelMax-pixelMin);rangeSlider.select('rect.'+constants.maskMinClassName).attr('width',pixelMin);rangeSlider.select('rect.'+constants.maskMaxClassName).attr('x',pixelMax).attr('width',opts._width-pixelMax);if(oppAxisRangeOpts.rangemode!=='match'){var pixelMinOppAxis=opts._height-clampOppAxis(opts.d2pOppAxis(oppAxisOpts._rl[1]));var pixelMaxOppAxis=opts._height-clampOppAxis(opts.d2pOppAxis(oppAxisOpts._rl[0]));rangeSlider.select('rect.'+constants.maskMinOppAxisClassName).attr('x',pixelMin).attr('height',pixelMinOppAxis).attr('width',pixelMax-pixelMin);rangeSlider.select('rect.'+constants.maskMaxOppAxisClassName).attr('x',pixelMin).attr('y',pixelMaxOppAxis).attr('height',opts._height-pixelMaxOppAxis).attr('width',pixelMax-pixelMin);rangeSlider.select('rect.'+constants.slideBoxClassName).attr('y',pixelMinOppAxis).attr('height',pixelMaxOppAxis-pixelMinOppAxis);}// add offset for crispier corners\n// https://github.com/plotly/plotly.js/pull/1409\nvar offset=0.5;var xMin=Math.round(clampHandle(pixelMin-hw2))-offset;var xMax=Math.round(clampHandle(pixelMax-hw2))+offset;rangeSlider.select('g.'+constants.grabberMinClassName).attr('transform','translate('+xMin+','+offset+')');rangeSlider.select('g.'+constants.grabberMaxClassName).attr('transform','translate('+xMax+','+offset+')');}function drawBg(rangeSlider,gd,axisOpts,opts){var bg=Lib.ensureSingle(rangeSlider,'rect',constants.bgClassName,function(s){s.attr({x:0,y:0,'shape-rendering':'crispEdges'});});var borderCorrect=opts.borderwidth%2===0?opts.borderwidth:opts.borderwidth-1;var offsetShift=-opts._offsetShift;var lw=Drawing.crispRound(gd,opts.borderwidth);bg.attr({width:opts._width+borderCorrect,height:opts._height+borderCorrect,transform:'translate('+offsetShift+','+offsetShift+')',fill:opts.bgcolor,stroke:opts.bordercolor,'stroke-width':lw});}function addClipPath(rangeSlider,gd,axisOpts,opts){var fullLayout=gd._fullLayout;var clipPath=Lib.ensureSingleById(fullLayout._topdefs,'clipPath',opts._clipId,function(s){s.append('rect').attr({x:0,y:0});});clipPath.select('rect').attr({width:opts._width,height:opts._height});}function drawRangePlot(rangeSlider,gd,axisOpts,opts){var calcData=gd.calcdata;var rangePlots=rangeSlider.selectAll('g.'+constants.rangePlotClassName).data(axisOpts._subplotsWith,Lib.identity);rangePlots.enter().append('g').attr('class',function(id){return constants.rangePlotClassName+' '+id;}).call(Drawing.setClipUrl,opts._clipId,gd);rangePlots.order();rangePlots.exit().remove();var mainplotinfo;rangePlots.each(function(id,i){var plotgroup=d3.select(this);var isMainPlot=i===0;var oppAxisOpts=axisIDs.getFromId(gd,id,'y');var oppAxisName=oppAxisOpts._name;var oppAxisRangeOpts=opts[oppAxisName];var mockFigure={data:[],layout:{xaxis:{type:axisOpts.type,domain:[0,1],range:opts.range.slice(),calendar:axisOpts.calendar},width:opts._width,height:opts._height,margin:{t:0,b:0,l:0,r:0}},_context:gd._context};mockFigure.layout[oppAxisName]={type:oppAxisOpts.type,domain:[0,1],range:oppAxisRangeOpts.rangemode!=='match'?oppAxisRangeOpts.range.slice():oppAxisOpts.range.slice(),calendar:oppAxisOpts.calendar};Plots.supplyDefaults(mockFigure);var xa=mockFigure._fullLayout.xaxis;var ya=mockFigure._fullLayout[oppAxisName];xa.clearCalc();xa.setScale();ya.clearCalc();ya.setScale();var plotinfo={id:id,plotgroup:plotgroup,xaxis:xa,yaxis:ya,isRangePlot:true};if(isMainPlot)mainplotinfo=plotinfo;else{plotinfo.mainplot='xy';plotinfo.mainplotinfo=mainplotinfo;}Cartesian.rangePlot(gd,plotinfo,filterRangePlotCalcData(calcData,id));});}function filterRangePlotCalcData(calcData,subplotId){var out=[];for(var i=0;i<calcData.length;i++){var calcTrace=calcData[i];var trace=calcTrace[0].trace;if(trace.xaxis+trace.yaxis===subplotId){out.push(calcTrace);}}return out;}function drawMasks(rangeSlider,gd,axisOpts,opts,oppAxisRangeOpts){var maskMin=Lib.ensureSingle(rangeSlider,'rect',constants.maskMinClassName,function(s){s.attr({x:0,y:0,'shape-rendering':'crispEdges'});});maskMin.attr('height',opts._height).call(Color.fill,constants.maskColor);var maskMax=Lib.ensureSingle(rangeSlider,'rect',constants.maskMaxClassName,function(s){s.attr({y:0,'shape-rendering':'crispEdges'});});maskMax.attr('height',opts._height).call(Color.fill,constants.maskColor);// masks used for oppAxis zoom\nif(oppAxisRangeOpts.rangemode!=='match'){var maskMinOppAxis=Lib.ensureSingle(rangeSlider,'rect',constants.maskMinOppAxisClassName,function(s){s.attr({y:0,'shape-rendering':'crispEdges'});});maskMinOppAxis.attr('width',opts._width).call(Color.fill,constants.maskOppAxisColor);var maskMaxOppAxis=Lib.ensureSingle(rangeSlider,'rect',constants.maskMaxOppAxisClassName,function(s){s.attr({y:0,'shape-rendering':'crispEdges'});});maskMaxOppAxis.attr('width',opts._width).style('border-top',constants.maskOppBorder).call(Color.fill,constants.maskOppAxisColor);}}function drawSlideBox(rangeSlider,gd,axisOpts,opts){if(gd._context.staticPlot)return;var slideBox=Lib.ensureSingle(rangeSlider,'rect',constants.slideBoxClassName,function(s){s.attr({y:0,cursor:constants.slideBoxCursor,'shape-rendering':'crispEdges'});});slideBox.attr({height:opts._height,fill:constants.slideBoxFill});}function drawGrabbers(rangeSlider,gd,axisOpts,opts){// <g grabber />\nvar grabberMin=Lib.ensureSingle(rangeSlider,'g',constants.grabberMinClassName);var grabberMax=Lib.ensureSingle(rangeSlider,'g',constants.grabberMaxClassName);// <g handle />\nvar handleFixAttrs={x:0,width:constants.handleWidth,rx:constants.handleRadius,fill:Color.background,stroke:Color.defaultLine,'stroke-width':constants.handleStrokeWidth,'shape-rendering':'crispEdges'};var handleDynamicAttrs={y:Math.round(opts._height/4),height:Math.round(opts._height/2)};var handleMin=Lib.ensureSingle(grabberMin,'rect',constants.handleMinClassName,function(s){s.attr(handleFixAttrs);});handleMin.attr(handleDynamicAttrs);var handleMax=Lib.ensureSingle(grabberMax,'rect',constants.handleMaxClassName,function(s){s.attr(handleFixAttrs);});handleMax.attr(handleDynamicAttrs);// <g grabarea />\nif(gd._context.staticPlot)return;var grabAreaFixAttrs={width:constants.grabAreaWidth,x:0,y:0,fill:constants.grabAreaFill,cursor:constants.grabAreaCursor};var grabAreaMin=Lib.ensureSingle(grabberMin,'rect',constants.grabAreaMinClassName,function(s){s.attr(grabAreaFixAttrs);});grabAreaMin.attr('height',opts._height);var grabAreaMax=Lib.ensureSingle(grabberMax,'rect',constants.grabAreaMaxClassName,function(s){s.attr(grabAreaFixAttrs);});grabAreaMax.attr('height',opts._height);}},{\"../../lib\":159,\"../../lib/setcursor\":178,\"../../plots/cartesian\":214,\"../../plots/cartesian/axis_ids\":206,\"../../plots/plots\":235,\"../../registry\":242,\"../color\":43,\"../dragelement\":61,\"../drawing\":64,\"../titles\":131,\"./constants\":113,\"d3\":8}],116:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var axisIDs=_dereq_('../../plots/cartesian/axis_ids');var constants=_dereq_('./constants');var name=constants.name;function isVisible(ax){var rangeSlider=ax&&ax[name];return rangeSlider&&rangeSlider.visible;}exports.isVisible=isVisible;exports.makeData=function(fullLayout){var axes=axisIDs.list({_fullLayout:fullLayout},'x',true);var margin=fullLayout.margin;var rangeSliderData=[];if(!fullLayout._has('gl2d')){for(var i=0;i<axes.length;i++){var ax=axes[i];if(isVisible(ax)){rangeSliderData.push(ax);var opts=ax[name];opts._id=name+ax._id;opts._height=(fullLayout.height-margin.b-margin.t)*opts.thickness;opts._offsetShift=Math.floor(opts.borderwidth/2);}}}fullLayout._rangeSliderData=rangeSliderData;};exports.autoMarginOpts=function(gd,ax){var opts=ax[name];var oppBottom=Infinity;var counterAxes=ax._counterAxes;for(var j=0;j<counterAxes.length;j++){var counterId=counterAxes[j];var oppAxis=axisIDs.getFromId(gd,counterId);oppBottom=Math.min(oppBottom,oppAxis.domain[0]);}opts._oppBottom=oppBottom;var tickHeight=ax.side==='bottom'&&ax._boundingBox.height||0;opts._tickHeight=tickHeight;return{x:0,y:oppBottom,l:0,r:0,t:0,b:opts._height+gd._fullLayout.margin.b+tickHeight,pad:constants.extraPad+opts._offsetShift*2};};},{\"../../plots/cartesian/axis_ids\":206,\"./constants\":113}],117:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var attrs=_dereq_('./attributes');var oppAxisAttrs=_dereq_('./oppaxis_attributes');var helpers=_dereq_('./helpers');module.exports={moduleType:'component',name:'rangeslider',schema:{subplots:{xaxis:{rangeslider:Lib.extendFlat({},attrs,{yaxis:oppAxisAttrs})}}},layoutAttributes:_dereq_('./attributes'),handleDefaults:_dereq_('./defaults'),calcAutorange:_dereq_('./calc_autorange'),draw:_dereq_('./draw'),isVisible:helpers.isVisible,makeData:helpers.makeData,autoMarginOpts:helpers.autoMarginOpts};},{\"../../lib\":159,\"./attributes\":111,\"./calc_autorange\":112,\"./defaults\":114,\"./draw\":115,\"./helpers\":116,\"./oppaxis_attributes\":118}],118:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports={// not really a 'subplot' attribute container,\n// but this is the flag we use to denote attributes that\n// support yaxis, yaxis2, yaxis3, ... counters\n_isSubplotObj:true,rangemode:{valType:'enumerated',values:['auto','fixed','match'],dflt:'match',editType:'calc'},range:{valType:'info_array',items:[{valType:'any',editType:'plot'},{valType:'any',editType:'plot'}],editType:'plot'},editType:'calc'};},{}],119:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var annAttrs=_dereq_('../annotations/attributes');var scatterLineAttrs=_dereq_('../../traces/scatter/attributes').line;var dash=_dereq_('../drawing/attributes').dash;var extendFlat=_dereq_('../../lib/extend').extendFlat;var templatedArray=_dereq_('../../plot_api/plot_template').templatedArray;module.exports=templatedArray('shape',{visible:{valType:'boolean',dflt:true,editType:'calc+arraydraw'},type:{valType:'enumerated',values:['circle','rect','path','line'],editType:'calc+arraydraw'},layer:{valType:'enumerated',values:['below','above'],dflt:'above',editType:'arraydraw'},xref:extendFlat({},annAttrs.xref,{}),xsizemode:{valType:'enumerated',values:['scaled','pixel'],dflt:'scaled',editType:'calc+arraydraw'},xanchor:{valType:'any',editType:'calc+arraydraw'},x0:{valType:'any',editType:'calc+arraydraw'},x1:{valType:'any',editType:'calc+arraydraw'},yref:extendFlat({},annAttrs.yref,{}),ysizemode:{valType:'enumerated',values:['scaled','pixel'],dflt:'scaled',editType:'calc+arraydraw'},yanchor:{valType:'any',editType:'calc+arraydraw'},y0:{valType:'any',editType:'calc+arraydraw'},y1:{valType:'any',editType:'calc+arraydraw'},path:{valType:'string',editType:'calc+arraydraw'},opacity:{valType:'number',min:0,max:1,dflt:1,editType:'arraydraw'},line:{color:extendFlat({},scatterLineAttrs.color,{editType:'arraydraw'}),width:extendFlat({},scatterLineAttrs.width,{editType:'calc+arraydraw'}),dash:extendFlat({},dash,{editType:'arraydraw'}),editType:'calc+arraydraw'},fillcolor:{valType:'color',dflt:'rgba(0,0,0,0)',editType:'arraydraw'},editType:'arraydraw'});},{\"../../lib/extend\":153,\"../../plot_api/plot_template\":193,\"../../traces/scatter/attributes\":280,\"../annotations/attributes\":28,\"../drawing/attributes\":63}],120:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var Axes=_dereq_('../../plots/cartesian/axes');var constants=_dereq_('./constants');var helpers=_dereq_('./helpers');module.exports=function calcAutorange(gd){var fullLayout=gd._fullLayout;var shapeList=Lib.filterVisible(fullLayout.shapes);if(!shapeList.length||!gd._fullData.length)return;for(var i=0;i<shapeList.length;i++){var shape=shapeList[i];shape._extremes={};var ax,bounds;if(shape.xref!=='paper'){var vx0=shape.xsizemode==='pixel'?shape.xanchor:shape.x0;var vx1=shape.xsizemode==='pixel'?shape.xanchor:shape.x1;ax=Axes.getFromId(gd,shape.xref);bounds=shapeBounds(ax,vx0,vx1,shape.path,constants.paramIsX);if(bounds){shape._extremes[ax._id]=Axes.findExtremes(ax,bounds,calcXPaddingOptions(shape));}}if(shape.yref!=='paper'){var vy0=shape.ysizemode==='pixel'?shape.yanchor:shape.y0;var vy1=shape.ysizemode==='pixel'?shape.yanchor:shape.y1;ax=Axes.getFromId(gd,shape.yref);bounds=shapeBounds(ax,vy0,vy1,shape.path,constants.paramIsY);if(bounds){shape._extremes[ax._id]=Axes.findExtremes(ax,bounds,calcYPaddingOptions(shape));}}}};function calcXPaddingOptions(shape){return calcPaddingOptions(shape.line.width,shape.xsizemode,shape.x0,shape.x1,shape.path,false);}function calcYPaddingOptions(shape){return calcPaddingOptions(shape.line.width,shape.ysizemode,shape.y0,shape.y1,shape.path,true);}function calcPaddingOptions(lineWidth,sizeMode,v0,v1,path,isYAxis){var ppad=lineWidth/2;var axisDirectionReverted=isYAxis;if(sizeMode==='pixel'){var coords=path?helpers.extractPathCoords(path,isYAxis?constants.paramIsY:constants.paramIsX):[v0,v1];var maxValue=Lib.aggNums(Math.max,null,coords);var minValue=Lib.aggNums(Math.min,null,coords);var beforePad=minValue<0?Math.abs(minValue)+ppad:ppad;var afterPad=maxValue>0?maxValue+ppad:ppad;return{ppad:ppad,ppadplus:axisDirectionReverted?beforePad:afterPad,ppadminus:axisDirectionReverted?afterPad:beforePad};}else{return{ppad:ppad};}}function shapeBounds(ax,v0,v1,path,paramsToUse){var convertVal=ax.type==='category'||ax.type==='multicategory'?ax.r2c:ax.d2c;if(v0!==undefined)return[convertVal(v0),convertVal(v1)];if(!path)return;var min=Infinity;var max=-Infinity;var segments=path.match(constants.segmentRE);var i;var segment;var drawnParam;var params;var val;if(ax.type==='date')convertVal=helpers.decodeDate(convertVal);for(i=0;i<segments.length;i++){segment=segments[i];drawnParam=paramsToUse[segment.charAt(0)].drawn;if(drawnParam===undefined)continue;params=segments[i].substr(1).match(constants.paramRE);if(!params||params.length<drawnParam)continue;val=convertVal(params[drawnParam]);if(val<min)min=val;if(val>max)max=val;}if(max>=min)return[min,max];}},{\"../../lib\":159,\"../../plots/cartesian/axes\":203,\"./constants\":121,\"./helpers\":124}],121:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports={segmentRE:/[MLHVQCTSZ][^MLHVQCTSZ]*/g,paramRE:/[^\\s,]+/g,// which numbers in each path segment are x (or y) values\n// drawn is which param is a drawn point, as opposed to a\n// control point (which doesn't count toward autorange.\n// TODO: this means curved paths could extend beyond the\n// autorange bounds. This is a bit tricky to get right\n// unless we revert to bounding boxes, but perhaps there's\n// a calculation we could do...)\nparamIsX:{M:{0:true,drawn:0},L:{0:true,drawn:0},H:{0:true,drawn:0},V:{},Q:{0:true,2:true,drawn:2},C:{0:true,2:true,4:true,drawn:4},T:{0:true,drawn:0},S:{0:true,2:true,drawn:2},// A: {0: true, 5: true},\nZ:{}},paramIsY:{M:{1:true,drawn:1},L:{1:true,drawn:1},H:{},V:{0:true,drawn:0},Q:{1:true,3:true,drawn:3},C:{1:true,3:true,5:true,drawn:5},T:{1:true,drawn:1},S:{1:true,3:true,drawn:5},// A: {1: true, 6: true},\nZ:{}},numParams:{M:2,L:2,H:1,V:1,Q:4,C:6,T:2,S:4,// A: 7,\nZ:0}};},{}],122:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var Axes=_dereq_('../../plots/cartesian/axes');var handleArrayContainerDefaults=_dereq_('../../plots/array_container_defaults');var attributes=_dereq_('./attributes');var helpers=_dereq_('./helpers');module.exports=function supplyLayoutDefaults(layoutIn,layoutOut){handleArrayContainerDefaults(layoutIn,layoutOut,{name:'shapes',handleItemDefaults:handleShapeDefaults});};function handleShapeDefaults(shapeIn,shapeOut,fullLayout){function coerce(attr,dflt){return Lib.coerce(shapeIn,shapeOut,attributes,attr,dflt);}var visible=coerce('visible');if(!visible)return;coerce('layer');coerce('opacity');coerce('fillcolor');coerce('line.color');coerce('line.width');coerce('line.dash');var dfltType=shapeIn.path?'path':'rect';var shapeType=coerce('type',dfltType);var xSizeMode=coerce('xsizemode');var ySizeMode=coerce('ysizemode');// positioning\nvar axLetters=['x','y'];for(var i=0;i<2;i++){var axLetter=axLetters[i];var attrAnchor=axLetter+'anchor';var sizeMode=axLetter==='x'?xSizeMode:ySizeMode;var gdMock={_fullLayout:fullLayout};var ax;var pos2r;var r2pos;// xref, yref\nvar axRef=Axes.coerceRef(shapeIn,shapeOut,gdMock,axLetter,'','paper');if(axRef!=='paper'){ax=Axes.getFromId(gdMock,axRef);ax._shapeIndices.push(shapeOut._index);r2pos=helpers.rangeToShapePosition(ax);pos2r=helpers.shapePositionToRange(ax);}else{pos2r=r2pos=Lib.identity;}// Coerce x0, x1, y0, y1\nif(shapeType!=='path'){var dflt0=0.25;var dflt1=0.75;// hack until V2.0 when log has regular range behavior - make it look like other\n// ranges to send to coerce, then put it back after\n// this is all to give reasonable default position behavior on log axes, which is\n// a pretty unimportant edge case so we could just ignore this.\nvar attr0=axLetter+'0';var attr1=axLetter+'1';var in0=shapeIn[attr0];var in1=shapeIn[attr1];shapeIn[attr0]=pos2r(shapeIn[attr0],true);shapeIn[attr1]=pos2r(shapeIn[attr1],true);if(sizeMode==='pixel'){coerce(attr0,0);coerce(attr1,10);}else{Axes.coercePosition(shapeOut,gdMock,coerce,axRef,attr0,dflt0);Axes.coercePosition(shapeOut,gdMock,coerce,axRef,attr1,dflt1);}// hack part 2\nshapeOut[attr0]=r2pos(shapeOut[attr0]);shapeOut[attr1]=r2pos(shapeOut[attr1]);shapeIn[attr0]=in0;shapeIn[attr1]=in1;}// Coerce xanchor and yanchor\nif(sizeMode==='pixel'){// Hack for log axis described above\nvar inAnchor=shapeIn[attrAnchor];shapeIn[attrAnchor]=pos2r(shapeIn[attrAnchor],true);Axes.coercePosition(shapeOut,gdMock,coerce,axRef,attrAnchor,0.25);// Hack part 2\nshapeOut[attrAnchor]=r2pos(shapeOut[attrAnchor]);shapeIn[attrAnchor]=inAnchor;}}if(shapeType==='path'){coerce('path');}else{Lib.noneOrAll(shapeIn,shapeOut,['x0','x1','y0','y1']);}}},{\"../../lib\":159,\"../../plots/array_container_defaults\":199,\"../../plots/cartesian/axes\":203,\"./attributes\":119,\"./helpers\":124}],123:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Registry=_dereq_('../../registry');var Lib=_dereq_('../../lib');var Axes=_dereq_('../../plots/cartesian/axes');var Color=_dereq_('../color');var Drawing=_dereq_('../drawing');var arrayEditor=_dereq_('../../plot_api/plot_template').arrayEditor;var dragElement=_dereq_('../dragelement');var setCursor=_dereq_('../../lib/setcursor');var constants=_dereq_('./constants');var helpers=_dereq_('./helpers');// Shapes are stored in gd.layout.shapes, an array of objects\n// index can point to one item in this array,\n//  or non-numeric to simply add a new one\n//  or -1 to modify all existing\n// opt can be the full options object, or one key (to be set to value)\n//  or undefined to simply redraw\n// if opt is blank, val can be 'add' or a full options object to add a new\n//  annotation at that point in the array, or 'remove' to delete this one\nmodule.exports={draw:draw,drawOne:drawOne};function draw(gd){var fullLayout=gd._fullLayout;// Remove previous shapes before drawing new in shapes in fullLayout.shapes\nfullLayout._shapeUpperLayer.selectAll('path').remove();fullLayout._shapeLowerLayer.selectAll('path').remove();for(var k in fullLayout._plots){var shapelayer=fullLayout._plots[k].shapelayer;if(shapelayer)shapelayer.selectAll('path').remove();}for(var i=0;i<fullLayout.shapes.length;i++){if(fullLayout.shapes[i].visible){drawOne(gd,i);}}// may need to resurrect this if we put text (LaTeX) in shapes\n// return Plots.previousPromises(gd);\n}function drawOne(gd,index){// remove the existing shape if there is one.\n// because indices can change, we need to look in all shape layers\ngd._fullLayout._paperdiv.selectAll('.shapelayer [data-index=\"'+index+'\"]').remove();var options=gd._fullLayout.shapes[index]||{};// this shape is gone - quit now after deleting it\n// TODO: use d3 idioms instead of deleting and redrawing every time\nif(!options._input||options.visible===false)return;if(options.layer!=='below'){drawShape(gd._fullLayout._shapeUpperLayer);}else if(options.xref==='paper'||options.yref==='paper'){drawShape(gd._fullLayout._shapeLowerLayer);}else{var plotinfo=gd._fullLayout._plots[options.xref+options.yref];if(plotinfo){var mainPlot=plotinfo.mainplotinfo||plotinfo;drawShape(mainPlot.shapelayer);}else{// Fall back to _shapeLowerLayer in case the requested subplot doesn't exist.\n// This can happen if you reference the shape to an x / y axis combination\n// that doesn't have any data on it (and layer is below)\ndrawShape(gd._fullLayout._shapeLowerLayer);}}function drawShape(shapeLayer){var attrs={'data-index':index,'fill-rule':'evenodd',d:getPathString(gd,options)};var lineColor=options.line.width?options.line.color:'rgba(0,0,0,0)';var path=shapeLayer.append('path').attr(attrs).style('opacity',options.opacity).call(Color.stroke,lineColor).call(Color.fill,options.fillcolor).call(Drawing.dashLine,options.line.dash,options.line.width);setClipPath(path,gd,options);if(gd._context.edits.shapePosition)setupDragElement(gd,path,options,index,shapeLayer);}}function setClipPath(shapePath,gd,shapeOptions){// note that for layer=\"below\" the clipAxes can be different from the\n// subplot we're drawing this in. This could cause problems if the shape\n// spans two subplots. See https://github.com/plotly/plotly.js/issues/1452\nvar clipAxes=(shapeOptions.xref+shapeOptions.yref).replace(/paper/g,'');Drawing.setClipUrl(shapePath,clipAxes?'clip'+gd._fullLayout._uid+clipAxes:null,gd);}function setupDragElement(gd,shapePath,shapeOptions,index,shapeLayer){var MINWIDTH=10;var MINHEIGHT=10;var xPixelSized=shapeOptions.xsizemode==='pixel';var yPixelSized=shapeOptions.ysizemode==='pixel';var isLine=shapeOptions.type==='line';var isPath=shapeOptions.type==='path';var editHelpers=arrayEditor(gd.layout,'shapes',shapeOptions);var modifyItem=editHelpers.modifyItem;var x0,y0,x1,y1,xAnchor,yAnchor;var n0,s0,w0,e0,optN,optS,optW,optE;var pathIn;// setup conversion functions\nvar xa=Axes.getFromId(gd,shapeOptions.xref);var ya=Axes.getFromId(gd,shapeOptions.yref);var x2p=helpers.getDataToPixel(gd,xa);var y2p=helpers.getDataToPixel(gd,ya,true);var p2x=helpers.getPixelToData(gd,xa);var p2y=helpers.getPixelToData(gd,ya,true);var sensoryElement=obtainSensoryElement();var dragOptions={element:sensoryElement.node(),gd:gd,prepFn:startDrag,doneFn:endDrag,clickFn:abortDrag};var dragMode;dragElement.init(dragOptions);sensoryElement.node().onmousemove=updateDragMode;function obtainSensoryElement(){return isLine?createLineDragHandles():shapePath;}function createLineDragHandles(){var minSensoryWidth=10;var sensoryWidth=Math.max(shapeOptions.line.width,minSensoryWidth);// Helper shapes group\n// Note that by setting the `data-index` attr, it is ensured that\n// the helper group is purged in this modules `draw` function\nvar g=shapeLayer.append('g').attr('data-index',index);// Helper path for moving\ng.append('path').attr('d',shapePath.attr('d')).style({'cursor':'move','stroke-width':sensoryWidth,'stroke-opacity':'0'// ensure not visible\n});// Helper circles for resizing\nvar circleStyle={'fill-opacity':'0'// ensure not visible\n};var circleRadius=sensoryWidth/2>minSensoryWidth?sensoryWidth/2:minSensoryWidth;g.append('circle').attr({'data-line-point':'start-point','cx':xPixelSized?x2p(shapeOptions.xanchor)+shapeOptions.x0:x2p(shapeOptions.x0),'cy':yPixelSized?y2p(shapeOptions.yanchor)-shapeOptions.y0:y2p(shapeOptions.y0),'r':circleRadius}).style(circleStyle).classed('cursor-grab',true);g.append('circle').attr({'data-line-point':'end-point','cx':xPixelSized?x2p(shapeOptions.xanchor)+shapeOptions.x1:x2p(shapeOptions.x1),'cy':yPixelSized?y2p(shapeOptions.yanchor)-shapeOptions.y1:y2p(shapeOptions.y1),'r':circleRadius}).style(circleStyle).classed('cursor-grab',true);return g;}function updateDragMode(evt){if(isLine){if(evt.target.tagName==='path'){dragMode='move';}else{dragMode=evt.target.attributes['data-line-point'].value==='start-point'?'resize-over-start-point':'resize-over-end-point';}}else{// element might not be on screen at time of setup,\n// so obtain bounding box here\nvar dragBBox=dragOptions.element.getBoundingClientRect();// choose 'move' or 'resize'\n// based on initial position of cursor within the drag element\nvar w=dragBBox.right-dragBBox.left;var h=dragBBox.bottom-dragBBox.top;var x=evt.clientX-dragBBox.left;var y=evt.clientY-dragBBox.top;var cursor=!isPath&&w>MINWIDTH&&h>MINHEIGHT&&!evt.shiftKey?dragElement.getCursor(x/w,1-y/h):'move';setCursor(shapePath,cursor);// possible values 'move', 'sw', 'w', 'se', 'e', 'ne', 'n', 'nw' and 'w'\ndragMode=cursor.split('-')[0];}}function startDrag(evt){// setup update strings and initial values\nif(xPixelSized){xAnchor=x2p(shapeOptions.xanchor);}if(yPixelSized){yAnchor=y2p(shapeOptions.yanchor);}if(shapeOptions.type==='path'){pathIn=shapeOptions.path;}else{x0=xPixelSized?shapeOptions.x0:x2p(shapeOptions.x0);y0=yPixelSized?shapeOptions.y0:y2p(shapeOptions.y0);x1=xPixelSized?shapeOptions.x1:x2p(shapeOptions.x1);y1=yPixelSized?shapeOptions.y1:y2p(shapeOptions.y1);}if(x0<x1){w0=x0;optW='x0';e0=x1;optE='x1';}else{w0=x1;optW='x1';e0=x0;optE='x0';}// For fixed size shapes take opposing direction of y-axis into account.\n// Hint: For data sized shapes this is done by the y2p function.\nif(!yPixelSized&&y0<y1||yPixelSized&&y0>y1){n0=y0;optN='y0';s0=y1;optS='y1';}else{n0=y1;optN='y1';s0=y0;optS='y0';}// setup dragMode and the corresponding handler\nupdateDragMode(evt);renderVisualCues(shapeLayer,shapeOptions);deactivateClipPathTemporarily(shapePath,shapeOptions,gd);dragOptions.moveFn=dragMode==='move'?moveShape:resizeShape;}function endDrag(){setCursor(shapePath);removeVisualCues(shapeLayer);// Don't rely on clipPath being activated during re-layout\nsetClipPath(shapePath,gd,shapeOptions);Registry.call('_guiRelayout',gd,editHelpers.getUpdateObj());}function abortDrag(){removeVisualCues(shapeLayer);}function moveShape(dx,dy){if(shapeOptions.type==='path'){var noOp=function noOp(coord){return coord;};var moveX=noOp;var moveY=noOp;if(xPixelSized){modifyItem('xanchor',shapeOptions.xanchor=p2x(xAnchor+dx));}else{moveX=function moveX(x){return p2x(x2p(x)+dx);};if(xa&&xa.type==='date')moveX=helpers.encodeDate(moveX);}if(yPixelSized){modifyItem('yanchor',shapeOptions.yanchor=p2y(yAnchor+dy));}else{moveY=function moveY(y){return p2y(y2p(y)+dy);};if(ya&&ya.type==='date')moveY=helpers.encodeDate(moveY);}modifyItem('path',shapeOptions.path=movePath(pathIn,moveX,moveY));}else{if(xPixelSized){modifyItem('xanchor',shapeOptions.xanchor=p2x(xAnchor+dx));}else{modifyItem('x0',shapeOptions.x0=p2x(x0+dx));modifyItem('x1',shapeOptions.x1=p2x(x1+dx));}if(yPixelSized){modifyItem('yanchor',shapeOptions.yanchor=p2y(yAnchor+dy));}else{modifyItem('y0',shapeOptions.y0=p2y(y0+dy));modifyItem('y1',shapeOptions.y1=p2y(y1+dy));}}shapePath.attr('d',getPathString(gd,shapeOptions));renderVisualCues(shapeLayer,shapeOptions);}function resizeShape(dx,dy){if(isPath){// TODO: implement path resize, don't forget to update dragMode code\nvar noOp=function noOp(coord){return coord;};var moveX=noOp;var moveY=noOp;if(xPixelSized){modifyItem('xanchor',shapeOptions.xanchor=p2x(xAnchor+dx));}else{moveX=function moveX(x){return p2x(x2p(x)+dx);};if(xa&&xa.type==='date')moveX=helpers.encodeDate(moveX);}if(yPixelSized){modifyItem('yanchor',shapeOptions.yanchor=p2y(yAnchor+dy));}else{moveY=function moveY(y){return p2y(y2p(y)+dy);};if(ya&&ya.type==='date')moveY=helpers.encodeDate(moveY);}modifyItem('path',shapeOptions.path=movePath(pathIn,moveX,moveY));}else if(isLine){if(dragMode==='resize-over-start-point'){var newX0=x0+dx;var newY0=yPixelSized?y0-dy:y0+dy;modifyItem('x0',shapeOptions.x0=xPixelSized?newX0:p2x(newX0));modifyItem('y0',shapeOptions.y0=yPixelSized?newY0:p2y(newY0));}else if(dragMode==='resize-over-end-point'){var newX1=x1+dx;var newY1=yPixelSized?y1-dy:y1+dy;modifyItem('x1',shapeOptions.x1=xPixelSized?newX1:p2x(newX1));modifyItem('y1',shapeOptions.y1=yPixelSized?newY1:p2y(newY1));}}else{var newN=~dragMode.indexOf('n')?n0+dy:n0;var newS=~dragMode.indexOf('s')?s0+dy:s0;var newW=~dragMode.indexOf('w')?w0+dx:w0;var newE=~dragMode.indexOf('e')?e0+dx:e0;// Do things in opposing direction for y-axis.\n// Hint: for data-sized shapes the reversal of axis direction is done in p2y.\nif(~dragMode.indexOf('n')&&yPixelSized)newN=n0-dy;if(~dragMode.indexOf('s')&&yPixelSized)newS=s0-dy;// Update shape eventually. Again, be aware of the\n// opposing direction of the y-axis of fixed size shapes.\nif(!yPixelSized&&newS-newN>MINHEIGHT||yPixelSized&&newN-newS>MINHEIGHT){modifyItem(optN,shapeOptions[optN]=yPixelSized?newN:p2y(newN));modifyItem(optS,shapeOptions[optS]=yPixelSized?newS:p2y(newS));}if(newE-newW>MINWIDTH){modifyItem(optW,shapeOptions[optW]=xPixelSized?newW:p2x(newW));modifyItem(optE,shapeOptions[optE]=xPixelSized?newE:p2x(newE));}}shapePath.attr('d',getPathString(gd,shapeOptions));renderVisualCues(shapeLayer,shapeOptions);}function renderVisualCues(shapeLayer,shapeOptions){if(xPixelSized||yPixelSized){renderAnchor();}function renderAnchor(){var isNotPath=shapeOptions.type!=='path';// d3 join with dummy data to satisfy d3 data-binding\nvar visualCues=shapeLayer.selectAll('.visual-cue').data([0]);// Enter\nvar strokeWidth=1;visualCues.enter().append('path').attr({'fill':'#fff','fill-rule':'evenodd','stroke':'#000','stroke-width':strokeWidth}).classed('visual-cue',true);// Update\nvar posX=x2p(xPixelSized?shapeOptions.xanchor:Lib.midRange(isNotPath?[shapeOptions.x0,shapeOptions.x1]:helpers.extractPathCoords(shapeOptions.path,constants.paramIsX)));var posY=y2p(yPixelSized?shapeOptions.yanchor:Lib.midRange(isNotPath?[shapeOptions.y0,shapeOptions.y1]:helpers.extractPathCoords(shapeOptions.path,constants.paramIsY)));posX=helpers.roundPositionForSharpStrokeRendering(posX,strokeWidth);posY=helpers.roundPositionForSharpStrokeRendering(posY,strokeWidth);if(xPixelSized&&yPixelSized){var crossPath='M'+(posX-1-strokeWidth)+','+(posY-1-strokeWidth)+'h-8v2h8 v8h2v-8 h8v-2h-8 v-8h-2 Z';visualCues.attr('d',crossPath);}else if(xPixelSized){var vBarPath='M'+(posX-1-strokeWidth)+','+(posY-9-strokeWidth)+'v18 h2 v-18 Z';visualCues.attr('d',vBarPath);}else{var hBarPath='M'+(posX-9-strokeWidth)+','+(posY-1-strokeWidth)+'h18 v2 h-18 Z';visualCues.attr('d',hBarPath);}}}function removeVisualCues(shapeLayer){shapeLayer.selectAll('.visual-cue').remove();}function deactivateClipPathTemporarily(shapePath,shapeOptions,gd){var xref=shapeOptions.xref;var yref=shapeOptions.yref;var xa=Axes.getFromId(gd,xref);var ya=Axes.getFromId(gd,yref);var clipAxes='';if(xref!=='paper'&&!xa.autorange)clipAxes+=xref;if(yref!=='paper'&&!ya.autorange)clipAxes+=yref;Drawing.setClipUrl(shapePath,clipAxes?'clip'+gd._fullLayout._uid+clipAxes:null,gd);}}function getPathString(gd,options){var type=options.type;var xa=Axes.getFromId(gd,options.xref);var ya=Axes.getFromId(gd,options.yref);var gs=gd._fullLayout._size;var x2r,x2p,y2r,y2p;var x0,x1,y0,y1;if(xa){x2r=helpers.shapePositionToRange(xa);x2p=function x2p(v){return xa._offset+xa.r2p(x2r(v,true));};}else{x2p=function x2p(v){return gs.l+gs.w*v;};}if(ya){y2r=helpers.shapePositionToRange(ya);y2p=function y2p(v){return ya._offset+ya.r2p(y2r(v,true));};}else{y2p=function y2p(v){return gs.t+gs.h*(1-v);};}if(type==='path'){if(xa&&xa.type==='date')x2p=helpers.decodeDate(x2p);if(ya&&ya.type==='date')y2p=helpers.decodeDate(y2p);return convertPath(options,x2p,y2p);}if(options.xsizemode==='pixel'){var xAnchorPos=x2p(options.xanchor);x0=xAnchorPos+options.x0;x1=xAnchorPos+options.x1;}else{x0=x2p(options.x0);x1=x2p(options.x1);}if(options.ysizemode==='pixel'){var yAnchorPos=y2p(options.yanchor);y0=yAnchorPos-options.y0;y1=yAnchorPos-options.y1;}else{y0=y2p(options.y0);y1=y2p(options.y1);}if(type==='line')return'M'+x0+','+y0+'L'+x1+','+y1;if(type==='rect')return'M'+x0+','+y0+'H'+x1+'V'+y1+'H'+x0+'Z';// circle\nvar cx=(x0+x1)/2;var cy=(y0+y1)/2;var rx=Math.abs(cx-x0);var ry=Math.abs(cy-y0);var rArc='A'+rx+','+ry;var rightPt=cx+rx+','+cy;var topPt=cx+','+(cy-ry);return'M'+rightPt+rArc+' 0 1,1 '+topPt+rArc+' 0 0,1 '+rightPt+'Z';}function convertPath(options,x2p,y2p){var pathIn=options.path;var xSizemode=options.xsizemode;var ySizemode=options.ysizemode;var xAnchor=options.xanchor;var yAnchor=options.yanchor;return pathIn.replace(constants.segmentRE,function(segment){var paramNumber=0;var segmentType=segment.charAt(0);var xParams=constants.paramIsX[segmentType];var yParams=constants.paramIsY[segmentType];var nParams=constants.numParams[segmentType];var paramString=segment.substr(1).replace(constants.paramRE,function(param){if(xParams[paramNumber]){if(xSizemode==='pixel')param=x2p(xAnchor)+Number(param);else param=x2p(param);}else if(yParams[paramNumber]){if(ySizemode==='pixel')param=y2p(yAnchor)-Number(param);else param=y2p(param);}paramNumber++;if(paramNumber>nParams)param='X';return param;});if(paramNumber>nParams){paramString=paramString.replace(/[\\s,]*X.*/,'');Lib.log('Ignoring extra params in segment '+segment);}return segmentType+paramString;});}function movePath(pathIn,moveX,moveY){return pathIn.replace(constants.segmentRE,function(segment){var paramNumber=0;var segmentType=segment.charAt(0);var xParams=constants.paramIsX[segmentType];var yParams=constants.paramIsY[segmentType];var nParams=constants.numParams[segmentType];var paramString=segment.substr(1).replace(constants.paramRE,function(param){if(paramNumber>=nParams)return param;if(xParams[paramNumber])param=moveX(param);else if(yParams[paramNumber])param=moveY(param);paramNumber++;return param;});return segmentType+paramString;});}},{\"../../lib\":159,\"../../lib/setcursor\":178,\"../../plot_api/plot_template\":193,\"../../plots/cartesian/axes\":203,\"../../registry\":242,\"../color\":43,\"../dragelement\":61,\"../drawing\":64,\"./constants\":121,\"./helpers\":124}],124:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var constants=_dereq_('./constants');var Lib=_dereq_('../../lib');// special position conversion functions... category axis positions can't be\n// specified by their data values, because they don't make a continuous mapping.\n// so these have to be specified in terms of the category serial numbers,\n// but can take fractional values. Other axis types we specify position based on\n// the actual data values.\n// TODO: in V2.0 (when log axis ranges are in data units) range and shape position\n// will be identical, so rangeToShapePosition and shapePositionToRange can be\n// removed entirely.\nexports.rangeToShapePosition=function(ax){return ax.type==='log'?ax.r2d:function(v){return v;};};exports.shapePositionToRange=function(ax){return ax.type==='log'?ax.d2r:function(v){return v;};};exports.decodeDate=function(convertToPx){return function(v){if(v.replace)v=v.replace('_',' ');return convertToPx(v);};};exports.encodeDate=function(convertToDate){return function(v){return convertToDate(v).replace(' ','_');};};exports.extractPathCoords=function(path,paramsToUse){var extractedCoordinates=[];var segments=path.match(constants.segmentRE);segments.forEach(function(segment){var relevantParamIdx=paramsToUse[segment.charAt(0)].drawn;if(relevantParamIdx===undefined)return;var params=segment.substr(1).match(constants.paramRE);if(!params||params.length<relevantParamIdx)return;extractedCoordinates.push(Lib.cleanNumber(params[relevantParamIdx]));});return extractedCoordinates;};exports.getDataToPixel=function(gd,axis,isVertical){var gs=gd._fullLayout._size;var dataToPixel;if(axis){var d2r=exports.shapePositionToRange(axis);dataToPixel=function dataToPixel(v){return axis._offset+axis.r2p(d2r(v,true));};if(axis.type==='date')dataToPixel=exports.decodeDate(dataToPixel);}else if(isVertical){dataToPixel=function dataToPixel(v){return gs.t+gs.h*(1-v);};}else{dataToPixel=function dataToPixel(v){return gs.l+gs.w*v;};}return dataToPixel;};exports.getPixelToData=function(gd,axis,isVertical){var gs=gd._fullLayout._size;var pixelToData;if(axis){var r2d=exports.rangeToShapePosition(axis);pixelToData=function pixelToData(p){return r2d(axis.p2r(p-axis._offset));};}else if(isVertical){pixelToData=function pixelToData(p){return 1-(p-gs.t)/gs.h;};}else{pixelToData=function pixelToData(p){return(p-gs.l)/gs.w;};}return pixelToData;};/**\n * Based on the given stroke width, rounds the passed\n * position value to represent either a full or half pixel.\n *\n * In case of an odd stroke width (e.g. 1), this measure ensures\n * that a stroke positioned at the returned position isn't rendered\n * blurry due to anti-aliasing.\n *\n * In case of an even stroke width (e.g. 2), this measure ensures\n * that the position value is transformed to a full pixel value\n * so that anti-aliasing doesn't take effect either.\n *\n * @param {number} pos The raw position value to be transformed\n * @param {number} strokeWidth The stroke width\n * @returns {number} either an integer or a .5 decimal number\n */exports.roundPositionForSharpStrokeRendering=function(pos,strokeWidth){var strokeWidthIsOdd=Math.round(strokeWidth%2)===1;var posValAsInt=Math.round(pos);return strokeWidthIsOdd?posValAsInt+0.5:posValAsInt;};},{\"../../lib\":159,\"./constants\":121}],125:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var drawModule=_dereq_('./draw');module.exports={moduleType:'component',name:'shapes',layoutAttributes:_dereq_('./attributes'),supplyLayoutDefaults:_dereq_('./defaults'),includeBasePlot:_dereq_('../../plots/cartesian/include_components')('shapes'),calcAutorange:_dereq_('./calc_autorange'),draw:drawModule.draw,drawOne:drawModule.drawOne};},{\"../../plots/cartesian/include_components\":213,\"./attributes\":119,\"./calc_autorange\":120,\"./defaults\":122,\"./draw\":123}],126:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var fontAttrs=_dereq_('../../plots/font_attributes');var padAttrs=_dereq_('../../plots/pad_attributes');var extendDeepAll=_dereq_('../../lib/extend').extendDeepAll;var overrideAll=_dereq_('../../plot_api/edit_types').overrideAll;var animationAttrs=_dereq_('../../plots/animation_attributes');var templatedArray=_dereq_('../../plot_api/plot_template').templatedArray;var constants=_dereq_('./constants');var stepsAttrs=templatedArray('step',{visible:{valType:'boolean',dflt:true},method:{valType:'enumerated',values:['restyle','relayout','animate','update','skip'],dflt:'restyle'},args:{valType:'info_array',freeLength:true,items:[{valType:'any'},{valType:'any'},{valType:'any'}]},label:{valType:'string'},value:{valType:'string'},execute:{valType:'boolean',dflt:true}});module.exports=overrideAll(templatedArray('slider',{visible:{valType:'boolean',dflt:true},active:{valType:'number',min:0,dflt:0},steps:stepsAttrs,lenmode:{valType:'enumerated',values:['fraction','pixels'],dflt:'fraction'},len:{valType:'number',min:0,dflt:1},x:{valType:'number',min:-2,max:3,dflt:0},pad:extendDeepAll(padAttrs({editType:'arraydraw'}),{},{t:{dflt:20}}),xanchor:{valType:'enumerated',values:['auto','left','center','right'],dflt:'left'},y:{valType:'number',min:-2,max:3,dflt:0},yanchor:{valType:'enumerated',values:['auto','top','middle','bottom'],dflt:'top'},transition:{duration:{valType:'number',min:0,dflt:150},easing:{valType:'enumerated',values:animationAttrs.transition.easing.values,dflt:'cubic-in-out'}},currentvalue:{visible:{valType:'boolean',dflt:true},xanchor:{valType:'enumerated',values:['left','center','right'],dflt:'left'},offset:{valType:'number',dflt:10},prefix:{valType:'string'},suffix:{valType:'string'},font:fontAttrs({})},font:fontAttrs({}),activebgcolor:{valType:'color',dflt:constants.gripBgActiveColor},bgcolor:{valType:'color',dflt:constants.railBgColor},bordercolor:{valType:'color',dflt:constants.railBorderColor},borderwidth:{valType:'number',min:0,dflt:constants.railBorderWidth},ticklen:{valType:'number',min:0,dflt:constants.tickLength},tickcolor:{valType:'color',dflt:constants.tickColor},tickwidth:{valType:'number',min:0,dflt:1},minorticklen:{valType:'number',min:0,dflt:constants.minorTickLength}}),'arraydraw','from-root');},{\"../../lib/extend\":153,\"../../plot_api/edit_types\":186,\"../../plot_api/plot_template\":193,\"../../plots/animation_attributes\":198,\"../../plots/font_attributes\":229,\"../../plots/pad_attributes\":234,\"./constants\":127}],127:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports={// layout attribute name\nname:'sliders',// class names\ncontainerClassName:'slider-container',groupClassName:'slider-group',inputAreaClass:'slider-input-area',railRectClass:'slider-rail-rect',railTouchRectClass:'slider-rail-touch-rect',gripRectClass:'slider-grip-rect',tickRectClass:'slider-tick-rect',inputProxyClass:'slider-input-proxy',labelsClass:'slider-labels',labelGroupClass:'slider-label-group',labelClass:'slider-label',currentValueClass:'slider-current-value',railHeight:5,// DOM attribute name in button group keeping track\n// of active update menu\nmenuIndexAttrName:'slider-active-index',// id root pass to Plots.autoMargin\nautoMarginIdRoot:'slider-',// min item width / height\nminWidth:30,minHeight:30,// padding around item text\ntextPadX:40,// arrow offset off right edge\narrowOffsetX:4,railRadius:2,railWidth:5,railBorder:4,railBorderWidth:1,railBorderColor:'#bec8d9',railBgColor:'#f8fafc',// The distance of the rail from the edge of the touchable area\n// Slightly less than the step inset because of the curved edges\n// of the rail\nrailInset:8,// The distance from the extremal tick marks to the edge of the\n// touchable area. This is basically the same as the grip radius,\n// but for other styles it wouldn't really need to be.\nstepInset:10,gripRadius:10,gripWidth:20,gripHeight:20,gripBorder:20,gripBorderWidth:1,gripBorderColor:'#bec8d9',gripBgColor:'#f6f8fa',gripBgActiveColor:'#dbdde0',labelPadding:8,labelOffset:0,tickWidth:1,tickColor:'#333',tickOffset:25,tickLength:7,minorTickOffset:25,minorTickColor:'#333',minorTickLength:4,// Extra space below the current value label:\ncurrentValuePadding:8,currentValueInset:0};},{}],128:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var handleArrayContainerDefaults=_dereq_('../../plots/array_container_defaults');var attributes=_dereq_('./attributes');var constants=_dereq_('./constants');var name=constants.name;var stepAttrs=attributes.steps;module.exports=function slidersDefaults(layoutIn,layoutOut){handleArrayContainerDefaults(layoutIn,layoutOut,{name:name,handleItemDefaults:sliderDefaults});};function sliderDefaults(sliderIn,sliderOut,layoutOut){function coerce(attr,dflt){return Lib.coerce(sliderIn,sliderOut,attributes,attr,dflt);}var steps=handleArrayContainerDefaults(sliderIn,sliderOut,{name:'steps',handleItemDefaults:stepDefaults});var stepCount=0;for(var i=0;i<steps.length;i++){if(steps[i].visible)stepCount++;}var visible;// If it has fewer than two options, it's not really a slider\nif(stepCount<2)visible=sliderOut.visible=false;else visible=coerce('visible');if(!visible)return;sliderOut._stepCount=stepCount;var visSteps=sliderOut._visibleSteps=Lib.filterVisible(steps);var active=coerce('active');if(!(steps[active]||{}).visible)sliderOut.active=visSteps[0]._index;coerce('x');coerce('y');Lib.noneOrAll(sliderIn,sliderOut,['x','y']);coerce('xanchor');coerce('yanchor');coerce('len');coerce('lenmode');coerce('pad.t');coerce('pad.r');coerce('pad.b');coerce('pad.l');Lib.coerceFont(coerce,'font',layoutOut.font);var currentValueIsVisible=coerce('currentvalue.visible');if(currentValueIsVisible){coerce('currentvalue.xanchor');coerce('currentvalue.prefix');coerce('currentvalue.suffix');coerce('currentvalue.offset');Lib.coerceFont(coerce,'currentvalue.font',sliderOut.font);}coerce('transition.duration');coerce('transition.easing');coerce('bgcolor');coerce('activebgcolor');coerce('bordercolor');coerce('borderwidth');coerce('ticklen');coerce('tickwidth');coerce('tickcolor');coerce('minorticklen');}function stepDefaults(valueIn,valueOut){function coerce(attr,dflt){return Lib.coerce(valueIn,valueOut,stepAttrs,attr,dflt);}var visible;if(valueIn.method!=='skip'&&!Array.isArray(valueIn.args)){visible=valueOut.visible=false;}else visible=coerce('visible');if(visible){coerce('method');coerce('args');var label=coerce('label','step-'+valueOut._index);coerce('value',label);coerce('execute');}}},{\"../../lib\":159,\"../../plots/array_container_defaults\":199,\"./attributes\":126,\"./constants\":127}],129:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var Plots=_dereq_('../../plots/plots');var Color=_dereq_('../color');var Drawing=_dereq_('../drawing');var Lib=_dereq_('../../lib');var svgTextUtils=_dereq_('../../lib/svg_text_utils');var arrayEditor=_dereq_('../../plot_api/plot_template').arrayEditor;var constants=_dereq_('./constants');var alignmentConstants=_dereq_('../../constants/alignment');var LINE_SPACING=alignmentConstants.LINE_SPACING;var FROM_TL=alignmentConstants.FROM_TL;var FROM_BR=alignmentConstants.FROM_BR;module.exports=function draw(gd){var fullLayout=gd._fullLayout;var sliderData=makeSliderData(fullLayout,gd);// draw a container for *all* sliders:\nvar sliders=fullLayout._infolayer.selectAll('g.'+constants.containerClassName).data(sliderData.length>0?[0]:[]);sliders.enter().append('g').classed(constants.containerClassName,true).style('cursor','ew-resize');function clearSlider(sliderOpts){if(sliderOpts._commandObserver){sliderOpts._commandObserver.remove();delete sliderOpts._commandObserver;}// Most components don't need to explicitly remove autoMargin, because\n// marginPushers does this - but slider updates don't go through\n// a full replot so we need to explicitly remove it.\nPlots.autoMargin(gd,autoMarginId(sliderOpts));}sliders.exit().each(function(){d3.select(this).selectAll('g.'+constants.groupClassName).each(clearSlider);}).remove();// Return early if no menus visible:\nif(sliderData.length===0)return;var sliderGroups=sliders.selectAll('g.'+constants.groupClassName).data(sliderData,keyFunction);sliderGroups.enter().append('g').classed(constants.groupClassName,true);sliderGroups.exit().each(clearSlider).remove();// Find the dimensions of the sliders:\nfor(var i=0;i<sliderData.length;i++){var sliderOpts=sliderData[i];findDimensions(gd,sliderOpts);}sliderGroups.each(function(sliderOpts){var gSlider=d3.select(this);computeLabelSteps(sliderOpts);Plots.manageCommandObserver(gd,sliderOpts,sliderOpts._visibleSteps,function(data){// NB: Same as below. This is *not* always the same as sliderOpts since\n// if a new set of steps comes in, the reference in this callback would\n// be invalid. We need to refetch it from the slider group, which is\n// the join data that creates this slider. So if this slider still exists,\n// the group should be valid, *to the best of my knowledge.* If not,\n// we'd have to look it up by d3 data join index/key.\nvar opts=gSlider.data()[0];if(opts.active===data.index)return;if(opts._dragging)return;setActive(gd,gSlider,opts,data.index,false,true);});drawSlider(gd,d3.select(this),sliderOpts);});};function autoMarginId(sliderOpts){return constants.autoMarginIdRoot+sliderOpts._index;}// This really only just filters by visibility:\nfunction makeSliderData(fullLayout,gd){var contOpts=fullLayout[constants.name];var sliderData=[];for(var i=0;i<contOpts.length;i++){var item=contOpts[i];if(!item.visible)continue;item._gd=gd;sliderData.push(item);}return sliderData;}// This is set in the defaults step:\nfunction keyFunction(opts){return opts._index;}// Compute the dimensions (mutates sliderOpts):\nfunction findDimensions(gd,sliderOpts){var sliderLabels=Drawing.tester.selectAll('g.'+constants.labelGroupClass).data(sliderOpts._visibleSteps);sliderLabels.enter().append('g').classed(constants.labelGroupClass,true);// loop over fake buttons to find width / height\nvar maxLabelWidth=0;var labelHeight=0;sliderLabels.each(function(stepOpts){var labelGroup=d3.select(this);var text=drawLabel(labelGroup,{step:stepOpts},sliderOpts);var textNode=text.node();if(textNode){var bBox=Drawing.bBox(textNode);labelHeight=Math.max(labelHeight,bBox.height);maxLabelWidth=Math.max(maxLabelWidth,bBox.width);}});sliderLabels.remove();var dims=sliderOpts._dims={};dims.inputAreaWidth=Math.max(constants.railWidth,constants.gripHeight);// calculate some overall dimensions - some of these are needed for\n// calculating the currentValue dimensions\nvar graphSize=gd._fullLayout._size;dims.lx=graphSize.l+graphSize.w*sliderOpts.x;dims.ly=graphSize.t+graphSize.h*(1-sliderOpts.y);if(sliderOpts.lenmode==='fraction'){// fraction:\ndims.outerLength=Math.round(graphSize.w*sliderOpts.len);}else{// pixels:\ndims.outerLength=sliderOpts.len;}// The length of the rail, *excluding* padding on either end:\ndims.inputAreaStart=0;dims.inputAreaLength=Math.round(dims.outerLength-sliderOpts.pad.l-sliderOpts.pad.r);var textableInputLength=dims.inputAreaLength-2*constants.stepInset;var availableSpacePerLabel=textableInputLength/(sliderOpts._stepCount-1);var computedSpacePerLabel=maxLabelWidth+constants.labelPadding;dims.labelStride=Math.max(1,Math.ceil(computedSpacePerLabel/availableSpacePerLabel));dims.labelHeight=labelHeight;// loop over all possible values for currentValue to find the\n// area we need for it\ndims.currentValueMaxWidth=0;dims.currentValueHeight=0;dims.currentValueTotalHeight=0;dims.currentValueMaxLines=1;if(sliderOpts.currentvalue.visible){// Get the dimensions of the current value label:\nvar dummyGroup=Drawing.tester.append('g');sliderLabels.each(function(stepOpts){var curValPrefix=drawCurrentValue(dummyGroup,sliderOpts,stepOpts.label);var curValSize=curValPrefix.node()&&Drawing.bBox(curValPrefix.node())||{width:0,height:0};var lines=svgTextUtils.lineCount(curValPrefix);dims.currentValueMaxWidth=Math.max(dims.currentValueMaxWidth,Math.ceil(curValSize.width));dims.currentValueHeight=Math.max(dims.currentValueHeight,Math.ceil(curValSize.height));dims.currentValueMaxLines=Math.max(dims.currentValueMaxLines,lines);});dims.currentValueTotalHeight=dims.currentValueHeight+sliderOpts.currentvalue.offset;dummyGroup.remove();}dims.height=dims.currentValueTotalHeight+constants.tickOffset+sliderOpts.ticklen+constants.labelOffset+dims.labelHeight+sliderOpts.pad.t+sliderOpts.pad.b;var xanchor='left';if(Lib.isRightAnchor(sliderOpts)){dims.lx-=dims.outerLength;xanchor='right';}if(Lib.isCenterAnchor(sliderOpts)){dims.lx-=dims.outerLength/2;xanchor='center';}var yanchor='top';if(Lib.isBottomAnchor(sliderOpts)){dims.ly-=dims.height;yanchor='bottom';}if(Lib.isMiddleAnchor(sliderOpts)){dims.ly-=dims.height/2;yanchor='middle';}dims.outerLength=Math.ceil(dims.outerLength);dims.height=Math.ceil(dims.height);dims.lx=Math.round(dims.lx);dims.ly=Math.round(dims.ly);var marginOpts={y:sliderOpts.y,b:dims.height*FROM_BR[yanchor],t:dims.height*FROM_TL[yanchor]};if(sliderOpts.lenmode==='fraction'){marginOpts.l=0;marginOpts.xl=sliderOpts.x-sliderOpts.len*FROM_TL[xanchor];marginOpts.r=0;marginOpts.xr=sliderOpts.x+sliderOpts.len*FROM_BR[xanchor];}else{marginOpts.x=sliderOpts.x;marginOpts.l=dims.outerLength*FROM_TL[xanchor];marginOpts.r=dims.outerLength*FROM_BR[xanchor];}Plots.autoMargin(gd,autoMarginId(sliderOpts),marginOpts);}function drawSlider(gd,sliderGroup,sliderOpts){// This is related to the other long notes in this file regarding what happens\n// when slider steps disappear. This particular fix handles what happens when\n// the *current* slider step is removed. The drawing functions will error out\n// when they fail to find it, so the fix for now is that it will just draw the\n// slider in the first position but will not execute the command.\nif(!(sliderOpts.steps[sliderOpts.active]||{}).visible){sliderOpts.active=sliderOpts._visibleSteps[0]._index;}// These are carefully ordered for proper z-ordering:\nsliderGroup.call(drawCurrentValue,sliderOpts).call(drawRail,sliderOpts).call(drawLabelGroup,sliderOpts).call(drawTicks,sliderOpts).call(drawTouchRect,gd,sliderOpts).call(drawGrip,gd,sliderOpts);var dims=sliderOpts._dims;// Position the rectangle:\nDrawing.setTranslate(sliderGroup,dims.lx+sliderOpts.pad.l,dims.ly+sliderOpts.pad.t);sliderGroup.call(setGripPosition,sliderOpts,false);sliderGroup.call(drawCurrentValue,sliderOpts);}function drawCurrentValue(sliderGroup,sliderOpts,valueOverride){if(!sliderOpts.currentvalue.visible)return;var dims=sliderOpts._dims;var x0,textAnchor;switch(sliderOpts.currentvalue.xanchor){case'right':// This is anchored left and adjusted by the width of the longest label\n// so that the prefix doesn't move. The goal of this is to emphasize\n// what's actually changing and make the update less distracting.\nx0=dims.inputAreaLength-constants.currentValueInset-dims.currentValueMaxWidth;textAnchor='left';break;case'center':x0=dims.inputAreaLength*0.5;textAnchor='middle';break;default:x0=constants.currentValueInset;textAnchor='left';}var text=Lib.ensureSingle(sliderGroup,'text',constants.labelClass,function(s){s.classed('user-select-none',true).attr({'text-anchor':textAnchor,'data-notex':1});});var str=sliderOpts.currentvalue.prefix?sliderOpts.currentvalue.prefix:'';if(typeof valueOverride==='string'){str+=valueOverride;}else{var curVal=sliderOpts.steps[sliderOpts.active].label;var meta=sliderOpts._gd._fullLayout.meta;if(meta){curVal=Lib.templateString(curVal,{meta:meta});}str+=curVal;}if(sliderOpts.currentvalue.suffix){str+=sliderOpts.currentvalue.suffix;}text.call(Drawing.font,sliderOpts.currentvalue.font).text(str).call(svgTextUtils.convertToTspans,sliderOpts._gd);var lines=svgTextUtils.lineCount(text);var y0=(dims.currentValueMaxLines+1-lines)*sliderOpts.currentvalue.font.size*LINE_SPACING;svgTextUtils.positionText(text,x0,y0);return text;}function drawGrip(sliderGroup,gd,sliderOpts){var grip=Lib.ensureSingle(sliderGroup,'rect',constants.gripRectClass,function(s){s.call(attachGripEvents,gd,sliderGroup,sliderOpts).style('pointer-events','all');});grip.attr({width:constants.gripWidth,height:constants.gripHeight,rx:constants.gripRadius,ry:constants.gripRadius}).call(Color.stroke,sliderOpts.bordercolor).call(Color.fill,sliderOpts.bgcolor).style('stroke-width',sliderOpts.borderwidth+'px');}function drawLabel(item,data,sliderOpts){var text=Lib.ensureSingle(item,'text',constants.labelClass,function(s){s.classed('user-select-none',true).attr({'text-anchor':'middle','data-notex':1});});var tx=data.step.label;var meta=sliderOpts._gd._fullLayout.meta;if(meta){tx=Lib.templateString(tx,{meta:meta});}text.call(Drawing.font,sliderOpts.font).text(tx).call(svgTextUtils.convertToTspans,sliderOpts._gd);return text;}function drawLabelGroup(sliderGroup,sliderOpts){var labels=Lib.ensureSingle(sliderGroup,'g',constants.labelsClass);var dims=sliderOpts._dims;var labelItems=labels.selectAll('g.'+constants.labelGroupClass).data(dims.labelSteps);labelItems.enter().append('g').classed(constants.labelGroupClass,true);labelItems.exit().remove();labelItems.each(function(d){var item=d3.select(this);item.call(drawLabel,d,sliderOpts);Drawing.setTranslate(item,normalizedValueToPosition(sliderOpts,d.fraction),constants.tickOffset+sliderOpts.ticklen+// position is the baseline of the top line of text only, even\n// if the label spans multiple lines\nsliderOpts.font.size*LINE_SPACING+constants.labelOffset+dims.currentValueTotalHeight);});}function handleInput(gd,sliderGroup,sliderOpts,normalizedPosition,doTransition){var quantizedPosition=Math.round(normalizedPosition*(sliderOpts._stepCount-1));var quantizedIndex=sliderOpts._visibleSteps[quantizedPosition]._index;if(quantizedIndex!==sliderOpts.active){setActive(gd,sliderGroup,sliderOpts,quantizedIndex,true,doTransition);}}function setActive(gd,sliderGroup,sliderOpts,index,doCallback,doTransition){var previousActive=sliderOpts.active;sliderOpts.active=index;// due to templating, it's possible this slider doesn't even exist yet\narrayEditor(gd.layout,constants.name,sliderOpts).applyUpdate('active',index);var step=sliderOpts.steps[sliderOpts.active];sliderGroup.call(setGripPosition,sliderOpts,doTransition);sliderGroup.call(drawCurrentValue,sliderOpts);gd.emit('plotly_sliderchange',{slider:sliderOpts,step:sliderOpts.steps[sliderOpts.active],interaction:doCallback,previousActive:previousActive});if(step&&step.method&&doCallback){if(sliderGroup._nextMethod){// If we've already queued up an update, just overwrite it with the most recent:\nsliderGroup._nextMethod.step=step;sliderGroup._nextMethod.doCallback=doCallback;sliderGroup._nextMethod.doTransition=doTransition;}else{sliderGroup._nextMethod={step:step,doCallback:doCallback,doTransition:doTransition};sliderGroup._nextMethodRaf=window.requestAnimationFrame(function(){var _step=sliderGroup._nextMethod.step;if(!_step.method)return;if(_step.execute){Plots.executeAPICommand(gd,_step.method,_step.args);}sliderGroup._nextMethod=null;sliderGroup._nextMethodRaf=null;});}}}function attachGripEvents(item,gd,sliderGroup){var node=sliderGroup.node();var $gd=d3.select(gd);// NB: This is *not* the same as sliderOpts itself! These callbacks\n// are in a closure so this array won't actually be correct if the\n// steps have changed since this was initialized. The sliderGroup,\n// however, has not changed since that *is* the slider, so it must\n// be present to receive mouse events.\nfunction getSliderOpts(){return sliderGroup.data()[0];}item.on('mousedown',function(){var sliderOpts=getSliderOpts();gd.emit('plotly_sliderstart',{slider:sliderOpts});var grip=sliderGroup.select('.'+constants.gripRectClass);d3.event.stopPropagation();d3.event.preventDefault();grip.call(Color.fill,sliderOpts.activebgcolor);var normalizedPosition=positionToNormalizedValue(sliderOpts,d3.mouse(node)[0]);handleInput(gd,sliderGroup,sliderOpts,normalizedPosition,true);sliderOpts._dragging=true;$gd.on('mousemove',function(){var sliderOpts=getSliderOpts();var normalizedPosition=positionToNormalizedValue(sliderOpts,d3.mouse(node)[0]);handleInput(gd,sliderGroup,sliderOpts,normalizedPosition,false);});$gd.on('mouseup',function(){var sliderOpts=getSliderOpts();sliderOpts._dragging=false;grip.call(Color.fill,sliderOpts.bgcolor);$gd.on('mouseup',null);$gd.on('mousemove',null);gd.emit('plotly_sliderend',{slider:sliderOpts,step:sliderOpts.steps[sliderOpts.active]});});});}function drawTicks(sliderGroup,sliderOpts){var tick=sliderGroup.selectAll('rect.'+constants.tickRectClass).data(sliderOpts._visibleSteps);var dims=sliderOpts._dims;tick.enter().append('rect').classed(constants.tickRectClass,true);tick.exit().remove();tick.attr({width:sliderOpts.tickwidth+'px','shape-rendering':'crispEdges'});tick.each(function(d,i){var isMajor=i%dims.labelStride===0;var item=d3.select(this);item.attr({height:isMajor?sliderOpts.ticklen:sliderOpts.minorticklen}).call(Color.fill,isMajor?sliderOpts.tickcolor:sliderOpts.tickcolor);Drawing.setTranslate(item,normalizedValueToPosition(sliderOpts,i/(sliderOpts._stepCount-1))-0.5*sliderOpts.tickwidth,(isMajor?constants.tickOffset:constants.minorTickOffset)+dims.currentValueTotalHeight);});}function computeLabelSteps(sliderOpts){var dims=sliderOpts._dims;dims.labelSteps=[];var nsteps=sliderOpts._stepCount;for(var i=0;i<nsteps;i+=dims.labelStride){dims.labelSteps.push({fraction:i/(nsteps-1),step:sliderOpts._visibleSteps[i]});}}function setGripPosition(sliderGroup,sliderOpts,doTransition){var grip=sliderGroup.select('rect.'+constants.gripRectClass);var quantizedIndex=0;for(var i=0;i<sliderOpts._stepCount;i++){if(sliderOpts._visibleSteps[i]._index===sliderOpts.active){quantizedIndex=i;break;}}var x=normalizedValueToPosition(sliderOpts,quantizedIndex/(sliderOpts._stepCount-1));// If this is true, then *this component* is already invoking its own command\n// and has triggered its own animation.\nif(sliderOpts._invokingCommand)return;var el=grip;if(doTransition&&sliderOpts.transition.duration>0){el=el.transition().duration(sliderOpts.transition.duration).ease(sliderOpts.transition.easing);}// Drawing.setTranslate doesn't work here becasue of the transition duck-typing.\n// It's also not necessary because there are no other transitions to preserve.\nel.attr('transform','translate('+(x-constants.gripWidth*0.5)+','+sliderOpts._dims.currentValueTotalHeight+')');}// Convert a number from [0-1] to a pixel position relative to the slider group container:\nfunction normalizedValueToPosition(sliderOpts,normalizedPosition){var dims=sliderOpts._dims;return dims.inputAreaStart+constants.stepInset+(dims.inputAreaLength-2*constants.stepInset)*Math.min(1,Math.max(0,normalizedPosition));}// Convert a position relative to the slider group to a nubmer in [0, 1]\nfunction positionToNormalizedValue(sliderOpts,position){var dims=sliderOpts._dims;return Math.min(1,Math.max(0,(position-constants.stepInset-dims.inputAreaStart)/(dims.inputAreaLength-2*constants.stepInset-2*dims.inputAreaStart)));}function drawTouchRect(sliderGroup,gd,sliderOpts){var dims=sliderOpts._dims;var rect=Lib.ensureSingle(sliderGroup,'rect',constants.railTouchRectClass,function(s){s.call(attachGripEvents,gd,sliderGroup,sliderOpts).style('pointer-events','all');});rect.attr({width:dims.inputAreaLength,height:Math.max(dims.inputAreaWidth,constants.tickOffset+sliderOpts.ticklen+dims.labelHeight)}).call(Color.fill,sliderOpts.bgcolor).attr('opacity',0);Drawing.setTranslate(rect,0,dims.currentValueTotalHeight);}function drawRail(sliderGroup,sliderOpts){var dims=sliderOpts._dims;var computedLength=dims.inputAreaLength-constants.railInset*2;var rect=Lib.ensureSingle(sliderGroup,'rect',constants.railRectClass);rect.attr({width:computedLength,height:constants.railWidth,rx:constants.railRadius,ry:constants.railRadius,'shape-rendering':'crispEdges'}).call(Color.stroke,sliderOpts.bordercolor).call(Color.fill,sliderOpts.bgcolor).style('stroke-width',sliderOpts.borderwidth+'px');Drawing.setTranslate(rect,constants.railInset,(dims.inputAreaWidth-constants.railWidth)*0.5+dims.currentValueTotalHeight);}},{\"../../constants/alignment\":138,\"../../lib\":159,\"../../lib/svg_text_utils\":180,\"../../plot_api/plot_template\":193,\"../../plots/plots\":235,\"../color\":43,\"../drawing\":64,\"./constants\":127,\"d3\":8}],130:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var constants=_dereq_('./constants');module.exports={moduleType:'component',name:constants.name,layoutAttributes:_dereq_('./attributes'),supplyLayoutDefaults:_dereq_('./defaults'),draw:_dereq_('./draw')};},{\"./attributes\":126,\"./constants\":127,\"./defaults\":128,\"./draw\":129}],131:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var isNumeric=_dereq_('fast-isnumeric');var Plots=_dereq_('../../plots/plots');var Registry=_dereq_('../../registry');var Lib=_dereq_('../../lib');var Drawing=_dereq_('../drawing');var Color=_dereq_('../color');var svgTextUtils=_dereq_('../../lib/svg_text_utils');var interactConstants=_dereq_('../../constants/interactions');module.exports={draw:draw};var numStripRE=/ [XY][0-9]* /;/**\n * Titles - (re)draw titles on the axes and plot:\n * @param {DOM element} gd - the graphDiv\n * @param {string} titleClass - the css class of this title\n * @param {object} options - how and what to draw\n *      propContainer - the layout object containing `title` and `titlefont`\n *          attributes that apply to this title\n *      propName - the full name of the title property (for Plotly.relayout)\n *      [traceIndex] - include only if this property applies to one trace\n *          (such as a colorbar title) - then editing pipes to Plotly.restyle\n *          instead of Plotly.relayout\n *      placeholder - placeholder text for an empty editable title\n *      [avoid] {object} - include if this title should move to avoid other elements\n *          selection - d3 selection of elements to avoid\n *          side - which direction to move if there is a conflict\n *          [offsetLeft] - if these elements are subject to a translation\n *              wrt the title element\n *          [offsetTop]\n *      attributes {object} - position and alignment attributes\n *          x - pixels\n *          y - pixels\n *          text-anchor - start|middle|end\n *      transform {object} - how to transform the title after positioning\n *          rotate - degrees\n *          offset - shift up/down in the rotated frame (unused?)\n *      containerGroup - if an svg <g> element already exists to hold this\n *          title, include here. Otherwise it will go in fullLayout._infolayer\n *\n *  @return {selection} d3 selection of title container group\n */function draw(gd,titleClass,options){var cont=options.propContainer;var prop=options.propName;var placeholder=options.placeholder;var traceIndex=options.traceIndex;var avoid=options.avoid||{};var attributes=options.attributes;var transform=options.transform;var group=options.containerGroup;var fullLayout=gd._fullLayout;var opacity=1;var isplaceholder=false;var title=cont.title;var txt=(title&&title.text?title.text:'').trim();var font=title&&title.font?title.font:{};var fontFamily=font.family;var fontSize=font.size;var fontColor=font.color;// only make this title editable if we positively identify its property\n// as one that has editing enabled.\nvar editAttr;if(prop==='title.text')editAttr='titleText';else if(prop.indexOf('axis')!==-1)editAttr='axisTitleText';else if(prop.indexOf('colorbar'!==-1))editAttr='colorbarTitleText';var editable=gd._context.edits[editAttr];if(txt==='')opacity=0;// look for placeholder text while stripping out numbers from eg X2, Y3\n// this is just for backward compatibility with the old version that had\n// \"Click to enter X2 title\" and may have gotten saved in some old plots,\n// we don't want this to show up when these are displayed.\nelse if(txt.replace(numStripRE,' % ')===placeholder.replace(numStripRE,' % ')){opacity=0.2;isplaceholder=true;if(!editable)txt='';}if(fullLayout.meta){txt=Lib.templateString(txt,{meta:fullLayout.meta});}var elShouldExist=txt||editable;if(!group){group=Lib.ensureSingle(fullLayout._infolayer,'g','g-'+titleClass);}var el=group.selectAll('text').data(elShouldExist?[0]:[]);el.enter().append('text');el.text(txt)// this is hacky, but convertToTspans uses the class\n// to determine whether to rotate mathJax...\n// so we need to clear out any old class and put the\n// correct one (only relevant for colorbars, at least\n// for now) - ie don't use .classed\n.attr('class',titleClass);el.exit().remove();if(!elShouldExist)return group;function titleLayout(titleEl){Lib.syncOrAsync([drawTitle,scootTitle],titleEl);}function drawTitle(titleEl){var transformVal;if(transform){transformVal='';if(transform.rotate){transformVal+='rotate('+[transform.rotate,attributes.x,attributes.y]+')';}if(transform.offset){transformVal+='translate(0, '+transform.offset+')';}}else{transformVal=null;}titleEl.attr('transform',transformVal);titleEl.style({'font-family':fontFamily,'font-size':d3.round(fontSize,2)+'px',fill:Color.rgb(fontColor),opacity:opacity*Color.opacity(fontColor),'font-weight':Plots.fontWeight}).attr(attributes).call(svgTextUtils.convertToTspans,gd);return Plots.previousPromises(gd);}function scootTitle(titleElIn){var titleGroup=d3.select(titleElIn.node().parentNode);if(avoid&&avoid.selection&&avoid.side&&txt){titleGroup.attr('transform',null);// move toward avoid.side (= left, right, top, bottom) if needed\n// can include pad (pixels, default 2)\nvar shift=0;var backside={left:'right',right:'left',top:'bottom',bottom:'top'}[avoid.side];var shiftSign=['left','top'].indexOf(avoid.side)!==-1?-1:1;var pad=isNumeric(avoid.pad)?avoid.pad:2;var titlebb=Drawing.bBox(titleGroup.node());var paperbb={left:0,top:0,right:fullLayout.width,bottom:fullLayout.height};var maxshift=avoid.maxShift||(paperbb[avoid.side]-titlebb[avoid.side])*(avoid.side==='left'||avoid.side==='top'?-1:1);// Prevent the title going off the paper\nif(maxshift<0)shift=maxshift;else{// so we don't have to offset each avoided element,\n// give the title the opposite offset\nvar offsetLeft=avoid.offsetLeft||0;var offsetTop=avoid.offsetTop||0;titlebb.left-=offsetLeft;titlebb.right-=offsetLeft;titlebb.top-=offsetTop;titlebb.bottom-=offsetTop;// iterate over a set of elements (avoid.selection)\n// to avoid collisions with\navoid.selection.each(function(){var avoidbb=Drawing.bBox(this);if(Lib.bBoxIntersect(titlebb,avoidbb,pad)){shift=Math.max(shift,shiftSign*(avoidbb[avoid.side]-titlebb[backside])+pad);}});shift=Math.min(maxshift,shift);}if(shift>0||maxshift<0){var shiftTemplate={left:[-shift,0],right:[shift,0],top:[0,-shift],bottom:[0,shift]}[avoid.side];titleGroup.attr('transform','translate('+shiftTemplate+')');}}}el.call(titleLayout);function setPlaceholder(){opacity=0;isplaceholder=true;el.text(placeholder).on('mouseover.opacity',function(){d3.select(this).transition().duration(interactConstants.SHOW_PLACEHOLDER).style('opacity',1);}).on('mouseout.opacity',function(){d3.select(this).transition().duration(interactConstants.HIDE_PLACEHOLDER).style('opacity',0);});}if(editable){if(!txt)setPlaceholder();else el.on('.opacity',null);el.call(svgTextUtils.makeEditable,{gd:gd}).on('edit',function(text){if(traceIndex!==undefined){Registry.call('_guiRestyle',gd,prop,text,traceIndex);}else{Registry.call('_guiRelayout',gd,prop,text);}}).on('cancel',function(){this.text(this.attr('data-unformatted')).call(titleLayout);}).on('input',function(d){this.text(d||' ').call(svgTextUtils.positionText,attributes.x,attributes.y);});}el.classed('js-placeholder',isplaceholder);return group;}},{\"../../constants/interactions\":139,\"../../lib\":159,\"../../lib/svg_text_utils\":180,\"../../plots/plots\":235,\"../../registry\":242,\"../color\":43,\"../drawing\":64,\"d3\":8,\"fast-isnumeric\":10}],132:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var fontAttrs=_dereq_('../../plots/font_attributes');var colorAttrs=_dereq_('../color/attributes');var extendFlat=_dereq_('../../lib/extend').extendFlat;var overrideAll=_dereq_('../../plot_api/edit_types').overrideAll;var padAttrs=_dereq_('../../plots/pad_attributes');var templatedArray=_dereq_('../../plot_api/plot_template').templatedArray;var buttonsAttrs=templatedArray('button',{visible:{valType:'boolean'},method:{valType:'enumerated',values:['restyle','relayout','animate','update','skip'],dflt:'restyle'},args:{valType:'info_array',freeLength:true,items:[{valType:'any'},{valType:'any'},{valType:'any'}]},label:{valType:'string',dflt:''},execute:{valType:'boolean',dflt:true}});module.exports=overrideAll(templatedArray('updatemenu',{_arrayAttrRegexps:[/^updatemenus\\[(0|[1-9][0-9]+)\\]\\.buttons/],visible:{valType:'boolean'},type:{valType:'enumerated',values:['dropdown','buttons'],dflt:'dropdown'},direction:{valType:'enumerated',values:['left','right','up','down'],dflt:'down'},active:{valType:'integer',min:-1,dflt:0},showactive:{valType:'boolean',dflt:true},buttons:buttonsAttrs,x:{valType:'number',min:-2,max:3,dflt:-0.05},xanchor:{valType:'enumerated',values:['auto','left','center','right'],dflt:'right'},y:{valType:'number',min:-2,max:3,dflt:1},yanchor:{valType:'enumerated',values:['auto','top','middle','bottom'],dflt:'top'},pad:extendFlat(padAttrs({editType:'arraydraw'}),{}),font:fontAttrs({}),bgcolor:{valType:'color'},bordercolor:{valType:'color',dflt:colorAttrs.borderLine},borderwidth:{valType:'number',min:0,dflt:1,editType:'arraydraw'}}),'arraydraw','from-root');},{\"../../lib/extend\":153,\"../../plot_api/edit_types\":186,\"../../plot_api/plot_template\":193,\"../../plots/font_attributes\":229,\"../../plots/pad_attributes\":234,\"../color/attributes\":42}],133:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports={// layout attribute name\nname:'updatemenus',// class names\ncontainerClassName:'updatemenu-container',headerGroupClassName:'updatemenu-header-group',headerClassName:'updatemenu-header',headerArrowClassName:'updatemenu-header-arrow',dropdownButtonGroupClassName:'updatemenu-dropdown-button-group',dropdownButtonClassName:'updatemenu-dropdown-button',buttonClassName:'updatemenu-button',itemRectClassName:'updatemenu-item-rect',itemTextClassName:'updatemenu-item-text',// DOM attribute name in button group keeping track\n// of active update menu\nmenuIndexAttrName:'updatemenu-active-index',// id root pass to Plots.autoMargin\nautoMarginIdRoot:'updatemenu-',// options when 'active: -1'\nblankHeaderOpts:{label:'  '},// min item width / height\nminWidth:30,minHeight:30,// padding around item text\ntextPadX:24,arrowPadX:16,// item rect radii\nrx:2,ry:2,// item  text x offset off left edge\ntextOffsetX:12,// item  text y offset (w.r.t. middle)\ntextOffsetY:3,// arrow offset off right edge\narrowOffsetX:4,// gap between header and buttons\ngapButtonHeader:5,// gap between between buttons\ngapButton:2,// color given to active buttons\nactiveColor:'#F4FAFF',// color given to hovered buttons\nhoverColor:'#F4FAFF',// symbol for menu open arrow\narrowSymbol:{left:'',right:'',up:'',down:''}};},{}],134:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var handleArrayContainerDefaults=_dereq_('../../plots/array_container_defaults');var attributes=_dereq_('./attributes');var constants=_dereq_('./constants');var name=constants.name;var buttonAttrs=attributes.buttons;module.exports=function updateMenusDefaults(layoutIn,layoutOut){var opts={name:name,handleItemDefaults:menuDefaults};handleArrayContainerDefaults(layoutIn,layoutOut,opts);};function menuDefaults(menuIn,menuOut,layoutOut){function coerce(attr,dflt){return Lib.coerce(menuIn,menuOut,attributes,attr,dflt);}var buttons=handleArrayContainerDefaults(menuIn,menuOut,{name:'buttons',handleItemDefaults:buttonDefaults});var visible=coerce('visible',buttons.length>0);if(!visible)return;coerce('active');coerce('direction');coerce('type');coerce('showactive');coerce('x');coerce('y');Lib.noneOrAll(menuIn,menuOut,['x','y']);coerce('xanchor');coerce('yanchor');coerce('pad.t');coerce('pad.r');coerce('pad.b');coerce('pad.l');Lib.coerceFont(coerce,'font',layoutOut.font);coerce('bgcolor',layoutOut.paper_bgcolor);coerce('bordercolor');coerce('borderwidth');}function buttonDefaults(buttonIn,buttonOut){function coerce(attr,dflt){return Lib.coerce(buttonIn,buttonOut,buttonAttrs,attr,dflt);}var visible=coerce('visible',buttonIn.method==='skip'||Array.isArray(buttonIn.args));if(visible){coerce('method');coerce('args');coerce('label');coerce('execute');}}},{\"../../lib\":159,\"../../plots/array_container_defaults\":199,\"./attributes\":132,\"./constants\":133}],135:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var Plots=_dereq_('../../plots/plots');var Color=_dereq_('../color');var Drawing=_dereq_('../drawing');var Lib=_dereq_('../../lib');var svgTextUtils=_dereq_('../../lib/svg_text_utils');var arrayEditor=_dereq_('../../plot_api/plot_template').arrayEditor;var LINE_SPACING=_dereq_('../../constants/alignment').LINE_SPACING;var constants=_dereq_('./constants');var ScrollBox=_dereq_('./scrollbox');module.exports=function draw(gd){var fullLayout=gd._fullLayout;var menuData=Lib.filterVisible(fullLayout[constants.name]);/* Update menu data is bound to the header-group.\n     * The items in the header group are always present.\n     *\n     * Upon clicking on a header its corresponding button\n     * data is bound to the button-group.\n     *\n     * We draw all headers in one group before all buttons\n     * so that the buttons *always* appear above the headers.\n     *\n     * Note that only one set of buttons are visible at once.\n     *\n     * <g container />\n     *\n     *     <g header-group />\n     *         <g item header />\n     *         <text item header-arrow />\n     *     <g header-group />\n     *         <g item header />\n     *         <text item header-arrow />\n     *     ...\n     *\n     *     <g button-group />\n     *         <g item button />\n     *         <g item button />\n     *         ...\n     */function clearAutoMargin(menuOpts){Plots.autoMargin(gd,autoMarginId(menuOpts));}// draw update menu container\nvar menus=fullLayout._menulayer.selectAll('g.'+constants.containerClassName).data(menuData.length>0?[0]:[]);menus.enter().append('g').classed(constants.containerClassName,true).style('cursor','pointer');menus.exit().each(function(){// Most components don't need to explicitly remove autoMargin, because\n// marginPushers does this - but updatemenu updates don't go through\n// a full replot so we need to explicitly remove it.\n// This is for removing *all* updatemenus, removing individuals is\n// handled below, in headerGroups.exit\nd3.select(this).selectAll('g.'+constants.headerGroupClassName).each(clearAutoMargin);}).remove();// return early if no update menus are visible\nif(menuData.length===0)return;// join header group\nvar headerGroups=menus.selectAll('g.'+constants.headerGroupClassName).data(menuData,keyFunction);headerGroups.enter().append('g').classed(constants.headerGroupClassName,true);// draw dropdown button container\nvar gButton=Lib.ensureSingle(menus,'g',constants.dropdownButtonGroupClassName,function(s){s.style('pointer-events','all');});// find dimensions before plotting anything (this mutates menuOpts)\nfor(var i=0;i<menuData.length;i++){var menuOpts=menuData[i];findDimensions(gd,menuOpts);}// setup scrollbox\nvar scrollBoxId='updatemenus'+fullLayout._uid;var scrollBox=new ScrollBox(gd,gButton,scrollBoxId);// remove exiting header, remove dropped buttons and reset margins\nif(headerGroups.enter().size()){// make sure gButton is on top of all headers\ngButton.node().parentNode.appendChild(gButton.node());gButton.call(removeAllButtons);}headerGroups.exit().each(function(menuOpts){gButton.call(removeAllButtons);clearAutoMargin(menuOpts);}).remove();// draw headers!\nheaderGroups.each(function(menuOpts){var gHeader=d3.select(this);var _gButton=menuOpts.type==='dropdown'?gButton:null;Plots.manageCommandObserver(gd,menuOpts,menuOpts.buttons,function(data){setActive(gd,menuOpts,menuOpts.buttons[data.index],gHeader,_gButton,scrollBox,data.index,true);});if(menuOpts.type==='dropdown'){drawHeader(gd,gHeader,gButton,scrollBox,menuOpts);// if this menu is active, update the dropdown container\nif(isActive(gButton,menuOpts)){drawButtons(gd,gHeader,gButton,scrollBox,menuOpts);}}else{drawButtons(gd,gHeader,null,null,menuOpts);}});};// Note that '_index' is set at the default step,\n// it corresponds to the menu index in the user layout update menu container.\n// Because a menu can be set invisible,\n// this is a more 'consistent' field than the index in the menuData.\nfunction keyFunction(menuOpts){return menuOpts._index;}function isFolded(gButton){return+gButton.attr(constants.menuIndexAttrName)===-1;}function isActive(gButton,menuOpts){return+gButton.attr(constants.menuIndexAttrName)===menuOpts._index;}function setActive(gd,menuOpts,buttonOpts,gHeader,gButton,scrollBox,buttonIndex,isSilentUpdate){// update 'active' attribute in menuOpts\nmenuOpts.active=buttonIndex;// due to templating, it's possible this slider doesn't even exist yet\narrayEditor(gd.layout,constants.name,menuOpts).applyUpdate('active',buttonIndex);if(menuOpts.type==='buttons'){drawButtons(gd,gHeader,null,null,menuOpts);}else if(menuOpts.type==='dropdown'){// fold up buttons and redraw header\ngButton.attr(constants.menuIndexAttrName,'-1');drawHeader(gd,gHeader,gButton,scrollBox,menuOpts);if(!isSilentUpdate){drawButtons(gd,gHeader,gButton,scrollBox,menuOpts);}}}function drawHeader(gd,gHeader,gButton,scrollBox,menuOpts){var header=Lib.ensureSingle(gHeader,'g',constants.headerClassName,function(s){s.style('pointer-events','all');});var dims=menuOpts._dims;var active=menuOpts.active;var headerOpts=menuOpts.buttons[active]||constants.blankHeaderOpts;var posOpts={y:menuOpts.pad.t,yPad:0,x:menuOpts.pad.l,xPad:0,index:0};var positionOverrides={width:dims.headerWidth,height:dims.headerHeight};header.call(drawItem,menuOpts,headerOpts,gd).call(setItemPosition,menuOpts,posOpts,positionOverrides);// draw drop arrow at the right edge\nvar arrow=Lib.ensureSingle(gHeader,'text',constants.headerArrowClassName,function(s){s.classed('user-select-none',true).attr('text-anchor','end').call(Drawing.font,menuOpts.font).text(constants.arrowSymbol[menuOpts.direction]);});arrow.attr({x:dims.headerWidth-constants.arrowOffsetX+menuOpts.pad.l,y:dims.headerHeight/2+constants.textOffsetY+menuOpts.pad.t});header.on('click',function(){gButton.call(removeAllButtons,String(isActive(gButton,menuOpts)?-1:menuOpts._index));drawButtons(gd,gHeader,gButton,scrollBox,menuOpts);});header.on('mouseover',function(){header.call(styleOnMouseOver);});header.on('mouseout',function(){header.call(styleOnMouseOut,menuOpts);});// translate header group\nDrawing.setTranslate(gHeader,dims.lx,dims.ly);}function drawButtons(gd,gHeader,gButton,scrollBox,menuOpts){// If this is a set of buttons, set pointer events = all since we play\n// some minor games with which container is which in order to simplify\n// the drawing of *either* buttons or menus\nif(!gButton){gButton=gHeader;gButton.attr('pointer-events','all');}var buttonData=!isFolded(gButton)||menuOpts.type==='buttons'?menuOpts.buttons:[];var klass=menuOpts.type==='dropdown'?constants.dropdownButtonClassName:constants.buttonClassName;var buttons=gButton.selectAll('g.'+klass).data(Lib.filterVisible(buttonData));var enter=buttons.enter().append('g').classed(klass,true);var exit=buttons.exit();if(menuOpts.type==='dropdown'){enter.attr('opacity','0').transition().attr('opacity','1');exit.transition().attr('opacity','0').remove();}else{exit.remove();}var x0=0;var y0=0;var dims=menuOpts._dims;var isVertical=['up','down'].indexOf(menuOpts.direction)!==-1;if(menuOpts.type==='dropdown'){if(isVertical){y0=dims.headerHeight+constants.gapButtonHeader;}else{x0=dims.headerWidth+constants.gapButtonHeader;}}if(menuOpts.type==='dropdown'&&menuOpts.direction==='up'){y0=-constants.gapButtonHeader+constants.gapButton-dims.openHeight;}if(menuOpts.type==='dropdown'&&menuOpts.direction==='left'){x0=-constants.gapButtonHeader+constants.gapButton-dims.openWidth;}var posOpts={x:dims.lx+x0+menuOpts.pad.l,y:dims.ly+y0+menuOpts.pad.t,yPad:constants.gapButton,xPad:constants.gapButton,index:0};var scrollBoxPosition={l:posOpts.x+menuOpts.borderwidth,t:posOpts.y+menuOpts.borderwidth};buttons.each(function(buttonOpts,buttonIndex){var button=d3.select(this);button.call(drawItem,menuOpts,buttonOpts,gd).call(setItemPosition,menuOpts,posOpts);button.on('click',function(){// skip `dragend` events\nif(d3.event.defaultPrevented)return;setActive(gd,menuOpts,buttonOpts,gHeader,gButton,scrollBox,buttonIndex);if(buttonOpts.execute){Plots.executeAPICommand(gd,buttonOpts.method,buttonOpts.args);}gd.emit('plotly_buttonclicked',{menu:menuOpts,button:buttonOpts,active:menuOpts.active});});button.on('mouseover',function(){button.call(styleOnMouseOver);});button.on('mouseout',function(){button.call(styleOnMouseOut,menuOpts);buttons.call(styleButtons,menuOpts);});});buttons.call(styleButtons,menuOpts);if(isVertical){scrollBoxPosition.w=Math.max(dims.openWidth,dims.headerWidth);scrollBoxPosition.h=posOpts.y-scrollBoxPosition.t;}else{scrollBoxPosition.w=posOpts.x-scrollBoxPosition.l;scrollBoxPosition.h=Math.max(dims.openHeight,dims.headerHeight);}scrollBoxPosition.direction=menuOpts.direction;if(scrollBox){if(buttons.size()){drawScrollBox(gd,gHeader,gButton,scrollBox,menuOpts,scrollBoxPosition);}else{hideScrollBox(scrollBox);}}}function drawScrollBox(gd,gHeader,gButton,scrollBox,menuOpts,position){// enable the scrollbox\nvar direction=menuOpts.direction;var isVertical=direction==='up'||direction==='down';var dims=menuOpts._dims;var active=menuOpts.active;var translateX,translateY;var i;if(isVertical){translateY=0;for(i=0;i<active;i++){translateY+=dims.heights[i]+constants.gapButton;}}else{translateX=0;for(i=0;i<active;i++){translateX+=dims.widths[i]+constants.gapButton;}}scrollBox.enable(position,translateX,translateY);if(scrollBox.hbar){scrollBox.hbar.attr('opacity','0').transition().attr('opacity','1');}if(scrollBox.vbar){scrollBox.vbar.attr('opacity','0').transition().attr('opacity','1');}}function hideScrollBox(scrollBox){var hasHBar=!!scrollBox.hbar;var hasVBar=!!scrollBox.vbar;if(hasHBar){scrollBox.hbar.transition().attr('opacity','0').each('end',function(){hasHBar=false;if(!hasVBar)scrollBox.disable();});}if(hasVBar){scrollBox.vbar.transition().attr('opacity','0').each('end',function(){hasVBar=false;if(!hasHBar)scrollBox.disable();});}}function drawItem(item,menuOpts,itemOpts,gd){item.call(drawItemRect,menuOpts).call(drawItemText,menuOpts,itemOpts,gd);}function drawItemRect(item,menuOpts){var rect=Lib.ensureSingle(item,'rect',constants.itemRectClassName,function(s){s.attr({rx:constants.rx,ry:constants.ry,'shape-rendering':'crispEdges'});});rect.call(Color.stroke,menuOpts.bordercolor).call(Color.fill,menuOpts.bgcolor).style('stroke-width',menuOpts.borderwidth+'px');}function drawItemText(item,menuOpts,itemOpts,gd){var text=Lib.ensureSingle(item,'text',constants.itemTextClassName,function(s){s.classed('user-select-none',true).attr({'text-anchor':'start','data-notex':1});});var tx=itemOpts.label;var meta=gd._fullLayout.meta;if(meta){tx=Lib.templateString(tx,{meta:meta});}text.call(Drawing.font,menuOpts.font).text(tx).call(svgTextUtils.convertToTspans,gd);}function styleButtons(buttons,menuOpts){var active=menuOpts.active;buttons.each(function(buttonOpts,i){var button=d3.select(this);if(i===active&&menuOpts.showactive){button.select('rect.'+constants.itemRectClassName).call(Color.fill,constants.activeColor);}});}function styleOnMouseOver(item){item.select('rect.'+constants.itemRectClassName).call(Color.fill,constants.hoverColor);}function styleOnMouseOut(item,menuOpts){item.select('rect.'+constants.itemRectClassName).call(Color.fill,menuOpts.bgcolor);}// find item dimensions (this mutates menuOpts)\nfunction findDimensions(gd,menuOpts){var dims=menuOpts._dims={width1:0,height1:0,heights:[],widths:[],totalWidth:0,totalHeight:0,openWidth:0,openHeight:0,lx:0,ly:0};var fakeButtons=Drawing.tester.selectAll('g.'+constants.dropdownButtonClassName).data(Lib.filterVisible(menuOpts.buttons));fakeButtons.enter().append('g').classed(constants.dropdownButtonClassName,true);var isVertical=['up','down'].indexOf(menuOpts.direction)!==-1;// loop over fake buttons to find width / height\nfakeButtons.each(function(buttonOpts,i){var button=d3.select(this);button.call(drawItem,menuOpts,buttonOpts,gd);var text=button.select('.'+constants.itemTextClassName);// width is given by max width of all buttons\nvar tWidth=text.node()&&Drawing.bBox(text.node()).width;var wEff=Math.max(tWidth+constants.textPadX,constants.minWidth);// height is determined by item text\nvar tHeight=menuOpts.font.size*LINE_SPACING;var tLines=svgTextUtils.lineCount(text);var hEff=Math.max(tHeight*tLines,constants.minHeight)+constants.textOffsetY;hEff=Math.ceil(hEff);wEff=Math.ceil(wEff);// Store per-item sizes since a row of horizontal buttons, for example,\n// don't all need to be the same width:\ndims.widths[i]=wEff;dims.heights[i]=hEff;// Height and width of individual element:\ndims.height1=Math.max(dims.height1,hEff);dims.width1=Math.max(dims.width1,wEff);if(isVertical){dims.totalWidth=Math.max(dims.totalWidth,wEff);dims.openWidth=dims.totalWidth;dims.totalHeight+=hEff+constants.gapButton;dims.openHeight+=hEff+constants.gapButton;}else{dims.totalWidth+=wEff+constants.gapButton;dims.openWidth+=wEff+constants.gapButton;dims.totalHeight=Math.max(dims.totalHeight,hEff);dims.openHeight=dims.totalHeight;}});if(isVertical){dims.totalHeight-=constants.gapButton;}else{dims.totalWidth-=constants.gapButton;}dims.headerWidth=dims.width1+constants.arrowPadX;dims.headerHeight=dims.height1;if(menuOpts.type==='dropdown'){if(isVertical){dims.width1+=constants.arrowPadX;dims.totalHeight=dims.height1;}else{dims.totalWidth=dims.width1;}dims.totalWidth+=constants.arrowPadX;}fakeButtons.remove();var paddedWidth=dims.totalWidth+menuOpts.pad.l+menuOpts.pad.r;var paddedHeight=dims.totalHeight+menuOpts.pad.t+menuOpts.pad.b;var graphSize=gd._fullLayout._size;dims.lx=graphSize.l+graphSize.w*menuOpts.x;dims.ly=graphSize.t+graphSize.h*(1-menuOpts.y);var xanchor='left';if(Lib.isRightAnchor(menuOpts)){dims.lx-=paddedWidth;xanchor='right';}if(Lib.isCenterAnchor(menuOpts)){dims.lx-=paddedWidth/2;xanchor='center';}var yanchor='top';if(Lib.isBottomAnchor(menuOpts)){dims.ly-=paddedHeight;yanchor='bottom';}if(Lib.isMiddleAnchor(menuOpts)){dims.ly-=paddedHeight/2;yanchor='middle';}dims.totalWidth=Math.ceil(dims.totalWidth);dims.totalHeight=Math.ceil(dims.totalHeight);dims.lx=Math.round(dims.lx);dims.ly=Math.round(dims.ly);Plots.autoMargin(gd,autoMarginId(menuOpts),{x:menuOpts.x,y:menuOpts.y,l:paddedWidth*({right:1,center:0.5}[xanchor]||0),r:paddedWidth*({left:1,center:0.5}[xanchor]||0),b:paddedHeight*({top:1,middle:0.5}[yanchor]||0),t:paddedHeight*({bottom:1,middle:0.5}[yanchor]||0)});}function autoMarginId(menuOpts){return constants.autoMarginIdRoot+menuOpts._index;}// set item positions (mutates posOpts)\nfunction setItemPosition(item,menuOpts,posOpts,overrideOpts){overrideOpts=overrideOpts||{};var rect=item.select('.'+constants.itemRectClassName);var text=item.select('.'+constants.itemTextClassName);var borderWidth=menuOpts.borderwidth;var index=posOpts.index;var dims=menuOpts._dims;Drawing.setTranslate(item,borderWidth+posOpts.x,borderWidth+posOpts.y);var isVertical=['up','down'].indexOf(menuOpts.direction)!==-1;var finalHeight=overrideOpts.height||(isVertical?dims.heights[index]:dims.height1);rect.attr({x:0,y:0,width:overrideOpts.width||(isVertical?dims.width1:dims.widths[index]),height:finalHeight});var tHeight=menuOpts.font.size*LINE_SPACING;var tLines=svgTextUtils.lineCount(text);var spanOffset=(tLines-1)*tHeight/2;svgTextUtils.positionText(text,constants.textOffsetX,finalHeight/2-spanOffset+constants.textOffsetY);if(isVertical){posOpts.y+=dims.heights[index]+posOpts.yPad;}else{posOpts.x+=dims.widths[index]+posOpts.xPad;}posOpts.index++;}function removeAllButtons(gButton,newMenuIndexAttr){gButton.attr(constants.menuIndexAttrName,newMenuIndexAttr||'-1').selectAll('g.'+constants.dropdownButtonClassName).remove();}},{\"../../constants/alignment\":138,\"../../lib\":159,\"../../lib/svg_text_utils\":180,\"../../plot_api/plot_template\":193,\"../../plots/plots\":235,\"../color\":43,\"../drawing\":64,\"./constants\":133,\"./scrollbox\":137,\"d3\":8}],136:[function(_dereq_,module,exports){arguments[4][130][0].apply(exports,arguments);},{\"./attributes\":132,\"./constants\":133,\"./defaults\":134,\"./draw\":135,\"dup\":130}],137:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports=ScrollBox;var d3=_dereq_('d3');var Color=_dereq_('../color');var Drawing=_dereq_('../drawing');var Lib=_dereq_('../../lib');/**\n * Helper class to setup a scroll box\n *\n * @class\n * @param           gd          Plotly's graph div\n * @param           container   Container to be scroll-boxed (as a D3 selection)\n * @param {string}  id          Id for the clip path to implement the scroll box\n */function ScrollBox(gd,container,id){this.gd=gd;this.container=container;this.id=id;// See ScrollBox.prototype.enable for further definition\nthis.position=null;// scrollbox position\nthis.translateX=null;// scrollbox horizontal translation\nthis.translateY=null;// scrollbox vertical translation\nthis.hbar=null;// horizontal scrollbar D3 selection\nthis.vbar=null;// vertical scrollbar D3 selection\n// <rect> element to capture pointer events\nthis.bg=this.container.selectAll('rect.scrollbox-bg').data([0]);this.bg.exit().on('.drag',null).on('wheel',null).remove();this.bg.enter().append('rect').classed('scrollbox-bg',true).style('pointer-events','all').attr({opacity:0,x:0,y:0,width:0,height:0});}// scroll bar dimensions\nScrollBox.barWidth=2;ScrollBox.barLength=20;ScrollBox.barRadius=2;ScrollBox.barPad=1;ScrollBox.barColor='#808BA4';/**\n * If needed, setup a clip path and scrollbars\n *\n * @method\n * @param {Object}  position\n * @param {number}  position.l  Left side position (in pixels)\n * @param {number}  position.t  Top side (in pixels)\n * @param {number}  position.w  Width (in pixels)\n * @param {number}  position.h  Height (in pixels)\n * @param {string}  [position.direction='down']\n *                  Either 'down', 'left', 'right' or 'up'\n * @param {number}  [translateX=0]  Horizontal offset (in pixels)\n * @param {number}  [translateY=0]  Vertical offset (in pixels)\n */ScrollBox.prototype.enable=function enable(position,translateX,translateY){var fullLayout=this.gd._fullLayout;var fullWidth=fullLayout.width;var fullHeight=fullLayout.height;// compute position of scrollbox\nthis.position=position;var l=this.position.l;var w=this.position.w;var t=this.position.t;var h=this.position.h;var direction=this.position.direction;var isDown=direction==='down';var isLeft=direction==='left';var isRight=direction==='right';var isUp=direction==='up';var boxW=w;var boxH=h;var boxL,boxR;var boxT,boxB;if(!isDown&&!isLeft&&!isRight&&!isUp){this.position.direction='down';isDown=true;}var isVertical=isDown||isUp;if(isVertical){boxL=l;boxR=boxL+boxW;if(isDown){// anchor to top side\nboxT=t;boxB=Math.min(boxT+boxH,fullHeight);boxH=boxB-boxT;}else{// anchor to bottom side\nboxB=t+boxH;boxT=Math.max(boxB-boxH,0);boxH=boxB-boxT;}}else{boxT=t;boxB=boxT+boxH;if(isLeft){// anchor to right side\nboxR=l+boxW;boxL=Math.max(boxR-boxW,0);boxW=boxR-boxL;}else{// anchor to left side\nboxL=l;boxR=Math.min(boxL+boxW,fullWidth);boxW=boxR-boxL;}}this._box={l:boxL,t:boxT,w:boxW,h:boxH};// compute position of horizontal scroll bar\nvar needsHorizontalScrollBar=w>boxW;var hbarW=ScrollBox.barLength+2*ScrollBox.barPad;var hbarH=ScrollBox.barWidth+2*ScrollBox.barPad;// draw horizontal scrollbar on the bottom side\nvar hbarL=l;var hbarT=t+h;if(hbarT+hbarH>fullHeight)hbarT=fullHeight-hbarH;var hbar=this.container.selectAll('rect.scrollbar-horizontal').data(needsHorizontalScrollBar?[0]:[]);hbar.exit().on('.drag',null).remove();hbar.enter().append('rect').classed('scrollbar-horizontal',true).call(Color.fill,ScrollBox.barColor);if(needsHorizontalScrollBar){this.hbar=hbar.attr({'rx':ScrollBox.barRadius,'ry':ScrollBox.barRadius,'x':hbarL,'y':hbarT,'width':hbarW,'height':hbarH});// hbar center moves between hbarXMin and hbarXMin + hbarTranslateMax\nthis._hbarXMin=hbarL+hbarW/2;this._hbarTranslateMax=boxW-hbarW;}else{delete this.hbar;delete this._hbarXMin;delete this._hbarTranslateMax;}// compute position of vertical scroll bar\nvar needsVerticalScrollBar=h>boxH;var vbarW=ScrollBox.barWidth+2*ScrollBox.barPad;var vbarH=ScrollBox.barLength+2*ScrollBox.barPad;// draw vertical scrollbar on the right side\nvar vbarL=l+w;var vbarT=t;if(vbarL+vbarW>fullWidth)vbarL=fullWidth-vbarW;var vbar=this.container.selectAll('rect.scrollbar-vertical').data(needsVerticalScrollBar?[0]:[]);vbar.exit().on('.drag',null).remove();vbar.enter().append('rect').classed('scrollbar-vertical',true).call(Color.fill,ScrollBox.barColor);if(needsVerticalScrollBar){this.vbar=vbar.attr({'rx':ScrollBox.barRadius,'ry':ScrollBox.barRadius,'x':vbarL,'y':vbarT,'width':vbarW,'height':vbarH});// vbar center moves between vbarYMin and vbarYMin + vbarTranslateMax\nthis._vbarYMin=vbarT+vbarH/2;this._vbarTranslateMax=boxH-vbarH;}else{delete this.vbar;delete this._vbarYMin;delete this._vbarTranslateMax;}// setup a clip path (if scroll bars are needed)\nvar clipId=this.id;var clipL=boxL-0.5;var clipR=needsVerticalScrollBar?boxR+vbarW+0.5:boxR+0.5;var clipT=boxT-0.5;var clipB=needsHorizontalScrollBar?boxB+hbarH+0.5:boxB+0.5;var clipPath=fullLayout._topdefs.selectAll('#'+clipId).data(needsHorizontalScrollBar||needsVerticalScrollBar?[0]:[]);clipPath.exit().remove();clipPath.enter().append('clipPath').attr('id',clipId).append('rect');if(needsHorizontalScrollBar||needsVerticalScrollBar){this._clipRect=clipPath.select('rect').attr({x:Math.floor(clipL),y:Math.floor(clipT),width:Math.ceil(clipR)-Math.floor(clipL),height:Math.ceil(clipB)-Math.floor(clipT)});this.container.call(Drawing.setClipUrl,clipId,this.gd);this.bg.attr({x:l,y:t,width:w,height:h});}else{this.bg.attr({width:0,height:0});this.container.on('wheel',null).on('.drag',null).call(Drawing.setClipUrl,null);delete this._clipRect;}// set up drag listeners (if scroll bars are needed)\nif(needsHorizontalScrollBar||needsVerticalScrollBar){var onBoxDrag=d3.behavior.drag().on('dragstart',function(){d3.event.sourceEvent.preventDefault();}).on('drag',this._onBoxDrag.bind(this));this.container.on('wheel',null).on('wheel',this._onBoxWheel.bind(this)).on('.drag',null).call(onBoxDrag);var onBarDrag=d3.behavior.drag().on('dragstart',function(){d3.event.sourceEvent.preventDefault();d3.event.sourceEvent.stopPropagation();}).on('drag',this._onBarDrag.bind(this));if(needsHorizontalScrollBar){this.hbar.on('.drag',null).call(onBarDrag);}if(needsVerticalScrollBar){this.vbar.on('.drag',null).call(onBarDrag);}}// set scrollbox translation\nthis.setTranslate(translateX,translateY);};/**\n * If present, remove clip-path and scrollbars\n *\n * @method\n */ScrollBox.prototype.disable=function disable(){if(this.hbar||this.vbar){this.bg.attr({width:0,height:0});this.container.on('wheel',null).on('.drag',null).call(Drawing.setClipUrl,null);delete this._clipRect;}if(this.hbar){this.hbar.on('.drag',null);this.hbar.remove();delete this.hbar;delete this._hbarXMin;delete this._hbarTranslateMax;}if(this.vbar){this.vbar.on('.drag',null);this.vbar.remove();delete this.vbar;delete this._vbarYMin;delete this._vbarTranslateMax;}};/**\n * Handles scroll box drag events\n *\n * @method\n */ScrollBox.prototype._onBoxDrag=function _onBoxDrag(){var translateX=this.translateX;var translateY=this.translateY;if(this.hbar){translateX-=d3.event.dx;}if(this.vbar){translateY-=d3.event.dy;}this.setTranslate(translateX,translateY);};/**\n * Handles scroll box wheel events\n *\n * @method\n */ScrollBox.prototype._onBoxWheel=function _onBoxWheel(){var translateX=this.translateX;var translateY=this.translateY;if(this.hbar){translateX+=d3.event.deltaY;}if(this.vbar){translateY+=d3.event.deltaY;}this.setTranslate(translateX,translateY);};/**\n * Handles scroll bar drag events\n *\n * @method\n */ScrollBox.prototype._onBarDrag=function _onBarDrag(){var translateX=this.translateX;var translateY=this.translateY;if(this.hbar){var xMin=translateX+this._hbarXMin;var xMax=xMin+this._hbarTranslateMax;var x=Lib.constrain(d3.event.x,xMin,xMax);var xf=(x-xMin)/(xMax-xMin);var translateXMax=this.position.w-this._box.w;translateX=xf*translateXMax;}if(this.vbar){var yMin=translateY+this._vbarYMin;var yMax=yMin+this._vbarTranslateMax;var y=Lib.constrain(d3.event.y,yMin,yMax);var yf=(y-yMin)/(yMax-yMin);var translateYMax=this.position.h-this._box.h;translateY=yf*translateYMax;}this.setTranslate(translateX,translateY);};/**\n * Set clip path and scroll bar translate transform\n *\n * @method\n * @param {number}  [translateX=0]  Horizontal offset (in pixels)\n * @param {number}  [translateY=0]  Vertical offset (in pixels)\n */ScrollBox.prototype.setTranslate=function setTranslate(translateX,translateY){// store translateX and translateY (needed by mouse event handlers)\nvar translateXMax=this.position.w-this._box.w;var translateYMax=this.position.h-this._box.h;translateX=Lib.constrain(translateX||0,0,translateXMax);translateY=Lib.constrain(translateY||0,0,translateYMax);this.translateX=translateX;this.translateY=translateY;this.container.call(Drawing.setTranslate,this._box.l-this.position.l-translateX,this._box.t-this.position.t-translateY);if(this._clipRect){this._clipRect.attr({x:Math.floor(this.position.l+translateX-0.5),y:Math.floor(this.position.t+translateY-0.5)});}if(this.hbar){var xf=translateX/translateXMax;this.hbar.call(Drawing.setTranslate,translateX+xf*this._hbarTranslateMax,translateY);}if(this.vbar){var yf=translateY/translateYMax;this.vbar.call(Drawing.setTranslate,translateX,translateY+yf*this._vbarTranslateMax);}};},{\"../../lib\":159,\"../color\":43,\"../drawing\":64,\"d3\":8}],138:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';// fraction of some size to get to a named position\nmodule.exports={// from bottom left: this is the origin of our paper-reference\n// positioning system\nFROM_BL:{left:0,center:0.5,right:1,bottom:0,middle:0.5,top:1},// from top left: this is the screen pixel positioning origin\nFROM_TL:{left:0,center:0.5,right:1,bottom:1,middle:0.5,top:0},// from bottom right: sometimes you just need the opposite of ^^\nFROM_BR:{left:1,center:0.5,right:0,bottom:0,middle:0.5,top:1},// multiple of fontSize to get the vertical offset between lines\nLINE_SPACING:1.3,// multiple of fontSize to shift from the baseline\n// to the cap (captical letter) line\n// (to use when we don't calculate this shift from Drawing.bBox)\n// This is an approximation since in reality cap height can differ\n// from font to font. However, according to Wikipedia\n//   an \"average\" font might have a cap height of 70% of the em\n// https://en.wikipedia.org/wiki/Em_(typography)#History\nCAP_SHIFT:0.70,// half the cap height (distance between baseline and cap line)\n// of an \"average\" font (for more info see above).\nMID_SHIFT:0.35,OPPOSITE_SIDE:{left:'right',right:'left',top:'bottom',bottom:'top'}};},{}],139:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports={/**\n     * Timing information for interactive elements\n     */SHOW_PLACEHOLDER:100,HIDE_PLACEHOLDER:1000,// ms between first mousedown and 2nd mouseup to constitute dblclick...\n// we don't seem to have access to the system setting\nDBLCLICKDELAY:300,// opacity dimming fraction for points that are not in selection\nDESELECTDIM:0.2};},{}],140:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports={/**\n     * Standardize all missing data in calcdata to use undefined\n     * never null or NaN.\n     * That way we can use !==undefined, or !== BADNUM,\n     * to test for real data\n     */BADNUM:undefined,/*\n     * Limit certain operations to well below floating point max value\n     * to avoid glitches: Make sure that even when you multiply it by the\n     * number of pixels on a giant screen it still works\n     */FP_SAFE:Number.MAX_VALUE/10000,/*\n     * conversion of date units to milliseconds\n     * year and month constants are marked \"AVG\"\n     * to remind us that not all years and months\n     * have the same length\n     */ONEAVGYEAR:31557600000,// 365.25 days\nONEAVGMONTH:2629800000,// 1/12 of ONEAVGYEAR\nONEDAY:86400000,ONEHOUR:3600000,ONEMIN:60000,ONESEC:1000,/*\n     * For fast conversion btwn world calendars and epoch ms, the Julian Day Number\n     * of the unix epoch. From calendars.instance().newDate(1970, 1, 1).toJD()\n     */EPOCHJD:2440587.5,/*\n     * Are two values nearly equal? Compare to 1PPM\n     */ALMOST_EQUAL:1-1e-6,/*\n     * If we're asked to clip a non-positive log value, how far off-screen\n     * do we put it?\n     */LOG_CLIP:10,/*\n     * not a number, but for displaying numbers: the \"minus sign\" symbol is\n     * wider than the regular ascii dash \"-\"\n     */MINUS_SIGN:\"\\u2212\"};},{}],141:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';exports.xmlns='http://www.w3.org/2000/xmlns/';exports.svg='http://www.w3.org/2000/svg';exports.xlink='http://www.w3.org/1999/xlink';// the 'old' d3 quirk got fix in v3.5.7\n// https://github.com/mbostock/d3/commit/a6f66e9dd37f764403fc7c1f26be09ab4af24fed\nexports.svgAttrs={xmlns:exports.svg,'xmlns:xlink':exports.xlink};},{}],142:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';// package version injected by `npm run preprocess`\nexports.version='1.47.4';// inject promise polyfill\n_dereq_('es6-promise').polyfill();// inject plot css\n_dereq_('../build/plotcss');// inject default MathJax config\n_dereq_('./fonts/mathjax_config')();// include registry module and expose register method\nvar Registry=_dereq_('./registry');var register=exports.register=Registry.register;// expose plot api methods\nvar plotApi=_dereq_('./plot_api');var methodNames=Object.keys(plotApi);for(var i=0;i<methodNames.length;i++){var name=methodNames[i];// _ -> private API methods, but still registered for internal use\nif(name.charAt(0)!=='_')exports[name]=plotApi[name];register({moduleType:'apiMethod',name:name,fn:plotApi[name]});}// scatter is the only trace included by default\nregister(_dereq_('./traces/scatter'));// register all registrable components modules\nregister([_dereq_('./components/fx'),_dereq_('./components/legend'),_dereq_('./components/annotations'),_dereq_('./components/annotations3d'),_dereq_('./components/shapes'),_dereq_('./components/images'),_dereq_('./components/updatemenus'),_dereq_('./components/sliders'),_dereq_('./components/rangeslider'),_dereq_('./components/rangeselector'),_dereq_('./components/grid'),_dereq_('./components/errorbars'),_dereq_('./components/colorscale')]);// locales en and en-US are required for default behavior\nregister([_dereq_('./locale-en'),_dereq_('./locale-en-us')]);// plot icons\nexports.Icons=_dereq_('../build/ploticon');// unofficial 'beta' plot methods, use at your own risk\nexports.Plots=_dereq_('./plots/plots');exports.Fx=_dereq_('./components/fx');exports.Snapshot=_dereq_('./snapshot');exports.PlotSchema=_dereq_('./plot_api/plot_schema');exports.Queue=_dereq_('./lib/queue');// export d3 used in the bundle\nexports.d3=_dereq_('d3');},{\"../build/plotcss\":1,\"../build/ploticon\":2,\"./components/annotations\":36,\"./components/annotations3d\":41,\"./components/colorscale\":55,\"./components/errorbars\":70,\"./components/fx\":82,\"./components/grid\":86,\"./components/images\":91,\"./components/legend\":99,\"./components/rangeselector\":110,\"./components/rangeslider\":117,\"./components/shapes\":125,\"./components/sliders\":130,\"./components/updatemenus\":136,\"./fonts/mathjax_config\":143,\"./lib/queue\":173,\"./locale-en\":184,\"./locale-en-us\":183,\"./plot_api\":188,\"./plot_api/plot_schema\":192,\"./plots/plots\":235,\"./registry\":242,\"./snapshot\":247,\"./traces/scatter\":292,\"d3\":8,\"es6-promise\":9}],143:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';/* global MathJax:false */module.exports=function(){if(typeof MathJax!=='undefined'){var globalConfig=(window.PlotlyConfig||{}).MathJaxConfig!=='local';if(globalConfig){MathJax.Hub.Config({messageStyle:'none',skipStartupTypeset:true,displayAlign:'left',tex2jax:{inlineMath:[['$','$'],['\\\\(','\\\\)']]}});MathJax.Hub.Configured();}}};},{}],144:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';/**\n * Determine the position anchor property of x/y xanchor/yanchor components.\n *\n * - values < 1/3 align the low side at that fraction,\n * - values [1/3, 2/3] align the center at that fraction,\n * - values > 2/3 align the right at that fraction.\n */exports.isLeftAnchor=function isLeftAnchor(opts){return opts.xanchor==='left'||opts.xanchor==='auto'&&opts.x<=1/3;};exports.isCenterAnchor=function isCenterAnchor(opts){return opts.xanchor==='center'||opts.xanchor==='auto'&&opts.x>1/3&&opts.x<2/3;};exports.isRightAnchor=function isRightAnchor(opts){return opts.xanchor==='right'||opts.xanchor==='auto'&&opts.x>=2/3;};exports.isTopAnchor=function isTopAnchor(opts){return opts.yanchor==='top'||opts.yanchor==='auto'&&opts.y>=2/3;};exports.isMiddleAnchor=function isMiddleAnchor(opts){return opts.yanchor==='middle'||opts.yanchor==='auto'&&opts.y>1/3&&opts.y<2/3;};exports.isBottomAnchor=function isBottomAnchor(opts){return opts.yanchor==='bottom'||opts.yanchor==='auto'&&opts.y<=1/3;};},{}],145:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var modModule=_dereq_('./mod');var mod=modModule.mod;var modHalf=modModule.modHalf;var PI=Math.PI;var twoPI=2*PI;function deg2rad(deg){return deg/180*PI;}function rad2deg(rad){return rad/PI*180;}/**\n * is sector a full circle?\n * ... this comes up a lot in SVG path-drawing routines\n *\n * N.B. we consider all sectors that span more that 2pi 'full' circles\n *\n * @param {2-item array} aBnds : angular bounds in *radians*\n * @return {boolean}\n */function isFullCircle(aBnds){return Math.abs(aBnds[1]-aBnds[0])>twoPI-1e-14;}/**\n * angular delta between angle 'a' and 'b'\n * solution taken from: https://stackoverflow.com/a/2007279\n *\n * @param {number} a : first angle in *radians*\n * @param {number} b : second angle in *radians*\n * @return {number} angular delta in *radians*\n */function angleDelta(a,b){return modHalf(b-a,twoPI);}/**\n * angular distance between angle 'a' and 'b'\n *\n * @param {number} a : first angle in *radians*\n * @param {number} b : second angle in *radians*\n * @return {number} angular distance in *radians*\n */function angleDist(a,b){return Math.abs(angleDelta(a,b));}/**\n * is angle inside sector?\n *\n * @param {number} a : angle to test in *radians*\n * @param {2-item array} aBnds : sector's angular bounds in *radians*\n * @param {boolean}\n */function isAngleInsideSector(a,aBnds){if(isFullCircle(aBnds))return true;var s0,s1;if(aBnds[0]<aBnds[1]){s0=aBnds[0];s1=aBnds[1];}else{s0=aBnds[1];s1=aBnds[0];}s0=mod(s0,twoPI);s1=mod(s1,twoPI);if(s0>s1)s1+=twoPI;var a0=mod(a,twoPI);var a1=a0+twoPI;return a0>=s0&&a0<=s1||a1>=s0&&a1<=s1;}/**\n * is pt (r,a) inside sector?\n *\n * @param {number} r : pt's radial coordinate\n * @param {number} a : pt's angular coordinate in *radians*\n * @param {2-item array} rBnds : sector's radial bounds\n * @param {2-item array} aBnds : sector's angular bounds in *radians*\n * @return {boolean}\n */function isPtInsideSector(r,a,rBnds,aBnds){if(!isAngleInsideSector(a,aBnds))return false;var r0,r1;if(rBnds[0]<rBnds[1]){r0=rBnds[0];r1=rBnds[1];}else{r0=rBnds[1];r1=rBnds[0];}return r>=r0&&r<=r1;}// common to pathArc, pathSector and pathAnnulus\nfunction _path(r0,r1,a0,a1,cx,cy,isClosed){cx=cx||0;cy=cy||0;var isCircle=isFullCircle([a0,a1]);var aStart,aMid,aEnd;var rStart,rEnd;if(isCircle){aStart=0;aMid=PI;aEnd=twoPI;}else{if(a0<a1){aStart=a0;aEnd=a1;}else{aStart=a1;aEnd=a0;}}if(r0<r1){rStart=r0;rEnd=r1;}else{rStart=r1;rEnd=r0;}// N.B. svg coordinates here, where y increases downward\nfunction pt(r,a){return[r*Math.cos(a)+cx,cy-r*Math.sin(a)];}var largeArc=Math.abs(aEnd-aStart)<=PI?0:1;function arc(r,a,cw){return'A'+[r,r]+' '+[0,largeArc,cw]+' '+pt(r,a);}var p;if(isCircle){if(rStart===null){p='M'+pt(rEnd,aStart)+arc(rEnd,aMid,0)+arc(rEnd,aEnd,0)+'Z';}else{p='M'+pt(rStart,aStart)+arc(rStart,aMid,0)+arc(rStart,aEnd,0)+'Z'+'M'+pt(rEnd,aStart)+arc(rEnd,aMid,1)+arc(rEnd,aEnd,1)+'Z';}}else{if(rStart===null){p='M'+pt(rEnd,aStart)+arc(rEnd,aEnd,0);if(isClosed)p+='L0,0Z';}else{p='M'+pt(rStart,aStart)+'L'+pt(rEnd,aStart)+arc(rEnd,aEnd,0)+'L'+pt(rStart,aEnd)+arc(rStart,aStart,1)+'Z';}}return p;}/**\n * path an arc\n *\n * @param {number} r : radius\n * @param {number} a0 : first angular coordinate in *radians*\n * @param {number} a1 : second angular coordinate in *radians*\n * @param {number (optional)} cx : x coordinate of center\n * @param {number (optional)} cy : y coordinate of center\n * @return {string} svg path\n */function pathArc(r,a0,a1,cx,cy){return _path(null,r,a0,a1,cx,cy,0);}/**\n * path a sector\n *\n * @param {number} r : radius\n * @param {number} a0 : first angular coordinate in *radians*\n * @param {number} a1 : second angular coordinate in *radians*\n * @param {number (optional)} cx : x coordinate of center\n * @param {number (optional)} cy : y coordinate of center\n * @return {string} svg path\n */function pathSector(r,a0,a1,cx,cy){return _path(null,r,a0,a1,cx,cy,1);}/**\n * path an annulus\n *\n * @param {number} r0 : first radial coordinate\n * @param {number} r1 : second radial coordinate\n * @param {number} a0 : first angular coordinate in *radians*\n * @param {number} a1 : second angular coordinate in *radians*\n * @param {number (optional)} cx : x coordinate of center\n * @param {number (optional)} cy : y coordinate of center\n * @return {string} svg path\n */function pathAnnulus(r0,r1,a0,a1,cx,cy){return _path(r0,r1,a0,a1,cx,cy,1);}module.exports={deg2rad:deg2rad,rad2deg:rad2deg,angleDelta:angleDelta,angleDist:angleDist,isFullCircle:isFullCircle,isAngleInsideSector:isAngleInsideSector,isPtInsideSector:isPtInsideSector,pathArc:pathArc,pathSector:pathSector,pathAnnulus:pathAnnulus};},{\"./mod\":166}],146:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var isArray=Array.isArray;// IE9 fallbacks\nvar ab=typeof ArrayBuffer==='undefined'||!ArrayBuffer.isView?{isView:function isView(){return false;}}:ArrayBuffer;var dv=typeof DataView==='undefined'?function(){}:DataView;function isTypedArray(a){return ab.isView(a)&&!(a instanceof dv);}exports.isTypedArray=isTypedArray;function isArrayOrTypedArray(a){return isArray(a)||isTypedArray(a);}exports.isArrayOrTypedArray=isArrayOrTypedArray;/*\n * Test whether an input object is 1D.\n *\n * Assumes we already know the object is an array.\n *\n * Looks only at the first element, if the dimensionality is\n * not consistent we won't figure that out here.\n */function isArray1D(a){return!isArrayOrTypedArray(a[0]);}exports.isArray1D=isArray1D;/*\n * Ensures an array has the right amount of storage space. If it doesn't\n * exist, it creates an array. If it does exist, it returns it if too\n * short or truncates it in-place.\n *\n * The goal is to just reuse memory to avoid a bit of excessive garbage\n * collection.\n */exports.ensureArray=function(out,n){// TODO: typed array support here? This is only used in\n// traces/carpet/compute_control_points\nif(!isArray(out))out=[];// If too long, truncate. (If too short, it will grow\n// automatically so we don't care about that case)\nout.length=n;return out;};/*\n * TypedArray-compatible concatenation of n arrays\n * if all arrays are the same type it will preserve that type,\n * otherwise it falls back on Array.\n * Also tries to avoid copying, in case one array has zero length\n * But never mutates an existing array\n */exports.concat=function(){var args=[];var allArray=true;var totalLen=0;var _constructor,arg0,i,argi,posi,leni,out,j;for(i=0;i<arguments.length;i++){argi=arguments[i];leni=argi.length;if(leni){if(arg0)args.push(argi);else{arg0=argi;posi=leni;}if(isArray(argi)){_constructor=false;}else{allArray=false;if(!totalLen){_constructor=argi.constructor;}else if(_constructor!==argi.constructor){// TODO: in principle we could upgrade here,\n// ie keep typed array but convert all to Float64Array?\n_constructor=false;}}totalLen+=leni;}}if(!totalLen)return[];if(!args.length)return arg0;if(allArray)return arg0.concat.apply(arg0,args);if(_constructor){// matching typed arrays\nout=new _constructor(totalLen);out.set(arg0);for(i=0;i<args.length;i++){argi=args[i];out.set(argi,posi);posi+=argi.length;}return out;}// mismatched types or Array + typed\nout=new Array(totalLen);for(j=0;j<arg0.length;j++){out[j]=arg0[j];}for(i=0;i<args.length;i++){argi=args[i];for(j=0;j<argi.length;j++){out[posi+j]=argi[j];}posi+=j;}return out;};exports.maxRowLength=function(z){return _rowLength(z,Math.max,0);};exports.minRowLength=function(z){return _rowLength(z,Math.min,Infinity);};function _rowLength(z,fn,len0){if(isArrayOrTypedArray(z)){if(isArrayOrTypedArray(z[0])){var len=len0;for(var i=0;i<z.length;i++){len=fn(len,z[i].length);}return len;}else{return z.length;}}return 0;}},{}],147:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var isNumeric=_dereq_('fast-isnumeric');var BADNUM=_dereq_('../constants/numerical').BADNUM;// precompile for speed\nvar JUNK=/^['\"%,$#\\s']+|[, ]|['\"%,$#\\s']+$/g;/**\n * cleanNumber: remove common leading and trailing cruft\n * Always returns either a number or BADNUM.\n */module.exports=function cleanNumber(v){if(typeof v==='string'){v=v.replace(JUNK,'');}if(isNumeric(v))return Number(v);return BADNUM;};},{\"../constants/numerical\":140,\"fast-isnumeric\":10}],148:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';/**\n * Clear gl frame (if any). This is a common pattern as\n * we usually set `preserveDrawingBuffer: true` during\n * gl context creation (e.g. via `reglUtils.prepare`).\n *\n * @param {DOM node or object} gd : graph div object\n */module.exports=function clearGlCanvases(gd){var fullLayout=gd._fullLayout;if(fullLayout._glcanvas&&fullLayout._glcanvas.size()){fullLayout._glcanvas.each(function(d){if(d.regl)d.regl.clear({color:true,depth:true});});}};},{}],149:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';/**\n * Clear responsive handlers (if any).\n *\n * @param {DOM node or object} gd : graph div object\n */module.exports=function clearResponsive(gd){if(gd._responsiveChartHandler){window.removeEventListener('resize',gd._responsiveChartHandler);delete gd._responsiveChartHandler;}};},{}],150:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var isNumeric=_dereq_('fast-isnumeric');var tinycolor=_dereq_('tinycolor2');var baseTraceAttrs=_dereq_('../plots/attributes');var colorscales=_dereq_('../components/colorscale/scales');var DESELECTDIM=_dereq_('../constants/interactions').DESELECTDIM;var nestedProperty=_dereq_('./nested_property');var counterRegex=_dereq_('./regex').counter;var modHalf=_dereq_('./mod').modHalf;var isArrayOrTypedArray=_dereq_('./array').isArrayOrTypedArray;exports.valObjectMeta={data_array:{// You can use *dflt=[] to force said array to exist though.\ncoerceFunction:function coerceFunction(v,propOut,dflt){// TODO maybe `v: {type: 'float32', vals: [/* ... */]}` also\nif(isArrayOrTypedArray(v))propOut.set(v);else if(dflt!==undefined)propOut.set(dflt);}},enumerated:{coerceFunction:function coerceFunction(v,propOut,dflt,opts){if(opts.coerceNumber)v=+v;if(opts.values.indexOf(v)===-1)propOut.set(dflt);else propOut.set(v);},validateFunction:function validateFunction(v,opts){if(opts.coerceNumber)v=+v;var values=opts.values;for(var i=0;i<values.length;i++){var k=String(values[i]);if(k.charAt(0)==='/'&&k.charAt(k.length-1)==='/'){var regex=new RegExp(k.substr(1,k.length-2));if(regex.test(v))return true;}else if(v===values[i])return true;}return false;}},'boolean':{coerceFunction:function coerceFunction(v,propOut,dflt){if(v===true||v===false)propOut.set(v);else propOut.set(dflt);}},number:{coerceFunction:function coerceFunction(v,propOut,dflt,opts){if(!isNumeric(v)||opts.min!==undefined&&v<opts.min||opts.max!==undefined&&v>opts.max){propOut.set(dflt);}else propOut.set(+v);}},integer:{coerceFunction:function coerceFunction(v,propOut,dflt,opts){if(v%1||!isNumeric(v)||opts.min!==undefined&&v<opts.min||opts.max!==undefined&&v>opts.max){propOut.set(dflt);}else propOut.set(+v);}},string:{// TODO 'values shouldn't be in there (edge case: 'dash' in Scatter)\ncoerceFunction:function coerceFunction(v,propOut,dflt,opts){if(typeof v!=='string'){var okToCoerce=typeof v==='number';if(opts.strict===true||!okToCoerce)propOut.set(dflt);else propOut.set(String(v));}else if(opts.noBlank&&!v)propOut.set(dflt);else propOut.set(v);}},color:{coerceFunction:function coerceFunction(v,propOut,dflt){if(tinycolor(v).isValid())propOut.set(v);else propOut.set(dflt);}},colorlist:{coerceFunction:function coerceFunction(v,propOut,dflt){function isColor(color){return tinycolor(color).isValid();}if(!Array.isArray(v)||!v.length)propOut.set(dflt);else if(v.every(isColor))propOut.set(v);else propOut.set(dflt);}},colorscale:{coerceFunction:function coerceFunction(v,propOut,dflt){propOut.set(colorscales.get(v,dflt));}},angle:{coerceFunction:function coerceFunction(v,propOut,dflt){if(v==='auto')propOut.set('auto');else if(!isNumeric(v))propOut.set(dflt);else propOut.set(modHalf(+v,360));}},subplotid:{coerceFunction:function coerceFunction(v,propOut,dflt,opts){var regex=opts.regex||counterRegex(dflt);if(typeof v==='string'&&regex.test(v)){propOut.set(v);return;}propOut.set(dflt);},validateFunction:function validateFunction(v,opts){var dflt=opts.dflt;if(v===dflt)return true;if(typeof v!=='string')return false;if(counterRegex(dflt).test(v))return true;return false;}},flaglist:{coerceFunction:function coerceFunction(v,propOut,dflt,opts){if(typeof v!=='string'){propOut.set(dflt);return;}if((opts.extras||[]).indexOf(v)!==-1){propOut.set(v);return;}var vParts=v.split('+');var i=0;while(i<vParts.length){var vi=vParts[i];if(opts.flags.indexOf(vi)===-1||vParts.indexOf(vi)<i){vParts.splice(i,1);}else i++;}if(!vParts.length)propOut.set(dflt);else propOut.set(vParts.join('+'));}},any:{coerceFunction:function coerceFunction(v,propOut,dflt){if(v===undefined)propOut.set(dflt);else propOut.set(v);}},info_array:{// set `dimensions=2` for a 2D array or '1-2' for either\n// `items` may be a single object instead of an array, in which case\n// `freeLength` must be true.\n// if `dimensions='1-2'` and items is a 1D array, then the value can\n// either be a matching 1D array or an array of such matching 1D arrays\ncoerceFunction:function coerceFunction(v,propOut,dflt,opts){// simplified coerce function just for array items\nfunction coercePart(v,opts,dflt){var out;var propPart={set:function set(v){out=v;}};if(dflt===undefined)dflt=opts.dflt;exports.valObjectMeta[opts.valType].coerceFunction(v,propPart,dflt,opts);return out;}var twoD=opts.dimensions===2||opts.dimensions==='1-2'&&Array.isArray(v)&&Array.isArray(v[0]);if(!Array.isArray(v)){propOut.set(dflt);return;}var items=opts.items;var vOut=[];var arrayItems=Array.isArray(items);var arrayItems2D=arrayItems&&twoD&&Array.isArray(items[0]);var innerItemsOnly=twoD&&arrayItems&&!arrayItems2D;var len=arrayItems&&!innerItemsOnly?items.length:v.length;var i,j,row,item,len2,vNew;dflt=Array.isArray(dflt)?dflt:[];if(twoD){for(i=0;i<len;i++){vOut[i]=[];row=Array.isArray(v[i])?v[i]:[];if(innerItemsOnly)len2=items.length;else if(arrayItems)len2=items[i].length;else len2=row.length;for(j=0;j<len2;j++){if(innerItemsOnly)item=items[j];else if(arrayItems)item=items[i][j];else item=items;vNew=coercePart(row[j],item,(dflt[i]||[])[j]);if(vNew!==undefined)vOut[i][j]=vNew;}}}else{for(i=0;i<len;i++){vNew=coercePart(v[i],arrayItems?items[i]:items,dflt[i]);if(vNew!==undefined)vOut[i]=vNew;}}propOut.set(vOut);},validateFunction:function validateFunction(v,opts){if(!Array.isArray(v))return false;var items=opts.items;var arrayItems=Array.isArray(items);var twoD=opts.dimensions===2;// when free length is off, input and declared lengths must match\nif(!opts.freeLength&&v.length!==items.length)return false;// valid when all input items are valid\nfor(var i=0;i<v.length;i++){if(twoD){if(!Array.isArray(v[i])||!opts.freeLength&&v[i].length!==items[i].length){return false;}for(var j=0;j<v[i].length;j++){if(!validate(v[i][j],arrayItems?items[i][j]:items)){return false;}}}else if(!validate(v[i],arrayItems?items[i]:items))return false;}return true;}}};/**\n * Ensures that container[attribute] has a valid value.\n *\n * attributes[attribute] is an object with possible keys:\n * - valType: data_array, enumerated, boolean, ... as in valObjectMeta\n * - values: (enumerated only) array of allowed vals\n * - min, max: (number, integer only) inclusive bounds on allowed vals\n *      either or both may be omitted\n * - dflt: if attribute is invalid or missing, use this default\n *      if dflt is provided as an argument to lib.coerce it takes precedence\n *      as a convenience, returns the value it finally set\n */exports.coerce=function(containerIn,containerOut,attributes,attribute,dflt){var opts=nestedProperty(attributes,attribute).get();var propIn=nestedProperty(containerIn,attribute);var propOut=nestedProperty(containerOut,attribute);var v=propIn.get();var template=containerOut._template;if(v===undefined&&template){v=nestedProperty(template,attribute).get();// already used the template value, so short-circuit the second check\ntemplate=0;}if(dflt===undefined)dflt=opts.dflt;/**\n     * arrayOk: value MAY be an array, then we do no value checking\n     * at this point, because it can be more complicated than the\n     * individual form (eg. some array vals can be numbers, even if the\n     * single values must be color strings)\n     */if(opts.arrayOk&&isArrayOrTypedArray(v)){propOut.set(v);return v;}var coerceFunction=exports.valObjectMeta[opts.valType].coerceFunction;coerceFunction(v,propOut,dflt,opts);var out=propOut.get();// in case v was provided but invalid, try the template again so it still\n// overrides the regular default\nif(template&&out===dflt&&!validate(v,opts)){v=nestedProperty(template,attribute).get();coerceFunction(v,propOut,dflt,opts);out=propOut.get();}return out;};/**\n * Variation on coerce\n *\n * Uses coerce to get attribute value if user input is valid,\n * returns attribute default if user input it not valid or\n * returns false if there is no user input.\n */exports.coerce2=function(containerIn,containerOut,attributes,attribute,dflt){var propIn=nestedProperty(containerIn,attribute);var propOut=exports.coerce(containerIn,containerOut,attributes,attribute,dflt);var valIn=propIn.get();return valIn!==undefined&&valIn!==null?propOut:false;};/*\n * Shortcut to coerce the three font attributes\n *\n * 'coerce' is a lib.coerce wrapper with implied first three arguments\n */exports.coerceFont=function(coerce,attr,dfltObj){var out={};dfltObj=dfltObj||{};out.family=coerce(attr+'.family',dfltObj.family);out.size=coerce(attr+'.size',dfltObj.size);out.color=coerce(attr+'.color',dfltObj.color);return out;};/** Coerce shortcut for 'hoverinfo'\n * handling 1-vs-multi-trace dflt logic\n *\n * @param {object} traceIn : user trace object\n * @param {object} traceOut : full trace object (requires _module ref)\n * @param {object} layoutOut : full layout object (require _dataLength ref)\n * @return {any} : the coerced value\n */exports.coerceHoverinfo=function(traceIn,traceOut,layoutOut){var moduleAttrs=traceOut._module.attributes;var attrs=moduleAttrs.hoverinfo?moduleAttrs:baseTraceAttrs;var valObj=attrs.hoverinfo;var dflt;if(layoutOut._dataLength===1){var flags=valObj.dflt==='all'?valObj.flags.slice():valObj.dflt.split('+');flags.splice(flags.indexOf('name'),1);dflt=flags.join('+');}return exports.coerce(traceIn,traceOut,attrs,'hoverinfo',dflt);};/** Coerce shortcut for [un]selected.marker.opacity,\n *  which has special default logic, to ensure that it corresponds to the\n *  default selection behavior while allowing to be overtaken by any other\n *  [un]selected attribute.\n *\n *  N.B. This must be called *after* coercing all the other [un]selected attrs,\n *  to give the intended result.\n *\n * @param {object} traceOut : fullData item\n * @param {function} coerce : lib.coerce wrapper with implied first three arguments\n */exports.coerceSelectionMarkerOpacity=function(traceOut,coerce){if(!traceOut.marker)return;var mo=traceOut.marker.opacity;// you can still have a `marker` container with no markers if there's text\nif(mo===undefined)return;var smoDflt;var usmoDflt;// Don't give [un]selected.marker.opacity a default value if\n// marker.opacity is an array: handle this during style step.\n//\n// Only give [un]selected.marker.opacity a default value if you don't\n// set any other [un]selected attributes.\nif(!isArrayOrTypedArray(mo)&&!traceOut.selected&&!traceOut.unselected){smoDflt=mo;usmoDflt=DESELECTDIM*mo;}coerce('selected.marker.opacity',smoDflt);coerce('unselected.marker.opacity',usmoDflt);};function validate(value,opts){var valObjectDef=exports.valObjectMeta[opts.valType];if(opts.arrayOk&&isArrayOrTypedArray(value))return true;if(valObjectDef.validateFunction){return valObjectDef.validateFunction(value,opts);}var failed={};var out=failed;var propMock={set:function set(v){out=v;}};// 'failed' just something mutable that won't be === anything else\nvalObjectDef.coerceFunction(value,propMock,failed,opts);return out!==failed;}exports.validate=validate;},{\"../components/colorscale/scales\":58,\"../constants/interactions\":139,\"../plots/attributes\":200,\"./array\":146,\"./mod\":166,\"./nested_property\":167,\"./regex\":174,\"fast-isnumeric\":10,\"tinycolor2\":26}],151:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var isNumeric=_dereq_('fast-isnumeric');var Loggers=_dereq_('./loggers');var mod=_dereq_('./mod').mod;var constants=_dereq_('../constants/numerical');var BADNUM=constants.BADNUM;var ONEDAY=constants.ONEDAY;var ONEHOUR=constants.ONEHOUR;var ONEMIN=constants.ONEMIN;var ONESEC=constants.ONESEC;var EPOCHJD=constants.EPOCHJD;var Registry=_dereq_('../registry');var utcFormat=d3.time.format.utc;var DATETIME_REGEXP=/^\\s*(-?\\d\\d\\d\\d|\\d\\d)(-(\\d?\\d)(-(\\d?\\d)([ Tt]([01]?\\d|2[0-3])(:([0-5]\\d)(:([0-5]\\d(\\.\\d+)?))?(Z|z|[+\\-]\\d\\d:?\\d\\d)?)?)?)?)?\\s*$/m;// special regex for chinese calendars to support yyyy-mmi-dd etc for intercalary months\nvar DATETIME_REGEXP_CN=/^\\s*(-?\\d\\d\\d\\d|\\d\\d)(-(\\d?\\di?)(-(\\d?\\d)([ Tt]([01]?\\d|2[0-3])(:([0-5]\\d)(:([0-5]\\d(\\.\\d+)?))?(Z|z|[+\\-]\\d\\d:?\\d\\d)?)?)?)?)?\\s*$/m;// for 2-digit years, the first year we map them onto\nvar YFIRST=new Date().getFullYear()-70;function isWorldCalendar(calendar){return calendar&&Registry.componentsRegistry.calendars&&typeof calendar==='string'&&calendar!=='gregorian';}/*\n * dateTick0: get the canonical tick for this calendar\n *\n * bool sunday is for week ticks, shift it to a Sunday.\n */exports.dateTick0=function(calendar,sunday){if(isWorldCalendar(calendar)){return sunday?Registry.getComponentMethod('calendars','CANONICAL_SUNDAY')[calendar]:Registry.getComponentMethod('calendars','CANONICAL_TICK')[calendar];}else{return sunday?'2000-01-02':'2000-01-01';}};/*\n * dfltRange: for each calendar, give a valid default range\n */exports.dfltRange=function(calendar){if(isWorldCalendar(calendar)){return Registry.getComponentMethod('calendars','DFLTRANGE')[calendar];}else{return['2000-01-01','2001-01-01'];}};// is an object a javascript date?\nexports.isJSDate=function(v){return _typeof(v)==='object'&&v!==null&&typeof v.getTime==='function';};// The absolute limits of our date-time system\n// This is a little weird: we use MIN_MS and MAX_MS in dateTime2ms\n// but we use dateTime2ms to calculate them (after defining it!)\nvar MIN_MS,MAX_MS;/**\n * dateTime2ms - turn a date object or string s into milliseconds\n * (relative to 1970-01-01, per javascript standard)\n * optional calendar (string) to use a non-gregorian calendar\n *\n * Returns BADNUM if it doesn't find a date\n *\n * strings should have the form:\n *\n *    -?YYYY-mm-dd<sep>HH:MM:SS.sss<tzInfo>?\n *\n * <sep>: space (our normal standard) or T or t (ISO-8601)\n * <tzInfo>: Z, z, or [+\\-]HH:?MM and we THROW IT AWAY\n * this format comes from https://tools.ietf.org/html/rfc3339#section-5.6\n * but we allow it even with a space as the separator\n *\n * May truncate after any full field, and sss can be any length\n * even >3 digits, though javascript dates truncate to milliseconds,\n * we keep as much as javascript numeric precision can hold, but we only\n * report back up to 100 microsecond precision, because most dates support\n * this precision (close to 1970 support more, very far away support less)\n *\n * Expanded to support negative years to -9999 but you must always\n * give 4 digits, except for 2-digit positive years which we assume are\n * near the present time.\n * Note that we follow ISO 8601:2004: there *is* a year 0, which\n * is 1BC/BCE, and -1===2BC etc.\n *\n * World calendars: not all of these *have* agreed extensions to this full range,\n * if you have another calendar system but want a date range outside its validity,\n * you can use a gregorian date string prefixed with 'G' or 'g'.\n *\n * Where to cut off 2-digit years between 1900s and 2000s?\n * from http://support.microsoft.com/kb/244664:\n *   1930-2029 (the most retro of all...)\n * but in my mac chrome from eg. d=new Date(Date.parse('8/19/50')):\n *   1950-2049\n * by Java, from http://stackoverflow.com/questions/2024273/:\n *   now-80 - now+19\n * or FileMaker Pro, from\n *      http://www.filemaker.com/12help/html/add_view_data.4.21.html:\n *   now-70 - now+29\n * but python strptime etc, via\n *      http://docs.python.org/py3k/library/time.html:\n *   1969-2068 (super forward-looking, but static, not sliding!)\n *\n * lets go with now-70 to now+29, and if anyone runs into this problem\n * they can learn the hard way not to use 2-digit years, as no choice we\n * make now will cover all possibilities. mostly this will all be taken\n * care of in initial parsing, should only be an issue for hand-entered data\n * currently (2016) this range is:\n *   1946-2045\n */exports.dateTime2ms=function(s,calendar){// first check if s is a date object\nif(exports.isJSDate(s)){// Convert to the UTC milliseconds that give the same\n// hours as this date has in the local timezone\nvar tzOffset=s.getTimezoneOffset()*ONEMIN;var offsetTweak=(s.getUTCMinutes()-s.getMinutes())*ONEMIN+(s.getUTCSeconds()-s.getSeconds())*ONESEC+(s.getUTCMilliseconds()-s.getMilliseconds());if(offsetTweak){var comb=3*ONEMIN;tzOffset=tzOffset-comb/2+mod(offsetTweak-tzOffset+comb/2,comb);}s=Number(s)-tzOffset;if(s>=MIN_MS&&s<=MAX_MS)return s;return BADNUM;}// otherwise only accept strings and numbers\nif(typeof s!=='string'&&typeof s!=='number')return BADNUM;s=String(s);var isWorld=isWorldCalendar(calendar);// to handle out-of-range dates in international calendars, accept\n// 'G' as a prefix to force the built-in gregorian calendar.\nvar s0=s.charAt(0);if(isWorld&&(s0==='G'||s0==='g')){s=s.substr(1);calendar='';}var isChinese=isWorld&&calendar.substr(0,7)==='chinese';var match=s.match(isChinese?DATETIME_REGEXP_CN:DATETIME_REGEXP);if(!match)return BADNUM;var y=match[1];var m=match[3]||'1';var d=Number(match[5]||1);var H=Number(match[7]||0);var M=Number(match[9]||0);var S=Number(match[11]||0);if(isWorld){// disallow 2-digit years for world calendars\nif(y.length===2)return BADNUM;y=Number(y);var cDate;try{var calInstance=Registry.getComponentMethod('calendars','getCal')(calendar);if(isChinese){var isIntercalary=m.charAt(m.length-1)==='i';m=parseInt(m,10);cDate=calInstance.newDate(y,calInstance.toMonthIndex(y,m,isIntercalary),d);}else{cDate=calInstance.newDate(y,Number(m),d);}}catch(e){return BADNUM;}// Invalid ... date\nif(!cDate)return BADNUM;return(cDate.toJD()-EPOCHJD)*ONEDAY+H*ONEHOUR+M*ONEMIN+S*ONESEC;}if(y.length===2){y=(Number(y)+2000-YFIRST)%100+YFIRST;}else y=Number(y);// new Date uses months from 0; subtract 1 here just so we\n// don't have to do it again during the validity test below\nm-=1;// javascript takes new Date(0..99,m,d) to mean 1900-1999, so\n// to support years 0-99 we need to use setFullYear explicitly\n// Note that 2000 is a leap year.\nvar date=new Date(Date.UTC(2000,m,d,H,M));date.setUTCFullYear(y);if(date.getUTCMonth()!==m)return BADNUM;if(date.getUTCDate()!==d)return BADNUM;return date.getTime()+S*ONESEC;};MIN_MS=exports.MIN_MS=exports.dateTime2ms('-9999');MAX_MS=exports.MAX_MS=exports.dateTime2ms('9999-12-31 23:59:59.9999');// is string s a date? (see above)\nexports.isDateTime=function(s,calendar){return exports.dateTime2ms(s,calendar)!==BADNUM;};// pad a number with zeroes, to given # of digits before the decimal point\nfunction lpad(val,digits){return String(val+Math.pow(10,digits)).substr(1);}/**\n * Turn ms into string of the form YYYY-mm-dd HH:MM:SS.ssss\n * Crop any trailing zeros in time, except never stop right after hours\n * (we could choose to crop '-01' from date too but for now we always\n * show the whole date)\n * Optional range r is the data range that applies, also in ms.\n * If rng is big, the later parts of time will be omitted\n */var NINETYDAYS=90*ONEDAY;var THREEHOURS=3*ONEHOUR;var FIVEMIN=5*ONEMIN;exports.ms2DateTime=function(ms,r,calendar){if(typeof ms!=='number'||!(ms>=MIN_MS&&ms<=MAX_MS))return BADNUM;if(!r)r=0;var msecTenths=Math.floor(mod(ms+0.05,1)*10);var msRounded=Math.round(ms-msecTenths/10);var dateStr,h,m,s,msec10,d;if(isWorldCalendar(calendar)){var dateJD=Math.floor(msRounded/ONEDAY)+EPOCHJD;var timeMs=Math.floor(mod(ms,ONEDAY));try{dateStr=Registry.getComponentMethod('calendars','getCal')(calendar).fromJD(dateJD).formatDate('yyyy-mm-dd');}catch(e){// invalid date in this calendar - fall back to Gyyyy-mm-dd\ndateStr=utcFormat('G%Y-%m-%d')(new Date(msRounded));}// yyyy does NOT guarantee 4-digit years. YYYY mostly does, but does\n// other things for a few calendars, so we can't trust it. Just pad\n// it manually (after the '-' if there is one)\nif(dateStr.charAt(0)==='-'){while(dateStr.length<11){dateStr='-0'+dateStr.substr(1);}}else{while(dateStr.length<10){dateStr='0'+dateStr;}}// TODO: if this is faster, we could use this block for extracting\n// the time components of regular gregorian too\nh=r<NINETYDAYS?Math.floor(timeMs/ONEHOUR):0;m=r<NINETYDAYS?Math.floor(timeMs%ONEHOUR/ONEMIN):0;s=r<THREEHOURS?Math.floor(timeMs%ONEMIN/ONESEC):0;msec10=r<FIVEMIN?timeMs%ONESEC*10+msecTenths:0;}else{d=new Date(msRounded);dateStr=utcFormat('%Y-%m-%d')(d);// <90 days: add hours and minutes - never *only* add hours\nh=r<NINETYDAYS?d.getUTCHours():0;m=r<NINETYDAYS?d.getUTCMinutes():0;// <3 hours: add seconds\ns=r<THREEHOURS?d.getUTCSeconds():0;// <5 minutes: add ms (plus one extra digit, this is msec*10)\nmsec10=r<FIVEMIN?d.getUTCMilliseconds()*10+msecTenths:0;}return includeTime(dateStr,h,m,s,msec10);};// For converting old-style milliseconds to date strings,\n// we use the local timezone rather than UTC like we use\n// everywhere else, both for backward compatibility and\n// because that's how people mostly use javasript date objects.\n// Clip one extra day off our date range though so we can't get\n// thrown beyond the range by the timezone shift.\nexports.ms2DateTimeLocal=function(ms){if(!(ms>=MIN_MS+ONEDAY&&ms<=MAX_MS-ONEDAY))return BADNUM;var msecTenths=Math.floor(mod(ms+0.05,1)*10);var d=new Date(Math.round(ms-msecTenths/10));var dateStr=d3.time.format('%Y-%m-%d')(d);var h=d.getHours();var m=d.getMinutes();var s=d.getSeconds();var msec10=d.getUTCMilliseconds()*10+msecTenths;return includeTime(dateStr,h,m,s,msec10);};function includeTime(dateStr,h,m,s,msec10){// include each part that has nonzero data in or after it\nif(h||m||s||msec10){dateStr+=' '+lpad(h,2)+':'+lpad(m,2);if(s||msec10){dateStr+=':'+lpad(s,2);if(msec10){var digits=4;while(msec10%10===0){digits-=1;msec10/=10;}dateStr+='.'+lpad(msec10,digits);}}}return dateStr;}// normalize date format to date string, in case it starts as\n// a Date object or milliseconds\n// optional dflt is the return value if cleaning fails\nexports.cleanDate=function(v,dflt,calendar){// let us use cleanDate to provide a missing default without an error\nif(v===BADNUM)return dflt;if(exports.isJSDate(v)||typeof v==='number'&&isFinite(v)){// do not allow milliseconds (old) or jsdate objects (inherently\n// described as gregorian dates) with world calendars\nif(isWorldCalendar(calendar)){Loggers.error('JS Dates and milliseconds are incompatible with world calendars',v);return dflt;}// NOTE: if someone puts in a year as a number rather than a string,\n// this will mistakenly convert it thinking it's milliseconds from 1970\n// that is: '2012' -> Jan. 1, 2012, but 2012 -> 2012 epoch milliseconds\nv=exports.ms2DateTimeLocal(+v);if(!v&&dflt!==undefined)return dflt;}else if(!exports.isDateTime(v,calendar)){Loggers.error('unrecognized date',v);return dflt;}return v;};/*\n *  Date formatting for ticks and hovertext\n */ /*\n * modDateFormat: Support world calendars, and add one item to\n * d3's vocabulary:\n * %{n}f where n is the max number of digits of fractional seconds\n */var fracMatch=/%\\d?f/g;function modDateFormat(fmt,x,formatter,calendar){fmt=fmt.replace(fracMatch,function(match){var digits=Math.min(+match.charAt(1)||6,6);var fracSecs=(x/1000%1+2).toFixed(digits).substr(2).replace(/0+$/,'')||'0';return fracSecs;});var d=new Date(Math.floor(x+0.05));if(isWorldCalendar(calendar)){try{fmt=Registry.getComponentMethod('calendars','worldCalFmt')(fmt,x,calendar);}catch(e){return'Invalid';}}return formatter(fmt)(d);}/*\n * formatTime: create a time string from:\n *   x: milliseconds\n *   tr: tickround ('M', 'S', or # digits)\n * only supports UTC times (where every day is 24 hours and 0 is at midnight)\n */var MAXSECONDS=[59,59.9,59.99,59.999,59.9999];function formatTime(x,tr){var timePart=mod(x+0.05,ONEDAY);var timeStr=lpad(Math.floor(timePart/ONEHOUR),2)+':'+lpad(mod(Math.floor(timePart/ONEMIN),60),2);if(tr!=='M'){if(!isNumeric(tr))tr=0;// should only be 'S'\n/*\n         * this is a weird one - and shouldn't come up unless people\n         * monkey with tick0 in weird ways, but we need to do something!\n         * IN PARTICULAR we had better not display garbage (see below)\n         * for numbers we always round to the nearest increment of the\n         * precision we're showing, and this seems like the right way to\n         * handle seconds and milliseconds, as they have a decimal point\n         * and people will interpret that to mean rounding like numbers.\n         * but for larger increments we floor the value: it's always\n         * 2013 until the ball drops on the new year. We could argue about\n         * which field it is where we start rounding (should 12:08:59\n         * round to 12:09 if we're stopping at minutes?) but for now I'll\n         * say we round seconds but floor everything else. BUT that means\n         * we need to never round up to 60 seconds, ie 23:59:60\n         */var sec=Math.min(mod(x/ONESEC,60),MAXSECONDS[tr]);var secStr=(100+sec).toFixed(tr).substr(1);if(tr>0){secStr=secStr.replace(/0+$/,'').replace(/[\\.]$/,'');}timeStr+=':'+secStr;}return timeStr;}/*\n * formatDate: turn a date into tick or hover label text.\n *\n *   x: milliseconds, the value to convert\n *   fmt: optional, an explicit format string (d3 format, even for world calendars)\n *   tr: tickround ('y', 'm', 'd', 'M', 'S', or # digits)\n *      used if no explicit fmt is provided\n *   formatter: locale-aware d3 date formatter for standard gregorian calendars\n *      should be the result of exports.getD3DateFormat(gd)\n *   calendar: optional string, the world calendar system to use\n *\n * returns the date/time as a string, potentially with the leading portion\n * on a separate line (after '\\n')\n * Note that this means if you provide an explicit format which includes '\\n'\n * the axis may choose to strip things after it when they don't change from\n * one tick to the next (as it does with automatic formatting)\n */exports.formatDate=function(x,fmt,tr,formatter,calendar,extraFormat){calendar=isWorldCalendar(calendar)&&calendar;if(!fmt){if(tr==='y')fmt=extraFormat.year;else if(tr==='m')fmt=extraFormat.month;else if(tr==='d'){fmt=extraFormat.dayMonth+'\\n'+extraFormat.year;}else{return formatTime(x,tr)+'\\n'+modDateFormat(extraFormat.dayMonthYear,x,formatter,calendar);}}return modDateFormat(fmt,x,formatter,calendar);};/*\n * incrementMonth: make a new milliseconds value from the given one,\n * having changed the month\n *\n * special case for world calendars: multiples of 12 are treated as years,\n * even for calendar systems that don't have (always or ever) 12 months/year\n * TODO: perhaps we need a different code for year increments to support this?\n *\n * ms (number): the initial millisecond value\n * dMonth (int): the (signed) number of months to shift\n * calendar (string): the calendar system to use\n *\n * changing month does not (and CANNOT) always preserve day, since\n * months have different lengths. The worst example of this is:\n *   d = new Date(1970,0,31); d.setMonth(1) -> Feb 31 turns into Mar 3\n *\n * But we want to be able to iterate over the last day of each month,\n * regardless of what its number is.\n * So shift 3 days forward, THEN set the new month, then unshift:\n *   1/31 -> 2/28 (or 29) -> 3/31 -> 4/30 -> ...\n *\n * Note that odd behavior still exists if you start from the 26th-28th:\n *   1/28 -> 2/28 -> 3/31\n * but at least you can't shift any dates into the wrong month,\n * and ticks on these days incrementing by month would be very unusual\n */var THREEDAYS=3*ONEDAY;exports.incrementMonth=function(ms,dMonth,calendar){calendar=isWorldCalendar(calendar)&&calendar;// pull time out and operate on pure dates, then add time back at the end\n// this gives maximum precision - not that we *normally* care if we're\n// incrementing by month, but better to be safe!\nvar timeMs=mod(ms,ONEDAY);ms=Math.round(ms-timeMs);if(calendar){try{var dateJD=Math.round(ms/ONEDAY)+EPOCHJD;var calInstance=Registry.getComponentMethod('calendars','getCal')(calendar);var cDate=calInstance.fromJD(dateJD);if(dMonth%12)calInstance.add(cDate,dMonth,'m');else calInstance.add(cDate,dMonth/12,'y');return(cDate.toJD()-EPOCHJD)*ONEDAY+timeMs;}catch(e){Loggers.error('invalid ms '+ms+' in calendar '+calendar);// then keep going in gregorian even though the result will be 'Invalid'\n}}var y=new Date(ms+THREEDAYS);return y.setUTCMonth(y.getUTCMonth()+dMonth)+timeMs-THREEDAYS;};/*\n * findExactDates: what fraction of data is exact days, months, or years?\n *\n * data: array of millisecond values\n * calendar (string) the calendar to test against\n */exports.findExactDates=function(data,calendar){var exactYears=0;var exactMonths=0;var exactDays=0;var blankCount=0;var d;var di;var calInstance=isWorldCalendar(calendar)&&Registry.getComponentMethod('calendars','getCal')(calendar);for(var i=0;i<data.length;i++){di=data[i];// not date data at all\nif(!isNumeric(di)){blankCount++;continue;}// not an exact date\nif(di%ONEDAY)continue;if(calInstance){try{d=calInstance.fromJD(di/ONEDAY+EPOCHJD);if(d.day()===1){if(d.month()===1)exactYears++;else exactMonths++;}else exactDays++;}catch(e){// invalid date in this calendar - ignore it here.\n}}else{d=new Date(di);if(d.getUTCDate()===1){if(d.getUTCMonth()===0)exactYears++;else exactMonths++;}else exactDays++;}}exactMonths+=exactYears;exactDays+=exactMonths;var dataCount=data.length-blankCount;return{exactYears:exactYears/dataCount,exactMonths:exactMonths/dataCount,exactDays:exactDays/dataCount};};},{\"../constants/numerical\":140,\"../registry\":242,\"./loggers\":163,\"./mod\":166,\"d3\":8,\"fast-isnumeric\":10}],152:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';/* global jQuery:false */var EventEmitter=_dereq_('events').EventEmitter;var Events={init:function init(plotObj){/*\n         * If we have already instantiated an emitter for this plot\n         * return early.\n         */if(plotObj._ev instanceof EventEmitter)return plotObj;var ev=new EventEmitter();var internalEv=new EventEmitter();/*\n         * Assign to plot._ev while we still live in a land\n         * where plot is a DOM element with stuff attached to it.\n         * In the future we can make plot the event emitter itself.\n         */plotObj._ev=ev;/*\n         * Create a second event handler that will manage events *internally*.\n         * This allows parts of plotly to respond to thing like relayout without\n         * having to use the user-facing event handler. They cannot peacefully\n         * coexist on the same handler because a user invoking\n         * plotObj.removeAllListeners() would detach internal events, breaking\n         * plotly.\n         */plotObj._internalEv=internalEv;/*\n         * Assign bound methods from the ev to the plot object. These methods\n         * will reference the 'this' of plot._ev even though they are methods\n         * of plot. This will keep the event machinery away from the plot object\n         * which currently is often a DOM element but presents an API that will\n         * continue to function when plot becomes an emitter. Not all EventEmitter\n         * methods have been bound to `plot` as some do not currently add value to\n         * the Plotly event API.\n         */plotObj.on=ev.on.bind(ev);plotObj.once=ev.once.bind(ev);plotObj.removeListener=ev.removeListener.bind(ev);plotObj.removeAllListeners=ev.removeAllListeners.bind(ev);/*\n         * Create functions for managing internal events. These are *only* triggered\n         * by the mirroring of external events via the emit function.\n         */plotObj._internalOn=internalEv.on.bind(internalEv);plotObj._internalOnce=internalEv.once.bind(internalEv);plotObj._removeInternalListener=internalEv.removeListener.bind(internalEv);plotObj._removeAllInternalListeners=internalEv.removeAllListeners.bind(internalEv);/*\n         * We must wrap emit to continue to support JQuery events. The idea\n         * is to check to see if the user is using JQuery events, if they are\n         * we emit JQuery events to trigger user handlers as well as the EventEmitter\n         * events.\n         */plotObj.emit=function(event,data){if(typeof jQuery!=='undefined'){jQuery(plotObj).trigger(event,data);}ev.emit(event,data);internalEv.emit(event,data);};return plotObj;},/*\n     * This function behaves like jQuery's triggerHandler. It calls\n     * all handlers for a particular event and returns the return value\n     * of the LAST handler. This function also triggers jQuery's\n     * triggerHandler for backwards compatibility.\n     */triggerHandler:function triggerHandler(plotObj,event,data){var jQueryHandlerValue;var nodeEventHandlerValue;/*\n         * If jQuery exists run all its handlers for this event and\n         * collect the return value of the LAST handler function\n         */if(typeof jQuery!=='undefined'){jQueryHandlerValue=jQuery(plotObj).triggerHandler(event,data);}/*\n         * Now run all the node style event handlers\n         */var ev=plotObj._ev;if(!ev)return jQueryHandlerValue;var handlers=ev._events[event];if(!handlers)return jQueryHandlerValue;// making sure 'this' is the EventEmitter instance\nfunction apply(handler){// The 'once' case, we can't just call handler() as we need\n// the return value here. So,\n// - remove handler\n// - call listener and grab return value!\n// - stash 'fired' key to not call handler twice\nif(handler.listener){ev.removeListener(event,handler.listener);if(!handler.fired){handler.fired=true;return handler.listener.apply(ev,[data]);}}else{return handler.apply(ev,[data]);}}// handlers can be function or an array of functions\nhandlers=Array.isArray(handlers)?handlers:[handlers];var i;for(i=0;i<handlers.length-1;i++){apply(handlers[i]);}// now call the final handler and collect its value\nnodeEventHandlerValue=apply(handlers[i]);/*\n         * Return either the jQuery handler value if it exists or the\n         * nodeEventHandler value. jQuery event value supersedes nodejs\n         * events for backwards compatibility reasons.\n         */return jQueryHandlerValue!==undefined?jQueryHandlerValue:nodeEventHandlerValue;},purge:function purge(plotObj){delete plotObj._ev;delete plotObj.on;delete plotObj.once;delete plotObj.removeListener;delete plotObj.removeAllListeners;delete plotObj.emit;delete plotObj._ev;delete plotObj._internalEv;delete plotObj._internalOn;delete plotObj._internalOnce;delete plotObj._removeInternalListener;delete plotObj._removeAllInternalListeners;return plotObj;}};module.exports=Events;},{\"events\":7}],153:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var isPlainObject=_dereq_('./is_plain_object.js');var isArray=Array.isArray;function primitivesLoopSplice(source,target){var i,value;for(i=0;i<source.length;i++){value=source[i];if(value!==null&&_typeof(value)==='object'){return false;}if(value!==void 0){target[i]=value;}}return true;}exports.extendFlat=function(){return _extend(arguments,false,false,false);};exports.extendDeep=function(){return _extend(arguments,true,false,false);};exports.extendDeepAll=function(){return _extend(arguments,true,true,false);};exports.extendDeepNoArrays=function(){return _extend(arguments,true,false,true);};/*\n * Inspired by https://github.com/justmoon/node-extend/blob/master/index.js\n * All credit to the jQuery authors for perfecting this amazing utility.\n *\n * API difference with jQuery version:\n * - No optional boolean (true -> deep extend) first argument,\n *   use `extendFlat` for first-level only extend and\n *   use `extendDeep` for a deep extend.\n *\n * Other differences with jQuery version:\n * - Uses a modern (and faster) isPlainObject routine.\n * - Expected to work with object {} and array [] arguments only.\n * - Does not check for circular structure.\n *   FYI: jQuery only does a check across one level.\n *   Warning: this might result in infinite loops.\n *\n */function _extend(inputs,isDeep,keepAllKeys,noArrayCopies){var target=inputs[0];var length=inputs.length;var input,key,src,copy,copyIsArray,clone,allPrimitives;// TODO does this do the right thing for typed arrays?\nif(length===2&&isArray(target)&&isArray(inputs[1])&&target.length===0){allPrimitives=primitivesLoopSplice(inputs[1],target);if(allPrimitives){return target;}else{target.splice(0,target.length);// reset target and continue to next block\n}}for(var i=1;i<length;i++){input=inputs[i];for(key in input){src=target[key];copy=input[key];if(noArrayCopies&&isArray(copy)){// Stop early and just transfer the array if array copies are disallowed:\ntarget[key]=copy;}else if(isDeep&&copy&&(isPlainObject(copy)||(copyIsArray=isArray(copy)))){// recurse if we're merging plain objects or arrays\nif(copyIsArray){copyIsArray=false;clone=src&&isArray(src)?src:[];}else{clone=src&&isPlainObject(src)?src:{};}// never move original objects, clone them\ntarget[key]=_extend([clone,copy],isDeep,keepAllKeys,noArrayCopies);}else if(typeof copy!=='undefined'||keepAllKeys){// don't bring in undefined values, except for extendDeepAll\ntarget[key]=copy;}}}return target;}},{\"./is_plain_object.js\":160}],154:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';/**\n * Return news array containing only the unique items\n * found in input array.\n *\n * IMPORTANT: Note that items are considered unique\n * if `String({})` is unique. For example;\n *\n *  Lib.filterUnique([ { a: 1 }, { b: 2 } ])\n *\n *  returns [{ a: 1 }]\n *\n * and\n *\n *  Lib.filterUnique([ '1', 1 ])\n *\n *  returns ['1']\n *\n *\n * @param {array} array base array\n * @return {array} new filtered array\n */module.exports=function filterUnique(array){var seen={};var out=[];var j=0;for(var i=0;i<array.length;i++){var item=array[i];if(seen[item]!==1){seen[item]=1;out[j++]=item;}}return out;};},{}],155:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';/** Filter out object items with visible !== true\n *  insider array container.\n *\n *  @param {array of objects} container\n *  @return {array of objects} of length <= container\n *\n */module.exports=function filterVisible(container){var filterFn=isCalcData(container)?calcDataFilter:baseFilter;var out=[];for(var i=0;i<container.length;i++){var item=container[i];if(filterFn(item))out.push(item);}return out;};function baseFilter(item){return item.visible===true;}function calcDataFilter(item){return item[0].trace.visible===true;}function isCalcData(cont){return Array.isArray(cont)&&Array.isArray(cont[0])&&cont[0][0]&&cont[0][0].trace;}},{}],156:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var mod=_dereq_('./mod').mod;/*\n * look for intersection of two line segments\n *   (1->2 and 3->4) - returns array [x,y] if they do, null if not\n */exports.segmentsIntersect=segmentsIntersect;function segmentsIntersect(x1,y1,x2,y2,x3,y3,x4,y4){var a=x2-x1;var b=x3-x1;var c=x4-x3;var d=y2-y1;var e=y3-y1;var f=y4-y3;var det=a*f-c*d;// parallel lines? intersection is undefined\n// ignore the case where they are colinear\nif(det===0)return null;var t=(b*f-c*e)/det;var u=(b*d-a*e)/det;// segments do not intersect?\nif(u<0||u>1||t<0||t>1)return null;return{x:x1+a*t,y:y1+d*t};}/*\n * find the minimum distance between two line segments (1->2 and 3->4)\n */exports.segmentDistance=function segmentDistance(x1,y1,x2,y2,x3,y3,x4,y4){if(segmentsIntersect(x1,y1,x2,y2,x3,y3,x4,y4))return 0;// the two segments and their lengths squared\nvar x12=x2-x1;var y12=y2-y1;var x34=x4-x3;var y34=y4-y3;var ll12=x12*x12+y12*y12;var ll34=x34*x34+y34*y34;// calculate distance squared, then take the sqrt at the very end\nvar dist2=Math.min(perpDistance2(x12,y12,ll12,x3-x1,y3-y1),perpDistance2(x12,y12,ll12,x4-x1,y4-y1),perpDistance2(x34,y34,ll34,x1-x3,y1-y3),perpDistance2(x34,y34,ll34,x2-x3,y2-y3));return Math.sqrt(dist2);};/*\n * distance squared from segment ab to point c\n * [xab, yab] is the vector b-a\n * [xac, yac] is the vector c-a\n * llab is the length squared of (b-a), just to simplify calculation\n */function perpDistance2(xab,yab,llab,xac,yac){var fcAB=xac*xab+yac*yab;if(fcAB<0){// point c is closer to point a\nreturn xac*xac+yac*yac;}else if(fcAB>llab){// point c is closer to point b\nvar xbc=xac-xab;var ybc=yac-yab;return xbc*xbc+ybc*ybc;}else{// perpendicular distance is the shortest\nvar crossProduct=xac*yab-yac*xab;return crossProduct*crossProduct/llab;}}// a very short-term cache for getTextLocation, just because\n// we're often looping over the same locations multiple times\n// invalidated as soon as we look at a different path\nvar locationCache,workingPath,workingTextWidth;// turn a path and position along it into x, y, and angle for the given text\nexports.getTextLocation=function getTextLocation(path,totalPathLen,positionOnPath,textWidth){if(path!==workingPath||textWidth!==workingTextWidth){locationCache={};workingPath=path;workingTextWidth=textWidth;}if(locationCache[positionOnPath]){return locationCache[positionOnPath];}// for the angle, use points on the path separated by the text width\n// even though due to curvature, the text will cover a bit more than that\nvar p0=path.getPointAtLength(mod(positionOnPath-textWidth/2,totalPathLen));var p1=path.getPointAtLength(mod(positionOnPath+textWidth/2,totalPathLen));// note: atan handles 1/0 nicely\nvar theta=Math.atan((p1.y-p0.y)/(p1.x-p0.x));// center the text at 2/3 of the center position plus 1/3 the p0/p1 midpoint\n// that's the average position of this segment, assuming it's roughly quadratic\nvar pCenter=path.getPointAtLength(mod(positionOnPath,totalPathLen));var x=(pCenter.x*4+p0.x+p1.x)/6;var y=(pCenter.y*4+p0.y+p1.y)/6;var out={x:x,y:y,theta:theta};locationCache[positionOnPath]=out;return out;};exports.clearLocationCache=function(){workingPath=null;};/*\n * Find the segment of `path` that's within the visible area\n * given by `bounds` {left, right, top, bottom}, to within a\n * precision of `buffer` px\n *\n * returns: undefined if nothing is visible, else object:\n * {\n *   min: position where the path first enters bounds, or 0 if it\n *        starts within bounds\n *   max: position where the path last exits bounds, or the path length\n *        if it finishes within bounds\n *   len: max - min, ie the length of visible path\n *   total: the total path length - just included so the caller doesn't\n *        need to call path.getTotalLength() again\n *   isClosed: true iff the start and end points of the path are both visible\n *        and are at the same point\n * }\n *\n * Works by starting from either end and repeatedly finding the distance from\n * that point to the plot area, and if it's outside the plot, moving along the\n * path by that distance (because the plot must be at least that far away on\n * the path). Note that if a path enters, exits, and re-enters the plot, we\n * will not capture this behavior.\n */exports.getVisibleSegment=function getVisibleSegment(path,bounds,buffer){var left=bounds.left;var right=bounds.right;var top=bounds.top;var bottom=bounds.bottom;var pMin=0;var pTotal=path.getTotalLength();var pMax=pTotal;var pt0,ptTotal;function getDistToPlot(len){var pt=path.getPointAtLength(len);// hold on to the start and end points for `closed`\nif(len===0)pt0=pt;else if(len===pTotal)ptTotal=pt;var dx=pt.x<left?left-pt.x:pt.x>right?pt.x-right:0;var dy=pt.y<top?top-pt.y:pt.y>bottom?pt.y-bottom:0;return Math.sqrt(dx*dx+dy*dy);}var distToPlot=getDistToPlot(pMin);while(distToPlot){pMin+=distToPlot+buffer;if(pMin>pMax)return;distToPlot=getDistToPlot(pMin);}distToPlot=getDistToPlot(pMax);while(distToPlot){pMax-=distToPlot+buffer;if(pMin>pMax)return;distToPlot=getDistToPlot(pMax);}return{min:pMin,max:pMax,len:pMax-pMin,total:pTotal,isClosed:pMin===0&&pMax===pTotal&&Math.abs(pt0.x-ptTotal.x)<0.1&&Math.abs(pt0.y-ptTotal.y)<0.1};};/**\n * Find point on SVG path corresponding to a given constraint coordinate\n *\n * @param {SVGPathElement} path\n * @param {Number} val : constraint coordinate value\n * @param {String} coord : 'x' or 'y' the constraint coordinate\n * @param {Object} opts :\n *  - {Number} pathLength : supply total path length before hand\n *  - {Number} tolerance\n *  - {Number} iterationLimit\n * @return {SVGPoint}\n */exports.findPointOnPath=function findPointOnPath(path,val,coord,opts){opts=opts||{};var pathLength=opts.pathLength||path.getTotalLength();var tolerance=opts.tolerance||1e-3;var iterationLimit=opts.iterationLimit||30;// if path starts at a val greater than the path tail (like on vertical violins),\n// we must flip the sign of the computed diff.\nvar mul=path.getPointAtLength(0)[coord]>path.getPointAtLength(pathLength)[coord]?-1:1;var i=0;var b0=0;var b1=pathLength;var mid;var pt;var diff;while(i<iterationLimit){mid=(b0+b1)/2;pt=path.getPointAtLength(mid);diff=pt[coord]-val;if(Math.abs(diff)<tolerance){return pt;}else{if(mul*diff>0){b1=mid;}else{b0=mid;}i++;}}return pt;};},{\"./mod\":166}],157:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';/**\n * Allow referencing a graph DOM element either directly\n * or by its id string\n *\n * @param {HTMLDivElement|string} gd: a graph element or its id\n *\n * @returns {HTMLDivElement} the DOM element of the graph\n */module.exports=function(gd){var gdElement;if(typeof gd==='string'){gdElement=document.getElementById(gd);if(gdElement===null){throw new Error('No DOM element with id \\''+gd+'\\' exists on the page.');}return gdElement;}else if(gd===null||gd===undefined){throw new Error('DOM element provided is null or undefined');}return gd;// otherwise assume that gd is a DOM element\n};},{}],158:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';// Simple helper functions\n// none of these need any external deps\nmodule.exports=function identity(d){return d;};},{}],159:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var isNumeric=_dereq_('fast-isnumeric');var numConstants=_dereq_('../constants/numerical');var FP_SAFE=numConstants.FP_SAFE;var BADNUM=numConstants.BADNUM;var lib=module.exports={};lib.nestedProperty=_dereq_('./nested_property');lib.keyedContainer=_dereq_('./keyed_container');lib.relativeAttr=_dereq_('./relative_attr');lib.isPlainObject=_dereq_('./is_plain_object');lib.toLogRange=_dereq_('./to_log_range');lib.relinkPrivateKeys=_dereq_('./relink_private');var arrayModule=_dereq_('./array');lib.isTypedArray=arrayModule.isTypedArray;lib.isArrayOrTypedArray=arrayModule.isArrayOrTypedArray;lib.isArray1D=arrayModule.isArray1D;lib.ensureArray=arrayModule.ensureArray;lib.concat=arrayModule.concat;lib.maxRowLength=arrayModule.maxRowLength;lib.minRowLength=arrayModule.minRowLength;var modModule=_dereq_('./mod');lib.mod=modModule.mod;lib.modHalf=modModule.modHalf;var coerceModule=_dereq_('./coerce');lib.valObjectMeta=coerceModule.valObjectMeta;lib.coerce=coerceModule.coerce;lib.coerce2=coerceModule.coerce2;lib.coerceFont=coerceModule.coerceFont;lib.coerceHoverinfo=coerceModule.coerceHoverinfo;lib.coerceSelectionMarkerOpacity=coerceModule.coerceSelectionMarkerOpacity;lib.validate=coerceModule.validate;var datesModule=_dereq_('./dates');lib.dateTime2ms=datesModule.dateTime2ms;lib.isDateTime=datesModule.isDateTime;lib.ms2DateTime=datesModule.ms2DateTime;lib.ms2DateTimeLocal=datesModule.ms2DateTimeLocal;lib.cleanDate=datesModule.cleanDate;lib.isJSDate=datesModule.isJSDate;lib.formatDate=datesModule.formatDate;lib.incrementMonth=datesModule.incrementMonth;lib.dateTick0=datesModule.dateTick0;lib.dfltRange=datesModule.dfltRange;lib.findExactDates=datesModule.findExactDates;lib.MIN_MS=datesModule.MIN_MS;lib.MAX_MS=datesModule.MAX_MS;var searchModule=_dereq_('./search');lib.findBin=searchModule.findBin;lib.sorterAsc=searchModule.sorterAsc;lib.sorterDes=searchModule.sorterDes;lib.distinctVals=searchModule.distinctVals;lib.roundUp=searchModule.roundUp;lib.sort=searchModule.sort;lib.findIndexOfMin=searchModule.findIndexOfMin;var statsModule=_dereq_('./stats');lib.aggNums=statsModule.aggNums;lib.len=statsModule.len;lib.mean=statsModule.mean;lib.midRange=statsModule.midRange;lib.variance=statsModule.variance;lib.stdev=statsModule.stdev;lib.interp=statsModule.interp;var matrixModule=_dereq_('./matrix');lib.init2dArray=matrixModule.init2dArray;lib.transposeRagged=matrixModule.transposeRagged;lib.dot=matrixModule.dot;lib.translationMatrix=matrixModule.translationMatrix;lib.rotationMatrix=matrixModule.rotationMatrix;lib.rotationXYMatrix=matrixModule.rotationXYMatrix;lib.apply2DTransform=matrixModule.apply2DTransform;lib.apply2DTransform2=matrixModule.apply2DTransform2;var anglesModule=_dereq_('./angles');lib.deg2rad=anglesModule.deg2rad;lib.rad2deg=anglesModule.rad2deg;lib.angleDelta=anglesModule.angleDelta;lib.angleDist=anglesModule.angleDist;lib.isFullCircle=anglesModule.isFullCircle;lib.isAngleInsideSector=anglesModule.isAngleInsideSector;lib.isPtInsideSector=anglesModule.isPtInsideSector;lib.pathArc=anglesModule.pathArc;lib.pathSector=anglesModule.pathSector;lib.pathAnnulus=anglesModule.pathAnnulus;var anchorUtils=_dereq_('./anchor_utils');lib.isLeftAnchor=anchorUtils.isLeftAnchor;lib.isCenterAnchor=anchorUtils.isCenterAnchor;lib.isRightAnchor=anchorUtils.isRightAnchor;lib.isTopAnchor=anchorUtils.isTopAnchor;lib.isMiddleAnchor=anchorUtils.isMiddleAnchor;lib.isBottomAnchor=anchorUtils.isBottomAnchor;var geom2dModule=_dereq_('./geometry2d');lib.segmentsIntersect=geom2dModule.segmentsIntersect;lib.segmentDistance=geom2dModule.segmentDistance;lib.getTextLocation=geom2dModule.getTextLocation;lib.clearLocationCache=geom2dModule.clearLocationCache;lib.getVisibleSegment=geom2dModule.getVisibleSegment;lib.findPointOnPath=geom2dModule.findPointOnPath;var extendModule=_dereq_('./extend');lib.extendFlat=extendModule.extendFlat;lib.extendDeep=extendModule.extendDeep;lib.extendDeepAll=extendModule.extendDeepAll;lib.extendDeepNoArrays=extendModule.extendDeepNoArrays;var loggersModule=_dereq_('./loggers');lib.log=loggersModule.log;lib.warn=loggersModule.warn;lib.error=loggersModule.error;var regexModule=_dereq_('./regex');lib.counterRegex=regexModule.counter;var throttleModule=_dereq_('./throttle');lib.throttle=throttleModule.throttle;lib.throttleDone=throttleModule.done;lib.clearThrottle=throttleModule.clear;lib.getGraphDiv=_dereq_('./get_graph_div');lib.clearResponsive=_dereq_('./clear_responsive');lib.makeTraceGroups=_dereq_('./make_trace_groups');lib._=_dereq_('./localize');lib.notifier=_dereq_('./notifier');lib.filterUnique=_dereq_('./filter_unique');lib.filterVisible=_dereq_('./filter_visible');lib.pushUnique=_dereq_('./push_unique');lib.cleanNumber=_dereq_('./clean_number');lib.ensureNumber=function ensureNumber(v){if(!isNumeric(v))return BADNUM;v=Number(v);if(v<-FP_SAFE||v>FP_SAFE)return BADNUM;return isNumeric(v)?Number(v):BADNUM;};/**\n * Is v a valid array index? Accepts numeric strings as well as numbers.\n *\n * @param {any} v: the value to test\n * @param {Optional[integer]} len: the array length we are indexing\n *\n * @return {bool}: v is a valid array index\n */lib.isIndex=function(v,len){if(len!==undefined&&v>=len)return false;return isNumeric(v)&&v>=0&&v%1===0;};lib.noop=_dereq_('./noop');lib.identity=_dereq_('./identity');/**\n * create an array of length 'cnt' filled with 'v' at all indices\n *\n * @param {any} v\n * @param {number} cnt\n * @return {array}\n */lib.repeat=function(v,cnt){var out=new Array(cnt);for(var i=0;i<cnt;i++){out[i]=v;}return out;};/**\n * swap x and y of the same attribute in container cont\n * specify attr with a ? in place of x/y\n * you can also swap other things than x/y by providing part1 and part2\n */lib.swapAttrs=function(cont,attrList,part1,part2){if(!part1)part1='x';if(!part2)part2='y';for(var i=0;i<attrList.length;i++){var attr=attrList[i];var xp=lib.nestedProperty(cont,attr.replace('?',part1));var yp=lib.nestedProperty(cont,attr.replace('?',part2));var temp=xp.get();xp.set(yp.get());yp.set(temp);}};/**\n * SVG painter's algo worked around with reinsertion\n */lib.raiseToTop=function raiseToTop(elem){elem.parentNode.appendChild(elem);};/**\n * cancel a possibly pending transition; returned selection may be used by caller\n */lib.cancelTransition=function(selection){return selection.transition().duration(0);};// constrain - restrict a number v to be between v0 and v1\nlib.constrain=function(v,v0,v1){if(v0>v1)return Math.max(v1,Math.min(v0,v));return Math.max(v0,Math.min(v1,v));};/**\n * do two bounding boxes from getBoundingClientRect,\n * ie {left,right,top,bottom,width,height}, overlap?\n * takes optional padding pixels\n */lib.bBoxIntersect=function(a,b,pad){pad=pad||0;return a.left<=b.right+pad&&b.left<=a.right+pad&&a.top<=b.bottom+pad&&b.top<=a.bottom+pad;};/*\n * simpleMap: alternative to Array.map that only\n * passes on the element and up to 2 extra args you\n * provide (but not the array index or the whole array)\n *\n * array: the array to map it to\n * func: the function to apply\n * x1, x2: optional extra args\n */lib.simpleMap=function(array,func,x1,x2){var len=array.length;var out=new Array(len);for(var i=0;i<len;i++){out[i]=func(array[i],x1,x2);}return out;};/**\n * Random string generator\n *\n * @param {object} existing\n *     pass in strings to avoid as keys with truthy values\n * @param {int} bits\n *     bits of information in the output string, default 24\n * @param {int} base\n *     base of string representation, default 16. Should be a power of 2.\n */lib.randstr=function randstr(existing,bits,base,_recursion){if(!base)base=16;if(bits===undefined)bits=24;if(bits<=0)return'0';var digits=Math.log(Math.pow(2,bits))/Math.log(base);var res='';var i,b,x;for(i=2;digits===Infinity;i*=2){digits=Math.log(Math.pow(2,bits/i))/Math.log(base)*i;}var rem=digits-Math.floor(digits);for(i=0;i<Math.floor(digits);i++){x=Math.floor(Math.random()*base).toString(base);res=x+res;}if(rem){b=Math.pow(base,rem);x=Math.floor(Math.random()*b).toString(base);res=x+res;}var parsed=parseInt(res,base);if(existing&&existing[res]||parsed!==Infinity&&parsed>=Math.pow(2,bits)){if(_recursion>10){lib.warn('randstr failed uniqueness');return res;}return randstr(existing,bits,base,(_recursion||0)+1);}else return res;};lib.OptionControl=function(opt,optname){/*\n     * An environment to contain all option setters and\n     * getters that collectively modify opts.\n     *\n     * You can call up opts from any function in new object\n     * as this.optname || this.opt\n     *\n     * See FitOpts for example of usage\n     */if(!opt)opt={};if(!optname)optname='opt';var self={};self.optionList=[];self._newoption=function(optObj){optObj[optname]=opt;self[optObj.name]=optObj;self.optionList.push(optObj);};self['_'+optname]=opt;return self;};/**\n * lib.smooth: smooth arrayIn by convolving with\n * a hann window with given full width at half max\n * bounce the ends in, so the output has the same length as the input\n */lib.smooth=function(arrayIn,FWHM){FWHM=Math.round(FWHM)||0;// only makes sense for integers\nif(FWHM<2)return arrayIn;var alen=arrayIn.length;var alen2=2*alen;var wlen=2*FWHM-1;var w=new Array(wlen);var arrayOut=new Array(alen);var i;var j;var k;var v;// first make the window array\nfor(i=0;i<wlen;i++){w[i]=(1-Math.cos(Math.PI*(i+1)/FWHM))/(2*FWHM);}// now do the convolution\nfor(i=0;i<alen;i++){v=0;for(j=0;j<wlen;j++){k=i+j+1-FWHM;// multibounce\nif(k<-alen)k-=alen2*Math.round(k/alen2);else if(k>=alen2)k-=alen2*Math.floor(k/alen2);// single bounce\nif(k<0)k=-1-k;else if(k>=alen)k=alen2-1-k;v+=arrayIn[k]*w[j];}arrayOut[i]=v;}return arrayOut;};/**\n * syncOrAsync: run a sequence of functions synchronously\n * as long as its returns are not promises (ie have no .then)\n * includes one argument arg to send to all functions...\n * this is mainly just to prevent us having to make wrapper functions\n * when the only purpose of the wrapper is to reference gd\n * and a final step to be executed at the end\n * TODO: if there's an error and everything is sync,\n * this doesn't happen yet because we want to make sure\n * that it gets reported\n */lib.syncOrAsync=function(sequence,arg,finalStep){var ret,fni;function continueAsync(){return lib.syncOrAsync(sequence,arg,finalStep);}while(sequence.length){fni=sequence.splice(0,1)[0];ret=fni(arg);if(ret&&ret.then){return ret.then(continueAsync).then(undefined,lib.promiseError);}}return finalStep&&finalStep(arg);};/**\n * Helper to strip trailing slash, from\n * http://stackoverflow.com/questions/6680825/return-string-without-trailing-slash\n */lib.stripTrailingSlash=function(str){if(str.substr(-1)==='/')return str.substr(0,str.length-1);return str;};lib.noneOrAll=function(containerIn,containerOut,attrList){/**\n     * some attributes come together, so if you have one of them\n     * in the input, you should copy the default values of the others\n     * to the input as well.\n     */if(!containerIn)return;var hasAny=false;var hasAll=true;var i;var val;for(i=0;i<attrList.length;i++){val=containerIn[attrList[i]];if(val!==undefined&&val!==null)hasAny=true;else hasAll=false;}if(hasAny&&!hasAll){for(i=0;i<attrList.length;i++){containerIn[attrList[i]]=containerOut[attrList[i]];}}};/** merges calcdata field (given by cdAttr) with traceAttr values\n *\n * N.B. Loop over minimum of cd.length and traceAttr.length\n * i.e. it does not try to fill in beyond traceAttr.length-1\n *\n * @param {array} traceAttr : trace attribute\n * @param {object} cd : calcdata trace\n * @param {string} cdAttr : calcdata key\n */lib.mergeArray=function(traceAttr,cd,cdAttr){if(lib.isArrayOrTypedArray(traceAttr)){var imax=Math.min(traceAttr.length,cd.length);for(var i=0;i<imax;i++){cd[i][cdAttr]=traceAttr[i];}}};/** fills calcdata field (given by cdAttr) with traceAttr values\n *  or function of traceAttr values (e.g. some fallback)\n *\n * N.B. Loops over all cd items.\n *\n * @param {array} traceAttr : trace attribute\n * @param {object} cd : calcdata trace\n * @param {string} cdAttr : calcdata key\n * @param {function} [fn] : optional function to apply to each array item\n */lib.fillArray=function(traceAttr,cd,cdAttr,fn){fn=fn||lib.identity;if(lib.isArrayOrTypedArray(traceAttr)){for(var i=0;i<cd.length;i++){cd[i][cdAttr]=fn(traceAttr[i]);}}};/** Handler for trace-wide vs per-point options\n *\n * @param {object} trace : (full) trace object\n * @param {number} ptNumber : index of the point in question\n * @param {string} astr : attribute string\n * @param {function} [fn] : optional function to apply to each array item\n *\n * @return {any}\n */lib.castOption=function(trace,ptNumber,astr,fn){fn=fn||lib.identity;var val=lib.nestedProperty(trace,astr).get();if(lib.isArrayOrTypedArray(val)){if(Array.isArray(ptNumber)&&lib.isArrayOrTypedArray(val[ptNumber[0]])){return fn(val[ptNumber[0]][ptNumber[1]]);}else{return fn(val[ptNumber]);}}else{return val;}};/** Extract option from calcdata item, correctly falling back to\n *  trace value if not found.\n *\n *  @param {object} calcPt : calcdata[i][j] item\n *  @param {object} trace : (full) trace object\n *  @param {string} calcKey : calcdata key\n *  @param {string} traceKey : aka trace attribute string\n *  @return {any}\n */lib.extractOption=function(calcPt,trace,calcKey,traceKey){if(calcKey in calcPt)return calcPt[calcKey];// fallback to trace value,\n//   must check if value isn't itself an array\n//   which means the trace attribute has a corresponding\n//   calcdata key, but its value is falsy\nvar traceVal=lib.nestedProperty(trace,traceKey).get();if(!Array.isArray(traceVal))return traceVal;};function makePtIndex2PtNumber(indexToPoints){var ptIndex2ptNumber={};for(var k in indexToPoints){var pts=indexToPoints[k];for(var j=0;j<pts.length;j++){ptIndex2ptNumber[pts[j]]=+k;}}return ptIndex2ptNumber;}/** Tag selected calcdata items\n *\n * N.B. note that point 'index' corresponds to input data array index\n *  whereas 'number' is its post-transform version.\n *\n * @param {array} calcTrace\n * @param {object} trace\n *  - selectedpoints {array}\n *  - _indexToPoints {object}\n * @param {ptNumber2cdIndex} ptNumber2cdIndex (optional)\n *  optional map object for trace types that do not have 1-to-1 point number to\n *  calcdata item index correspondence (e.g. histogram)\n */lib.tagSelected=function(calcTrace,trace,ptNumber2cdIndex){var selectedpoints=trace.selectedpoints;var indexToPoints=trace._indexToPoints;var ptIndex2ptNumber;// make pt index-to-number map object, which takes care of transformed traces\nif(indexToPoints){ptIndex2ptNumber=makePtIndex2PtNumber(indexToPoints);}function isCdIndexValid(v){return v!==undefined&&v<calcTrace.length;}for(var i=0;i<selectedpoints.length;i++){var ptIndex=selectedpoints[i];if(lib.isIndex(ptIndex)){var ptNumber=ptIndex2ptNumber?ptIndex2ptNumber[ptIndex]:ptIndex;var cdIndex=ptNumber2cdIndex?ptNumber2cdIndex[ptNumber]:ptNumber;if(isCdIndexValid(cdIndex)){calcTrace[cdIndex].selected=1;}}}};lib.selIndices2selPoints=function(trace){var selectedpoints=trace.selectedpoints;var indexToPoints=trace._indexToPoints;if(indexToPoints){var ptIndex2ptNumber=makePtIndex2PtNumber(indexToPoints);var out=[];for(var i=0;i<selectedpoints.length;i++){var ptIndex=selectedpoints[i];if(lib.isIndex(ptIndex)){var ptNumber=ptIndex2ptNumber[ptIndex];if(lib.isIndex(ptNumber)){out.push(ptNumber);}}}return out;}else{return selectedpoints;}};/** Returns target as set by 'target' transform attribute\n *\n * @param {object} trace : full trace object\n * @param {object} transformOpts : transform option object\n *  - target (string} :\n *      either an attribute string referencing an array in the trace object, or\n *      a set array.\n *\n * @return {array or false} : the target array (NOT a copy!!) or false if invalid\n */lib.getTargetArray=function(trace,transformOpts){var target=transformOpts.target;if(typeof target==='string'&&target){var array=lib.nestedProperty(trace,target).get();return Array.isArray(array)?array:false;}else if(Array.isArray(target)){return target;}return false;};/**\n * modified version of jQuery's extend to strip out private objs and functions,\n * and cut arrays down to first <arraylen> or 1 elements\n * because extend-like algorithms are hella slow\n * obj2 is assumed to already be clean of these things (including no arrays)\n */lib.minExtend=function(obj1,obj2){var objOut={};if(_typeof(obj2)!=='object')obj2={};var arrayLen=3;var keys=Object.keys(obj1);var i,k,v;for(i=0;i<keys.length;i++){k=keys[i];v=obj1[k];if(k.charAt(0)==='_'||typeof v==='function')continue;else if(k==='module')objOut[k]=v;else if(Array.isArray(v)){if(k==='colorscale'){objOut[k]=v.slice();}else{objOut[k]=v.slice(0,arrayLen);}}else if(v&&_typeof(v)==='object')objOut[k]=lib.minExtend(obj1[k],obj2[k]);else objOut[k]=v;}keys=Object.keys(obj2);for(i=0;i<keys.length;i++){k=keys[i];v=obj2[k];if(_typeof(v)!=='object'||!(k in objOut)||_typeof(objOut[k])!=='object'){objOut[k]=v;}}return objOut;};lib.titleCase=function(s){return s.charAt(0).toUpperCase()+s.substr(1);};lib.containsAny=function(s,fragments){for(var i=0;i<fragments.length;i++){if(s.indexOf(fragments[i])!==-1)return true;}return false;};lib.isPlotDiv=function(el){var el3=d3.select(el);return el3.node()instanceof HTMLElement&&el3.size()&&el3.classed('js-plotly-plot');};lib.removeElement=function(el){var elParent=el&&el.parentNode;if(elParent)elParent.removeChild(el);};/**\n * for dynamically adding style rules\n * makes one stylesheet that contains all rules added\n * by all calls to this function\n */lib.addStyleRule=function(selector,styleString){lib.addRelatedStyleRule('global',selector,styleString);};/**\n * for dynamically adding style rules\n * to a stylesheet uniquely identified by a uid\n */lib.addRelatedStyleRule=function(uid,selector,styleString){var id='plotly.js-style-'+uid;var style=document.getElementById(id);if(!style){style=document.createElement('style');style.setAttribute('id',id);// WebKit hack :(\nstyle.appendChild(document.createTextNode(''));document.head.appendChild(style);}var styleSheet=style.sheet;if(styleSheet.insertRule){styleSheet.insertRule(selector+'{'+styleString+'}',0);}else if(styleSheet.addRule){styleSheet.addRule(selector,styleString,0);}else lib.warn('addStyleRule failed');};/**\n * to remove from the page a stylesheet identified by a given uid\n */lib.deleteRelatedStyleRule=function(uid){var id='plotly.js-style-'+uid;var style=document.getElementById(id);if(style)lib.removeElement(style);};lib.isIE=function(){return typeof window.navigator.msSaveBlob!=='undefined';};/**\n * Duck typing to recognize a d3 selection, mostly for IE9's benefit\n * because it doesn't handle instanceof like modern browsers\n */lib.isD3Selection=function(obj){return obj&&typeof obj.classed==='function';};/**\n * Append element to DOM only if not present.\n *\n * @param {d3 selection} parent : parent selection of the element in question\n * @param {string} nodeType : node type of element to append\n * @param {string} className (optional) : class name of element in question\n * @param {fn} enterFn (optional) : optional fn applied to entering elements only\n * @return {d3 selection} selection of new layer\n *\n * Previously, we were using the following pattern:\n *\n * ```\n * var sel = parent.selectAll('.' + className)\n *     .data([0]);\n *\n * sel.enter().append(nodeType)\n *     .classed(className, true);\n *\n * return sel;\n * ```\n *\n * in numerous places in our codebase to achieve the same behavior.\n *\n * The logic below performs much better, mostly as we are using\n * `.select` instead `.selectAll` that is `querySelector` instead of\n * `querySelectorAll`.\n *\n */lib.ensureSingle=function(parent,nodeType,className,enterFn){var sel=parent.select(nodeType+(className?'.'+className:''));if(sel.size())return sel;var layer=parent.append(nodeType);if(className)layer.classed(className,true);if(enterFn)layer.call(enterFn);return layer;};/**\n * Same as Lib.ensureSingle, but using id as selector.\n * This version is mostly used for clipPath nodes.\n *\n * @param {d3 selection} parent : parent selection of the element in question\n * @param {string} nodeType : node type of element to append\n * @param {string} id : id of element in question\n * @param {fn} enterFn (optional) : optional fn applied to entering elements only\n * @return {d3 selection} selection of new layer\n */lib.ensureSingleById=function(parent,nodeType,id,enterFn){var sel=parent.select(nodeType+'#'+id);if(sel.size())return sel;var layer=parent.append(nodeType).attr('id',id);if(enterFn)layer.call(enterFn);return layer;};/**\n * Converts a string path to an object.\n *\n * When given a string containing an array element, it will create a `null`\n * filled array of the given size.\n *\n * @example\n * lib.objectFromPath('nested.test[2].path', 'value');\n * // returns { nested: { test: [null, null, { path: 'value' }]}\n *\n * @param   {string}    path to nested value\n * @param   {*}         any value to be set\n *\n * @return {Object} the constructed object with a full nested path\n */lib.objectFromPath=function(path,value){var keys=path.split('.');var tmpObj;var obj=tmpObj={};for(var i=0;i<keys.length;i++){var key=keys[i];var el=null;var parts=keys[i].match(/(.*)\\[([0-9]+)\\]/);if(parts){key=parts[1];el=parts[2];tmpObj=tmpObj[key]=[];if(i===keys.length-1){tmpObj[el]=value;}else{tmpObj[el]={};}tmpObj=tmpObj[el];}else{if(i===keys.length-1){tmpObj[key]=value;}else{tmpObj[key]={};}tmpObj=tmpObj[key];}}return obj;};/**\n * Iterate through an object in-place, converting dotted properties to objects.\n *\n * Examples:\n *\n *   lib.expandObjectPaths({'nested.test.path': 'value'});\n *     => { nested: { test: {path: 'value'}}}\n *\n * It also handles array notation, e.g.:\n *\n *   lib.expandObjectPaths({'foo[1].bar': 'value'});\n *     => { foo: [null, {bar: value}] }\n *\n * It handles merges the results when two properties are specified in parallel:\n *\n *   lib.expandObjectPaths({'foo[1].bar': 10, 'foo[0].bar': 20});\n *     => { foo: [{bar: 10}, {bar: 20}] }\n *\n * It does NOT, however, merge mulitple mutliply-nested arrays::\n *\n *   lib.expandObjectPaths({'marker[1].range[1]': 5, 'marker[1].range[0]': 4})\n *     => { marker: [null, {range: 4}] }\n */ // Store this to avoid recompiling regex on *every* prop since this may happen many\n// many times for animations. Could maybe be inside the function. Not sure about\n// scoping vs. recompilation tradeoff, but at least it's not just inlining it into\n// the inner loop.\nvar dottedPropertyRegex=/^([^\\[\\.]+)\\.(.+)?/;var indexedPropertyRegex=/^([^\\.]+)\\[([0-9]+)\\](\\.)?(.+)?/;lib.expandObjectPaths=function(data){var match,key,prop,datum,idx,dest,trailingPath;if(_typeof(data)==='object'&&!Array.isArray(data)){for(key in data){if(data.hasOwnProperty(key)){if(match=key.match(dottedPropertyRegex)){datum=data[key];prop=match[1];delete data[key];data[prop]=lib.extendDeepNoArrays(data[prop]||{},lib.objectFromPath(key,lib.expandObjectPaths(datum))[prop]);}else if(match=key.match(indexedPropertyRegex)){datum=data[key];prop=match[1];idx=parseInt(match[2]);delete data[key];data[prop]=data[prop]||[];if(match[3]==='.'){// This is the case where theere are subsequent properties into which\n// we must recurse, e.g. transforms[0].value\ntrailingPath=match[4];dest=data[prop][idx]=data[prop][idx]||{};// NB: Extend deep no arrays prevents this from working on multiple\n// nested properties in the same object, e.g.\n//\n// {\n//   foo[0].bar[1].range\n//   foo[0].bar[0].range\n// }\n//\n// In this case, the extendDeepNoArrays will overwrite one array with\n// the other, so that both properties *will not* be present in the\n// result. Fixing this would require a more intelligent tracking\n// of changes and merging than extendDeepNoArrays currently accomplishes.\nlib.extendDeepNoArrays(dest,lib.objectFromPath(trailingPath,lib.expandObjectPaths(datum)));}else{// This is the case where this property is the end of the line,\n// e.g. xaxis.range[0]\ndata[prop][idx]=lib.expandObjectPaths(datum);}}else{data[key]=lib.expandObjectPaths(data[key]);}}}}return data;};/**\n * Converts value to string separated by the provided separators.\n *\n * @example\n * lib.numSeparate(2016, '.,');\n * // returns '2016'\n *\n * @example\n * lib.numSeparate(3000, '.,', true);\n * // returns '3,000'\n *\n * @example\n * lib.numSeparate(1234.56, '|,')\n * // returns '1,234|56'\n *\n * @param   {string|number} value       the value to be converted\n * @param   {string}    separators  string of decimal, then thousands separators\n * @param   {boolean}    separatethousands  boolean, 4-digit integers are separated if true\n *\n * @return  {string}    the value that has been separated\n */lib.numSeparate=function(value,separators,separatethousands){if(!separatethousands)separatethousands=false;if(typeof separators!=='string'||separators.length===0){throw new Error('Separator string required for formatting!');}if(typeof value==='number'){value=String(value);}var thousandsRe=/(\\d+)(\\d{3})/;var decimalSep=separators.charAt(0);var thouSep=separators.charAt(1);var x=value.split('.');var x1=x[0];var x2=x.length>1?decimalSep+x[1]:'';// Years are ignored for thousands separators\nif(thouSep&&(x.length>1||x1.length>4||separatethousands)){while(thousandsRe.test(x1)){x1=x1.replace(thousandsRe,'$1'+thouSep+'$2');}}return x1+x2;};lib.TEMPLATE_STRING_REGEX=/%{([^\\s%{}:]*)(:[^}]*)?}/g;var SIMPLE_PROPERTY_REGEX=/^\\w*$/;/**\n * Substitute values from an object into a string\n *\n * Examples:\n *  Lib.templateString('name: %{trace}', {trace: 'asdf'}) --> 'name: asdf'\n *  Lib.templateString('name: %{trace[0].name}', {trace: [{name: 'asdf'}]}) --> 'name: asdf'\n *\n * @param {string}  input string containing %{...} template strings\n * @param {obj}     data object containing substitution values\n *\n * @return {string} templated string\n */lib.templateString=function(string,obj){// Not all that useful, but cache nestedProperty instantiation\n// just in case it speeds things up *slightly*:\nvar getterCache={};return string.replace(lib.TEMPLATE_STRING_REGEX,function(dummy,key){if(SIMPLE_PROPERTY_REGEX.test(key)){return obj[key]||'';}getterCache[key]=getterCache[key]||lib.nestedProperty(obj,key).get;return getterCache[key]()||'';});};var TEMPLATE_STRING_FORMAT_SEPARATOR=/^:/;var numberOfHoverTemplateWarnings=0;var maximumNumberOfHoverTemplateWarnings=10;/**\n * Substitute values from an object into a string and optionally formats them using d3-format,\n * or fallback to associated labels.\n *\n * Examples:\n *  Lib.hovertemplateString('name: %{trace}', {trace: 'asdf'}) --> 'name: asdf'\n *  Lib.hovertemplateString('name: %{trace[0].name}', {trace: [{name: 'asdf'}]}) --> 'name: asdf'\n *  Lib.hovertemplateString('price: %{y:$.2f}', {y: 1}) --> 'price: $1.00'\n *\n * @param {obj}     d3 locale\n * @param {string}  input string containing %{...:...} template strings\n * @param {obj}     data object containing fallback text when no formatting is specified, ex.: {yLabel: 'formattedYValue'}\n * @param {obj}     data objects containing substitution values\n *\n * @return {string} templated string\n */lib.hovertemplateString=function(string,labels,d3locale){var args=arguments;// Not all that useful, but cache nestedProperty instantiation\n// just in case it speeds things up *slightly*:\nvar getterCache={};return string.replace(lib.TEMPLATE_STRING_REGEX,function(match,key,format){var obj,value,i;for(i=3;i<args.length;i++){obj=args[i];if(obj.hasOwnProperty(key)){value=obj[key];break;}if(!SIMPLE_PROPERTY_REGEX.test(key)){value=getterCache[key]||lib.nestedProperty(obj,key).get();if(value)getterCache[key]=value;}if(value!==undefined)break;}if(value===undefined){if(numberOfHoverTemplateWarnings<maximumNumberOfHoverTemplateWarnings){lib.warn('Variable \\''+key+'\\' in hovertemplate could not be found!');value=match;}if(numberOfHoverTemplateWarnings===maximumNumberOfHoverTemplateWarnings){lib.warn('Too many hovertemplate warnings - additional warnings will be suppressed');}numberOfHoverTemplateWarnings++;}if(format){var fmt;if(d3locale){fmt=d3locale.numberFormat;}else{fmt=d3.format;}value=fmt(format.replace(TEMPLATE_STRING_FORMAT_SEPARATOR,''))(value);}else{if(labels.hasOwnProperty(key+'Label'))value=labels[key+'Label'];}return value;});};/*\n * alphanumeric string sort, tailored for subplot IDs like scene2, scene10, x10y13 etc\n */var char0=48;var char9=57;lib.subplotSort=function(a,b){var l=Math.min(a.length,b.length)+1;var numA=0;var numB=0;for(var i=0;i<l;i++){var charA=a.charCodeAt(i)||0;var charB=b.charCodeAt(i)||0;var isNumA=charA>=char0&&charA<=char9;var isNumB=charB>=char0&&charB<=char9;if(isNumA)numA=10*numA+charA-char0;if(isNumB)numB=10*numB+charB-char0;if(!isNumA||!isNumB){if(numA!==numB)return numA-numB;if(charA!==charB)return charA-charB;}}return numB-numA;};// repeatable pseudorandom generator\nvar randSeed=2000000000;lib.seedPseudoRandom=function(){randSeed=2000000000;};lib.pseudoRandom=function(){var lastVal=randSeed;randSeed=(69069*randSeed+1)%4294967296;// don't let consecutive vals be too close together\n// gets away from really trying to be random, in favor of better local uniformity\nif(Math.abs(randSeed-lastVal)<429496729)return lib.pseudoRandom();return randSeed/4294967296;};},{\"../constants/numerical\":140,\"./anchor_utils\":144,\"./angles\":145,\"./array\":146,\"./clean_number\":147,\"./clear_responsive\":149,\"./coerce\":150,\"./dates\":151,\"./extend\":153,\"./filter_unique\":154,\"./filter_visible\":155,\"./geometry2d\":156,\"./get_graph_div\":157,\"./identity\":158,\"./is_plain_object\":160,\"./keyed_container\":161,\"./localize\":162,\"./loggers\":163,\"./make_trace_groups\":164,\"./matrix\":165,\"./mod\":166,\"./nested_property\":167,\"./noop\":168,\"./notifier\":169,\"./push_unique\":172,\"./regex\":174,\"./relative_attr\":175,\"./relink_private\":176,\"./search\":177,\"./stats\":179,\"./throttle\":181,\"./to_log_range\":182,\"d3\":8,\"fast-isnumeric\":10}],160:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';// more info: http://stackoverflow.com/questions/18531624/isplainobject-thing\nmodule.exports=function isPlainObject(obj){// We need to be a little less strict in the `imagetest` container because\n// of how async image requests are handled.\n//\n// N.B. isPlainObject(new Constructor()) will return true in `imagetest`\nif(window&&window.process&&window.process.versions){return Object.prototype.toString.call(obj)==='[object Object]';}return Object.prototype.toString.call(obj)==='[object Object]'&&Object.getPrototypeOf(obj)===Object.prototype;};},{}],161:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var nestedProperty=_dereq_('./nested_property');var SIMPLE_PROPERTY_REGEX=/^\\w*$/;// bitmask for deciding what's updated. Sometimes the name needs to be updated,\n// sometimes the value needs to be updated, and sometimes both do. This is just\n// a simple way to track what's updated such that it's a simple OR operation to\n// assimilate new updates.\n//\n// The only exception is the UNSET bit that tracks when we need to explicitly\n// unset and remove the property. This concrn arises because of the special\n// way in which nestedProperty handles null/undefined. When you specify `null`,\n// it prunes any unused items in the tree. I ran into some issues with it getting\n// null vs undefined confused, so UNSET is just a bit that forces the property\n// update to send `null`, removing the property explicitly rather than setting\n// it to undefined.\nvar NONE=0;var NAME=1;var VALUE=2;var BOTH=3;var UNSET=4;module.exports=function keyedContainer(baseObj,path,keyName,valueName){keyName=keyName||'name';valueName=valueName||'value';var i,arr,baseProp;var changeTypes={};if(path&&path.length){baseProp=nestedProperty(baseObj,path);arr=baseProp.get();}else{arr=baseObj;}path=path||'';// Construct an index:\nvar indexLookup={};if(arr){for(i=0;i<arr.length;i++){indexLookup[arr[i][keyName]]=i;}}var isSimpleValueProp=SIMPLE_PROPERTY_REGEX.test(valueName);var obj={set:function set(name,value){var changeType=value===null?UNSET:NONE;// create the base array if necessary\nif(!arr){if(!baseProp||changeType===UNSET)return;arr=[];baseProp.set(arr);}var idx=indexLookup[name];if(idx===undefined){if(changeType===UNSET)return;changeType=changeType|BOTH;idx=arr.length;indexLookup[name]=idx;}else if(value!==(isSimpleValueProp?arr[idx][valueName]:nestedProperty(arr[idx],valueName).get())){changeType=changeType|VALUE;}var newValue=arr[idx]=arr[idx]||{};newValue[keyName]=name;if(isSimpleValueProp){newValue[valueName]=value;}else{nestedProperty(newValue,valueName).set(value);}// If it's not an unset, force that bit to be unset. This is all related to the fact\n// that undefined and null are a bit specially implemented in nestedProperties.\nif(value!==null){changeType=changeType&~UNSET;}changeTypes[idx]=changeTypes[idx]|changeType;return obj;},get:function get(name){if(!arr)return;var idx=indexLookup[name];if(idx===undefined){return undefined;}else if(isSimpleValueProp){return arr[idx][valueName];}else{return nestedProperty(arr[idx],valueName).get();}},rename:function rename(name,newName){var idx=indexLookup[name];if(idx===undefined)return obj;changeTypes[idx]=changeTypes[idx]|NAME;indexLookup[newName]=idx;delete indexLookup[name];arr[idx][keyName]=newName;return obj;},remove:function remove(name){var idx=indexLookup[name];if(idx===undefined)return obj;var object=arr[idx];if(Object.keys(object).length>2){// This object contains more than just the key/value, so unset\n// the value without modifying the entry otherwise:\nchangeTypes[idx]=changeTypes[idx]|VALUE;return obj.set(name,null);}if(isSimpleValueProp){for(i=idx;i<arr.length;i++){changeTypes[i]=changeTypes[i]|BOTH;}for(i=idx;i<arr.length;i++){indexLookup[arr[i][keyName]]--;}arr.splice(idx,1);delete indexLookup[name];}else{// Perform this update *strictly* so we can check whether the result's\n// been pruned. If so, it's a removal. If not, it's a value unset only.\nnestedProperty(object,valueName).set(null);// Now check if the top level nested property has any keys left. If so,\n// the object still has values so we only want to unset the key. If not,\n// the entire object can be removed since there's no other data.\n// var topLevelKeys = Object.keys(object[valueName.split('.')[0]] || []);\nchangeTypes[idx]=changeTypes[idx]|VALUE|UNSET;}return obj;},constructUpdate:function constructUpdate(){var astr,idx;var update={};var changed=Object.keys(changeTypes);for(var i=0;i<changed.length;i++){idx=changed[i];astr=path+'['+idx+']';if(arr[idx]){if(changeTypes[idx]&NAME){update[astr+'.'+keyName]=arr[idx][keyName];}if(changeTypes[idx]&VALUE){if(isSimpleValueProp){update[astr+'.'+valueName]=changeTypes[idx]&UNSET?null:arr[idx][valueName];}else{update[astr+'.'+valueName]=changeTypes[idx]&UNSET?null:nestedProperty(arr[idx],valueName).get();}}}else{update[astr]=null;}}return update;}};return obj;};},{\"./nested_property\":167}],162:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Registry=_dereq_('../registry');/**\n * localize: translate a string for the current locale\n *\n * @param {object} gd: the graphDiv for context\n *  gd._context.locale determines the language (& optional region/country)\n *  the dictionary for each locale may either be supplied in\n *  gd._context.locales or globally via Plotly.register\n * @param {string} s: the string to translate\n */module.exports=function localize(gd,s){var locale=gd._context.locale;/*\n     * Priority of lookup:\n     *     contextDicts[locale],\n     *     registeredDicts[locale],\n     *     contextDicts[baseLocale], (if baseLocale is distinct)\n     *     registeredDicts[baseLocale]\n     * Return the first translation we find.\n     * This way if you have a regionalization you are allowed to specify\n     * only what's different from the base locale, everything else will\n     * fall back on the base.\n     */for(var i=0;i<2;i++){var locales=gd._context.locales;for(var j=0;j<2;j++){var dict=(locales[locale]||{}).dictionary;if(dict){var out=dict[s];if(out)return out;}locales=Registry.localeRegistry;}var baseLocale=locale.split('-')[0];if(baseLocale===locale)break;locale=baseLocale;}return s;};},{\"../registry\":242}],163:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';/* eslint-disable no-console */var dfltConfig=_dereq_('../plot_api/plot_config').dfltConfig;var loggers=module.exports={};/**\n * ------------------------------------------\n * debugging tools\n * ------------------------------------------\n */loggers.log=function(){if(dfltConfig.logging>1){var messages=['LOG:'];for(var i=0;i<arguments.length;i++){messages.push(arguments[i]);}apply(console.trace||console.log,messages);}};loggers.warn=function(){if(dfltConfig.logging>0){var messages=['WARN:'];for(var i=0;i<arguments.length;i++){messages.push(arguments[i]);}apply(console.trace||console.log,messages);}};loggers.error=function(){if(dfltConfig.logging>0){var messages=['ERROR:'];for(var i=0;i<arguments.length;i++){messages.push(arguments[i]);}apply(console.error,messages);}};/*\n * Robust apply, for IE9 where console.log doesn't support\n * apply like other functions do\n */function apply(f,args){if(f&&f.apply){try{// `this` should always be console, since here we're always\n// applying a method of the console object.\nf.apply(console,args);return;}catch(e){/* in case apply failed, fall back on the code below */}}// no apply - just try calling the function on each arg independently\nfor(var i=0;i<args.length;i++){try{f(args[i]);}catch(e){// still fails - last resort simple console.log\nconsole.log(args[i]);}}}},{\"../plot_api/plot_config\":191}],164:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';/**\n * General helper to manage trace groups based on calcdata\n *\n * @param {d3.selection} traceLayer: a selection containing a single group\n *     to draw these traces into\n * @param {array} cdModule: array of calcdata items for this\n *     module and subplot combination. Assumes the calcdata item for each\n *     trace is an array with the fullData trace attached to the first item.\n * @param {string} cls: the class attribute to give each trace group\n *     so you can give multiple classes separated by spaces\n */module.exports=function makeTraceGroups(traceLayer,cdModule,cls){var traces=traceLayer.selectAll('g.'+cls.replace(/\\s/g,'.')).data(cdModule,function(cd){return cd[0].trace.uid;});traces.exit().remove();traces.enter().append('g').attr('class',cls);traces.order();return traces;};},{}],165:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';exports.init2dArray=function(rowLength,colLength){var array=new Array(rowLength);for(var i=0;i<rowLength;i++){array[i]=new Array(colLength);}return array;};/**\n * transpose a (possibly ragged) 2d array z. inspired by\n * http://stackoverflow.com/questions/17428587/\n * transposing-a-2d-array-in-javascript\n */exports.transposeRagged=function(z){var maxlen=0;var zlen=z.length;var i,j;// Maximum row length:\nfor(i=0;i<zlen;i++){maxlen=Math.max(maxlen,z[i].length);}var t=new Array(maxlen);for(i=0;i<maxlen;i++){t[i]=new Array(zlen);for(j=0;j<zlen;j++){t[i][j]=z[j][i];}}return t;};// our own dot function so that we don't need to include numeric\nexports.dot=function(x,y){if(!(x.length&&y.length)||x.length!==y.length)return null;var len=x.length;var out;var i;if(x[0].length){// mat-vec or mat-mat\nout=new Array(len);for(i=0;i<len;i++){out[i]=exports.dot(x[i],y);}}else if(y[0].length){// vec-mat\nvar yTranspose=exports.transposeRagged(y);out=new Array(yTranspose.length);for(i=0;i<yTranspose.length;i++){out[i]=exports.dot(x,yTranspose[i]);}}else{// vec-vec\nout=0;for(i=0;i<len;i++){out+=x[i]*y[i];}}return out;};// translate by (x,y)\nexports.translationMatrix=function(x,y){return[[1,0,x],[0,1,y],[0,0,1]];};// rotate by alpha around (0,0)\nexports.rotationMatrix=function(alpha){var a=alpha*Math.PI/180;return[[Math.cos(a),-Math.sin(a),0],[Math.sin(a),Math.cos(a),0],[0,0,1]];};// rotate by alpha around (x,y)\nexports.rotationXYMatrix=function(a,x,y){return exports.dot(exports.dot(exports.translationMatrix(x,y),exports.rotationMatrix(a)),exports.translationMatrix(-x,-y));};// applies a 2D transformation matrix to either x and y params or an [x,y] array\nexports.apply2DTransform=function(transform){return function(){var args=arguments;if(args.length===3){args=args[0];}// from map\nvar xy=arguments.length===1?args[0]:[args[0],args[1]];return exports.dot(transform,[xy[0],xy[1],1]).slice(0,2);};};// applies a 2D transformation matrix to an [x1,y1,x2,y2] array (to transform a segment)\nexports.apply2DTransform2=function(transform){var at=exports.apply2DTransform(transform);return function(xys){return at(xys.slice(0,2)).concat(at(xys.slice(2,4)));};};},{}],166:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';/**\n * sanitized modulus function that always returns in the range [0, d)\n * rather than (-d, 0] if v is negative\n */function mod(v,d){var out=v%d;return out<0?out+d:out;}/**\n * sanitized modulus function that always returns in the range [-d/2, d/2]\n * rather than (-d, 0] if v is negative\n */function modHalf(v,d){return Math.abs(v)>d/2?v-Math.round(v/d)*d:v;}module.exports={mod:mod,modHalf:modHalf};},{}],167:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var isNumeric=_dereq_('fast-isnumeric');var isArrayOrTypedArray=_dereq_('./array').isArrayOrTypedArray;/**\n * convert a string s (such as 'xaxis.range[0]')\n * representing a property of nested object into set and get methods\n * also return the string and object so we don't have to keep track of them\n * allows [-1] for an array index, to set a property inside all elements\n * of an array\n * eg if obj = {arr: [{a: 1}, {a: 2}]}\n * you can do p = nestedProperty(obj, 'arr[-1].a')\n * but you cannot set the array itself this way, to do that\n * just set the whole array.\n * eg if obj = {arr: [1, 2, 3]}\n * you can't do nestedProperty(obj, 'arr[-1]').set(5)\n * but you can do nestedProperty(obj, 'arr').set([5, 5, 5])\n */module.exports=function nestedProperty(container,propStr){if(isNumeric(propStr))propStr=String(propStr);else if(typeof propStr!=='string'||propStr.substr(propStr.length-4)==='[-1]'){throw'bad property string';}var j=0;var propParts=propStr.split('.');var indexed;var indices;var i;// check for parts of the nesting hierarchy that are numbers (ie array elements)\nwhile(j<propParts.length){// look for non-bracket chars, then any number of [##] blocks\nindexed=String(propParts[j]).match(/^([^\\[\\]]*)((\\[\\-?[0-9]*\\])+)$/);if(indexed){if(indexed[1])propParts[j]=indexed[1];// allow propStr to start with bracketed array indices\nelse if(j===0)propParts.splice(0,1);else throw'bad property string';indices=indexed[2].substr(1,indexed[2].length-2).split('][');for(i=0;i<indices.length;i++){j++;propParts.splice(j,0,Number(indices[i]));}}j++;}if(_typeof(container)!=='object'){return badContainer(container,propStr,propParts);}return{set:npSet(container,propParts,propStr),get:npGet(container,propParts),astr:propStr,parts:propParts,obj:container};};function npGet(cont,parts){return function(){var curCont=cont;var curPart;var allSame;var out;var i;var j;for(i=0;i<parts.length-1;i++){curPart=parts[i];if(curPart===-1){allSame=true;out=[];for(j=0;j<curCont.length;j++){out[j]=npGet(curCont[j],parts.slice(i+1))();if(out[j]!==out[0])allSame=false;}return allSame?out[0]:out;}if(typeof curPart==='number'&&!isArrayOrTypedArray(curCont)){return undefined;}curCont=curCont[curPart];if(_typeof(curCont)!=='object'||curCont===null){return undefined;}}// only hit this if parts.length === 1\nif(_typeof(curCont)!=='object'||curCont===null)return undefined;out=curCont[parts[i]];if(out===null)return undefined;return out;};}/*\n * Can this value be deleted? We can delete `undefined`, and `null` except INSIDE an\n * *args* array.\n *\n * Previously we also deleted some `{}` and `[]`, in order to try and make set/unset\n * a net noop; but this causes far more complication than it's worth, and still had\n * lots of exceptions. See https://github.com/plotly/plotly.js/issues/1410\n *\n * *args* arrays get passed directly to API methods and we should respect null if\n * the user put it there, but otherwise null is deleted as we use it as code\n * in restyle/relayout/update for \"delete this value\" whereas undefined means\n * \"ignore this edit\"\n */var ARGS_PATTERN=/(^|\\.)args\\[/;function isDeletable(val,propStr){return val===undefined||val===null&&!propStr.match(ARGS_PATTERN);}function npSet(cont,parts,propStr){return function(val){var curCont=cont;var propPart='';var containerLevels=[[cont,propPart]];var toDelete=isDeletable(val,propStr);var curPart;var i;for(i=0;i<parts.length-1;i++){curPart=parts[i];if(typeof curPart==='number'&&!isArrayOrTypedArray(curCont)){throw'array index but container is not an array';}// handle special -1 array index\nif(curPart===-1){toDelete=!setArrayAll(curCont,parts.slice(i+1),val,propStr);if(toDelete)break;else return;}if(!checkNewContainer(curCont,curPart,parts[i+1],toDelete)){break;}curCont=curCont[curPart];if(_typeof(curCont)!=='object'||curCont===null){throw'container is not an object';}propPart=joinPropStr(propPart,curPart);containerLevels.push([curCont,propPart]);}if(toDelete){if(i===parts.length-1){delete curCont[parts[i]];// The one bit of pruning we still do: drop `undefined` from the end of arrays.\n// In case someone has already unset previous items, continue until we hit a\n// non-undefined value.\nif(Array.isArray(curCont)&&+parts[i]===curCont.length-1){while(curCont.length&&curCont[curCont.length-1]===undefined){curCont.pop();}}}}else curCont[parts[i]]=val;};}function joinPropStr(propStr,newPart){var toAdd=newPart;if(isNumeric(newPart))toAdd='['+newPart+']';else if(propStr)toAdd='.'+newPart;return propStr+toAdd;}// handle special -1 array index\nfunction setArrayAll(containerArray,innerParts,val,propStr){var arrayVal=isArrayOrTypedArray(val);var allSet=true;var thisVal=val;var thisPropStr=propStr.replace('-1',0);var deleteThis=arrayVal?false:isDeletable(val,thisPropStr);var firstPart=innerParts[0];var i;for(i=0;i<containerArray.length;i++){thisPropStr=propStr.replace('-1',i);if(arrayVal){thisVal=val[i%val.length];deleteThis=isDeletable(thisVal,thisPropStr);}if(deleteThis)allSet=false;if(!checkNewContainer(containerArray,i,firstPart,deleteThis)){continue;}npSet(containerArray[i],innerParts,propStr.replace('-1',i))(thisVal);}return allSet;}/**\n * make new sub-container as needed.\n * returns false if there's no container and none is needed\n * because we're only deleting an attribute\n */function checkNewContainer(container,part,nextPart,toDelete){if(container[part]===undefined){if(toDelete)return false;if(typeof nextPart==='number')container[part]=[];else container[part]={};}return true;}function badContainer(container,propStr,propParts){return{set:function set(){throw'bad container';},get:function get(){},astr:propStr,parts:propParts,obj:container};}},{\"./array\":146,\"fast-isnumeric\":10}],168:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';// Simple helper functions\n// none of these need any external deps\nmodule.exports=function noop(){};},{}],169:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var isNumeric=_dereq_('fast-isnumeric');var NOTEDATA=[];/**\n * notifier\n * @param {String} text The person's user name\n * @param {Number} [delay=1000] The delay time in milliseconds\n *          or 'long' which provides 2000 ms delay time.\n * @return {undefined} this function does not return a value\n */module.exports=function(text,displayLength){if(NOTEDATA.indexOf(text)!==-1)return;NOTEDATA.push(text);var ts=1000;if(isNumeric(displayLength))ts=displayLength;else if(displayLength==='long')ts=3000;var notifierContainer=d3.select('body').selectAll('.plotly-notifier').data([0]);notifierContainer.enter().append('div').classed('plotly-notifier',true);var notes=notifierContainer.selectAll('.notifier-note').data(NOTEDATA);function killNote(transition){transition.duration(700).style('opacity',0).each('end',function(thisText){var thisIndex=NOTEDATA.indexOf(thisText);if(thisIndex!==-1)NOTEDATA.splice(thisIndex,1);d3.select(this).remove();});}notes.enter().append('div').classed('notifier-note',true).style('opacity',0).each(function(thisText){var note=d3.select(this);note.append('button').classed('notifier-close',true).html('&times;').on('click',function(){note.transition().call(killNote);});var p=note.append('p');var lines=thisText.split(/<br\\s*\\/?>/g);for(var i=0;i<lines.length;i++){if(i)p.append('br');p.append('span').text(lines[i]);}note.transition().duration(700).style('opacity',1).transition().delay(ts).call(killNote);});};},{\"d3\":8,\"fast-isnumeric\":10}],170:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var setCursor=_dereq_('./setcursor');var STASHATTR='data-savedcursor';var NO_CURSOR='!!';/*\n * works with our CSS cursor classes (see css/_cursor.scss)\n * to override a previous cursor set on d3 single-element selections,\n * by moving the name of the original cursor to the data-savedcursor attr.\n * omit cursor to revert to the previously set value.\n */module.exports=function overrideCursor(el3,csr){var savedCursor=el3.attr(STASHATTR);if(csr){if(!savedCursor){var classes=(el3.attr('class')||'').split(' ');for(var i=0;i<classes.length;i++){var cls=classes[i];if(cls.indexOf('cursor-')===0){el3.attr(STASHATTR,cls.substr(7)).classed(cls,false);}}if(!el3.attr(STASHATTR)){el3.attr(STASHATTR,NO_CURSOR);}}setCursor(el3,csr);}else if(savedCursor){el3.attr(STASHATTR,null);if(savedCursor===NO_CURSOR)setCursor(el3);else setCursor(el3,savedCursor);}};},{\"./setcursor\":178}],171:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var dot=_dereq_('./matrix').dot;var BADNUM=_dereq_('../constants/numerical').BADNUM;var polygon=module.exports={};/**\n * Turn an array of [x, y] pairs into a polygon object\n * that can test if points are inside it\n *\n * @param ptsIn Array of [x, y] pairs\n *\n * @returns polygon Object {xmin, xmax, ymin, ymax, pts, contains}\n *      (x|y)(min|max) are the bounding rect of the polygon\n *      pts is the original array, with the first pair repeated at the end\n *      contains is a function: (pt, omitFirstEdge)\n *          pt is the [x, y] pair to test\n *          omitFirstEdge truthy means points exactly on the first edge don't\n *              count. This is for use adding one polygon to another so we\n *              don't double-count the edge where they meet.\n *          returns boolean: is pt inside the polygon (including on its edges)\n */polygon.tester=function tester(ptsIn){var pts=ptsIn.slice();var xmin=pts[0][0];var xmax=xmin;var ymin=pts[0][1];var ymax=ymin;var i;pts.push(pts[0]);for(i=1;i<pts.length;i++){xmin=Math.min(xmin,pts[i][0]);xmax=Math.max(xmax,pts[i][0]);ymin=Math.min(ymin,pts[i][1]);ymax=Math.max(ymax,pts[i][1]);}// do we have a rectangle? Handle this here, so we can use the same\n// tester for the rectangular case without sacrificing speed\nvar isRect=false;var rectFirstEdgeTest;if(pts.length===5){if(pts[0][0]===pts[1][0]){// vert, horz, vert, horz\nif(pts[2][0]===pts[3][0]&&pts[0][1]===pts[3][1]&&pts[1][1]===pts[2][1]){isRect=true;rectFirstEdgeTest=function rectFirstEdgeTest(pt){return pt[0]===pts[0][0];};}}else if(pts[0][1]===pts[1][1]){// horz, vert, horz, vert\nif(pts[2][1]===pts[3][1]&&pts[0][0]===pts[3][0]&&pts[1][0]===pts[2][0]){isRect=true;rectFirstEdgeTest=function rectFirstEdgeTest(pt){return pt[1]===pts[0][1];};}}}function rectContains(pt,omitFirstEdge){var x=pt[0];var y=pt[1];if(x===BADNUM||x<xmin||x>xmax||y===BADNUM||y<ymin||y>ymax){// pt is outside the bounding box of polygon\nreturn false;}if(omitFirstEdge&&rectFirstEdgeTest(pt))return false;return true;}function contains(pt,omitFirstEdge){var x=pt[0];var y=pt[1];if(x===BADNUM||x<xmin||x>xmax||y===BADNUM||y<ymin||y>ymax){// pt is outside the bounding box of polygon\nreturn false;}var imax=pts.length;var x1=pts[0][0];var y1=pts[0][1];var crossings=0;var i;var x0;var y0;var xmini;var ycross;for(i=1;i<imax;i++){// find all crossings of a vertical line upward from pt with\n// polygon segments\n// crossings exactly at xmax don't count, unless the point is\n// exactly on the segment, then it counts as inside.\nx0=x1;y0=y1;x1=pts[i][0];y1=pts[i][1];xmini=Math.min(x0,x1);if(x<xmini||x>Math.max(x0,x1)||y>Math.max(y0,y1)){// outside the bounding box of this segment, it's only a crossing\n// if it's below the box.\ncontinue;}else if(y<Math.min(y0,y1)){// don't count the left-most point of the segment as a crossing\n// because we don't want to double-count adjacent crossings\n// UNLESS the polygon turns past vertical at exactly this x\n// Note that this is repeated below, but we can't factor it out\n// because\nif(x!==xmini)crossings++;}else{// inside the bounding box, check the actual line intercept\n// vertical segment - we know already that the point is exactly\n// on the segment, so mark the crossing as exactly at the point.\nif(x1===x0)ycross=y;// any other angle\nelse ycross=y0+(x-x0)*(y1-y0)/(x1-x0);// exactly on the edge: counts as inside the polygon, unless it's the\n// first edge and we're omitting it.\nif(y===ycross){if(i===1&&omitFirstEdge)return false;return true;}if(y<=ycross&&x!==xmini)crossings++;}}// if we've gotten this far, odd crossings means inside, even is outside\nreturn crossings%2===1;}// detect if poly is degenerate\nvar degenerate=true;var lastPt=pts[0];for(i=1;i<pts.length;i++){if(lastPt[0]!==pts[i][0]||lastPt[1]!==pts[i][1]){degenerate=false;break;}}return{xmin:xmin,xmax:xmax,ymin:ymin,ymax:ymax,pts:pts,contains:isRect?rectContains:contains,isRect:isRect,degenerate:degenerate};};/**\n * Test if a segment of a points array is bent or straight\n *\n * @param pts Array of [x, y] pairs\n * @param start the index of the proposed start of the straight section\n * @param end the index of the proposed end point\n * @param tolerance the max distance off the line connecting start and end\n *      before the line counts as bent\n * @returns boolean: true means this segment is bent, false means straight\n */polygon.isSegmentBent=function isSegmentBent(pts,start,end,tolerance){var startPt=pts[start];var segment=[pts[end][0]-startPt[0],pts[end][1]-startPt[1]];var segmentSquared=dot(segment,segment);var segmentLen=Math.sqrt(segmentSquared);var unitPerp=[-segment[1]/segmentLen,segment[0]/segmentLen];var i;var part;var partParallel;for(i=start+1;i<end;i++){part=[pts[i][0]-startPt[0],pts[i][1]-startPt[1]];partParallel=dot(part,segment);if(partParallel<0||partParallel>segmentSquared||Math.abs(dot(part,unitPerp))>tolerance)return true;}return false;};/**\n * Make a filtering polygon, to minimize the number of segments\n *\n * @param pts Array of [x, y] pairs (must start with at least 1 pair)\n * @param tolerance the maximum deviation from straight allowed for\n *      removing points to simplify the polygon\n *\n * @returns Object {addPt, raw, filtered}\n *      addPt is a function(pt: [x, y] pair) to add a raw point and\n *          continue filtering\n *      raw is all the input points\n *      filtered is the resulting filtered Array of [x, y] pairs\n */polygon.filter=function filter(pts,tolerance){var ptsFiltered=[pts[0]];var doneRawIndex=0;var doneFilteredIndex=0;function addPt(pt){pts.push(pt);var prevFilterLen=ptsFiltered.length;var iLast=doneRawIndex;ptsFiltered.splice(doneFilteredIndex+1);for(var i=iLast+1;i<pts.length;i++){if(i===pts.length-1||polygon.isSegmentBent(pts,iLast,i+1,tolerance)){ptsFiltered.push(pts[i]);if(ptsFiltered.length<prevFilterLen-2){doneRawIndex=i;doneFilteredIndex=ptsFiltered.length-1;}iLast=i;}}}if(pts.length>1){var lastPt=pts.pop();addPt(lastPt);}return{addPt:addPt,raw:pts,filtered:ptsFiltered};};},{\"../constants/numerical\":140,\"./matrix\":165}],172:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';/**\n * Push array with unique items\n *\n * Ignores falsy items, except 0 so we can use it to construct arrays of indices.\n *\n * @param {array} array\n *  array to be filled\n * @param {any} item\n *  item to be or not to be inserted\n * @return {array}\n *  ref to array (now possibly containing one more item)\n *\n */module.exports=function pushUnique(array,item){if(item instanceof RegExp){var itemStr=item.toString();for(var i=0;i<array.length;i++){if(array[i]instanceof RegExp&&array[i].toString()===itemStr){return array;}}array.push(item);}else if((item||item===0)&&array.indexOf(item)===-1)array.push(item);return array;};},{}],173:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../lib');var dfltConfig=_dereq_('../plot_api/plot_config').dfltConfig;/**\n * Copy arg array *without* removing `undefined` values from objects.\n *\n * @param gd\n * @param args\n * @returns {Array}\n */function copyArgArray(gd,args){var copy=[];var arg;for(var i=0;i<args.length;i++){arg=args[i];if(arg===gd)copy[i]=arg;else if(_typeof(arg)==='object'){copy[i]=Array.isArray(arg)?Lib.extendDeep([],arg):Lib.extendDeepAll({},arg);}else copy[i]=arg;}return copy;}// -----------------------------------------------------\n// Undo/Redo queue for plots\n// -----------------------------------------------------\nvar queue={};// TODO: disable/enable undo and redo buttons appropriately\n/**\n * Add an item to the undoQueue for a graphDiv\n *\n * @param gd\n * @param undoFunc Function undo this operation\n * @param undoArgs Args to supply undoFunc with\n * @param redoFunc Function to redo this operation\n * @param redoArgs Args to supply redoFunc with\n */queue.add=function(gd,undoFunc,undoArgs,redoFunc,redoArgs){var queueObj,queueIndex;// make sure we have the queue and our position in it\ngd.undoQueue=gd.undoQueue||{index:0,queue:[],sequence:false};queueIndex=gd.undoQueue.index;// if we're already playing an undo or redo, or if this is an auto operation\n// (like pane resize... any others?) then we don't save this to the undo queue\nif(gd.autoplay){if(!gd.undoQueue.inSequence)gd.autoplay=false;return;}// if we're not in a sequence or are just starting, we need a new queue item\nif(!gd.undoQueue.sequence||gd.undoQueue.beginSequence){queueObj={undo:{calls:[],args:[]},redo:{calls:[],args:[]}};gd.undoQueue.queue.splice(queueIndex,gd.undoQueue.queue.length-queueIndex,queueObj);gd.undoQueue.index+=1;}else{queueObj=gd.undoQueue.queue[queueIndex-1];}gd.undoQueue.beginSequence=false;// we unshift to handle calls for undo in a forward for loop later\nif(queueObj){queueObj.undo.calls.unshift(undoFunc);queueObj.undo.args.unshift(undoArgs);queueObj.redo.calls.push(redoFunc);queueObj.redo.args.push(redoArgs);}if(gd.undoQueue.queue.length>dfltConfig.queueLength){gd.undoQueue.queue.shift();gd.undoQueue.index--;}};/**\n * Begin a sequence of undoQueue changes\n *\n * @param gd\n */queue.startSequence=function(gd){gd.undoQueue=gd.undoQueue||{index:0,queue:[],sequence:false};gd.undoQueue.sequence=true;gd.undoQueue.beginSequence=true;};/**\n * Stop a sequence of undoQueue changes\n *\n * Call this *after* you're sure your undo chain has ended\n *\n * @param gd\n */queue.stopSequence=function(gd){gd.undoQueue=gd.undoQueue||{index:0,queue:[],sequence:false};gd.undoQueue.sequence=false;gd.undoQueue.beginSequence=false;};/**\n * Move one step back in the undo queue, and undo the object there.\n *\n * @param gd\n */queue.undo=function undo(gd){var queueObj,i;if(gd.framework&&gd.framework.isPolar){gd.framework.undo();return;}if(gd.undoQueue===undefined||isNaN(gd.undoQueue.index)||gd.undoQueue.index<=0){return;}// index is pointing to next *forward* queueObj, point to the one we're undoing\ngd.undoQueue.index--;// get the queueObj for instructions on how to undo\nqueueObj=gd.undoQueue.queue[gd.undoQueue.index];// this sequence keeps things from adding to the queue during undo/redo\ngd.undoQueue.inSequence=true;for(i=0;i<queueObj.undo.calls.length;i++){queue.plotDo(gd,queueObj.undo.calls[i],queueObj.undo.args[i]);}gd.undoQueue.inSequence=false;gd.autoplay=false;};/**\n * Redo the current object in the undo, then move forward in the queue.\n *\n * @param gd\n */queue.redo=function redo(gd){var queueObj,i;if(gd.framework&&gd.framework.isPolar){gd.framework.redo();return;}if(gd.undoQueue===undefined||isNaN(gd.undoQueue.index)||gd.undoQueue.index>=gd.undoQueue.queue.length){return;}// get the queueObj for instructions on how to undo\nqueueObj=gd.undoQueue.queue[gd.undoQueue.index];// this sequence keeps things from adding to the queue during undo/redo\ngd.undoQueue.inSequence=true;for(i=0;i<queueObj.redo.calls.length;i++){queue.plotDo(gd,queueObj.redo.calls[i],queueObj.redo.args[i]);}gd.undoQueue.inSequence=false;gd.autoplay=false;// index is pointing to the thing we just redid, move it\ngd.undoQueue.index++;};/**\n * Called by undo/redo to make the actual changes.\n *\n * Not meant to be called publically, but included for mocking out in tests.\n *\n * @param gd\n * @param func\n * @param args\n */queue.plotDo=function(gd,func,args){gd.autoplay=true;// this *won't* copy gd and it preserves `undefined` properties!\nargs=copyArgArray(gd,args);// call the supplied function\nfunc.apply(null,args);};module.exports=queue;},{\"../lib\":159,\"../plot_api/plot_config\":191}],174:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';/*\n * make a regex for matching counter ids/names ie xaxis, xaxis2, xaxis10...\n *\n * @param {string} head: the head of the pattern, eg 'x' matches 'x', 'x2', 'x10' etc.\n *      'xy' is a special case for cartesian subplots: it matches 'x2y3' etc\n * @param {Optional(string)} tail: a fixed piece after the id\n *      eg counterRegex('scene', '.annotations') for scene2.annotations etc.\n * @param {boolean} openEnded: if true, the string may continue past the match.\n * @param {boolean} matchBeginning: if false, the string may start before the match.\n */exports.counter=function(head,tail,openEnded,matchBeginning){var fullTail=(tail||'')+(openEnded?'':'$');var startWithPrefix=matchBeginning===false?'':'^';if(head==='xy'){return new RegExp(startWithPrefix+'x([2-9]|[1-9][0-9]+)?y([2-9]|[1-9][0-9]+)?'+fullTail);}return new RegExp(startWithPrefix+head+'([2-9]|[1-9][0-9]+)?'+fullTail);};},{}],175:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';// ASCEND: chop off the last nesting level - either [<n>] or .<key> - to ascend\n// the attribute tree. the remaining attrString is in match[1]\nvar ASCEND=/^(.*)(\\.[^\\.\\[\\]]+|\\[\\d\\])$/;// SIMPLEATTR: is this an un-nested attribute? (no dots or brackets)\nvar SIMPLEATTR=/^[^\\.\\[\\]]+$/;/*\n * calculate a relative attribute string, similar to a relative path\n *\n * @param {string} baseAttr:\n *   an attribute string, such as 'annotations[3].x'. The \"current location\"\n *   is the attribute string minus the last component ('annotations[3]')\n * @param {string} relativeAttr:\n *   a route to the desired attribute string, using '^' to ascend\n *\n * @return {string} attrString:\n *   for example:\n *     relativeAttr('annotations[3].x', 'y') = 'annotations[3].y'\n *     relativeAttr('annotations[3].x', '^[2].z') = 'annotations[2].z'\n *     relativeAttr('annotations[3].x', '^^margin') = 'margin'\n *     relativeAttr('annotations[3].x', '^^margin.r') = 'margin.r'\n */module.exports=function(baseAttr,relativeAttr){while(relativeAttr){var match=baseAttr.match(ASCEND);if(match)baseAttr=match[1];else if(baseAttr.match(SIMPLEATTR))baseAttr='';else throw new Error('bad relativeAttr call:'+[baseAttr,relativeAttr]);if(relativeAttr.charAt(0)==='^')relativeAttr=relativeAttr.slice(1);else break;}if(baseAttr&&relativeAttr.charAt(0)!=='['){return baseAttr+'.'+relativeAttr;}return baseAttr+relativeAttr;};},{}],176:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var isArrayOrTypedArray=_dereq_('./array').isArrayOrTypedArray;var isPlainObject=_dereq_('./is_plain_object');/**\n * Relink private _keys and keys with a function value from one container\n * to the new container.\n * Relink means copying if object is pass-by-value and adding a reference\n * if object is pass-by-ref.\n * This prevents deepCopying massive structures like a webgl context.\n */module.exports=function relinkPrivateKeys(toContainer,fromContainer){for(var k in fromContainer){var fromVal=fromContainer[k];var toVal=toContainer[k];if(toVal===fromVal){continue;}if(k.charAt(0)==='_'||typeof fromVal==='function'){// if it already exists at this point, it's something\n// that we recreate each time around, so ignore it\nif(k in toContainer)continue;toContainer[k]=fromVal;}else if(isArrayOrTypedArray(fromVal)&&isArrayOrTypedArray(toVal)&&isPlainObject(fromVal[0])){// filter out data_array items that can contain user objects\n// most of the time the toVal === fromVal check will catch these early\n// but if the user makes new ones we also don't want to recurse in.\nif(k==='customdata'||k==='ids')continue;// recurse into arrays containers\nvar minLen=Math.min(fromVal.length,toVal.length);for(var j=0;j<minLen;j++){if(toVal[j]!==fromVal[j]&&isPlainObject(fromVal[j])&&isPlainObject(toVal[j])){relinkPrivateKeys(toVal[j],fromVal[j]);}}}else if(isPlainObject(fromVal)&&isPlainObject(toVal)){// recurse into objects, but only if they still exist\nrelinkPrivateKeys(toVal,fromVal);if(!Object.keys(toVal).length)delete toContainer[k];}}};},{\"./array\":146,\"./is_plain_object\":160}],177:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var isNumeric=_dereq_('fast-isnumeric');var loggers=_dereq_('./loggers');var identity=_dereq_('./identity');// don't trust floating point equality - fraction of bin size to call\n// \"on the line\" and ensure that they go the right way specified by\n// linelow\nvar roundingError=1e-9;/**\n * findBin - find the bin for val - note that it can return outside the\n * bin range any pos. or neg. integer for linear bins, or -1 or\n * bins.length-1 for explicit.\n * bins is either an object {start,size,end} or an array length #bins+1\n * bins can be either increasing or decreasing but must be monotonic\n * for linear bins, we can just calculate. For listed bins, run a binary\n * search linelow (truthy) says the bin boundary should be attributed to\n * the lower bin rather than the default upper bin\n */exports.findBin=function(val,bins,linelow){if(isNumeric(bins.start)){return linelow?Math.ceil((val-bins.start)/bins.size-roundingError)-1:Math.floor((val-bins.start)/bins.size+roundingError);}else{var n1=0;var n2=bins.length;var c=0;var binSize=n2>1?(bins[n2-1]-bins[0])/(n2-1):1;var n,test;if(binSize>=0){test=linelow?lessThan:lessOrEqual;}else{test=linelow?greaterOrEqual:greaterThan;}val+=binSize*roundingError*(linelow?-1:1)*(binSize>=0?1:-1);// c is just to avoid infinite loops if there's an error\nwhile(n1<n2&&c++<100){n=Math.floor((n1+n2)/2);if(test(bins[n],val))n1=n+1;else n2=n;}if(c>90)loggers.log('Long binary search...');return n1-1;}};function lessThan(a,b){return a<b;}function lessOrEqual(a,b){return a<=b;}function greaterThan(a,b){return a>b;}function greaterOrEqual(a,b){return a>=b;}exports.sorterAsc=function(a,b){return a-b;};exports.sorterDes=function(a,b){return b-a;};/**\n * find distinct values in an array, lumping together ones that appear to\n * just be off by a rounding error\n * return the distinct values and the minimum difference between any two\n */exports.distinctVals=function(valsIn){var vals=valsIn.slice();// otherwise we sort the original array...\nvals.sort(exports.sorterAsc);var l=vals.length-1;var minDiff=vals[l]-vals[0]||1;var errDiff=minDiff/(l||1)/10000;var v2=[vals[0]];for(var i=0;i<l;i++){// make sure values aren't just off by a rounding error\nif(vals[i+1]>vals[i]+errDiff){minDiff=Math.min(minDiff,vals[i+1]-vals[i]);v2.push(vals[i+1]);}}return{vals:v2,minDiff:minDiff};};/**\n * return the smallest element from (sorted) array arrayIn that's bigger than val,\n * or (reverse) the largest element smaller than val\n * used to find the best tick given the minimum (non-rounded) tick\n * particularly useful for date/time where things are not powers of 10\n * binary search is probably overkill here...\n */exports.roundUp=function(val,arrayIn,reverse){var low=0;var high=arrayIn.length-1;var mid;var c=0;var dlow=reverse?0:1;var dhigh=reverse?1:0;var rounded=reverse?Math.ceil:Math.floor;// c is just to avoid infinite loops if there's an error\nwhile(low<high&&c++<100){mid=rounded((low+high)/2);if(arrayIn[mid]<=val)low=mid+dlow;else high=mid-dhigh;}return arrayIn[low];};/**\n * Tweak to Array.sort(sortFn) that improves performance for pre-sorted arrays\n *\n * Note that newer browsers (such as Chrome v70+) are starting to pick up\n * on pre-sorted arrays which may render the following optimization unnecessary\n * in the future.\n *\n * Motivation: sometimes we need to sort arrays but the input is likely to\n * already be sorted. Browsers don't seem to pick up on pre-sorted arrays,\n * and in fact Chrome is actually *slower* sorting pre-sorted arrays than purely\n * random arrays. FF is at least faster if the array is pre-sorted, but still\n * not as fast as it could be.\n * Here's how this plays out sorting a length-1e6 array:\n *\n * Calls to Sort FN  |  Chrome bare  |  FF bare  |  Chrome tweak  |  FF tweak\n *                   |  v68.0 Mac    |  v61.0 Mac|                |\n * ------------------+---------------+-----------+----------------+------------\n * ordered           |  30.4e6       |  10.1e6   |  1e6           |  1e6\n * reversed          |  29.4e6       |  9.9e6    |  1e6 + reverse |  1e6 + reverse\n * random            |  ~21e6        |  ~18.7e6  |  ~21e6         |  ~18.7e6\n *\n * So this is a substantial win for pre-sorted (ordered or exactly reversed)\n * arrays. Including this wrapper on an unsorted array adds a penalty that will\n * in general be only a few calls to the sort function. The only case this\n * penalty will be significant is if the array is mostly sorted but there are\n * a few unsorted items near the end, but the penalty is still at most N calls\n * out of (for N=1e6) ~20N total calls\n *\n * @param {Array} array: the array, to be sorted in place\n * @param {function} sortFn: As in Array.sort, function(a, b) that puts\n *     item a before item b if the return is negative, a after b if positive,\n *     and no change if zero.\n * @return {Array}: the original array, sorted in place.\n */exports.sort=function(array,sortFn){var notOrdered=0;var notReversed=0;for(var i=1;i<array.length;i++){var pairOrder=sortFn(array[i],array[i-1]);if(pairOrder<0)notOrdered=1;else if(pairOrder>0)notReversed=1;if(notOrdered&&notReversed)return array.sort(sortFn);}return notReversed?array:array.reverse();};/**\n * find index in array 'arr' that minimizes 'fn'\n *\n * @param {array} arr : array where to search\n * @param {fn (optional)} fn : function to minimize,\n *   if not given, fn is the identity function\n * @return {integer}\n */exports.findIndexOfMin=function(arr,fn){fn=fn||identity;var min=Infinity;var ind;for(var i=0;i<arr.length;i++){var v=fn(arr[i]);if(v<min){min=v;ind=i;}}return ind;};},{\"./identity\":158,\"./loggers\":163,\"fast-isnumeric\":10}],178:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';// works with our CSS cursor classes (see css/_cursor.scss)\n// to apply cursors to d3 single-element selections.\n// omit cursor to revert to the default.\nmodule.exports=function setCursor(el3,csr){(el3.attr('class')||'').split(' ').forEach(function(cls){if(cls.indexOf('cursor-')===0)el3.classed(cls,false);});if(csr)el3.classed('cursor-'+csr,true);};},{}],179:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var isNumeric=_dereq_('fast-isnumeric');var isArrayOrTypedArray=_dereq_('./array').isArrayOrTypedArray;/**\n * aggNums() returns the result of an aggregate function applied to an array of\n * values, where non-numerical values have been tossed out.\n *\n * @param {function} f - aggregation function (e.g., Math.min)\n * @param {Number} v - initial value (continuing from previous calls)\n *      if there's no continuing value, use null for selector-type\n *      functions (max,min), or 0 for summations\n * @param {Array} a - array to aggregate (may be nested, we will recurse,\n *                    but all elements must have the same dimension)\n * @param {Number} len - maximum length of a to aggregate\n * @return {Number} - result of f applied to a starting from v\n */exports.aggNums=function(f,v,a,len){var i,b;if(!len||len>a.length)len=a.length;if(!isNumeric(v))v=false;if(isArrayOrTypedArray(a[0])){b=new Array(len);for(i=0;i<len;i++){b[i]=exports.aggNums(f,v,a[i]);}a=b;}for(i=0;i<len;i++){if(!isNumeric(v))v=a[i];else if(isNumeric(a[i]))v=f(+v,+a[i]);}return v;};/**\n * mean & std dev functions using aggNums, so it handles non-numerics nicely\n * even need to use aggNums instead of .length, to toss out non-numerics\n */exports.len=function(data){return exports.aggNums(function(a){return a+1;},0,data);};exports.mean=function(data,len){if(!len)len=exports.len(data);return exports.aggNums(function(a,b){return a+b;},0,data)/len;};exports.midRange=function(numArr){if(numArr===undefined||numArr.length===0)return undefined;return(exports.aggNums(Math.max,null,numArr)+exports.aggNums(Math.min,null,numArr))/2;};exports.variance=function(data,len,mean){if(!len)len=exports.len(data);if(!isNumeric(mean))mean=exports.mean(data,len);return exports.aggNums(function(a,b){return a+Math.pow(b-mean,2);},0,data)/len;};exports.stdev=function(data,len,mean){return Math.sqrt(exports.variance(data,len,mean));};/**\n * interp() computes a percentile (quantile) for a given distribution.\n * We interpolate the distribution (to compute quantiles, we follow method #10 here:\n * http://www.amstat.org/publications/jse/v14n3/langford.html).\n * Typically the index or rank (n * arr.length) may be non-integer.\n * For reference: ends are clipped to the extreme values in the array;\n * For box plots: index you get is half a point too high (see\n * http://en.wikipedia.org/wiki/Percentile#Nearest_rank) but note that this definition\n * indexes from 1 rather than 0, so we subtract 1/2 (instead of add).\n *\n * @param {Array} arr - This array contains the values that make up the distribution.\n * @param {Number} n - Between 0 and 1, n = p/100 is such that we compute the p^th percentile.\n * For example, the 50th percentile (or median) corresponds to n = 0.5\n * @return {Number} - percentile\n */exports.interp=function(arr,n){if(!isNumeric(n))throw'n should be a finite number';n=n*arr.length-0.5;if(n<0)return arr[0];if(n>arr.length-1)return arr[arr.length-1];var frac=n%1;return frac*arr[Math.ceil(n)]+(1-frac)*arr[Math.floor(n)];};},{\"./array\":146,\"fast-isnumeric\":10}],180:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';/* global MathJax:false */var d3=_dereq_('d3');var Lib=_dereq_('../lib');var xmlnsNamespaces=_dereq_('../constants/xmlns_namespaces');var LINE_SPACING=_dereq_('../constants/alignment').LINE_SPACING;// text converter\nfunction getSize(_selection,_dimension){return _selection.node().getBoundingClientRect()[_dimension];}var FIND_TEX=/([^$]*)([$]+[^$]*[$]+)([^$]*)/;exports.convertToTspans=function(_context,gd,_callback){var str=_context.text();// Until we get tex integrated more fully (so it can be used along with non-tex)\n// allow some elements to prohibit it by attaching 'data-notex' to the original\nvar tex=!_context.attr('data-notex')&&typeof MathJax!=='undefined'&&str.match(FIND_TEX);var parent=d3.select(_context.node().parentNode);if(parent.empty())return;var svgClass=_context.attr('class')?_context.attr('class').split(' ')[0]:'text';svgClass+='-math';parent.selectAll('svg.'+svgClass).remove();parent.selectAll('g.'+svgClass+'-group').remove();_context.style('display',null).attr({// some callers use data-unformatted *from the <text> element* in 'cancel'\n// so we need it here even if we're going to turn it into math\n// these two (plus style and text-anchor attributes) form the key we're\n// going to use for Drawing.bBox\n'data-unformatted':str,'data-math':'N'});function showText(){if(!parent.empty()){svgClass=_context.attr('class')+'-math';parent.select('svg.'+svgClass).remove();}_context.text('').style('white-space','pre');var hasLink=buildSVGText(_context.node(),str);if(hasLink){// at least in Chrome, pointer-events does not seem\n// to be honored in children of <text> elements\n// so if we have an anchor, we have to make the\n// whole element respond\n_context.style('pointer-events','all');}exports.positionText(_context);if(_callback)_callback.call(_context);}if(tex){(gd&&gd._promises||[]).push(new Promise(function(resolve){_context.style('display','none');var fontSize=parseInt(_context.node().style.fontSize,10);var config={fontSize:fontSize};texToSVG(tex[2],config,function(_svgEl,_glyphDefs,_svgBBox){parent.selectAll('svg.'+svgClass).remove();parent.selectAll('g.'+svgClass+'-group').remove();var newSvg=_svgEl&&_svgEl.select('svg');if(!newSvg||!newSvg.node()){showText();resolve();return;}var mathjaxGroup=parent.append('g').classed(svgClass+'-group',true).attr({'pointer-events':'none','data-unformatted':str,'data-math':'Y'});mathjaxGroup.node().appendChild(newSvg.node());// stitch the glyph defs\nif(_glyphDefs&&_glyphDefs.node()){newSvg.node().insertBefore(_glyphDefs.node().cloneNode(true),newSvg.node().firstChild);}newSvg.attr({'class':svgClass,height:_svgBBox.height,preserveAspectRatio:'xMinYMin meet'}).style({overflow:'visible','pointer-events':'none'});var fill=_context.node().style.fill||'black';var g=newSvg.select('g');g.attr({fill:fill,stroke:fill});var newSvgW=getSize(g,'width');var newSvgH=getSize(g,'height');var newX=+_context.attr('x')-newSvgW*{start:0,middle:0.5,end:1}[_context.attr('text-anchor')||'start'];// font baseline is about 1/4 fontSize below centerline\nvar textHeight=fontSize||getSize(_context,'height');var dy=-textHeight/4;if(svgClass[0]==='y'){mathjaxGroup.attr({transform:'rotate('+[-90,+_context.attr('x'),+_context.attr('y')]+') translate('+[-newSvgW/2,dy-newSvgH/2]+')'});newSvg.attr({x:+_context.attr('x'),y:+_context.attr('y')});}else if(svgClass[0]==='l'){newSvg.attr({x:_context.attr('x'),y:dy-newSvgH/2});}else if(svgClass[0]==='a'&&svgClass.indexOf('atitle')!==0){newSvg.attr({x:0,y:dy});}else{newSvg.attr({x:newX,y:+_context.attr('y')+dy-newSvgH/2});}if(_callback)_callback.call(_context,mathjaxGroup);resolve(mathjaxGroup);});}));}else showText();return _context;};// MathJax\nvar LT_MATCH=/(<|&lt;|&#60;)/g;var GT_MATCH=/(>|&gt;|&#62;)/g;function cleanEscapesForTex(s){return s.replace(LT_MATCH,'\\\\lt ').replace(GT_MATCH,'\\\\gt ');}function texToSVG(_texString,_config,_callback){var originalRenderer,originalConfig,originalProcessSectionDelay,tmpDiv;MathJax.Hub.Queue(function(){originalConfig=Lib.extendDeepAll({},MathJax.Hub.config);originalProcessSectionDelay=MathJax.Hub.processSectionDelay;if(MathJax.Hub.processSectionDelay!==undefined){// MathJax 2.5+\nMathJax.Hub.processSectionDelay=0;}return MathJax.Hub.Config({messageStyle:'none',tex2jax:{inlineMath:[['$','$'],['\\\\(','\\\\)']]},displayAlign:'left'});},function(){// Get original renderer\noriginalRenderer=MathJax.Hub.config.menuSettings.renderer;if(originalRenderer!=='SVG'){return MathJax.Hub.setRenderer('SVG');}},function(){var randomID='math-output-'+Lib.randstr({},64);tmpDiv=d3.select('body').append('div').attr({id:randomID}).style({visibility:'hidden',position:'absolute'}).style({'font-size':_config.fontSize+'px'}).text(cleanEscapesForTex(_texString));return MathJax.Hub.Typeset(tmpDiv.node());},function(){var glyphDefs=d3.select('body').select('#MathJax_SVG_glyphs');if(tmpDiv.select('.MathJax_SVG').empty()||!tmpDiv.select('svg').node()){Lib.log('There was an error in the tex syntax.',_texString);_callback();}else{var svgBBox=tmpDiv.select('svg').node().getBoundingClientRect();_callback(tmpDiv.select('.MathJax_SVG'),glyphDefs,svgBBox);}tmpDiv.remove();if(originalRenderer!=='SVG'){return MathJax.Hub.setRenderer(originalRenderer);}},function(){if(originalProcessSectionDelay!==undefined){MathJax.Hub.processSectionDelay=originalProcessSectionDelay;}return MathJax.Hub.Config(originalConfig);});}var TAG_STYLES={// would like to use baseline-shift for sub/sup but FF doesn't support it\n// so we need to use dy along with the uber hacky shift-back-to\n// baseline below\nsup:'font-size:70%',sub:'font-size:70%',b:'font-weight:bold',i:'font-style:italic',a:'cursor:pointer',span:'',em:'font-style:italic;font-weight:bold'};// baseline shifts for sub and sup\nvar SHIFT_DY={sub:'0.3em',sup:'-0.6em'};// reset baseline by adding a tspan (empty except for a zero-width space)\n// with dy of -70% * SHIFT_DY (because font-size=70%)\nvar RESET_DY={sub:'-0.21em',sup:'0.42em'};var ZERO_WIDTH_SPACE=\"\\u200B\";/*\n * Whitelist of protocols in user-supplied urls. Mostly we want to avoid javascript\n * and related attack vectors. The empty items are there for IE, that in various\n * versions treats relative paths as having different flavors of no protocol, while\n * other browsers have these explicitly inherit the protocol of the page they're in.\n */var PROTOCOLS=['http:','https:','mailto:','',undefined,':'];var NEWLINES=/(\\r\\n?|\\n)/g;var SPLIT_TAGS=/(<[^<>]*>)/;var ONE_TAG=/<(\\/?)([^ >]*)(\\s+(.*))?>/i;var BR_TAG=/<br(\\s+.*)?>/i;/*\n * style and href: pull them out of either single or double quotes. Also\n * - target: (_blank|_self|_parent|_top|framename)\n *     note that you can't use target to get a popup but if you use popup,\n *     a `framename` will be passed along as the name of the popup window.\n *     per the spec, cannot contain whitespace.\n *     for backward compatibility we default to '_blank'\n * - popup: a custom one for us to enable popup (new window) links. String\n *     for window.open -> strWindowFeatures, like 'menubar=yes,width=500,height=550'\n *     note that at least in Chrome, you need to give at least one property\n *     in this string or the page will open in a new tab anyway. We follow this\n *     convention and will not make a popup if this string is empty.\n *     per the spec, cannot contain whitespace.\n *\n * Because we hack in other attributes with style (sub & sup), drop any trailing\n * semicolon in user-supplied styles so we can consistently append the tag-dependent style\n *\n * These are for tag attributes; Chrome anyway will convert entities in\n * attribute values, but not in attribute names\n * you can test this by for example:\n * > p = document.createElement('p')\n * > p.innerHTML = '<span styl&#x65;=\"font-color:r&#x65;d;\">Hi</span>'\n * > p.innerHTML\n * <- '<span styl&#x65;=\"font-color:red;\">Hi</span>'\n */var STYLEMATCH=/(^|[\\s\"'])style\\s*=\\s*(\"([^\"]*);?\"|'([^']*);?')/i;var HREFMATCH=/(^|[\\s\"'])href\\s*=\\s*(\"([^\"]*)\"|'([^']*)')/i;var TARGETMATCH=/(^|[\\s\"'])target\\s*=\\s*(\"([^\"\\s]*)\"|'([^'\\s]*)')/i;var POPUPMATCH=/(^|[\\s\"'])popup\\s*=\\s*(\"([\\w=,]*)\"|'([\\w=,]*)')/i;// dedicated matcher for these quoted regexes, that can return their results\n// in two different places\nfunction getQuotedMatch(_str,re){if(!_str)return null;var match=_str.match(re);var result=match&&(match[3]||match[4]);return result&&convertEntities(result);}var COLORMATCH=/(^|;)\\s*color:/;/**\n * Strip string of tags\n *\n * @param {string} _str : input string\n * @param {object} opts :\n * - len {number} max length of output string\n * - allowedTags {array} list of pseudo-html tags to NOT strip\n * @return {string}\n */exports.plainText=function(_str,opts){opts=opts||{};var len=opts.len!==undefined&&opts.len!==-1?opts.len:Infinity;var allowedTags=opts.allowedTags!==undefined?opts.allowedTags:['br'];var ellipsis='...';var eLen=ellipsis.length;var oldParts=_str.split(SPLIT_TAGS);var newParts=[];var prevTag='';var l=0;for(var i=0;i<oldParts.length;i++){var p=oldParts[i];var match=p.match(ONE_TAG);var tagType=match&&match[2].toLowerCase();if(tagType){// N.B. tags do not count towards string length\nif(allowedTags.indexOf(tagType)!==-1){newParts.push(p);prevTag=tagType;}}else{var pLen=p.length;if(l+pLen<len){newParts.push(p);l+=pLen;}else if(l<len){var pLen2=len-l;if(prevTag&&(prevTag!=='br'||pLen2<=eLen||pLen<=eLen)){newParts.pop();}if(len>eLen){newParts.push(p.substr(0,pLen2-eLen)+ellipsis);}else{newParts.push(p.substr(0,pLen2));}break;}prevTag='';}}return newParts.join('');};/*\n * N.B. HTML entities are listed without the leading '&' and trailing ';'\n * https://www.freeformatter.com/html-entities.html\n *\n * FWIW if we wanted to support the full set, it has 2261 entries:\n * https://www.w3.org/TR/html5/entities.json\n * though I notice that some of these are duplicates and/or are missing \";\"\n * eg: \"&amp;\", \"&amp\", \"&AMP;\", and \"&AMP\" all map to \"&\"\n * We no longer need to include numeric entities here, these are now handled\n * by String.fromCodePoint/fromCharCode\n *\n * Anyway the only ones that are really important to allow are the HTML special\n * chars <, >, and &, because these ones can trigger special processing if not\n * replaced by the corresponding entity.\n */var entityToUnicode={mu:'',amp:'&',lt:'<',gt:'>',nbsp:'',times:'',plusmn:'',deg:''};// NOTE: in general entities can contain uppercase too (so [a-zA-Z]) but all the\n// ones we support use only lowercase. If we ever change that, update the regex.\nvar ENTITY_MATCH=/&(#\\d+|#x[\\da-fA-F]+|[a-z]+);/g;function convertEntities(_str){return _str.replace(ENTITY_MATCH,function(fullMatch,innerMatch){var outChar;if(innerMatch.charAt(0)==='#'){// cannot use String.fromCodePoint in IE\noutChar=fromCodePoint(innerMatch.charAt(1)==='x'?parseInt(innerMatch.substr(2),16):parseInt(innerMatch.substr(1),10));}else outChar=entityToUnicode[innerMatch];// as in regular HTML, if we didn't decode the entity just\n// leave the raw text in place.\nreturn outChar||fullMatch;});}exports.convertEntities=convertEntities;function fromCodePoint(code){// Don't allow overflow. In Chrome this turns into  but I feel like it's\n// more useful to just not convert it at all.\nif(code>0x10FFFF)return;var stringFromCodePoint=String.fromCodePoint;if(stringFromCodePoint)return stringFromCodePoint(code);// IE doesn't have String.fromCodePoint\n// see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint\nvar stringFromCharCode=String.fromCharCode;if(code<=0xFFFF)return stringFromCharCode(code);return stringFromCharCode((code>>10)+0xD7C0,code%0x400+0xDC00);}/*\n * buildSVGText: convert our pseudo-html into SVG tspan elements, and attach these\n * to containerNode\n *\n * @param {svg text element} containerNode: the <text> node to insert this text into\n * @param {string} str: the pseudo-html string to convert to svg\n *\n * @returns {bool}: does the result contain any links? We need to handle the text element\n *   somewhat differently if it does, so just keep track of this when it happens.\n */function buildSVGText(containerNode,str){/*\n     * Normalize behavior between IE and others wrt newlines and whitespace:pre\n     * this combination makes IE barf https://github.com/plotly/plotly.js/issues/746\n     * Chrome and FF display \\n, \\r, or \\r\\n as a space in this mode.\n     * I feel like at some point we turned these into <br> but currently we don't so\n     * I'm just going to cement what we do now in Chrome and FF\n     */str=str.replace(NEWLINES,' ');var hasLink=false;// as we're building the text, keep track of what elements we're nested inside\n// nodeStack will be an array of {node, type, style, href, target, popup}\n// where only type: 'a' gets the last 3 and node is only added when it's created\nvar nodeStack=[];var currentNode;var currentLine=-1;function newLine(){currentLine++;var lineNode=document.createElementNS(xmlnsNamespaces.svg,'tspan');d3.select(lineNode).attr({\"class\":'line',dy:currentLine*LINE_SPACING+'em'});containerNode.appendChild(lineNode);currentNode=lineNode;var oldNodeStack=nodeStack;nodeStack=[{node:lineNode}];if(oldNodeStack.length>1){for(var i=1;i<oldNodeStack.length;i++){enterNode(oldNodeStack[i]);}}}function enterNode(nodeSpec){var type=nodeSpec.type;var nodeAttrs={};var nodeType;if(type==='a'){nodeType='a';var target=nodeSpec.target;var href=nodeSpec.href;var popup=nodeSpec.popup;if(href){nodeAttrs={'xlink:xlink:show':target==='_blank'||target.charAt(0)!=='_'?'new':'replace',target:target,'xlink:xlink:href':href};if(popup){// security: href and target are not inserted as code but\n// as attributes. popup is, but limited to /[A-Za-z0-9_=,]/\nnodeAttrs.onclick='window.open(this.href.baseVal,this.target.baseVal,\"'+popup+'\");return false;';}}}else nodeType='tspan';if(nodeSpec.style)nodeAttrs.style=nodeSpec.style;var newNode=document.createElementNS(xmlnsNamespaces.svg,nodeType);if(type==='sup'||type==='sub'){addTextNode(currentNode,ZERO_WIDTH_SPACE);currentNode.appendChild(newNode);var resetter=document.createElementNS(xmlnsNamespaces.svg,'tspan');addTextNode(resetter,ZERO_WIDTH_SPACE);d3.select(resetter).attr('dy',RESET_DY[type]);nodeAttrs.dy=SHIFT_DY[type];currentNode.appendChild(newNode);currentNode.appendChild(resetter);}else{currentNode.appendChild(newNode);}d3.select(newNode).attr(nodeAttrs);currentNode=nodeSpec.node=newNode;nodeStack.push(nodeSpec);}function addTextNode(node,text){node.appendChild(document.createTextNode(text));}function exitNode(type){// A bare closing tag can't close the root node. If we encounter this it\n// means there's an extra closing tag that can just be ignored:\nif(nodeStack.length===1){Lib.log('Ignoring unexpected end tag </'+type+'>.',str);return;}var innerNode=nodeStack.pop();if(type!==innerNode.type){Lib.log('Start tag <'+innerNode.type+'> doesnt match end tag <'+type+'>. Pretending it did match.',str);}currentNode=nodeStack[nodeStack.length-1].node;}var hasLines=BR_TAG.test(str);if(hasLines)newLine();else{currentNode=containerNode;nodeStack=[{node:containerNode}];}var parts=str.split(SPLIT_TAGS);for(var i=0;i<parts.length;i++){var parti=parts[i];var match=parti.match(ONE_TAG);var tagType=match&&match[2].toLowerCase();var tagStyle=TAG_STYLES[tagType];if(tagType==='br'){newLine();}else if(tagStyle===undefined){addTextNode(currentNode,convertEntities(parti));}else{// tag - open or close\nif(match[1]){exitNode(tagType);}else{var extra=match[4];var nodeSpec={type:tagType};// now add style, from both the tag name and any extra css\n// Most of the svg css that users will care about is just like html,\n// but font color is different (uses fill). Let our users ignore this.\nvar css=getQuotedMatch(extra,STYLEMATCH);if(css){css=css.replace(COLORMATCH,'$1 fill:');if(tagStyle)css+=';'+tagStyle;}else if(tagStyle)css=tagStyle;if(css)nodeSpec.style=css;if(tagType==='a'){hasLink=true;var href=getQuotedMatch(extra,HREFMATCH);if(href){// check safe protocols\nvar dummyAnchor=document.createElement('a');dummyAnchor.href=href;if(PROTOCOLS.indexOf(dummyAnchor.protocol)!==-1){// Decode href to allow both already encoded and not encoded\n// URIs. Without decoding prior encoding, an already encoded\n// URI would be encoded twice producing a semantically different URI.\nnodeSpec.href=encodeURI(decodeURI(href));nodeSpec.target=getQuotedMatch(extra,TARGETMATCH)||'_blank';nodeSpec.popup=getQuotedMatch(extra,POPUPMATCH);}}}enterNode(nodeSpec);}}}return hasLink;}exports.lineCount=function lineCount(s){return s.selectAll('tspan.line').size()||1;};exports.positionText=function positionText(s,x,y){return s.each(function(){var text=d3.select(this);function setOrGet(attr,val){if(val===undefined){val=text.attr(attr);if(val===null){text.attr(attr,0);val=0;}}else text.attr(attr,val);return val;}var thisX=setOrGet('x',x);var thisY=setOrGet('y',y);if(this.nodeName==='text'){text.selectAll('tspan.line').attr({x:thisX,y:thisY});}});};function alignHTMLWith(_base,container,options){var alignH=options.horizontalAlign;var alignV=options.verticalAlign||'top';var bRect=_base.node().getBoundingClientRect();var cRect=container.node().getBoundingClientRect();var thisRect;var getTop;var getLeft;if(alignV==='bottom'){getTop=function getTop(){return bRect.bottom-thisRect.height;};}else if(alignV==='middle'){getTop=function getTop(){return bRect.top+(bRect.height-thisRect.height)/2;};}else{// default: top\ngetTop=function getTop(){return bRect.top;};}if(alignH==='right'){getLeft=function getLeft(){return bRect.right-thisRect.width;};}else if(alignH==='center'){getLeft=function getLeft(){return bRect.left+(bRect.width-thisRect.width)/2;};}else{// default: left\ngetLeft=function getLeft(){return bRect.left;};}return function(){thisRect=this.node().getBoundingClientRect();this.style({top:getTop()-cRect.top+'px',left:getLeft()-cRect.left+'px','z-index':1000});return this;};}/*\n * Editable title\n * @param {d3.selection} context: the element being edited. Normally text,\n *   but if it isn't, you should provide the styling options\n * @param {object} options:\n *   @param {div} options.gd: graphDiv\n *   @param {d3.selection} options.delegate: item to bind events to if not this\n *   @param {boolean} options.immediate: start editing now (true) or on click (false, default)\n *   @param {string} options.fill: font color if not as shown\n *   @param {string} options.background: background color if not as shown\n *   @param {string} options.text: initial text, if not as shown\n *   @param {string} options.horizontalAlign: alignment of the edit box wrt. the bound element\n *   @param {string} options.verticalAlign: alignment of the edit box wrt. the bound element\n */exports.makeEditable=function(context,options){var gd=options.gd;var _delegate=options.delegate;var dispatch=d3.dispatch('edit','input','cancel');var handlerElement=_delegate||context;context.style({'pointer-events':_delegate?'none':'all'});if(context.size()!==1)throw new Error('boo');function handleClick(){appendEditable();context.style({opacity:0});// also hide any mathjax svg\nvar svgClass=handlerElement.attr('class');var mathjaxClass;if(svgClass)mathjaxClass='.'+svgClass.split(' ')[0]+'-math-group';else mathjaxClass='[class*=-math-group]';if(mathjaxClass){d3.select(context.node().parentNode).select(mathjaxClass).style({opacity:0});}}function selectElementContents(_el){var el=_el.node();var range=document.createRange();range.selectNodeContents(el);var sel=window.getSelection();sel.removeAllRanges();sel.addRange(range);el.focus();}function appendEditable(){var plotDiv=d3.select(gd);var container=plotDiv.select('.svg-container');var div=container.append('div');var cStyle=context.node().style;var fontSize=parseFloat(cStyle.fontSize||12);var initialText=options.text;if(initialText===undefined)initialText=context.attr('data-unformatted');div.classed('plugin-editable editable',true).style({position:'absolute','font-family':cStyle.fontFamily||'Arial','font-size':fontSize,color:options.fill||cStyle.fill||'black',opacity:1,'background-color':options.background||'transparent',outline:'#ffffff33 1px solid',margin:[-fontSize/8+1,0,0,-1].join('px ')+'px',padding:'0','box-sizing':'border-box'}).attr({contenteditable:true}).text(initialText).call(alignHTMLWith(context,container,options)).on('blur',function(){gd._editing=false;context.text(this.textContent).style({opacity:1});var svgClass=d3.select(this).attr('class');var mathjaxClass;if(svgClass)mathjaxClass='.'+svgClass.split(' ')[0]+'-math-group';else mathjaxClass='[class*=-math-group]';if(mathjaxClass){d3.select(context.node().parentNode).select(mathjaxClass).style({opacity:0});}var text=this.textContent;d3.select(this).transition().duration(0).remove();d3.select(document).on('mouseup',null);dispatch.edit.call(context,text);}).on('focus',function(){var editDiv=this;gd._editing=true;d3.select(document).on('mouseup',function(){if(d3.event.target===editDiv)return false;if(document.activeElement===div.node())div.node().blur();});}).on('keyup',function(){if(d3.event.which===27){gd._editing=false;context.style({opacity:1});d3.select(this).style({opacity:0}).on('blur',function(){return false;}).transition().remove();dispatch.cancel.call(context,this.textContent);}else{dispatch.input.call(context,this.textContent);d3.select(this).call(alignHTMLWith(context,container,options));}}).on('keydown',function(){if(d3.event.which===13)this.blur();}).call(selectElementContents);}if(options.immediate)handleClick();else handlerElement.on('click',handleClick);return d3.rebind(context,dispatch,'on');};},{\"../constants/alignment\":138,\"../constants/xmlns_namespaces\":141,\"../lib\":159,\"d3\":8}],181:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var timerCache={};/**\n * Throttle a callback. `callback` executes synchronously only if\n * more than `minInterval` milliseconds have already elapsed since the latest\n * call (if any). Otherwise we wait until `minInterval` is over and execute the\n * last callback received while waiting.\n * So the first and last events in a train are always executed (eventually)\n * but some of the events in the middle can be dropped.\n *\n * @param {string} id: an identifier to mark events to throttle together\n * @param {number} minInterval: minimum time, in milliseconds, between\n *   invocations of `callback`\n * @param {function} callback: the function to throttle. `callback` itself\n *   should be a purely synchronous function.\n */exports.throttle=function throttle(id,minInterval,callback){var cache=timerCache[id];var now=Date.now();if(!cache){/*\n         * Throw out old items before making a new one, to prevent the cache\n         * getting overgrown, for example from old plots that have been replaced.\n         * 1 minute age is arbitrary.\n         */for(var idi in timerCache){if(timerCache[idi].ts<now-60000){delete timerCache[idi];}}cache=timerCache[id]={ts:0,timer:null};}_clearTimeout(cache);function exec(){callback();cache.ts=Date.now();if(cache.onDone){cache.onDone();cache.onDone=null;}}if(now>cache.ts+minInterval){exec();return;}cache.timer=setTimeout(function(){exec();cache.timer=null;},minInterval);};exports.done=function(id){var cache=timerCache[id];if(!cache||!cache.timer)return Promise.resolve();return new Promise(function(resolve){var previousOnDone=cache.onDone;cache.onDone=function onDone(){if(previousOnDone)previousOnDone();resolve();cache.onDone=null;};});};/**\n * Clear the throttle cache for one or all timers\n * @param {optional string} id:\n *   if provided, clear just this timer\n *   if omitted, clear all timers (mainly useful for testing)\n */exports.clear=function(id){if(id){_clearTimeout(timerCache[id]);delete timerCache[id];}else{for(var idi in timerCache){exports.clear(idi);}}};function _clearTimeout(cache){if(cache&&cache.timer!==null){clearTimeout(cache.timer);cache.timer=null;}}},{}],182:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var isNumeric=_dereq_('fast-isnumeric');/**\n * convert a linear value into a logged value, folding negative numbers into\n * the given range\n */module.exports=function toLogRange(val,range){if(val>0)return Math.log(val)/Math.LN10;// move a negative value reference to a log axis - just put the\n// result at the lowest range value on the plot (or if the range also went negative,\n// one millionth of the top of the range)\nvar newVal=Math.log(Math.min(range[0],range[1]))/Math.LN10;if(!isNumeric(newVal))newVal=Math.log(Math.max(range[0],range[1]))/Math.LN10-6;return newVal;};},{\"fast-isnumeric\":10}],183:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports={moduleType:'locale',name:'en-US',dictionary:{'Click to enter Colorscale title':'Click to enter Colorscale title'},format:{date:'%m/%d/%Y'}};},{}],184:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports={moduleType:'locale',name:'en',dictionary:{'Click to enter Colorscale title':'Click to enter Colourscale title'},format:{days:['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],shortDays:['Sun','Mon','Tue','Wed','Thu','Fri','Sat'],months:['January','February','March','April','May','June','July','August','September','October','November','December'],shortMonths:['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'],periods:['AM','PM'],dateTime:'%a %b %e %X %Y',date:'%d/%m/%Y',time:'%H:%M:%S',decimal:'.',thousands:',',grouping:[3],currency:['$',''],year:'%Y',month:'%b %Y',dayMonth:'%b %-d',dayMonthYear:'%b %-d, %Y'}};},{}],185:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Registry=_dereq_('../registry');/*\n * containerArrayMatch: does this attribute string point into a\n * layout container array?\n *\n * @param {String} astr: an attribute string, like *annotations[2].text*\n *\n * @returns {Object | false} Returns false if `astr` doesn't match a container\n *  array. If it does, returns:\n *     {array: {String}, index: {Number}, property: {String}}\n *  ie the attribute string for the array, the index within the array (or ''\n *  if the whole array) and the property within that (or '' if the whole array\n *  or the whole object)\n */module.exports=function containerArrayMatch(astr){var rootContainers=Registry.layoutArrayContainers;var regexpContainers=Registry.layoutArrayRegexes;var rootPart=astr.split('[')[0];var arrayStr;var match;// look for regexp matches first, because they may be nested inside root matches\n// eg updatemenus[i].buttons is nested inside updatemenus\nfor(var i=0;i<regexpContainers.length;i++){match=astr.match(regexpContainers[i]);if(match&&match.index===0){arrayStr=match[0];break;}}// now look for root matches\nif(!arrayStr)arrayStr=rootContainers[rootContainers.indexOf(rootPart)];if(!arrayStr)return false;var tail=astr.substr(arrayStr.length);if(!tail)return{array:arrayStr,index:'',property:''};match=tail.match(/^\\[(0|[1-9][0-9]*)\\](\\.(.+))?$/);if(!match)return false;return{array:arrayStr,index:Number(match[1]),property:match[3]||''};};},{\"../registry\":242}],186:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../lib');var extendFlat=Lib.extendFlat;var isPlainObject=Lib.isPlainObject;var traceOpts={valType:'flaglist',extras:['none'],flags:['calc','clearAxisTypes','plot','style','markerSize','colorbars']};var layoutOpts={valType:'flaglist',extras:['none'],flags:['calc','plot','legend','ticks','axrange','layoutstyle','modebar','camera','arraydraw']};// flags for inside restyle/relayout include a few extras\n// that shouldn't be used in attributes, to deal with certain\n// combinations and conditionals efficiently\nvar traceEditTypeFlags=traceOpts.flags.slice().concat(['fullReplot']);var layoutEditTypeFlags=layoutOpts.flags.slice().concat('layoutReplot');module.exports={traces:traceOpts,layout:layoutOpts,/*\n     * default (all false) edit flags for restyle (traces)\n     * creates a new object each call, so the caller can mutate freely\n     */traceFlags:function traceFlags(){return falseObj(traceEditTypeFlags);},/*\n     * default (all false) edit flags for relayout\n     * creates a new object each call, so the caller can mutate freely\n     */layoutFlags:function layoutFlags(){return falseObj(layoutEditTypeFlags);},/*\n     * update `flags` with the `editType` values found in `attr`\n     */update:function update(flags,attr){var editType=attr.editType;if(editType&&editType!=='none'){var editTypeParts=editType.split('+');for(var i=0;i<editTypeParts.length;i++){flags[editTypeParts[i]]=true;}}},overrideAll:overrideAll};function falseObj(keys){var out={};for(var i=0;i<keys.length;i++){out[keys[i]]=false;}return out;}/**\n * For attributes that are largely copied from elsewhere into a plot type that doesn't\n * support partial redraws - overrides the editType field of all attributes in the object\n *\n * @param {object} attrs: the attributes to override. Will not be mutated.\n * @param {string} editTypeOverride: the new editType to use\n * @param {'nested'|'from-root'} overrideContainers:\n *   - 'nested' will override editType for nested containers but not the root.\n *   - 'from-root' will also override editType of the root container.\n *   Containers below the absolute top level (trace or layout root) DO need an\n *   editType even if they are not `valObject`s themselves (eg `scatter.marker`)\n *   to handle the case where you edit the whole container.\n *\n * @return {object} a new attributes object with `editType` modified as directed\n */function overrideAll(attrs,editTypeOverride,overrideContainers){var out=extendFlat({},attrs);for(var key in out){var attr=out[key];if(isPlainObject(attr)){out[key]=overrideOne(attr,editTypeOverride,overrideContainers,key);}}if(overrideContainers==='from-root')out.editType=editTypeOverride;return out;}function overrideOne(attr,editTypeOverride,overrideContainers,key){if(attr.valType){var out=extendFlat({},attr);out.editType=editTypeOverride;if(Array.isArray(attr.items)){out.items=new Array(attr.items.length);for(var i=0;i<attr.items.length;i++){out.items[i]=overrideOne(attr.items[i],editTypeOverride,'from-root');}}return out;}else{// don't provide an editType for the _deprecated container\nreturn overrideAll(attr,editTypeOverride,key.charAt(0)==='_'?'nested':'from-root');}}},{\"../lib\":159}],187:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var isNumeric=_dereq_('fast-isnumeric');var m4FromQuat=_dereq_('gl-mat4/fromQuat');var Registry=_dereq_('../registry');var Lib=_dereq_('../lib');var Plots=_dereq_('../plots/plots');var AxisIds=_dereq_('../plots/cartesian/axis_ids');var Color=_dereq_('../components/color');var cleanId=AxisIds.cleanId;var getFromTrace=AxisIds.getFromTrace;var traceIs=Registry.traceIs;// clear the promise queue if one of them got rejected\nexports.clearPromiseQueue=function(gd){if(Array.isArray(gd._promises)&&gd._promises.length>0){Lib.log('Clearing previous rejected promises from queue.');}gd._promises=[];};// make a few changes to the layout right away\n// before it gets used for anything\n// backward compatibility and cleanup of nonstandard options\nexports.cleanLayout=function(layout){var i,j;if(!layout)layout={};// cannot have (x|y)axis1, numbering goes axis, axis2, axis3...\nif(layout.xaxis1){if(!layout.xaxis)layout.xaxis=layout.xaxis1;delete layout.xaxis1;}if(layout.yaxis1){if(!layout.yaxis)layout.yaxis=layout.yaxis1;delete layout.yaxis1;}if(layout.scene1){if(!layout.scene)layout.scene=layout.scene1;delete layout.scene1;}var axisAttrRegex=(Plots.subplotsRegistry.cartesian||{}).attrRegex;var polarAttrRegex=(Plots.subplotsRegistry.polar||{}).attrRegex;var ternaryAttrRegex=(Plots.subplotsRegistry.ternary||{}).attrRegex;var sceneAttrRegex=(Plots.subplotsRegistry.gl3d||{}).attrRegex;var keys=Object.keys(layout);for(i=0;i<keys.length;i++){var key=keys[i];if(axisAttrRegex&&axisAttrRegex.test(key)){// modifications to cartesian axes\nvar ax=layout[key];if(ax.anchor&&ax.anchor!=='free'){ax.anchor=cleanId(ax.anchor);}if(ax.overlaying)ax.overlaying=cleanId(ax.overlaying);// old method of axis type - isdate and islog (before category existed)\nif(!ax.type){if(ax.isdate)ax.type='date';else if(ax.islog)ax.type='log';else if(ax.isdate===false&&ax.islog===false)ax.type='linear';}if(ax.autorange==='withzero'||ax.autorange==='tozero'){ax.autorange=true;ax.rangemode='tozero';}delete ax.islog;delete ax.isdate;delete ax.categories;// replaced by _categories\n// prune empty domain arrays made before the new nestedProperty\nif(emptyContainer(ax,'domain'))delete ax.domain;// autotick -> tickmode\nif(ax.autotick!==undefined){if(ax.tickmode===undefined){ax.tickmode=ax.autotick?'auto':'linear';}delete ax.autotick;}cleanTitle(ax);}else if(polarAttrRegex&&polarAttrRegex.test(key)){// modifications for polar\nvar polar=layout[key];cleanTitle(polar.radialaxis);}else if(ternaryAttrRegex&&ternaryAttrRegex.test(key)){// modifications for ternary\nvar ternary=layout[key];cleanTitle(ternary.aaxis);cleanTitle(ternary.baxis);cleanTitle(ternary.caxis);}else if(sceneAttrRegex&&sceneAttrRegex.test(key)){// modifications for 3D scenes\nvar scene=layout[key];// clean old Camera coords\nvar cameraposition=scene.cameraposition;if(Array.isArray(cameraposition)&&cameraposition[0].length===4){var rotation=cameraposition[0];var center=cameraposition[1];var radius=cameraposition[2];var mat=m4FromQuat([],rotation);var eye=[];for(j=0;j<3;++j){eye[j]=center[j]+radius*mat[2+4*j];}scene.camera={eye:{x:eye[0],y:eye[1],z:eye[2]},center:{x:center[0],y:center[1],z:center[2]},up:{x:0,y:0,z:1// we just ignore calculating camera z up in this case\n}};delete scene.cameraposition;}// clean axis titles\ncleanTitle(scene.xaxis);cleanTitle(scene.yaxis);cleanTitle(scene.zaxis);}}var annotationsLen=Array.isArray(layout.annotations)?layout.annotations.length:0;for(i=0;i<annotationsLen;i++){var ann=layout.annotations[i];if(!Lib.isPlainObject(ann))continue;if(ann.ref){if(ann.ref==='paper'){ann.xref='paper';ann.yref='paper';}else if(ann.ref==='data'){ann.xref='x';ann.yref='y';}delete ann.ref;}cleanAxRef(ann,'xref');cleanAxRef(ann,'yref');}var shapesLen=Array.isArray(layout.shapes)?layout.shapes.length:0;for(i=0;i<shapesLen;i++){var shape=layout.shapes[i];if(!Lib.isPlainObject(shape))continue;cleanAxRef(shape,'xref');cleanAxRef(shape,'yref');}var legend=layout.legend;if(legend){// check for old-style legend positioning (x or y is +/- 100)\nif(legend.x>3){legend.x=1.02;legend.xanchor='left';}else if(legend.x<-2){legend.x=-0.02;legend.xanchor='right';}if(legend.y>3){legend.y=1.02;legend.yanchor='bottom';}else if(legend.y<-2){legend.y=-0.02;legend.yanchor='top';}}// clean plot title\ncleanTitle(layout);/*\n     * Moved from rotate -> orbit for dragmode\n     */if(layout.dragmode==='rotate')layout.dragmode='orbit';// sanitize rgb(fractions) and rgba(fractions) that old tinycolor\n// supported, but new tinycolor does not because they're not valid css\nColor.clean(layout);// clean the layout container in layout.template\nif(layout.template&&layout.template.layout){exports.cleanLayout(layout.template.layout);}return layout;};function cleanAxRef(container,attr){var valIn=container[attr];var axLetter=attr.charAt(0);if(valIn&&valIn!=='paper'){container[attr]=cleanId(valIn,axLetter);}}/**\n * Cleans up old title attribute structure (flat) in favor of the new one (nested).\n *\n * @param {Object} titleContainer - an object potentially including deprecated title attributes\n */function cleanTitle(titleContainer){if(titleContainer){// title -> title.text\n// (although title used to be a string attribute,\n// numbers are accepted as well)\nif(typeof titleContainer.title==='string'||typeof titleContainer.title==='number'){titleContainer.title={text:titleContainer.title};}rewireAttr('titlefont','font');rewireAttr('titleposition','position');rewireAttr('titleside','side');rewireAttr('titleoffset','offset');}function rewireAttr(oldAttrName,newAttrName){var oldAttrSet=titleContainer[oldAttrName];var newAttrSet=titleContainer.title&&titleContainer.title[newAttrName];if(oldAttrSet&&!newAttrSet){// Ensure title object exists\nif(!titleContainer.title){titleContainer.title={};}titleContainer.title[newAttrName]=titleContainer[oldAttrName];delete titleContainer[oldAttrName];}}}/*\n * cleanData: Make a few changes to the data for backward compatibility\n * before it gets used for anything. Modifies the data traces users provide.\n *\n * Important: if you're going to add something here that modifies a data array,\n * update it in place so the new array === the old one.\n */exports.cleanData=function(data){for(var tracei=0;tracei<data.length;tracei++){var trace=data[tracei];var i;// use xbins to bin data in x, and ybins to bin data in y\nif(trace.type==='histogramy'&&'xbins'in trace&&!('ybins'in trace)){trace.ybins=trace.xbins;delete trace.xbins;}// error_y.opacity is obsolete - merge into color\nif(trace.error_y&&'opacity'in trace.error_y){var dc=Color.defaults;var yeColor=trace.error_y.color||(traceIs(trace,'bar')?Color.defaultLine:dc[tracei%dc.length]);trace.error_y.color=Color.addOpacity(Color.rgb(yeColor),Color.opacity(yeColor)*trace.error_y.opacity);delete trace.error_y.opacity;}// convert bardir to orientation, and put the data into\n// the axes it's eventually going to be used with\nif('bardir'in trace){if(trace.bardir==='h'&&(traceIs(trace,'bar')||trace.type.substr(0,9)==='histogram')){trace.orientation='h';exports.swapXYData(trace);}delete trace.bardir;}// now we have only one 1D histogram type, and whether\n// it uses x or y data depends on trace.orientation\nif(trace.type==='histogramy')exports.swapXYData(trace);if(trace.type==='histogramx'||trace.type==='histogramy'){trace.type='histogram';}// scl->scale, reversescl->reversescale\nif('scl'in trace&&!('colorscale'in trace)){trace.colorscale=trace.scl;delete trace.scl;}if('reversescl'in trace&&!('reversescale'in trace)){trace.reversescale=trace.reversescl;delete trace.reversescl;}// axis ids x1 -> x, y1-> y\nif(trace.xaxis)trace.xaxis=cleanId(trace.xaxis,'x');if(trace.yaxis)trace.yaxis=cleanId(trace.yaxis,'y');// scene ids scene1 -> scene\nif(traceIs(trace,'gl3d')&&trace.scene){trace.scene=Plots.subplotsRegistry.gl3d.cleanId(trace.scene);}if(!traceIs(trace,'pie')&&!traceIs(trace,'bar')&&trace.type!=='waterfall'){if(Array.isArray(trace.textposition)){for(i=0;i<trace.textposition.length;i++){trace.textposition[i]=cleanTextPosition(trace.textposition[i]);}}else if(trace.textposition){trace.textposition=cleanTextPosition(trace.textposition);}}// fix typo in colorscale definition\nvar _module=Registry.getModule(trace);if(_module&&_module.colorbar){var containerName=_module.colorbar.container;var container=containerName?trace[containerName]:trace;if(container&&container.colorscale){if(container.colorscale==='YIGnBu')container.colorscale='YlGnBu';if(container.colorscale==='YIOrRd')container.colorscale='YlOrRd';}}// fix typo in surface 'highlight*' definitions\nif(trace.type==='surface'&&Lib.isPlainObject(trace.contours)){var dims=['x','y','z'];for(i=0;i<dims.length;i++){var opts=trace.contours[dims[i]];if(!Lib.isPlainObject(opts))continue;if(opts.highlightColor){opts.highlightcolor=opts.highlightColor;delete opts.highlightColor;}if(opts.highlightWidth){opts.highlightwidth=opts.highlightWidth;delete opts.highlightWidth;}}}// fixes from converting finance from transforms to real trace types\nif(trace.type==='candlestick'||trace.type==='ohlc'){var increasingShowlegend=(trace.increasing||{}).showlegend!==false;var decreasingShowlegend=(trace.decreasing||{}).showlegend!==false;var increasingName=cleanFinanceDir(trace.increasing);var decreasingName=cleanFinanceDir(trace.decreasing);// now figure out something smart to do with the separate direction\n// names we removed\nif(increasingName!==false&&decreasingName!==false){// both sub-names existed: base name previously had no effect\n// so ignore it and try to find a shared part of the sub-names\nvar newName=commonPrefix(increasingName,decreasingName,increasingShowlegend,decreasingShowlegend);// if no common part, leave whatever name was (or wasn't) there\nif(newName)trace.name=newName;}else if((increasingName||decreasingName)&&!trace.name){// one sub-name existed but not the base name - just use the sub-name\ntrace.name=increasingName||decreasingName;}}// transforms backward compatibility fixes\nif(Array.isArray(trace.transforms)){var transforms=trace.transforms;for(i=0;i<transforms.length;i++){var transform=transforms[i];if(!Lib.isPlainObject(transform))continue;switch(transform.type){case'filter':if(transform.filtersrc){transform.target=transform.filtersrc;delete transform.filtersrc;}if(transform.calendar){if(!transform.valuecalendar){transform.valuecalendar=transform.calendar;}delete transform.calendar;}break;case'groupby':// Name has changed from `style` to `styles`, so use `style` but prefer `styles`:\ntransform.styles=transform.styles||transform.style;if(transform.styles&&!Array.isArray(transform.styles)){var prevStyles=transform.styles;var styleKeys=Object.keys(prevStyles);transform.styles=[];for(var j=0;j<styleKeys.length;j++){transform.styles.push({target:styleKeys[j],value:prevStyles[styleKeys[j]]});}}break;}}}// prune empty containers made before the new nestedProperty\nif(emptyContainer(trace,'line'))delete trace.line;if('marker'in trace){if(emptyContainer(trace.marker,'line'))delete trace.marker.line;if(emptyContainer(trace,'marker'))delete trace.marker;}// sanitize rgb(fractions) and rgba(fractions) that old tinycolor\n// supported, but new tinycolor does not because they're not valid css\nColor.clean(trace);// remove obsolete autobin(x|y) attributes, but only if true\n// if false, this needs to happen in Histogram.calc because it\n// can be a one-time autobin so we need to know the results before\n// we can push them back into the trace.\nif(trace.autobinx){delete trace.autobinx;delete trace.xbins;}if(trace.autobiny){delete trace.autobiny;delete trace.ybins;}cleanTitle(trace);if(trace.colorbar)cleanTitle(trace.colorbar);if(trace.marker&&trace.marker.colorbar)cleanTitle(trace.marker.colorbar);if(trace.line&&trace.line.colorbar)cleanTitle(trace.line.colorbar);if(trace.aaxis)cleanTitle(trace.aaxis);if(trace.baxis)cleanTitle(trace.baxis);}};function cleanFinanceDir(dirContainer){if(!Lib.isPlainObject(dirContainer))return false;var dirName=dirContainer.name;delete dirContainer.name;delete dirContainer.showlegend;return(typeof dirName==='string'||typeof dirName==='number')&&String(dirName);}function commonPrefix(name1,name2,show1,show2){// if only one is shown in the legend, use that\nif(show1&&!show2)return name1;if(show2&&!show1)return name2;// if both or neither are in the legend, check if one is blank (or whitespace)\n// and use the other one\n// note that hover labels can still use the name even if the legend doesn't\nif(!name1.trim())return name2;if(!name2.trim())return name1;var minLen=Math.min(name1.length,name2.length);var i;for(i=0;i<minLen;i++){if(name1.charAt(i)!==name2.charAt(i))break;}var out=name1.substr(0,i);return out.trim();}// textposition - support partial attributes (ie just 'top')\n// and incorrect use of middle / center etc.\nfunction cleanTextPosition(textposition){var posY='middle';var posX='center';if(typeof textposition==='string'){if(textposition.indexOf('top')!==-1)posY='top';else if(textposition.indexOf('bottom')!==-1)posY='bottom';if(textposition.indexOf('left')!==-1)posX='left';else if(textposition.indexOf('right')!==-1)posX='right';}return posY+' '+posX;}function emptyContainer(outer,innerStr){return innerStr in outer&&_typeof(outer[innerStr])==='object'&&Object.keys(outer[innerStr]).length===0;}// swap all the data and data attributes associated with x and y\nexports.swapXYData=function(trace){var i;Lib.swapAttrs(trace,['?','?0','d?','?bins','nbins?','autobin?','?src','error_?']);if(Array.isArray(trace.z)&&Array.isArray(trace.z[0])){if(trace.transpose)delete trace.transpose;else trace.transpose=true;}if(trace.error_x&&trace.error_y){var errorY=trace.error_y;var copyYstyle='copy_ystyle'in errorY?errorY.copy_ystyle:!(errorY.color||errorY.thickness||errorY.width);Lib.swapAttrs(trace,['error_?.copy_ystyle']);if(copyYstyle){Lib.swapAttrs(trace,['error_?.color','error_?.thickness','error_?.width']);}}if(typeof trace.hoverinfo==='string'){var hoverInfoParts=trace.hoverinfo.split('+');for(i=0;i<hoverInfoParts.length;i++){if(hoverInfoParts[i]==='x')hoverInfoParts[i]='y';else if(hoverInfoParts[i]==='y')hoverInfoParts[i]='x';}trace.hoverinfo=hoverInfoParts.join('+');}};// coerce traceIndices input to array of trace indices\nexports.coerceTraceIndices=function(gd,traceIndices){if(isNumeric(traceIndices)){return[traceIndices];}else if(!Array.isArray(traceIndices)||!traceIndices.length){return gd.data.map(function(_,i){return i;});}else if(Array.isArray(traceIndices)){var traceIndicesOut=[];for(var i=0;i<traceIndices.length;i++){if(Lib.isIndex(traceIndices[i],gd.data.length)){traceIndicesOut.push(traceIndices[i]);}else{Lib.warn('trace index (',traceIndices[i],') is not a number or is out of bounds');}}return traceIndicesOut;}return traceIndices;};/**\n * Manages logic around array container item creation / deletion / update\n * that nested property alone can't handle.\n *\n * @param {Object} np\n *  nested property of update attribute string about trace or layout object\n * @param {*} newVal\n *  update value passed to restyle / relayout / update\n * @param {Object} undoit\n *  undo hash (N.B. undoit may be mutated here).\n *\n */exports.manageArrayContainers=function(np,newVal,undoit){var obj=np.obj;var parts=np.parts;var pLength=parts.length;var pLast=parts[pLength-1];var pLastIsNumber=isNumeric(pLast);if(pLastIsNumber&&newVal===null){// delete item\n// Clear item in array container when new value is null\nvar contPath=parts.slice(0,pLength-1).join('.');var cont=Lib.nestedProperty(obj,contPath).get();cont.splice(pLast,1);// Note that nested property clears null / undefined at end of\n// array container, but not within them.\n}else if(pLastIsNumber&&np.get()===undefined){// create item\n// When adding a new item, make sure undo command will remove it\nif(np.get()===undefined)undoit[np.astr]=null;np.set(newVal);}else{// update item\n// If the last part of attribute string isn't a number,\n// np.set is all we need.\nnp.set(newVal);}};/*\n * Match the part to strip off to turn an attribute into its parent\n * really it should be either '.some_characters' or '[number]'\n * but we're a little more permissive here and match either\n * '.not_brackets_or_dot' or '[not_brackets_or_dot]'\n */var ATTR_TAIL_RE=/(\\.[^\\[\\]\\.]+|\\[[^\\[\\]\\.]+\\])$/;function getParent(attr){var tail=attr.search(ATTR_TAIL_RE);if(tail>0)return attr.substr(0,tail);}/*\n * hasParent: does an attribute object contain a parent of the given attribute?\n * for example, given 'images[2].x' do we also have 'images' or 'images[2]'?\n *\n * @param {Object} aobj\n *  update object, whose keys are attribute strings and values are their new settings\n * @param {string} attr\n *  the attribute string to test against\n * @returns {Boolean}\n *  is a parent of attr present in aobj?\n */exports.hasParent=function(aobj,attr){var attrParent=getParent(attr);while(attrParent){if(attrParent in aobj)return true;attrParent=getParent(attrParent);}return false;};/**\n * Empty out types for all axes containing these traces so we auto-set them again\n *\n * @param {object} gd\n * @param {[integer]} traces: trace indices to search for axes to clear the types of\n * @param {object} layoutUpdate: any update being done concurrently to the layout,\n *   which may supercede clearing the axis types\n */var axLetters=['x','y','z'];exports.clearAxisTypes=function(gd,traces,layoutUpdate){for(var i=0;i<traces.length;i++){var trace=gd._fullData[i];for(var j=0;j<3;j++){var ax=getFromTrace(gd,trace,axLetters[j]);// do not clear log type - that's never an auto result so must have been intentional\nif(ax&&ax.type!=='log'){var axAttr=ax._name;var sceneName=ax._id.substr(1);if(sceneName.substr(0,5)==='scene'){if(layoutUpdate[sceneName]!==undefined)continue;axAttr=sceneName+'.'+axAttr;}var typeAttr=axAttr+'.type';if(layoutUpdate[axAttr]===undefined&&layoutUpdate[typeAttr]===undefined){Lib.nestedProperty(gd.layout,typeAttr).set(null);}}}}};},{\"../components/color\":43,\"../lib\":159,\"../plots/cartesian/axis_ids\":206,\"../plots/plots\":235,\"../registry\":242,\"fast-isnumeric\":10,\"gl-mat4/fromQuat\":11}],188:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var main=_dereq_('./plot_api');exports.plot=main.plot;exports.newPlot=main.newPlot;exports.restyle=main.restyle;exports.relayout=main.relayout;exports.redraw=main.redraw;exports.update=main.update;exports._guiRestyle=main._guiRestyle;exports._guiRelayout=main._guiRelayout;exports._guiUpdate=main._guiUpdate;exports._storeDirectGUIEdit=main._storeDirectGUIEdit;exports.react=main.react;exports.extendTraces=main.extendTraces;exports.prependTraces=main.prependTraces;exports.addTraces=main.addTraces;exports.deleteTraces=main.deleteTraces;exports.moveTraces=main.moveTraces;exports.purge=main.purge;exports.addFrames=main.addFrames;exports.deleteFrames=main.deleteFrames;exports.animate=main.animate;exports.setPlotConfig=main.setPlotConfig;exports.toImage=_dereq_('./to_image');exports.validate=_dereq_('./validate');exports.downloadImage=_dereq_('../snapshot/download');var templateApi=_dereq_('./template_api');exports.makeTemplate=templateApi.makeTemplate;exports.validateTemplate=templateApi.validateTemplate;},{\"../snapshot/download\":244,\"./plot_api\":190,\"./template_api\":195,\"./to_image\":196,\"./validate\":197}],189:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var isPlainObject=_dereq_('../lib/is_plain_object');var noop=_dereq_('../lib/noop');var Loggers=_dereq_('../lib/loggers');var sorterAsc=_dereq_('../lib/search').sorterAsc;var Registry=_dereq_('../registry');exports.containerArrayMatch=_dereq_('./container_array_match');var isAddVal=exports.isAddVal=function isAddVal(val){return val==='add'||isPlainObject(val);};var isRemoveVal=exports.isRemoveVal=function isRemoveVal(val){return val===null||val==='remove';};/*\n * applyContainerArrayChanges: for managing arrays of layout components in relayout\n * handles them all with a consistent interface.\n *\n * Here are the supported actions -> relayout calls -> edits we get here\n * (as prepared in _relayout):\n *\n * add an empty obj -> {'annotations[2]': 'add'} -> {2: {'': 'add'}}\n * add a specific obj -> {'annotations[2]': {attrs}} -> {2: {'': {attrs}}}\n * delete an obj -> {'annotations[2]': 'remove'} -> {2: {'': 'remove'}}\n *               -> {'annotations[2]': null} -> {2: {'': null}}\n * delete the whole array -> {'annotations': 'remove'} -> {'': {'': 'remove'}}\n *                        -> {'annotations': null} -> {'': {'': null}}\n * edit an object -> {'annotations[2].text': 'boo'} -> {2: {'text': 'boo'}}\n *\n * You can combine many edits to different objects. Objects are added and edited\n * in ascending order, then removed in descending order.\n * For example, starting with [a, b, c], if you want to:\n * - replace b with d:\n *   {'annotations[1]': d, 'annotations[2]': null} (b is item 2 after adding d)\n * - add a new item d between a and b, and edit b:\n *    {'annotations[1]': d, 'annotations[2].x': newX} (b is item 2 after adding d)\n * - delete b and edit c:\n *    {'annotations[1]': null, 'annotations[2].x': newX} (c is edited before b is removed)\n *\n * You CANNOT combine adding/deleting an item at index `i` with edits to the same index `i`\n * You CANNOT combine replacing/deleting the whole array with anything else (for the same array).\n *\n * @param {HTMLDivElement} gd\n *  the DOM element of the graph container div\n * @param {Lib.nestedProperty} componentType: the array we are editing\n * @param {Object} edits\n *  the changes to make; keys are indices to edit, values are themselves objects:\n *  {attr: newValue} of changes to make to that index (with add/remove behavior\n *  in special values of the empty attr)\n * @param {Object} flags\n *  the flags for which actions we're going to perform to display these (and\n *  any other) changes. If we're already `recalc`ing, we don't need to redraw\n *  individual items\n * @param {function} _nestedProperty\n *  a (possibly modified for gui edits) nestedProperty constructor\n *  The modified version takes a 3rd argument, for a prefix to the attribute\n *  string necessary for storing GUI edits\n *\n * @returns {bool} `true` if it managed to complete drawing of the changes\n *  `false` would mean the parent should replot.\n */exports.applyContainerArrayChanges=function applyContainerArrayChanges(gd,np,edits,flags,_nestedProperty){var componentType=np.astr;var supplyComponentDefaults=Registry.getComponentMethod(componentType,'supplyLayoutDefaults');var draw=Registry.getComponentMethod(componentType,'draw');var drawOne=Registry.getComponentMethod(componentType,'drawOne');var replotLater=flags.replot||flags.recalc||supplyComponentDefaults===noop||draw===noop;var layout=gd.layout;var fullLayout=gd._fullLayout;if(edits['']){if(Object.keys(edits).length>1){Loggers.warn('Full array edits are incompatible with other edits',componentType);}var fullVal=edits[''][''];if(isRemoveVal(fullVal))np.set(null);else if(Array.isArray(fullVal))np.set(fullVal);else{Loggers.warn('Unrecognized full array edit value',componentType,fullVal);return true;}if(replotLater)return false;supplyComponentDefaults(layout,fullLayout);draw(gd);return true;}var componentNums=Object.keys(edits).map(Number).sort(sorterAsc);var componentArrayIn=np.get();var componentArray=componentArrayIn||[];// componentArrayFull is used just to keep splices in line between\n// full and input arrays, so private keys can be copied over after\n// redoing supplyDefaults\n// TODO: this assumes componentArray is in gd.layout - which will not be\n// true after we extend this to restyle\nvar componentArrayFull=_nestedProperty(fullLayout,componentType).get();var deletes=[];var firstIndexChange=-1;var maxIndex=componentArray.length;var i;var j;var componentNum;var objEdits;var objKeys;var objVal;var adding,prefix;// first make the add and edit changes\nfor(i=0;i<componentNums.length;i++){componentNum=componentNums[i];objEdits=edits[componentNum];objKeys=Object.keys(objEdits);objVal=objEdits[''],adding=isAddVal(objVal);if(componentNum<0||componentNum>componentArray.length-(adding?0:1)){Loggers.warn('index out of range',componentType,componentNum);continue;}if(objVal!==undefined){if(objKeys.length>1){Loggers.warn('Insertion & removal are incompatible with edits to the same index.',componentType,componentNum);}if(isRemoveVal(objVal)){deletes.push(componentNum);}else if(adding){if(objVal==='add')objVal={};componentArray.splice(componentNum,0,objVal);if(componentArrayFull)componentArrayFull.splice(componentNum,0,{});}else{Loggers.warn('Unrecognized full object edit value',componentType,componentNum,objVal);}if(firstIndexChange===-1)firstIndexChange=componentNum;}else{for(j=0;j<objKeys.length;j++){prefix=componentType+'['+componentNum+'].';_nestedProperty(componentArray[componentNum],objKeys[j],prefix).set(objEdits[objKeys[j]]);}}}// now do deletes\nfor(i=deletes.length-1;i>=0;i--){componentArray.splice(deletes[i],1);// TODO: this drops private keys that had been stored in componentArrayFull\n// does this have any ill effects?\nif(componentArrayFull)componentArrayFull.splice(deletes[i],1);}if(!componentArray.length)np.set(null);else if(!componentArrayIn)np.set(componentArray);if(replotLater)return false;supplyComponentDefaults(layout,fullLayout);// finally draw all the components we need to\n// if we added or removed any, redraw all after it\nif(drawOne!==noop){var indicesToDraw;if(firstIndexChange===-1){// there's no re-indexing to do, so only redraw components that changed\nindicesToDraw=componentNums;}else{// in case the component array was shortened, we still need do call\n// drawOne on the latter items so they get properly removed\nmaxIndex=Math.max(componentArray.length,maxIndex);indicesToDraw=[];for(i=0;i<componentNums.length;i++){componentNum=componentNums[i];if(componentNum>=firstIndexChange)break;indicesToDraw.push(componentNum);}for(i=firstIndexChange;i<maxIndex;i++){indicesToDraw.push(i);}}for(i=0;i<indicesToDraw.length;i++){drawOne(gd,indicesToDraw[i]);}}else draw(gd);return true;};},{\"../lib/is_plain_object\":160,\"../lib/loggers\":163,\"../lib/noop\":168,\"../lib/search\":177,\"../registry\":242,\"./container_array_match\":185}],190:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var isNumeric=_dereq_('fast-isnumeric');var hasHover=_dereq_('has-hover');var Lib=_dereq_('../lib');var nestedProperty=Lib.nestedProperty;var Events=_dereq_('../lib/events');var Queue=_dereq_('../lib/queue');var Registry=_dereq_('../registry');var PlotSchema=_dereq_('./plot_schema');var Plots=_dereq_('../plots/plots');var Polar=_dereq_('../plots/polar/legacy');var Axes=_dereq_('../plots/cartesian/axes');var Drawing=_dereq_('../components/drawing');var Color=_dereq_('../components/color');var connectColorbar=_dereq_('../components/colorbar/connect');var initInteractions=_dereq_('../plots/cartesian/graph_interact').initInteractions;var xmlnsNamespaces=_dereq_('../constants/xmlns_namespaces');var svgTextUtils=_dereq_('../lib/svg_text_utils');var clearSelect=_dereq_('../plots/cartesian/select').clearSelect;var dfltConfig=_dereq_('./plot_config').dfltConfig;var manageArrays=_dereq_('./manage_arrays');var helpers=_dereq_('./helpers');var subroutines=_dereq_('./subroutines');var editTypes=_dereq_('./edit_types');var AX_NAME_PATTERN=_dereq_('../plots/cartesian/constants').AX_NAME_PATTERN;var numericNameWarningCount=0;var numericNameWarningCountLimit=5;/**\n * Main plot-creation function\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {array of objects} data\n *      array of traces, containing the data and display information for each trace\n * @param {object} layout\n *      object describing the overall display of the plot,\n *      all the stuff that doesn't pertain to any individual trace\n * @param {object} config\n *      configuration options (see ./plot_config.js for more info)\n *\n * OR\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {object} figure\n *      object containing `data`, `layout`, `config`, and `frames` members\n *\n */function plot(gd,data,layout,config){var frames;gd=Lib.getGraphDiv(gd);// Events.init is idempotent and bails early if gd has already been init'd\nEvents.init(gd);if(Lib.isPlainObject(data)){var obj=data;data=obj.data;layout=obj.layout;config=obj.config;frames=obj.frames;}var okToPlot=Events.triggerHandler(gd,'plotly_beforeplot',[data,layout,config]);if(okToPlot===false)return Promise.reject();// if there's no data or layout, and this isn't yet a plotly plot\n// container, log a warning to help plotly.js users debug\nif(!data&&!layout&&!Lib.isPlotDiv(gd)){Lib.warn('Calling Plotly.plot as if redrawing '+'but this container doesn\\'t yet have a plot.',gd);}function addFrames(){if(frames){return exports.addFrames(gd,frames);}}// transfer configuration options to gd until we move over to\n// a more OO like model\nsetPlotContext(gd,config);if(!layout)layout={};// hook class for plots main container (in case of plotly.js\n// this won't be #embedded-graph or .js-tab-contents)\nd3.select(gd).classed('js-plotly-plot',true);// off-screen getBoundingClientRect testing space,\n// in #js-plotly-tester (and stored as Drawing.tester)\n// so we can share cached text across tabs\nDrawing.makeTester();// collect promises for any async actions during plotting\n// any part of the plotting code can push to gd._promises, then\n// before we move to the next step, we check that they're all\n// complete, and empty out the promise list again.\nif(!Array.isArray(gd._promises))gd._promises=[];var graphWasEmpty=(gd.data||[]).length===0&&Array.isArray(data);// if there is already data on the graph, append the new data\n// if you only want to redraw, pass a non-array for data\nif(Array.isArray(data)){helpers.cleanData(data);if(graphWasEmpty)gd.data=data;else gd.data.push.apply(gd.data,data);// for routines outside graph_obj that want a clean tab\n// (rather than appending to an existing one) gd.empty\n// is used to determine whether to make a new tab\ngd.empty=false;}if(!gd.layout||graphWasEmpty){gd.layout=helpers.cleanLayout(layout);}Plots.supplyDefaults(gd);var fullLayout=gd._fullLayout;var hasCartesian=fullLayout._has('cartesian');// Legacy polar plots\nif(!fullLayout._has('polar')&&data&&data[0]&&data[0].r){Lib.log('Legacy polar charts are deprecated!');return plotLegacyPolar(gd,data,layout);}// so we don't try to re-call Plotly.plot from inside\n// legend and colorbar, if margins changed\nfullLayout._replotting=true;// make or remake the framework if we need to\nif(graphWasEmpty)makePlotFramework(gd);// polar need a different framework\nif(gd.framework!==makePlotFramework){gd.framework=makePlotFramework;makePlotFramework(gd);}// clear gradient defs on each .plot call, because we know we'll loop through all traces\nDrawing.initGradients(gd);// save initial show spikes once per graph\nif(graphWasEmpty)Axes.saveShowSpikeInitial(gd);// prepare the data and find the autorange\n// generate calcdata, if we need to\n// to force redoing calcdata, just delete it before calling Plotly.plot\nvar recalc=!gd.calcdata||gd.calcdata.length!==(gd._fullData||[]).length;if(recalc)Plots.doCalcdata(gd);// in case it has changed, attach fullData traces to calcdata\nfor(var i=0;i<gd.calcdata.length;i++){gd.calcdata[i][0].trace=gd._fullData[i];}// make the figure responsive\nif(gd._context.responsive){if(!gd._responsiveChartHandler){// Keep a reference to the resize handler to purge it down the road\ngd._responsiveChartHandler=function(){Plots.resize(gd);};// Listen to window resize\nwindow.addEventListener('resize',gd._responsiveChartHandler);}}else{Lib.clearResponsive(gd);}/*\n     * start async-friendly code - now we're actually drawing things\n     */var oldmargins=JSON.stringify(fullLayout._size);// draw framework first so that margin-pushing\n// components can position themselves correctly\nvar drawFrameworkCalls=0;function drawFramework(){var basePlotModules=fullLayout._basePlotModules;for(var i=0;i<basePlotModules.length;i++){if(basePlotModules[i].drawFramework){basePlotModules[i].drawFramework(gd);}}if(!fullLayout._glcanvas&&fullLayout._has('gl')){fullLayout._glcanvas=fullLayout._glcontainer.selectAll('.gl-canvas').data([{key:'contextLayer',context:true,pick:false},{key:'focusLayer',context:false,pick:false},{key:'pickLayer',context:false,pick:true}],function(d){return d.key;});fullLayout._glcanvas.enter().append('canvas').attr('class',function(d){return'gl-canvas gl-canvas-'+d.key.replace('Layer','');}).style({position:'absolute',top:0,left:0,overflow:'visible','pointer-events':'none'});}if(fullLayout._glcanvas){fullLayout._glcanvas.attr('width',fullLayout.width).attr('height',fullLayout.height);var regl=fullLayout._glcanvas.data()[0].regl;if(regl){// Unfortunately, this can happen when relayouting to large\n// width/height on some browsers.\nif(Math.floor(fullLayout.width)!==regl._gl.drawingBufferWidth||Math.floor(fullLayout.height)!==regl._gl.drawingBufferHeight){var msg='WebGL context buffer and canvas dimensions do not match due to browser/WebGL bug.';if(drawFrameworkCalls){Lib.error(msg);}else{Lib.log(msg+' Clearing graph and plotting again.');Plots.cleanPlot([],{},gd._fullData,fullLayout);Plots.supplyDefaults(gd);fullLayout=gd._fullLayout;Plots.doCalcdata(gd);drawFrameworkCalls++;return drawFramework();}}}}if(fullLayout.modebar.orientation==='h'){fullLayout._modebardiv.style('height',null).style('width','100%');}else{fullLayout._modebardiv.style('width',null).style('height',fullLayout.height+'px');}return Plots.previousPromises(gd);}// draw anything that can affect margins.\nfunction marginPushers(){var calcdata=gd.calcdata;var i,cd,trace;// First reset the list of things that are allowed to change the margins\n// So any deleted traces or components will be wiped out of the\n// automargin calculation.\n// This means *every* margin pusher must be listed here, even if it\n// doesn't actually try to push the margins until later.\nPlots.clearAutoMarginIds(gd);subroutines.drawMarginPushers(gd);Axes.allowAutoMargin(gd);for(i=0;i<calcdata.length;i++){cd=calcdata[i];trace=cd[0].trace;var colorbarOpts=trace._module.colorbar;if(trace.visible!==true||!colorbarOpts){Plots.autoMargin(gd,'cb'+trace.uid);}else connectColorbar(gd,cd,colorbarOpts);}Plots.doAutoMargin(gd);return Plots.previousPromises(gd);}// in case the margins changed, draw margin pushers again\nfunction marginPushersAgain(){if(JSON.stringify(fullLayout._size)===oldmargins)return;return Lib.syncOrAsync([marginPushers,subroutines.layoutStyles],gd);}function positionAndAutorange(){if(!recalc){doAutoRangeAndConstraints();return;}// TODO: autosize extra for text markers and images\n// see https://github.com/plotly/plotly.js/issues/1111\nreturn Lib.syncOrAsync([Registry.getComponentMethod('shapes','calcAutorange'),Registry.getComponentMethod('annotations','calcAutorange'),doAutoRangeAndConstraints],gd);}function doAutoRangeAndConstraints(){if(gd._transitioning)return;subroutines.doAutoRangeAndConstraints(gd);// store initial ranges *after* enforcing constraints, otherwise\n// we will never look like we're at the initial ranges\nif(graphWasEmpty)Axes.saveRangeInitial(gd);// this one is different from shapes/annotations calcAutorange\n// the others incorporate those components into ax._extremes,\n// this one actually sets the ranges in rangesliders.\nRegistry.getComponentMethod('rangeslider','calcAutorange')(gd);}// draw ticks, titles, and calculate axis scaling (._b, ._m)\nfunction drawAxes(){return Axes.draw(gd,graphWasEmpty?'':'redraw');}var seq=[Plots.previousPromises,addFrames,drawFramework,marginPushers,marginPushersAgain];if(hasCartesian)seq.push(positionAndAutorange);seq.push(subroutines.layoutStyles);if(hasCartesian)seq.push(drawAxes);seq.push(subroutines.drawData,subroutines.finalDraw,initInteractions,Plots.addLinks,Plots.rehover,Plots.redrag,// TODO: doAutoMargin is only needed here for axis automargin, which\n// happens outside of marginPushers where all the other automargins are\n// calculated. Would be much better to separate margin calculations from\n// component drawing - see https://github.com/plotly/plotly.js/issues/2704\nPlots.doAutoMargin,Plots.previousPromises);// even if everything we did was synchronous, return a promise\n// so that the caller doesn't care which route we took\nvar plotDone=Lib.syncOrAsync(seq,gd);if(!plotDone||!plotDone.then)plotDone=Promise.resolve();return plotDone.then(function(){emitAfterPlot(gd);return gd;});}function emitAfterPlot(gd){var fullLayout=gd._fullLayout;if(fullLayout._redrawFromAutoMarginCount){fullLayout._redrawFromAutoMarginCount--;}else{gd.emit('plotly_afterplot');}}function setPlotConfig(obj){return Lib.extendFlat(dfltConfig,obj);}function setBackground(gd,bgColor){try{gd._fullLayout._paper.style('background',bgColor);}catch(e){Lib.error(e);}}function opaqueSetBackground(gd,bgColor){var blend=Color.combine(bgColor,'white');setBackground(gd,blend);}function setPlotContext(gd,config){if(!gd._context){gd._context=Lib.extendDeep({},dfltConfig);// stash <base> href, used to make robust clipPath URLs\nvar base=d3.select('base');gd._context._baseUrl=base.size()&&base.attr('href')?window.location.href.split('#')[0]:'';}var context=gd._context;var i,keys,key;if(config){keys=Object.keys(config);for(i=0;i<keys.length;i++){key=keys[i];if(key==='editable'||key==='edits')continue;if(key in context){if(key==='setBackground'&&config[key]==='opaque'){context[key]=opaqueSetBackground;}else{context[key]=config[key];}}}// map plot3dPixelRatio to plotGlPixelRatio for backward compatibility\nif(config.plot3dPixelRatio&&!context.plotGlPixelRatio){context.plotGlPixelRatio=context.plot3dPixelRatio;}// now deal with editable and edits - first editable overrides\n// everything, then edits refines\nvar editable=config.editable;if(editable!==undefined){// we're not going to *use* context.editable, we're only going to\n// use context.edits... but keep it for the record\ncontext.editable=editable;keys=Object.keys(context.edits);for(i=0;i<keys.length;i++){context.edits[keys[i]]=editable;}}if(config.edits){keys=Object.keys(config.edits);for(i=0;i<keys.length;i++){key=keys[i];if(key in context.edits){context.edits[key]=config.edits[key];}}}// not part of the user-facing config options\ncontext._exportedPlot=config._exportedPlot;}// staticPlot forces a bunch of others:\nif(context.staticPlot){context.editable=false;context.edits={};context.autosizable=false;context.scrollZoom=false;context.doubleClick=false;context.showTips=false;context.showLink=false;context.displayModeBar=false;}// make sure hover-only devices have mode bar visible\nif(context.displayModeBar==='hover'&&!hasHover){context.displayModeBar=true;}// default and fallback for setBackground\nif(context.setBackground==='transparent'||typeof context.setBackground!=='function'){context.setBackground=setBackground;}// Check if gd has a specified widht/height to begin with\ncontext._hasZeroHeight=context._hasZeroHeight||gd.clientHeight===0;context._hasZeroWidth=context._hasZeroWidth||gd.clientWidth===0;// fill context._scrollZoom helper to help manage scrollZoom flaglist\nvar szIn=context.scrollZoom;var szOut=context._scrollZoom={};if(szIn===true){szOut.cartesian=1;szOut.gl3d=1;szOut.geo=1;szOut.mapbox=1;}else if(typeof szIn==='string'){var parts=szIn.split('+');for(i=0;i<parts.length;i++){szOut[parts[i]]=1;}}else if(szIn!==false){szOut.gl3d=1;szOut.geo=1;szOut.mapbox=1;}}function plotLegacyPolar(gd,data,layout){// build or reuse the container skeleton\nvar plotContainer=d3.select(gd).selectAll('.plot-container').data([0]);plotContainer.enter().insert('div',':first-child').classed('plot-container plotly',true);var paperDiv=plotContainer.selectAll('.svg-container').data([0]);paperDiv.enter().append('div').classed('svg-container',true).style('position','relative');// empty it everytime for now\npaperDiv.html('');// fulfill gd requirements\nif(data)gd.data=data;if(layout)gd.layout=layout;Polar.manager.fillLayout(gd);// resize canvas\npaperDiv.style({width:gd._fullLayout.width+'px',height:gd._fullLayout.height+'px'});// instantiate framework\ngd.framework=Polar.manager.framework(gd);// plot\ngd.framework({data:gd.data,layout:gd.layout},paperDiv.node());// set undo point\ngd.framework.setUndoPoint();// get the resulting svg for extending it\nvar polarPlotSVG=gd.framework.svg();// editable title\nvar opacity=1;var txt=gd._fullLayout.title?gd._fullLayout.title.text:'';if(txt===''||!txt)opacity=0;var titleLayout=function titleLayout(){this.call(svgTextUtils.convertToTspans,gd);// TODO: html/mathjax\n// TODO: center title\n};var title=polarPlotSVG.select('.title-group text').call(titleLayout);if(gd._context.edits.titleText){var placeholderText=Lib._(gd,'Click to enter Plot title');if(!txt||txt===placeholderText){opacity=0.2;// placeholder is not going through convertToTspans\n// so needs explicit data-unformatted\ntitle.attr({'data-unformatted':placeholderText}).text(placeholderText).style({opacity:opacity}).on('mouseover.opacity',function(){d3.select(this).transition().duration(100).style('opacity',1);}).on('mouseout.opacity',function(){d3.select(this).transition().duration(1000).style('opacity',0);});}var setContenteditable=function setContenteditable(){this.call(svgTextUtils.makeEditable,{gd:gd}).on('edit',function(text){gd.framework({layout:{title:{text:text}}});this.text(text).call(titleLayout);this.call(setContenteditable);}).on('cancel',function(){var txt=this.attr('data-unformatted');this.text(txt).call(titleLayout);});};title.call(setContenteditable);}gd._context.setBackground(gd,gd._fullLayout.paper_bgcolor);Plots.addLinks(gd);return Promise.resolve();}// convenience function to force a full redraw, mostly for use by plotly.js\nfunction redraw(gd){gd=Lib.getGraphDiv(gd);if(!Lib.isPlotDiv(gd)){throw new Error('This element is not a Plotly plot: '+gd);}helpers.cleanData(gd.data);helpers.cleanLayout(gd.layout);gd.calcdata=undefined;return exports.plot(gd).then(function(){gd.emit('plotly_redraw');return gd;});}/**\n * Convenience function to make idempotent plot option obvious to users.\n *\n * @param gd\n * @param {Object[]} data\n * @param {Object} layout\n * @param {Object} config\n */function newPlot(gd,data,layout,config){gd=Lib.getGraphDiv(gd);// remove gl contexts\nPlots.cleanPlot([],{},gd._fullData||[],gd._fullLayout||{});Plots.purge(gd);return exports.plot(gd,data,layout,config);}/**\n * Wrap negative indicies to their positive counterparts.\n *\n * @param {Number[]} indices An array of indices\n * @param {Number} maxIndex The maximum index allowable (arr.length - 1)\n */function positivifyIndices(indices,maxIndex){var parentLength=maxIndex+1;var positiveIndices=[];var i;var index;for(i=0;i<indices.length;i++){index=indices[i];if(index<0){positiveIndices.push(parentLength+index);}else{positiveIndices.push(index);}}return positiveIndices;}/**\n * Ensures that an index array for manipulating gd.data is valid.\n *\n * Intended for use with addTraces, deleteTraces, and moveTraces.\n *\n * @param gd\n * @param indices\n * @param arrayName\n */function assertIndexArray(gd,indices,arrayName){var i,index;for(i=0;i<indices.length;i++){index=indices[i];// validate that indices are indeed integers\nif(index!==parseInt(index,10)){throw new Error('all values in '+arrayName+' must be integers');}// check that all indices are in bounds for given gd.data array length\nif(index>=gd.data.length||index<-gd.data.length){throw new Error(arrayName+' must be valid indices for gd.data.');}// check that indices aren't repeated\nif(indices.indexOf(index,i+1)>-1||index>=0&&indices.indexOf(-gd.data.length+index)>-1||index<0&&indices.indexOf(gd.data.length+index)>-1){throw new Error('each index in '+arrayName+' must be unique.');}}}/**\n * Private function used by Plotly.moveTraces to check input args\n *\n * @param gd\n * @param currentIndices\n * @param newIndices\n */function checkMoveTracesArgs(gd,currentIndices,newIndices){// check that gd has attribute 'data' and 'data' is array\nif(!Array.isArray(gd.data)){throw new Error('gd.data must be an array.');}// validate currentIndices array\nif(typeof currentIndices==='undefined'){throw new Error('currentIndices is a required argument.');}else if(!Array.isArray(currentIndices)){currentIndices=[currentIndices];}assertIndexArray(gd,currentIndices,'currentIndices');// validate newIndices array if it exists\nif(typeof newIndices!=='undefined'&&!Array.isArray(newIndices)){newIndices=[newIndices];}if(typeof newIndices!=='undefined'){assertIndexArray(gd,newIndices,'newIndices');}// check currentIndices and newIndices are the same length if newIdices exists\nif(typeof newIndices!=='undefined'&&currentIndices.length!==newIndices.length){throw new Error('current and new indices must be of equal length.');}}/**\n * A private function to reduce the type checking clutter in addTraces.\n *\n * @param gd\n * @param traces\n * @param newIndices\n */function checkAddTracesArgs(gd,traces,newIndices){var i,value;// check that gd has attribute 'data' and 'data' is array\nif(!Array.isArray(gd.data)){throw new Error('gd.data must be an array.');}// make sure traces exists\nif(typeof traces==='undefined'){throw new Error('traces must be defined.');}// make sure traces is an array\nif(!Array.isArray(traces)){traces=[traces];}// make sure each value in traces is an object\nfor(i=0;i<traces.length;i++){value=traces[i];if(_typeof(value)!=='object'||Array.isArray(value)||value===null){throw new Error('all values in traces array must be non-array objects');}}// make sure we have an index for each trace\nif(typeof newIndices!=='undefined'&&!Array.isArray(newIndices)){newIndices=[newIndices];}if(typeof newIndices!=='undefined'&&newIndices.length!==traces.length){throw new Error('if indices is specified, traces.length must equal indices.length');}}/**\n * A private function to reduce the type checking clutter in spliceTraces.\n * Get all update Properties from gd.data. Validate inputs and outputs.\n * Used by prependTrace and extendTraces\n *\n * @param gd\n * @param update\n * @param indices\n * @param maxPoints\n */function assertExtendTracesArgs(gd,update,indices,maxPoints){var maxPointsIsObject=Lib.isPlainObject(maxPoints);if(!Array.isArray(gd.data)){throw new Error('gd.data must be an array');}if(!Lib.isPlainObject(update)){throw new Error('update must be a key:value object');}if(typeof indices==='undefined'){throw new Error('indices must be an integer or array of integers');}assertIndexArray(gd,indices,'indices');for(var key in update){/*\n         * Verify that the attribute to be updated contains as many trace updates\n         * as indices. Failure must result in throw and no-op\n         */if(!Array.isArray(update[key])||update[key].length!==indices.length){throw new Error('attribute '+key+' must be an array of length equal to indices array length');}/*\n         * if maxPoints is an object it must match keys and array lengths of 'update' 1:1\n         */if(maxPointsIsObject&&(!(key in maxPoints)||!Array.isArray(maxPoints[key])||maxPoints[key].length!==update[key].length)){throw new Error('when maxPoints is set as a key:value object it must contain a 1:1 '+'corrispondence with the keys and number of traces in the update object');}}}/**\n * A private function to reduce the type checking clutter in spliceTraces.\n *\n * @param {Object|HTMLDivElement} gd\n * @param {Object} update\n * @param {Number[]} indices\n * @param {Number||Object} maxPoints\n * @return {Object[]}\n */function getExtendProperties(gd,update,indices,maxPoints){var maxPointsIsObject=Lib.isPlainObject(maxPoints);var updateProps=[];var trace,target,prop,insert,maxp;// allow scalar index to represent a single trace position\nif(!Array.isArray(indices))indices=[indices];// negative indices are wrapped around to their positive value. Equivalent to python indexing.\nindices=positivifyIndices(indices,gd.data.length-1);// loop through all update keys and traces and harvest validated data.\nfor(var key in update){for(var j=0;j<indices.length;j++){/*\n             * Choose the trace indexed by the indices map argument and get the prop setter-getter\n             * instance that references the key and value for this particular trace.\n             */trace=gd.data[indices[j]];prop=nestedProperty(trace,key);/*\n             * Target is the existing gd.data.trace.dataArray value like \"x\" or \"marker.size\"\n             * Target must exist as an Array to allow the extend operation to be performed.\n             */target=prop.get();insert=update[key][j];if(!Lib.isArrayOrTypedArray(insert)){throw new Error('attribute: '+key+' index: '+j+' must be an array');}if(!Lib.isArrayOrTypedArray(target)){throw new Error('cannot extend missing or non-array attribute: '+key);}if(target.constructor!==insert.constructor){throw new Error('cannot extend array with an array of a different type: '+key);}/*\n             * maxPoints may be an object map or a scalar. If object select the key:value, else\n             * Use the scalar maxPoints for all key and trace combinations.\n             */maxp=maxPointsIsObject?maxPoints[key][j]:maxPoints;// could have chosen null here, -1 just tells us to not take a window\nif(!isNumeric(maxp))maxp=-1;/*\n             * Wrap the nestedProperty in an object containing required data\n             * for lengthening and windowing this particular trace - key combination.\n             * Flooring maxp mirrors the behaviour of floats in the Array.slice JSnative function.\n             */updateProps.push({prop:prop,target:target,insert:insert,maxp:Math.floor(maxp)});}}// all target and insertion data now validated\nreturn updateProps;}/**\n * A private function to key Extend and Prepend traces DRY\n *\n * @param {Object|HTMLDivElement} gd\n * @param {Object} update\n * @param {Number[]} indices\n * @param {Number||Object} maxPoints\n * @param {Function} updateArray\n * @return {Object}\n */function spliceTraces(gd,update,indices,maxPoints,updateArray){assertExtendTracesArgs(gd,update,indices,maxPoints);var updateProps=getExtendProperties(gd,update,indices,maxPoints);var undoUpdate={};var undoPoints={};for(var i=0;i<updateProps.length;i++){var prop=updateProps[i].prop;var maxp=updateProps[i].maxp;// return new array and remainder\nvar out=updateArray(updateProps[i].target,updateProps[i].insert,maxp);prop.set(out[0]);// build the inverse update object for the undo operation\nif(!Array.isArray(undoUpdate[prop.astr]))undoUpdate[prop.astr]=[];undoUpdate[prop.astr].push(out[1]);// build the matching maxPoints undo object containing original trace lengths\nif(!Array.isArray(undoPoints[prop.astr]))undoPoints[prop.astr]=[];undoPoints[prop.astr].push(updateProps[i].target.length);}return{update:undoUpdate,maxPoints:undoPoints};}function concatTypedArray(arr0,arr1){var arr2=new arr0.constructor(arr0.length+arr1.length);arr2.set(arr0);arr2.set(arr1,arr0.length);return arr2;}/**\n * extend && prepend traces at indices with update arrays, window trace lengths to maxPoints\n *\n * Extend and Prepend have identical APIs. Prepend inserts an array at the head while Extend\n * inserts an array off the tail. Prepend truncates the tail of the array - counting maxPoints\n * from the head, whereas Extend truncates the head of the array, counting backward maxPoints\n * from the tail.\n *\n * If maxPoints is undefined, nonNumeric, negative or greater than extended trace length no\n * truncation / windowing will be performed. If its zero, well the whole trace is truncated.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object} update The key:array map of target attributes to extend\n * @param {Number|Number[]} indices The locations of traces to be extended\n * @param {Number|Object} [maxPoints] Number of points for trace window after lengthening.\n *\n */function extendTraces(gd,update,indices,maxPoints){gd=Lib.getGraphDiv(gd);function updateArray(target,insert,maxp){var newArray,remainder;if(Lib.isTypedArray(target)){if(maxp<0){var none=new target.constructor(0);var both=concatTypedArray(target,insert);if(maxp<0){newArray=both;remainder=none;}else{newArray=none;remainder=both;}}else{newArray=new target.constructor(maxp);remainder=new target.constructor(target.length+insert.length-maxp);if(maxp===insert.length){newArray.set(insert);remainder.set(target);}else if(maxp<insert.length){var numberOfItemsFromInsert=insert.length-maxp;newArray.set(insert.subarray(numberOfItemsFromInsert));remainder.set(target);remainder.set(insert.subarray(0,numberOfItemsFromInsert),target.length);}else{var numberOfItemsFromTarget=maxp-insert.length;var targetBegin=target.length-numberOfItemsFromTarget;newArray.set(target.subarray(targetBegin));newArray.set(insert,numberOfItemsFromTarget);remainder.set(target.subarray(0,targetBegin));}}}else{newArray=target.concat(insert);remainder=maxp>=0&&maxp<newArray.length?newArray.splice(0,newArray.length-maxp):[];}return[newArray,remainder];}var undo=spliceTraces(gd,update,indices,maxPoints,updateArray);var promise=exports.redraw(gd);var undoArgs=[gd,undo.update,indices,undo.maxPoints];Queue.add(gd,exports.prependTraces,undoArgs,extendTraces,arguments);return promise;}function prependTraces(gd,update,indices,maxPoints){gd=Lib.getGraphDiv(gd);function updateArray(target,insert,maxp){var newArray,remainder;if(Lib.isTypedArray(target)){if(maxp<=0){var none=new target.constructor(0);var both=concatTypedArray(insert,target);if(maxp<0){newArray=both;remainder=none;}else{newArray=none;remainder=both;}}else{newArray=new target.constructor(maxp);remainder=new target.constructor(target.length+insert.length-maxp);if(maxp===insert.length){newArray.set(insert);remainder.set(target);}else if(maxp<insert.length){var numberOfItemsFromInsert=insert.length-maxp;newArray.set(insert.subarray(0,numberOfItemsFromInsert));remainder.set(insert.subarray(numberOfItemsFromInsert));remainder.set(target,numberOfItemsFromInsert);}else{var numberOfItemsFromTarget=maxp-insert.length;newArray.set(insert);newArray.set(target.subarray(0,numberOfItemsFromTarget),insert.length);remainder.set(target.subarray(numberOfItemsFromTarget));}}}else{newArray=insert.concat(target);remainder=maxp>=0&&maxp<newArray.length?newArray.splice(maxp,newArray.length):[];}return[newArray,remainder];}var undo=spliceTraces(gd,update,indices,maxPoints,updateArray);var promise=exports.redraw(gd);var undoArgs=[gd,undo.update,indices,undo.maxPoints];Queue.add(gd,exports.extendTraces,undoArgs,prependTraces,arguments);return promise;}/**\n * Add data traces to an existing graph div.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're adding to\n * @param {Object[]|Object} traces The object or array of objects to add\n * @param {Number[]|Number} [newIndices=[gd.data.length]] Locations to add traces\n *\n */function addTraces(gd,traces,newIndices){gd=Lib.getGraphDiv(gd);var currentIndices=[];var undoFunc=exports.deleteTraces;var redoFunc=addTraces;var undoArgs=[gd,currentIndices];var redoArgs=[gd,traces];// no newIndices here\nvar i;var promise;// all validation is done elsewhere to remove clutter here\ncheckAddTracesArgs(gd,traces,newIndices);// make sure traces is an array\nif(!Array.isArray(traces)){traces=[traces];}// make sure traces do not repeat existing ones\ntraces=traces.map(function(trace){return Lib.extendFlat({},trace);});helpers.cleanData(traces);// add the traces to gd.data (no redrawing yet!)\nfor(i=0;i<traces.length;i++){gd.data.push(traces[i]);}// to continue, we need to call moveTraces which requires currentIndices\nfor(i=0;i<traces.length;i++){currentIndices.push(-traces.length+i);}// if the user didn't define newIndices, they just want the traces appended\n// i.e., we can simply redraw and be done\nif(typeof newIndices==='undefined'){promise=exports.redraw(gd);Queue.add(gd,undoFunc,undoArgs,redoFunc,redoArgs);return promise;}// make sure indices is property defined\nif(!Array.isArray(newIndices)){newIndices=[newIndices];}try{// this is redundant, but necessary to not catch later possible errors!\ncheckMoveTracesArgs(gd,currentIndices,newIndices);}catch(error){// something went wrong, reset gd to be safe and rethrow error\ngd.data.splice(gd.data.length-traces.length,traces.length);throw error;}// if we're here, the user has defined specific places to place the new traces\n// this requires some extra work that moveTraces will do\nQueue.startSequence(gd);Queue.add(gd,undoFunc,undoArgs,redoFunc,redoArgs);promise=exports.moveTraces(gd,currentIndices,newIndices);Queue.stopSequence(gd);return promise;}/**\n * Delete traces at `indices` from gd.data array.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're removing from\n * @param {Number|Number[]} indices The indices\n */function deleteTraces(gd,indices){gd=Lib.getGraphDiv(gd);var traces=[];var undoFunc=exports.addTraces;var redoFunc=deleteTraces;var undoArgs=[gd,traces,indices];var redoArgs=[gd,indices];var i;var deletedTrace;// make sure indices are defined\nif(typeof indices==='undefined'){throw new Error('indices must be an integer or array of integers.');}else if(!Array.isArray(indices)){indices=[indices];}assertIndexArray(gd,indices,'indices');// convert negative indices to positive indices\nindices=positivifyIndices(indices,gd.data.length-1);// we want descending here so that splicing later doesn't affect indexing\nindices.sort(Lib.sorterDes);for(i=0;i<indices.length;i+=1){deletedTrace=gd.data.splice(indices[i],1)[0];traces.push(deletedTrace);}var promise=exports.redraw(gd);Queue.add(gd,undoFunc,undoArgs,redoFunc,redoArgs);return promise;}/**\n * Move traces at currentIndices array to locations in newIndices array.\n *\n * If newIndices is omitted, currentIndices will be moved to the end. E.g.,\n * these are equivalent:\n *\n * Plotly.moveTraces(gd, [1, 2, 3], [-3, -2, -1])\n * Plotly.moveTraces(gd, [1, 2, 3])\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're removing from\n * @param {Number|Number[]} currentIndices The locations of traces to be moved\n * @param {Number|Number[]} [newIndices] The locations to move traces to\n *\n * Example calls:\n *\n *      // move trace i to location x\n *      Plotly.moveTraces(gd, i, x)\n *\n *      // move trace i to end of array\n *      Plotly.moveTraces(gd, i)\n *\n *      // move traces i, j, k to end of array (i != j != k)\n *      Plotly.moveTraces(gd, [i, j, k])\n *\n *      // move traces [i, j, k] to [x, y, z] (i != j != k) (x != y != z)\n *      Plotly.moveTraces(gd, [i, j, k], [x, y, z])\n *\n *      // reorder all traces (assume there are 5--a, b, c, d, e)\n *      Plotly.moveTraces(gd, [b, d, e, a, c])  // same as 'move to end'\n */function moveTraces(gd,currentIndices,newIndices){gd=Lib.getGraphDiv(gd);var newData=[];var movingTraceMap=[];var undoFunc=moveTraces;var redoFunc=moveTraces;var undoArgs=[gd,newIndices,currentIndices];var redoArgs=[gd,currentIndices,newIndices];var i;// to reduce complexity here, check args elsewhere\n// this throws errors where appropriate\ncheckMoveTracesArgs(gd,currentIndices,newIndices);// make sure currentIndices is an array\ncurrentIndices=Array.isArray(currentIndices)?currentIndices:[currentIndices];// if undefined, define newIndices to point to the end of gd.data array\nif(typeof newIndices==='undefined'){newIndices=[];for(i=0;i<currentIndices.length;i++){newIndices.push(-currentIndices.length+i);}}// make sure newIndices is an array if it's user-defined\nnewIndices=Array.isArray(newIndices)?newIndices:[newIndices];// convert negative indices to positive indices (they're the same length)\ncurrentIndices=positivifyIndices(currentIndices,gd.data.length-1);newIndices=positivifyIndices(newIndices,gd.data.length-1);// at this point, we've coerced the index arrays into predictable forms\n// get the traces that aren't being moved around\nfor(i=0;i<gd.data.length;i++){// if index isn't in currentIndices, include it in ignored!\nif(currentIndices.indexOf(i)===-1){newData.push(gd.data[i]);}}// get a mapping of indices to moving traces\nfor(i=0;i<currentIndices.length;i++){movingTraceMap.push({newIndex:newIndices[i],trace:gd.data[currentIndices[i]]});}// reorder this mapping by newIndex, ascending\nmovingTraceMap.sort(function(a,b){return a.newIndex-b.newIndex;});// now, add the moving traces back in, in order!\nfor(i=0;i<movingTraceMap.length;i+=1){newData.splice(movingTraceMap[i].newIndex,0,movingTraceMap[i].trace);}gd.data=newData;var promise=exports.redraw(gd);Queue.add(gd,undoFunc,undoArgs,redoFunc,redoArgs);return promise;}/**\n * restyle: update trace attributes of an existing plot\n *\n * Can be called two ways.\n *\n * Signature 1:\n * @param {String | HTMLDivElement} gd\n *  the id or DOM element of the graph container div\n * @param {String} astr\n *  attribute string (like `'marker.symbol'`) to update\n * @param {*} val\n *  value to give this attribute\n * @param {Number[] | Number} [traces]\n *  integer or array of integers for the traces to alter (all if omitted)\n *\n * Signature 2:\n * @param {String | HTMLDivElement} gd\n *  (as in signature 1)\n * @param {Object} aobj\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  allows setting multiple attributes simultaneously\n * @param {Number[] | Number} [traces]\n *  (as in signature 1)\n *\n * `val` (or `val1`, `val2` ... in the object form) can be an array,\n * to apply different values to each trace.\n *\n * If the array is too short, it will wrap around (useful for\n * style files that want to specify cyclical default values).\n */function restyle(gd,astr,val,_traces){gd=Lib.getGraphDiv(gd);helpers.clearPromiseQueue(gd);var aobj={};if(typeof astr==='string')aobj[astr]=val;else if(Lib.isPlainObject(astr)){// the 3-arg form\naobj=Lib.extendFlat({},astr);if(_traces===undefined)_traces=val;}else{Lib.warn('Restyle fail.',astr,val,_traces);return Promise.reject();}if(Object.keys(aobj).length)gd.changed=true;var traces=helpers.coerceTraceIndices(gd,_traces);var specs=_restyle(gd,aobj,traces);var flags=specs.flags;// clear calcdata and/or axis types if required so they get regenerated\nif(flags.calc)gd.calcdata=undefined;if(flags.clearAxisTypes)helpers.clearAxisTypes(gd,traces,{});// fill in redraw sequence\nvar seq=[];if(flags.fullReplot){seq.push(exports.plot);}else{seq.push(Plots.previousPromises);// maybe only call Plots.supplyDataDefaults in the splom case,\n// to skip over long and slow axes defaults\nPlots.supplyDefaults(gd);if(flags.markerSize){Plots.doCalcdata(gd);addAxRangeSequence(seq);// TODO\n// if all axes have autorange:false, then\n// proceed to subroutines.doTraceStyle(),\n// otherwise we must go through addAxRangeSequence,\n// which in general must redraws 'all' axes\n}if(flags.style)seq.push(subroutines.doTraceStyle);if(flags.colorbars)seq.push(subroutines.doColorBars);seq.push(emitAfterPlot);}seq.push(Plots.rehover,Plots.redrag);Queue.add(gd,restyle,[gd,specs.undoit,specs.traces],restyle,[gd,specs.redoit,specs.traces]);var plotDone=Lib.syncOrAsync(seq,gd);if(!plotDone||!plotDone.then)plotDone=Promise.resolve();return plotDone.then(function(){gd.emit('plotly_restyle',specs.eventData);return gd;});}// for undo: undefined initial vals must be turned into nulls\n// so that we unset rather than ignore them\nfunction undefinedToNull(val){if(val===undefined)return null;return val;}/**\n * Factory function to wrap nestedProperty with GUI edits if necessary\n * with GUI edits we add an optional prefix to the nestedProperty constructor\n * to prepend to the attribute string in the preGUI store.\n */function makeNP(preGUI,guiEditFlag){if(!guiEditFlag)return nestedProperty;return function(container,attr,prefix){var np=nestedProperty(container,attr);var npSet=np.set;np.set=function(val){var fullAttr=(prefix||'')+attr;storeCurrent(fullAttr,np.get(),val,preGUI);npSet(val);};return np;};}function storeCurrent(attr,val,newVal,preGUI){if(Array.isArray(val)||Array.isArray(newVal)){var arrayVal=Array.isArray(val)?val:[];var arrayNew=Array.isArray(newVal)?newVal:[];var maxLen=Math.max(arrayVal.length,arrayNew.length);for(var i=0;i<maxLen;i++){storeCurrent(attr+'['+i+']',arrayVal[i],arrayNew[i],preGUI);}}else if(Lib.isPlainObject(val)||Lib.isPlainObject(newVal)){var objVal=Lib.isPlainObject(val)?val:{};var objNew=Lib.isPlainObject(newVal)?newVal:{};var objBoth=Lib.extendFlat({},objVal,objNew);for(var key in objBoth){storeCurrent(attr+'.'+key,objVal[key],objNew[key],preGUI);}}else if(preGUI[attr]===undefined){preGUI[attr]=undefinedToNull(val);}}/**\n * storeDirectGUIEdit: for routines that skip restyle/relayout and mock it\n * by emitting a plotly_restyle or plotly_relayout event, this routine\n * keeps track of the initial state in _preGUI for use by uirevision\n * Does *not* apply these changes to data/layout - that's the responsibility\n * of the calling routine.\n *\n * @param {object} container: the input attributes container (eg `layout` or a `trace`)\n * @param {object} preGUI: where original values should be stored, either\n *     `layout._preGUI` or `layout._tracePreGUI[uid]`\n * @param {object} edits: the {attr: val} object as normally passed to `relayout` etc\n */function _storeDirectGUIEdit(container,preGUI,edits){for(var attr in edits){var np=nestedProperty(container,attr);storeCurrent(attr,np.get(),edits[attr],preGUI);}}function _restyle(gd,aobj,traces){var fullLayout=gd._fullLayout;var fullData=gd._fullData;var data=gd.data;var guiEditFlag=fullLayout._guiEditing;var layoutNP=makeNP(fullLayout._preGUI,guiEditFlag);var eventData=Lib.extendDeepAll({},aobj);var i;cleanDeprecatedAttributeKeys(aobj);// initialize flags\nvar flags=editTypes.traceFlags();// copies of the change (and previous values of anything affected)\n// for the undo / redo queue\nvar redoit={};var undoit={};var axlist;// make a new empty vals array for undoit\nfunction a0(){return traces.map(function(){return undefined;});}// for autoranging multiple axes\nfunction addToAxlist(axid){var axName=Axes.id2name(axid);if(axlist.indexOf(axName)===-1)axlist.push(axName);}function autorangeAttr(axName){return'LAYOUT'+axName+'.autorange';}function rangeAttr(axName){return'LAYOUT'+axName+'.range';}function getFullTrace(traceIndex){// usually fullData maps 1:1 onto data, but with groupby transforms\n// the fullData index can be greater. Take the *first* matching trace.\nfor(var j=traceIndex;j<fullData.length;j++){if(fullData[j]._input===data[traceIndex])return fullData[j];}// should never get here - and if we *do* it should cause an error\n// later on undefined fullTrace is passed to nestedProperty.\n}// for attrs that interact (like scales & autoscales), save the\n// old vals before making the change\n// val=undefined will not set a value, just record what the value was.\n// val=null will delete the attribute\n// attr can be an array to set several at once (all to the same val)\nfunction doextra(attr,val,i){if(Array.isArray(attr)){attr.forEach(function(a){doextra(a,val,i);});return;}// quit if explicitly setting this elsewhere\nif(attr in aobj||helpers.hasParent(aobj,attr))return;var extraparam;if(attr.substr(0,6)==='LAYOUT'){extraparam=layoutNP(gd.layout,attr.replace('LAYOUT',''));}else{var tracei=traces[i];var preGUI=fullLayout._tracePreGUI[getFullTrace(tracei)._fullInput.uid];extraparam=makeNP(preGUI,guiEditFlag)(data[tracei],attr);}if(!(attr in undoit)){undoit[attr]=a0();}if(undoit[attr][i]===undefined){undoit[attr][i]=undefinedToNull(extraparam.get());}if(val!==undefined){extraparam.set(val);}}function allBins(binAttr){return function(j){return fullData[j][binAttr];};}function arrayBins(binAttr){return function(vij,j){return vij===false?fullData[traces[j]][binAttr]:null;};}// now make the changes to gd.data (and occasionally gd.layout)\n// and figure out what kind of graphics update we need to do\nfor(var ai in aobj){if(helpers.hasParent(aobj,ai)){throw new Error('cannot set '+ai+' and a parent attribute simultaneously');}var vi=aobj[ai];var cont;var contFull;var param;var oldVal;var newVal;var valObject;// Backward compatibility shim for turning histogram autobin on,\n// or freezing previous autobinned values.\n// Replace obsolete `autobin(x|y): true` with `(x|y)bins: null`\n// and `autobin(x|y): false` with the `(x|y)bins` in `fullData`\nif(ai==='autobinx'||ai==='autobiny'){ai=ai.charAt(ai.length-1)+'bins';if(Array.isArray(vi))vi=vi.map(arrayBins(ai));else if(vi===false)vi=traces.map(allBins(ai));else vi=null;}redoit[ai]=vi;if(ai.substr(0,6)==='LAYOUT'){param=layoutNP(gd.layout,ai.replace('LAYOUT',''));undoit[ai]=[undefinedToNull(param.get())];// since we're allowing val to be an array, allow it here too,\n// even though that's meaningless\nparam.set(Array.isArray(vi)?vi[0]:vi);// ironically, the layout attrs in restyle only require replot,\n// not relayout\nflags.calc=true;continue;}// set attribute in gd.data\nundoit[ai]=a0();for(i=0;i<traces.length;i++){cont=data[traces[i]];contFull=getFullTrace(traces[i]);var preGUI=fullLayout._tracePreGUI[contFull._fullInput.uid];param=makeNP(preGUI,guiEditFlag)(cont,ai);oldVal=param.get();newVal=Array.isArray(vi)?vi[i%vi.length]:vi;if(newVal===undefined)continue;var finalPart=param.parts[param.parts.length-1];var prefix=ai.substr(0,ai.length-finalPart.length-1);var prefixDot=prefix?prefix+'.':'';var innerContFull=prefix?nestedProperty(contFull,prefix).get():contFull;valObject=PlotSchema.getTraceValObject(contFull,param.parts);if(valObject&&valObject.impliedEdits&&newVal!==null){for(var impliedKey in valObject.impliedEdits){doextra(Lib.relativeAttr(ai,impliedKey),valObject.impliedEdits[impliedKey],i);}}else if((finalPart==='thicknessmode'||finalPart==='lenmode')&&oldVal!==newVal&&(newVal==='fraction'||newVal==='pixels')&&innerContFull){// changing colorbar size modes,\n// make the resulting size not change\n// note that colorbar fractional sizing is based on the\n// original plot size, before anything (like a colorbar)\n// increases the margins\nvar gs=fullLayout._size;var orient=innerContFull.orient;var topOrBottom=orient==='top'||orient==='bottom';if(finalPart==='thicknessmode'){var thicknorm=topOrBottom?gs.h:gs.w;doextra(prefixDot+'thickness',innerContFull.thickness*(newVal==='fraction'?1/thicknorm:thicknorm),i);}else{var lennorm=topOrBottom?gs.w:gs.h;doextra(prefixDot+'len',innerContFull.len*(newVal==='fraction'?1/lennorm:lennorm),i);}}else if(ai==='type'&&newVal==='pie'!==(oldVal==='pie')){var labelsTo='x';var valuesTo='y';if((newVal==='bar'||oldVal==='bar')&&cont.orientation==='h'){labelsTo='y';valuesTo='x';}Lib.swapAttrs(cont,['?','?src'],'labels',labelsTo);Lib.swapAttrs(cont,['d?','?0'],'label',labelsTo);Lib.swapAttrs(cont,['?','?src'],'values',valuesTo);if(oldVal==='pie'){nestedProperty(cont,'marker.color').set(nestedProperty(cont,'marker.colors').get());// super kludgy - but if all pies are gone we won't remove them otherwise\nfullLayout._pielayer.selectAll('g.trace').remove();}else if(Registry.traceIs(cont,'cartesian')){nestedProperty(cont,'marker.colors').set(nestedProperty(cont,'marker.color').get());}}undoit[ai][i]=undefinedToNull(oldVal);// set the new value - if val is an array, it's one el per trace\n// first check for attributes that get more complex alterations\nvar swapAttrs=['swapxy','swapxyaxes','orientation','orientationaxes'];if(swapAttrs.indexOf(ai)!==-1){// setting an orientation: make sure it's changing\n// before we swap everything else\nif(ai==='orientation'){param.set(newVal);// obnoxious that we need this level of coupling... but in order to\n// properly handle setting orientation to `null` we need to mimic\n// the logic inside Bars.supplyDefaults for default orientation\nvar defaultOrientation=cont.x&&!cont.y?'h':'v';if((param.get()||defaultOrientation)===contFull.orientation){continue;}}else if(ai==='orientationaxes'){// orientationaxes has no value,\n// it flips everything and the axes\ncont.orientation={v:'h',h:'v'}[contFull.orientation];}helpers.swapXYData(cont);flags.calc=flags.clearAxisTypes=true;}else if(Plots.dataArrayContainers.indexOf(param.parts[0])!==-1){// TODO: use manageArrays.applyContainerArrayChanges here too\nhelpers.manageArrayContainers(param,newVal,undoit);flags.calc=true;}else{if(valObject){// must redo calcdata when restyling array values of arrayOk attributes\n// ... but no need to this for regl-based traces\nif(valObject.arrayOk&&!Registry.traceIs(contFull,'regl')&&(Lib.isArrayOrTypedArray(newVal)||Lib.isArrayOrTypedArray(oldVal))){flags.calc=true;}else editTypes.update(flags,valObject);}else{/*\n                     * if we couldn't find valObject,  assume a full recalc.\n                     * This can happen if you're changing type and making\n                     * some other edits too, so the modules we're\n                     * looking at don't have these attributes in them.\n                     */flags.calc=true;}// all the other ones, just modify that one attribute\nparam.set(newVal);}}// swap the data attributes of the relevant x and y axes?\nif(['swapxyaxes','orientationaxes'].indexOf(ai)!==-1){Axes.swap(gd,traces);}// swap hovermode if set to \"compare x/y data\"\nif(ai==='orientationaxes'){var hovermode=nestedProperty(gd.layout,'hovermode');if(hovermode.get()==='x'){hovermode.set('y');}else if(hovermode.get()==='y'){hovermode.set('x');}}// Major enough changes deserve autoscale and\n// non-reversed axes so people don't get confused\n//\n// Note: autobin (or its new analog bin clearing) is not included here\n// since we're not pushing bins back to gd.data, so if we have bin\n// info it was explicitly provided by the user.\nif(['orientation','type'].indexOf(ai)!==-1){axlist=[];for(i=0;i<traces.length;i++){var trace=data[traces[i]];if(Registry.traceIs(trace,'cartesian')){addToAxlist(trace.xaxis||'x');addToAxlist(trace.yaxis||'y');}}doextra(axlist.map(autorangeAttr),true,0);doextra(axlist.map(rangeAttr),[0,1],0);}}if(flags.calc||flags.plot){flags.fullReplot=true;}return{flags:flags,undoit:undoit,redoit:redoit,traces:traces,eventData:Lib.extendDeepNoArrays([],[eventData,traces])};}/**\n * Converts deprecated attribute keys to\n * the current API to ensure backwards compatibility.\n *\n * This is needed for the update mechanism to determine which\n * subroutines to run based on the actual attribute\n * definitions (that don't include the deprecated ones).\n *\n * E.g. Maps {'xaxis.title': 'A chart'} to {'xaxis.title.text': 'A chart'}\n * and {titlefont: {...}} to {'title.font': {...}}.\n *\n * @param aobj\n */function cleanDeprecatedAttributeKeys(aobj){var oldAxisTitleRegex=Lib.counterRegex('axis','\\.title',false,false);var colorbarRegex=/colorbar\\.title$/;var keys=Object.keys(aobj);var i,key,value;for(i=0;i<keys.length;i++){key=keys[i];value=aobj[key];if((key==='title'||oldAxisTitleRegex.test(key)||colorbarRegex.test(key))&&(typeof value==='string'||typeof value==='number')){replace(key,key.replace('title','title.text'));}else if(key.indexOf('titlefont')>-1){replace(key,key.replace('titlefont','title.font'));}else if(key.indexOf('titleposition')>-1){replace(key,key.replace('titleposition','title.position'));}else if(key.indexOf('titleside')>-1){replace(key,key.replace('titleside','title.side'));}else if(key.indexOf('titleoffset')>-1){replace(key,key.replace('titleoffset','title.offset'));}}function replace(oldAttrStr,newAttrStr){aobj[newAttrStr]=aobj[oldAttrStr];delete aobj[oldAttrStr];}}/**\n * relayout: update layout attributes of an existing plot\n *\n * Can be called two ways:\n *\n * Signature 1:\n * @param {String | HTMLDivElement} gd\n *  the id or dom element of the graph container div\n * @param {String} astr\n *  attribute string (like `'xaxis.range[0]'`) to update\n * @param {*} val\n *  value to give this attribute\n *\n * Signature 2:\n * @param {String | HTMLDivElement} gd\n *  (as in signature 1)\n * @param {Object} aobj\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  allows setting multiple attributes simultaneously\n */function relayout(gd,astr,val){gd=Lib.getGraphDiv(gd);helpers.clearPromiseQueue(gd);if(gd.framework&&gd.framework.isPolar){return Promise.resolve(gd);}var aobj={};if(typeof astr==='string'){aobj[astr]=val;}else if(Lib.isPlainObject(astr)){aobj=Lib.extendFlat({},astr);}else{Lib.warn('Relayout fail.',astr,val);return Promise.reject();}if(Object.keys(aobj).length)gd.changed=true;var specs=_relayout(gd,aobj);var flags=specs.flags;// clear calcdata if required\nif(flags.calc)gd.calcdata=undefined;// fill in redraw sequence\n// even if we don't have anything left in aobj,\n// something may have happened within relayout that we\n// need to wait for\nvar seq=[Plots.previousPromises];if(flags.layoutReplot){seq.push(subroutines.layoutReplot);}else if(Object.keys(aobj).length){axRangeSupplyDefaultsByPass(gd,flags,specs)||Plots.supplyDefaults(gd);if(flags.legend)seq.push(subroutines.doLegend);if(flags.layoutstyle)seq.push(subroutines.layoutStyles);if(flags.axrange)addAxRangeSequence(seq,specs.rangesAltered);if(flags.ticks)seq.push(subroutines.doTicksRelayout);if(flags.modebar)seq.push(subroutines.doModeBar);if(flags.camera)seq.push(subroutines.doCamera);seq.push(emitAfterPlot);}seq.push(Plots.rehover,Plots.redrag);Queue.add(gd,relayout,[gd,specs.undoit],relayout,[gd,specs.redoit]);var plotDone=Lib.syncOrAsync(seq,gd);if(!plotDone||!plotDone.then)plotDone=Promise.resolve(gd);return plotDone.then(function(){gd.emit('plotly_relayout',specs.eventData);return gd;});}// Optimization mostly for large splom traces where\n// Plots.supplyDefaults can take > 100ms\nfunction axRangeSupplyDefaultsByPass(gd,flags,specs){var fullLayout=gd._fullLayout;if(!flags.axrange)return false;for(var k in flags){if(k!=='axrange'&&flags[k])return false;}for(var axId in specs.rangesAltered){var axName=Axes.id2name(axId);var axIn=gd.layout[axName];var axOut=fullLayout[axName];axOut.autorange=axIn.autorange;axOut.range=axIn.range.slice();axOut.cleanRange();if(axOut._matchGroup){for(var axId2 in axOut._matchGroup){if(axId2!==axId){var ax2=fullLayout[Axes.id2name(axId2)];ax2.autorange=axOut.autorange;ax2.range=axOut.range.slice();ax2._input.range=axOut.range.slice();}}}}return true;}function addAxRangeSequence(seq,rangesAltered){// N.B. leave as sequence of subroutines (for now) instead of\n// subroutine of its own so that finalDraw always gets\n// executed after drawData\nvar drawAxes=rangesAltered?function(gd){var axIds=[];var skipTitle=true;for(var id in rangesAltered){var ax=Axes.getFromId(gd,id);axIds.push(id);if(ax._matchGroup){for(var id2 in ax._matchGroup){if(!rangesAltered[id2]){axIds.push(id2);}}}if(ax.automargin)skipTitle=false;}return Axes.draw(gd,axIds,{skipTitle:skipTitle});}:function(gd){return Axes.draw(gd,'redraw');};seq.push(clearSelect,subroutines.doAutoRangeAndConstraints,drawAxes,subroutines.drawData,subroutines.finalDraw);}var AX_RANGE_RE=/^[xyz]axis[0-9]*\\.range(\\[[0|1]\\])?$/;var AX_AUTORANGE_RE=/^[xyz]axis[0-9]*\\.autorange$/;var AX_DOMAIN_RE=/^[xyz]axis[0-9]*\\.domain(\\[[0|1]\\])?$/;function _relayout(gd,aobj){var layout=gd.layout;var fullLayout=gd._fullLayout;var guiEditFlag=fullLayout._guiEditing;var layoutNP=makeNP(fullLayout._preGUI,guiEditFlag);var keys=Object.keys(aobj);var axes=Axes.list(gd);var eventData=Lib.extendDeepAll({},aobj);var arrayEdits={};var arrayStr,i,j;cleanDeprecatedAttributeKeys(aobj);keys=Object.keys(aobj);// look for 'allaxes', split out into all axes\n// in case of 3D the axis are nested within a scene which is held in _id\nfor(i=0;i<keys.length;i++){if(keys[i].indexOf('allaxes')===0){for(j=0;j<axes.length;j++){var scene=axes[j]._id.substr(1);var axisAttr=scene.indexOf('scene')!==-1?scene+'.':'';var newkey=keys[i].replace('allaxes',axisAttr+axes[j]._name);if(!aobj[newkey])aobj[newkey]=aobj[keys[i]];}delete aobj[keys[i]];}}// initialize flags\nvar flags=editTypes.layoutFlags();// copies of the change (and previous values of anything affected)\n// for the undo / redo queue\nvar redoit={};var undoit={};// for attrs that interact (like scales & autoscales), save the\n// old vals before making the change\n// val=undefined will not set a value, just record what the value was.\n// attr can be an array to set several at once (all to the same val)\nfunction doextra(attr,val){if(Array.isArray(attr)){attr.forEach(function(a){doextra(a,val);});return;}// if we have another value for this attribute (explicitly or\n// via a parent) do not override with this auto-generated extra\nif(attr in aobj||helpers.hasParent(aobj,attr))return;var p=layoutNP(layout,attr);if(!(attr in undoit)){undoit[attr]=undefinedToNull(p.get());}if(val!==undefined)p.set(val);}// for constraint enforcement: keep track of all axes (as {id: name})\n// we're editing the (auto)range of, so we can tell the others constrained\n// to scale with them that it's OK for them to shrink\nvar rangesAltered={};var axId;function recordAlteredAxis(pleafPlus){var axId=Axes.name2id(pleafPlus.split('.')[0]);rangesAltered[axId]=1;return axId;}// alter gd.layout\nfor(var ai in aobj){if(helpers.hasParent(aobj,ai)){throw new Error('cannot set '+ai+' and a parent attribute simultaneously');}var p=layoutNP(layout,ai);var vi=aobj[ai];var plen=p.parts.length;// p.parts may end with an index integer if the property is an array\nvar pend=plen-1;while(pend>0&&typeof p.parts[pend]!=='string'){pend--;}// last property in chain (leaf node)\nvar pleaf=p.parts[pend];// leaf plus immediate parent\nvar pleafPlus=p.parts[pend-1]+'.'+pleaf;// trunk nodes (everything except the leaf)\nvar ptrunk=p.parts.slice(0,pend).join('.');var parentIn=nestedProperty(gd.layout,ptrunk).get();var parentFull=nestedProperty(fullLayout,ptrunk).get();var vOld=p.get();if(vi===undefined)continue;redoit[ai]=vi;// axis reverse is special - it is its own inverse\n// op and has no flag.\nundoit[ai]=pleaf==='reverse'?vi:undefinedToNull(vOld);var valObject=PlotSchema.getLayoutValObject(fullLayout,p.parts);if(valObject&&valObject.impliedEdits&&vi!==null){for(var impliedKey in valObject.impliedEdits){doextra(Lib.relativeAttr(ai,impliedKey),valObject.impliedEdits[impliedKey]);}}// Setting width or height to null must reset the graph's width / height\n// back to its initial value as computed during the first pass in Plots.plotAutoSize.\n//\n// To do so, we must manually set them back here using the _initialAutoSize cache.\n// can't use impliedEdits for this because behavior depends on vi\nif(['width','height'].indexOf(ai)!==-1){if(vi){doextra('autosize',null);// currently we don't support autosize one dim only - so\n// explicitly set the other one. Note that doextra will\n// ignore this if the same relayout call also provides oppositeAttr\nvar oppositeAttr=ai==='height'?'width':'height';doextra(oppositeAttr,fullLayout[oppositeAttr]);}else{fullLayout[ai]=gd._initialAutoSize[ai];}}else if(ai==='autosize'){// depends on vi here too, so again can't use impliedEdits\ndoextra('width',vi?null:fullLayout.width);doextra('height',vi?null:fullLayout.height);}else if(pleafPlus.match(AX_RANGE_RE)){// check autorange vs range\nrecordAlteredAxis(pleafPlus);nestedProperty(fullLayout,ptrunk+'._inputRange').set(null);}else if(pleafPlus.match(AX_AUTORANGE_RE)){recordAlteredAxis(pleafPlus);nestedProperty(fullLayout,ptrunk+'._inputRange').set(null);var axFull=nestedProperty(fullLayout,ptrunk).get();if(axFull._inputDomain){// if we're autoranging and this axis has a constrained domain,\n// reset it so we don't get locked into a shrunken size\naxFull._input.domain=axFull._inputDomain.slice();}}else if(pleafPlus.match(AX_DOMAIN_RE)){nestedProperty(fullLayout,ptrunk+'._inputDomain').set(null);}// toggling axis type between log and linear: we need to convert\n// positions for components that are still using linearized values,\n// not data values like newer components.\n// previously we did this for log <-> not-log, but now only do it\n// for log <-> linear\nif(pleaf==='type'){var ax=parentIn;var toLog=parentFull.type==='linear'&&vi==='log';var fromLog=parentFull.type==='log'&&vi==='linear';if(toLog||fromLog){if(!ax||!ax.range){// 2D never gets here, but 3D does\n// I don't think this is needed, but left here in case there\n// are edge cases I'm not thinking of.\ndoextra(ptrunk+'.autorange',true);}else if(!parentFull.autorange){// toggling log without autorange: need to also recalculate ranges\n// because log axes use linearized values for range endpoints\nvar r0=ax.range[0];var r1=ax.range[1];if(toLog){// if both limits are negative, autorange\nif(r0<=0&&r1<=0){doextra(ptrunk+'.autorange',true);}// if one is negative, set it 6 orders below the other.\nif(r0<=0)r0=r1/1e6;else if(r1<=0)r1=r0/1e6;// now set the range values as appropriate\ndoextra(ptrunk+'.range[0]',Math.log(r0)/Math.LN10);doextra(ptrunk+'.range[1]',Math.log(r1)/Math.LN10);}else{doextra(ptrunk+'.range[0]',Math.pow(10,r0));doextra(ptrunk+'.range[1]',Math.pow(10,r1));}}else if(toLog){// just make sure the range is positive and in the right\n// order, it'll get recalculated later\nax.range=ax.range[1]>ax.range[0]?[1,2]:[2,1];}// clear polar view initial stash for radial range so that\n// value get recomputed in correct units\nif(Array.isArray(fullLayout._subplots.polar)&&fullLayout._subplots.polar.length&&fullLayout[p.parts[0]]&&p.parts[1]==='radialaxis'){delete fullLayout[p.parts[0]]._subplot.viewInitial['radialaxis.range'];}// Annotations and images also need to convert to/from linearized coords\n// Shapes do not need this :)\nRegistry.getComponentMethod('annotations','convertCoords')(gd,parentFull,vi,doextra);Registry.getComponentMethod('images','convertCoords')(gd,parentFull,vi,doextra);}else{// any other type changes: the range from the previous type\n// will not make sense, so autorange it.\ndoextra(ptrunk+'.autorange',true);doextra(ptrunk+'.range',null);}nestedProperty(fullLayout,ptrunk+'._inputRange').set(null);}else if(pleaf.match(AX_NAME_PATTERN)){var fullProp=nestedProperty(fullLayout,ai).get();var newType=(vi||{}).type;// This can potentially cause strange behavior if the autotype is not\n// numeric (linear, because we don't auto-log) but the previous type\n// was log. That's a very strange edge case though\nif(!newType||newType==='-')newType='linear';Registry.getComponentMethod('annotations','convertCoords')(gd,fullProp,newType,doextra);Registry.getComponentMethod('images','convertCoords')(gd,fullProp,newType,doextra);}// alter gd.layout\n// collect array component edits for execution all together\n// so we can ensure consistent behavior adding/removing items\n// and order-independence for add/remove/edit all together in\n// one relayout call\nvar containerArrayMatch=manageArrays.containerArrayMatch(ai);if(containerArrayMatch){arrayStr=containerArrayMatch.array;i=containerArrayMatch.index;var propStr=containerArrayMatch.property;var updateValObject=valObject||{editType:'calc'};if(i!==''&&propStr===''){// special handling of undoit if we're adding or removing an element\n// ie 'annotations[2]' which can be {...} (add) or null,\n// does not work when replacing the entire array\nif(manageArrays.isAddVal(vi)){undoit[ai]=null;}else if(manageArrays.isRemoveVal(vi)){undoit[ai]=(nestedProperty(layout,arrayStr).get()||[])[i];}else{Lib.warn('unrecognized full object value',aobj);}}editTypes.update(flags,updateValObject);// prepare the edits object we'll send to applyContainerArrayChanges\nif(!arrayEdits[arrayStr])arrayEdits[arrayStr]={};var objEdits=arrayEdits[arrayStr][i];if(!objEdits)objEdits=arrayEdits[arrayStr][i]={};objEdits[propStr]=vi;delete aobj[ai];}else if(pleaf==='reverse'){// handle axis reversal explicitly, as there's no 'reverse' attribute\nif(parentIn.range)parentIn.range.reverse();else{doextra(ptrunk+'.autorange',true);parentIn.range=[1,0];}if(parentFull.autorange)flags.calc=true;else flags.plot=true;}else{if(fullLayout._has('scatter-like')&&fullLayout._has('regl')&&ai==='dragmode'&&(vi==='lasso'||vi==='select')&&!(vOld==='lasso'||vOld==='select')){flags.plot=true;}else if(fullLayout._has('gl2d')){flags.plot=true;}else if(valObject)editTypes.update(flags,valObject);else flags.calc=true;p.set(vi);}}// now we've collected component edits - execute them all together\nfor(arrayStr in arrayEdits){var finished=manageArrays.applyContainerArrayChanges(gd,layoutNP(layout,arrayStr),arrayEdits[arrayStr],flags,layoutNP);if(!finished)flags.plot=true;}// figure out if we need to recalculate axis constraints\nvar constraints=fullLayout._axisConstraintGroups||[];for(axId in rangesAltered){for(i=0;i<constraints.length;i++){var group=constraints[i];if(group[axId]){// Always recalc if we're changing constrained ranges.\n// Otherwise it's possible to violate the constraints by\n// specifying arbitrary ranges for all axes in the group.\n// this way some ranges may expand beyond what's specified,\n// as they do at first draw, to satisfy the constraints.\nflags.calc=true;for(var groupAxId in group){if(!rangesAltered[groupAxId]){Axes.getFromId(gd,groupAxId)._constraintShrinkable=true;}}}}}// If the autosize changed or height or width was explicitly specified,\n// this triggers a redraw\n// TODO: do we really need special aobj.height/width handling here?\n// couldn't editType do this?\nif(updateAutosize(gd)||aobj.height||aobj.width)flags.plot=true;if(flags.plot||flags.calc){flags.layoutReplot=true;}// now all attribute mods are done, as are\n// redo and undo so we can save them\nreturn{flags:flags,rangesAltered:rangesAltered,undoit:undoit,redoit:redoit,eventData:eventData};}/*\n * updateAutosize: we made a change, does it change the autosize result?\n * puts the new size into fullLayout\n * returns true if either height or width changed\n */function updateAutosize(gd){var fullLayout=gd._fullLayout;var oldWidth=fullLayout.width;var oldHeight=fullLayout.height;// calculate autosizing\nif(gd.layout.autosize)Plots.plotAutoSize(gd,gd.layout,fullLayout);return fullLayout.width!==oldWidth||fullLayout.height!==oldHeight;}/**\n * update: update trace and layout attributes of an existing plot\n *\n * @param {String | HTMLDivElement} gd\n *  the id or DOM element of the graph container div\n * @param {Object} traceUpdate\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  corresponding to updates in the plot's traces\n * @param {Object} layoutUpdate\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  corresponding to updates in the plot's layout\n * @param {Number[] | Number} [traces]\n *  integer or array of integers for the traces to alter (all if omitted)\n *\n */function update(gd,traceUpdate,layoutUpdate,_traces){gd=Lib.getGraphDiv(gd);helpers.clearPromiseQueue(gd);if(gd.framework&&gd.framework.isPolar){return Promise.resolve(gd);}if(!Lib.isPlainObject(traceUpdate))traceUpdate={};if(!Lib.isPlainObject(layoutUpdate))layoutUpdate={};if(Object.keys(traceUpdate).length)gd.changed=true;if(Object.keys(layoutUpdate).length)gd.changed=true;var traces=helpers.coerceTraceIndices(gd,_traces);var restyleSpecs=_restyle(gd,Lib.extendFlat({},traceUpdate),traces);var restyleFlags=restyleSpecs.flags;var relayoutSpecs=_relayout(gd,Lib.extendFlat({},layoutUpdate));var relayoutFlags=relayoutSpecs.flags;// clear calcdata and/or axis types if required\nif(restyleFlags.calc||relayoutFlags.calc)gd.calcdata=undefined;if(restyleFlags.clearAxisTypes)helpers.clearAxisTypes(gd,traces,layoutUpdate);// fill in redraw sequence\nvar seq=[];if(restyleFlags.fullReplot&&relayoutFlags.layoutReplot){var data=gd.data;var layout=gd.layout;// clear existing data/layout on gd\n// so that Plotly.plot doesn't try to extend them\ngd.data=undefined;gd.layout=undefined;seq.push(function(){return exports.plot(gd,data,layout);});}else if(restyleFlags.fullReplot){seq.push(exports.plot);}else if(relayoutFlags.layoutReplot){seq.push(subroutines.layoutReplot);}else{seq.push(Plots.previousPromises);axRangeSupplyDefaultsByPass(gd,relayoutFlags,relayoutSpecs)||Plots.supplyDefaults(gd);if(restyleFlags.style)seq.push(subroutines.doTraceStyle);if(restyleFlags.colorbars)seq.push(subroutines.doColorBars);if(relayoutFlags.legend)seq.push(subroutines.doLegend);if(relayoutFlags.layoutstyle)seq.push(subroutines.layoutStyles);if(relayoutFlags.axrange)addAxRangeSequence(seq,relayoutSpecs.rangesAltered);if(relayoutFlags.ticks)seq.push(subroutines.doTicksRelayout);if(relayoutFlags.modebar)seq.push(subroutines.doModeBar);if(relayoutFlags.camera)seq.push(subroutines.doCamera);seq.push(emitAfterPlot);}seq.push(Plots.rehover,Plots.redrag);Queue.add(gd,update,[gd,restyleSpecs.undoit,relayoutSpecs.undoit,restyleSpecs.traces],update,[gd,restyleSpecs.redoit,relayoutSpecs.redoit,restyleSpecs.traces]);var plotDone=Lib.syncOrAsync(seq,gd);if(!plotDone||!plotDone.then)plotDone=Promise.resolve(gd);return plotDone.then(function(){gd.emit('plotly_update',{data:restyleSpecs.eventData,layout:relayoutSpecs.eventData});return gd;});}/*\n * internal-use-only restyle/relayout/update variants that record the initial\n * values in (fullLayout|fullTrace)._preGUI so changes can be persisted across\n * Plotly.react data updates, dependent on uirevision attributes\n */function guiEdit(func){return function wrappedEdit(gd){gd._fullLayout._guiEditing=true;var p=func.apply(null,arguments);gd._fullLayout._guiEditing=false;return p;};}// For connecting edited layout attributes to uirevision attrs\n// If no `attr` we use `match[1] + '.uirevision'`\n// Ordered by most common edits first, to minimize our search time\nvar layoutUIControlPatterns=[{pattern:/^hiddenlabels/,attr:'legend.uirevision'},{pattern:/^((x|y)axis\\d*)\\.((auto)?range|title\\.text)/},// showspikes and modes include those nested inside scenes\n{pattern:/axis\\d*\\.showspikes$/,attr:'modebar.uirevision'},{pattern:/(hover|drag)mode$/,attr:'modebar.uirevision'},{pattern:/^(scene\\d*)\\.camera/},{pattern:/^(geo\\d*)\\.(projection|center)/},{pattern:/^(ternary\\d*\\.[abc]axis)\\.(min|title\\.text)$/},{pattern:/^(polar\\d*\\.radialaxis)\\.((auto)?range|angle|title\\.text)/},{pattern:/^(polar\\d*\\.angularaxis)\\.rotation/},{pattern:/^(mapbox\\d*)\\.(center|zoom|bearing|pitch)/},{pattern:/^legend\\.(x|y)$/,attr:'editrevision'},{pattern:/^(shapes|annotations)/,attr:'editrevision'},{pattern:/^title\\.text$/,attr:'editrevision'}];// same for trace attributes: if `attr` is given it's in layout,\n// or with no `attr` we use `trace.uirevision`\nvar traceUIControlPatterns=[{pattern:/^selectedpoints$/,attr:'selectionrevision'},// \"visible\" includes trace.transforms[i].styles[j].value.visible\n{pattern:/(^|value\\.)visible$/,attr:'legend.uirevision'},{pattern:/^dimensions\\[\\d+\\]\\.constraintrange/},{pattern:/^node\\.(x|y|groups)/},// for Sankey nodes\n{pattern:/^level$/},// for Sunburst traces\n// below this you must be in editable: true mode\n// TODO: I still put name and title with `trace.uirevision`\n// reasonable or should these be `editrevision`?\n// Also applies to axis titles up in the layout section\n// \"name\" also includes transform.styles\n{pattern:/(^|value\\.)name$/},// including nested colorbar attributes (ie marker.colorbar)\n{pattern:/colorbar\\.title\\.text$/},{pattern:/colorbar\\.(x|y)$/,attr:'editrevision'}];function findUIPattern(key,patternSpecs){for(var i=0;i<patternSpecs.length;i++){var spec=patternSpecs[i];var match=key.match(spec.pattern);if(match){return{head:match[1],attr:spec.attr};}}}// We're finding the new uirevision before supplyDefaults, so do the\n// inheritance manually. Note that only `undefined` inherits - other\n// falsy values are returned.\nfunction getNewRev(revAttr,container){var newRev=nestedProperty(container,revAttr).get();if(newRev!==undefined)return newRev;var parts=revAttr.split('.');parts.pop();while(parts.length>1){parts.pop();newRev=nestedProperty(container,parts.join('.')+'.uirevision').get();if(newRev!==undefined)return newRev;}return container.uirevision;}function getFullTraceIndexFromUid(uid,fullData){for(var i=0;i<fullData.length;i++){if(fullData[i]._fullInput.uid===uid)return i;}return-1;}function getTraceIndexFromUid(uid,data,tracei){for(var i=0;i<data.length;i++){if(data[i].uid===uid)return i;}// fall back on trace order, but only if user didn't provide a uid for that trace\nreturn!data[tracei]||data[tracei].uid?-1:tracei;}function valsMatch(v1,v2){var v1IsObj=Lib.isPlainObject(v1);var v1IsArray=Array.isArray(v1);if(v1IsObj||v1IsArray){return(v1IsObj&&Lib.isPlainObject(v2)||v1IsArray&&Array.isArray(v2))&&JSON.stringify(v1)===JSON.stringify(v2);}return v1===v2;}function applyUIRevisions(data,layout,oldFullData,oldFullLayout){var layoutPreGUI=oldFullLayout._preGUI;var key,revAttr,oldRev,newRev,match,preGUIVal,newNP,newVal;var bothInheritAutorange=[];var newRangeAccepted={};for(key in layoutPreGUI){match=findUIPattern(key,layoutUIControlPatterns);if(match){revAttr=match.attr||match.head+'.uirevision';oldRev=nestedProperty(oldFullLayout,revAttr).get();newRev=oldRev&&getNewRev(revAttr,layout);if(newRev&&newRev===oldRev){preGUIVal=layoutPreGUI[key];if(preGUIVal===null)preGUIVal=undefined;newNP=nestedProperty(layout,key);newVal=newNP.get();if(valsMatch(newVal,preGUIVal)){if(newVal===undefined&&key.substr(key.length-9)==='autorange'){bothInheritAutorange.push(key.substr(0,key.length-10));}newNP.set(undefinedToNull(nestedProperty(oldFullLayout,key).get()));continue;}}}else{Lib.warn('unrecognized GUI edit: '+key);}// if we got this far, the new value was accepted as the new starting\n// point (either because it changed or revision changed)\n// so remove it from _preGUI for next time.\ndelete layoutPreGUI[key];if(key.substr(key.length-8,6)==='range['){newRangeAccepted[key.substr(0,key.length-9)]=1;}}// Special logic for `autorange`, since it interacts with `range`:\n// If the new figure's matching `range` was kept, and `autorange`\n// wasn't supplied explicitly in either the original or the new figure,\n// we shouldn't alter that - but we may just have done that, so fix it.\nfor(var i=0;i<bothInheritAutorange.length;i++){var axAttr=bothInheritAutorange[i];if(newRangeAccepted[axAttr]){var newAx=nestedProperty(layout,axAttr).get();if(newAx)delete newAx.autorange;}}// Now traces - try to match them up by uid (in case we added/deleted in\n// the middle), then fall back on index.\nvar allTracePreGUI=oldFullLayout._tracePreGUI;for(var uid in allTracePreGUI){var tracePreGUI=allTracePreGUI[uid];var newTrace=null;var fullInput;for(key in tracePreGUI){// wait until we know we have preGUI values to look for traces\n// but if we don't find both, stop looking at this uid\nif(!newTrace){var fulli=getFullTraceIndexFromUid(uid,oldFullData);if(fulli<0){// Somehow we didn't even have this trace in oldFullData...\n// I guess this could happen with `deleteTraces` or something\ndelete allTracePreGUI[uid];break;}var fullTrace=oldFullData[fulli];fullInput=fullTrace._fullInput;var newTracei=getTraceIndexFromUid(uid,data,fullInput.index);if(newTracei<0){// No match in new data\ndelete allTracePreGUI[uid];break;}newTrace=data[newTracei];}match=findUIPattern(key,traceUIControlPatterns);if(match){if(match.attr){oldRev=nestedProperty(oldFullLayout,match.attr).get();newRev=oldRev&&getNewRev(match.attr,layout);}else{oldRev=fullInput.uirevision;// inheritance for trace.uirevision is simple, just layout.uirevision\nnewRev=newTrace.uirevision;if(newRev===undefined)newRev=layout.uirevision;}if(newRev&&newRev===oldRev){preGUIVal=tracePreGUI[key];if(preGUIVal===null)preGUIVal=undefined;newNP=nestedProperty(newTrace,key);newVal=newNP.get();if(valsMatch(newVal,preGUIVal)){newNP.set(undefinedToNull(nestedProperty(fullInput,key).get()));continue;}}}else{Lib.warn('unrecognized GUI edit: '+key+' in trace uid '+uid);}delete tracePreGUI[key];}}}/**\n * Plotly.react:\n * A plot/update method that takes the full plot state (same API as plot/newPlot)\n * and diffs to determine the minimal update pathway\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {array of objects} data\n *      array of traces, containing the data and display information for each trace\n * @param {object} layout\n *      object describing the overall display of the plot,\n *      all the stuff that doesn't pertain to any individual trace\n * @param {object} config\n *      configuration options (see ./plot_config.js for more info)\n *\n * OR\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {object} figure\n *      object containing `data`, `layout`, `config`, and `frames` members\n *\n */function react(gd,data,layout,config){var frames,plotDone;function addFrames(){return exports.addFrames(gd,frames);}gd=Lib.getGraphDiv(gd);var oldFullData=gd._fullData;var oldFullLayout=gd._fullLayout;// you can use this as the initial draw as well as to update\nif(!Lib.isPlotDiv(gd)||!oldFullData||!oldFullLayout){plotDone=exports.newPlot(gd,data,layout,config);}else{if(Lib.isPlainObject(data)){var obj=data;data=obj.data;layout=obj.layout;config=obj.config;frames=obj.frames;}var configChanged=false;// assume that if there's a config at all, we're reacting to it too,\n// and completely replace the previous config\nif(config){var oldConfig=Lib.extendDeep({},gd._context);gd._context=undefined;setPlotContext(gd,config);configChanged=diffConfig(oldConfig,gd._context);}gd.data=data||[];helpers.cleanData(gd.data);gd.layout=layout||{};helpers.cleanLayout(gd.layout);applyUIRevisions(gd.data,gd.layout,oldFullData,oldFullLayout);// \"true\" skips updating calcdata and remapping arrays from calcTransforms,\n// which supplyDefaults usually does at the end, but we may need to NOT do\n// if the diff (which we haven't determined yet) says we'll recalc\nPlots.supplyDefaults(gd,{skipUpdateCalc:true});var newFullData=gd._fullData;var newFullLayout=gd._fullLayout;var immutable=newFullLayout.datarevision===undefined;var transition=newFullLayout.transition;var relayoutFlags=diffLayout(gd,oldFullLayout,newFullLayout,immutable,transition);var newDataRevision=relayoutFlags.newDataRevision;var restyleFlags=diffData(gd,oldFullData,newFullData,immutable,transition,newDataRevision);// TODO: how to translate this part of relayout to Plotly.react?\n// // Setting width or height to null must reset the graph's width / height\n// // back to its initial value as computed during the first pass in Plots.plotAutoSize.\n// //\n// // To do so, we must manually set them back here using the _initialAutoSize cache.\n// if(['width', 'height'].indexOf(ai) !== -1 && vi === null) {\n//     fullLayout[ai] = gd._initialAutoSize[ai];\n// }\nif(updateAutosize(gd))relayoutFlags.layoutReplot=true;// clear calcdata if required\nif(restyleFlags.calc||relayoutFlags.calc)gd.calcdata=undefined;// otherwise do the calcdata updates and calcTransform array remaps that we skipped earlier\nelse Plots.supplyDefaultsUpdateCalc(gd.calcdata,newFullData);// Note: what restyle/relayout use impliedEdits and clearAxisTypes for\n// must be handled by the user when using Plotly.react.\n// fill in redraw sequence\nvar seq=[];if(frames){gd._transitionData={};Plots.createTransitionData(gd);seq.push(addFrames);}// Transition pathway,\n// only used when 'transition' is set by user and\n// when at least one animatable attribute has changed,\n// N.B. config changed aren't animatable\nif(newFullLayout.transition&&!configChanged&&(restyleFlags.anim||relayoutFlags.anim)){Plots.doCalcdata(gd);subroutines.doAutoRangeAndConstraints(gd);seq.push(function(){return Plots.transitionFromReact(gd,restyleFlags,relayoutFlags,oldFullLayout);});}else if(restyleFlags.fullReplot||relayoutFlags.layoutReplot||configChanged){gd._fullLayout._skipDefaults=true;seq.push(exports.plot);}else{for(var componentType in relayoutFlags.arrays){var indices=relayoutFlags.arrays[componentType];if(indices.length){var drawOne=Registry.getComponentMethod(componentType,'drawOne');if(drawOne!==Lib.noop){for(var i=0;i<indices.length;i++){drawOne(gd,indices[i]);}}else{var draw=Registry.getComponentMethod(componentType,'draw');if(draw===Lib.noop){throw new Error('cannot draw components: '+componentType);}draw(gd);}}}seq.push(Plots.previousPromises);if(restyleFlags.style)seq.push(subroutines.doTraceStyle);if(restyleFlags.colorbars)seq.push(subroutines.doColorBars);if(relayoutFlags.legend)seq.push(subroutines.doLegend);if(relayoutFlags.layoutstyle)seq.push(subroutines.layoutStyles);if(relayoutFlags.axrange)addAxRangeSequence(seq);if(relayoutFlags.ticks)seq.push(subroutines.doTicksRelayout);if(relayoutFlags.modebar)seq.push(subroutines.doModeBar);if(relayoutFlags.camera)seq.push(subroutines.doCamera);seq.push(emitAfterPlot);}seq.push(Plots.rehover,Plots.redrag);plotDone=Lib.syncOrAsync(seq,gd);if(!plotDone||!plotDone.then)plotDone=Promise.resolve(gd);}return plotDone.then(function(){gd.emit('plotly_react',{data:data,layout:layout});return gd;});}function diffData(gd,oldFullData,newFullData,immutable,transition,newDataRevision){var sameTraceLength=oldFullData.length===newFullData.length;if(!transition&&!sameTraceLength){return{fullReplot:true,calc:true};}var flags=editTypes.traceFlags();flags.arrays={};flags.nChanges=0;flags.nChangesAnim=0;var i,trace;function getTraceValObject(parts){return PlotSchema.getTraceValObject(trace,parts);}var diffOpts={getValObject:getTraceValObject,flags:flags,immutable:immutable,transition:transition,newDataRevision:newDataRevision,gd:gd};var seenUIDs={};for(i=0;i<oldFullData.length;i++){if(newFullData[i]){trace=newFullData[i]._fullInput;if(Plots.hasMakesDataTransform(trace))trace=newFullData[i];if(seenUIDs[trace.uid])continue;seenUIDs[trace.uid]=1;getDiffFlags(oldFullData[i]._fullInput,trace,[],diffOpts);}}if(flags.calc||flags.plot){flags.fullReplot=true;}if(transition&&flags.nChanges&&flags.nChangesAnim){flags.anim=flags.nChanges===flags.nChangesAnim&&sameTraceLength?'all':'some';}return flags;}function diffLayout(gd,oldFullLayout,newFullLayout,immutable,transition){var flags=editTypes.layoutFlags();flags.arrays={};flags.rangesAltered={};flags.nChanges=0;flags.nChangesAnim=0;function getLayoutValObject(parts){return PlotSchema.getLayoutValObject(newFullLayout,parts);}var diffOpts={getValObject:getLayoutValObject,flags:flags,immutable:immutable,transition:transition,gd:gd};getDiffFlags(oldFullLayout,newFullLayout,[],diffOpts);if(flags.plot||flags.calc){flags.layoutReplot=true;}if(transition&&flags.nChanges&&flags.nChangesAnim){flags.anim=flags.nChanges===flags.nChangesAnim?'all':'some';}return flags;}function getDiffFlags(oldContainer,newContainer,outerparts,opts){var valObject,key,astr;var getValObject=opts.getValObject;var flags=opts.flags;var immutable=opts.immutable;var inArray=opts.inArray;var arrayIndex=opts.arrayIndex;function changed(){var editType=valObject.editType;if(inArray&&editType.indexOf('arraydraw')!==-1){Lib.pushUnique(flags.arrays[inArray],arrayIndex);return;}editTypes.update(flags,valObject);if(editType!=='none'){flags.nChanges++;}// track animatable changes\nif(opts.transition&&valObject.anim){flags.nChangesAnim++;}// track cartesian axes with altered ranges\nif(AX_RANGE_RE.test(astr)||AX_AUTORANGE_RE.test(astr)){flags.rangesAltered[outerparts[0]]=1;}// clear _inputDomain on cartesian axes with altered domains\nif(AX_DOMAIN_RE.test(astr)){nestedProperty(newContainer,'_inputDomain').set(null);}// track datarevision changes\nif(key==='datarevision'){flags.newDataRevision=1;}}function valObjectCanBeDataArray(valObject){return valObject.valType==='data_array'||valObject.arrayOk;}for(key in oldContainer){// short-circuit based on previous calls or previous keys that already maximized the pathway\nif(flags.calc&&!opts.transition)return;var oldVal=oldContainer[key];var newVal=newContainer[key];var parts=outerparts.concat(key);astr=parts.join('.');if(key.charAt(0)==='_'||typeof oldVal==='function'||oldVal===newVal)continue;// FIXME: ax.tick0 and dtick get filled in during plotting (except for geo subplots),\n// and unlike other auto values they don't make it back into the input,\n// so newContainer won't have them.\nif((key==='tick0'||key==='dtick')&&outerparts[0]!=='geo'){var tickMode=newContainer.tickmode;if(tickMode==='auto'||tickMode==='array'||!tickMode)continue;}// FIXME: Similarly for axis ranges for 3D\n// contourcarpet doesn't HAVE zmin/zmax, they're just auto-added. It needs them.\nif(key==='range'&&newContainer.autorange)continue;if((key==='zmin'||key==='zmax')&&newContainer.type==='contourcarpet')continue;valObject=getValObject(parts);// in case type changed, we may not even *have* a valObject.\nif(!valObject)continue;if(valObject._compareAsJSON&&JSON.stringify(oldVal)===JSON.stringify(newVal))continue;var valType=valObject.valType;var i;var canBeDataArray=valObjectCanBeDataArray(valObject);var wasArray=Array.isArray(oldVal);var nowArray=Array.isArray(newVal);// hack for traces that modify the data in supplyDefaults, like\n// converting 1D to 2D arrays, which will always create new objects\nif(wasArray&&nowArray){var inputKey='_input_'+key;var oldValIn=oldContainer[inputKey];var newValIn=newContainer[inputKey];if(Array.isArray(oldValIn)&&oldValIn===newValIn)continue;}if(newVal===undefined){if(canBeDataArray&&wasArray)flags.calc=true;else changed();}else if(valObject._isLinkedToArray){var arrayEditIndices=[];var extraIndices=false;if(!inArray)flags.arrays[key]=arrayEditIndices;var minLen=Math.min(oldVal.length,newVal.length);var maxLen=Math.max(oldVal.length,newVal.length);if(minLen!==maxLen){if(valObject.editType==='arraydraw'){extraIndices=true;}else{changed();continue;}}for(i=0;i<minLen;i++){getDiffFlags(oldVal[i],newVal[i],parts.concat(i),// add array indices, but not if we're already in an array\nLib.extendFlat({inArray:key,arrayIndex:i},opts));}// put this at the end so that we know our collected array indices are sorted\n// but the check for length changes happens up front so we can short-circuit\n// diffing if appropriate\nif(extraIndices){for(i=minLen;i<maxLen;i++){arrayEditIndices.push(i);}}}else if(!valType&&Lib.isPlainObject(oldVal)){getDiffFlags(oldVal,newVal,parts,opts);}else if(canBeDataArray){if(wasArray&&nowArray){// don't try to diff two data arrays. If immutable we know the data changed,\n// if not, assume it didn't and let `layout.datarevision` tell us if it did\nif(immutable){flags.calc=true;}// look for animatable attributes when the data changed\nif(immutable||opts.newDataRevision){changed();}}else if(wasArray!==nowArray){flags.calc=true;}else changed();}else if(wasArray&&nowArray){// info array, colorscale, 'any' - these are short, just stringify.\n// I don't *think* that covers up any real differences post-validation, does it?\n// otherwise we need to dive in 1 (info_array) or 2 (colorscale) levels and compare\n// all elements.\nif(oldVal.length!==newVal.length||String(oldVal)!==String(newVal)){changed();}}else{changed();}}for(key in newContainer){if(!(key in oldContainer||key.charAt(0)==='_'||typeof newContainer[key]==='function')){valObject=getValObject(outerparts.concat(key));if(valObjectCanBeDataArray(valObject)&&Array.isArray(newContainer[key])){flags.calc=true;return;}else changed();}}}/*\n * simple diff for config - for now, just treat all changes as equivalent\n */function diffConfig(oldConfig,newConfig){var key;for(key in oldConfig){if(key.charAt(0)==='_')continue;var oldVal=oldConfig[key];var newVal=newConfig[key];if(oldVal!==newVal){if(Lib.isPlainObject(oldVal)&&Lib.isPlainObject(newVal)){if(diffConfig(oldVal,newVal)){return true;}}else if(Array.isArray(oldVal)&&Array.isArray(newVal)){if(oldVal.length!==newVal.length){return true;}for(var i=0;i<oldVal.length;i++){if(oldVal[i]!==newVal[i]){if(Lib.isPlainObject(oldVal[i])&&Lib.isPlainObject(newVal[i])){if(diffConfig(oldVal[i],newVal[i])){return true;}}else{return true;}}}}else{return true;}}}}/**\n * Animate to a frame, sequence of frame, frame group, or frame definition\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {string or object or array of strings or array of objects} frameOrGroupNameOrFrameList\n *      a single frame, array of frames, or group to which to animate. The intent is\n *      inferred by the type of the input. Valid inputs are:\n *\n *      - string, e.g. 'groupname': animate all frames of a given `group` in the order\n *            in which they are defined via `Plotly.addFrames`.\n *\n *      - array of strings, e.g. ['frame1', frame2']: a list of frames by name to which\n *            to animate in sequence\n *\n *      - object: {data: ...}: a frame definition to which to animate. The frame is not\n *            and does not need to be added via `Plotly.addFrames`. It may contain any of\n *            the properties of a frame, including `data`, `layout`, and `traces`. The\n *            frame is used as provided and does not use the `baseframe` property.\n *\n *      - array of objects, e.g. [{data: ...}, {data: ...}]: a list of frame objects,\n *            each following the same rules as a single `object`.\n *\n * @param {object} animationOpts\n *      configuration for the animation\n */function animate(gd,frameOrGroupNameOrFrameList,animationOpts){gd=Lib.getGraphDiv(gd);if(!Lib.isPlotDiv(gd)){throw new Error('This element is not a Plotly plot: '+gd+'. It\\'s likely that you\\'ve failed '+'to create a plot before animating it. For more details, see '+'https://plot.ly/javascript/animations/');}var trans=gd._transitionData;// This is the queue of frames that will be animated as soon as possible. They\n// are popped immediately upon the *start* of a transition:\nif(!trans._frameQueue){trans._frameQueue=[];}animationOpts=Plots.supplyAnimationDefaults(animationOpts);var transitionOpts=animationOpts.transition;var frameOpts=animationOpts.frame;// Since frames are popped immediately, an empty queue only means all frames have\n// *started* to transition, not that the animation is complete. To solve that,\n// track a separate counter that increments at the same time as frames are added\n// to the queue, but decrements only when the transition is complete.\nif(trans._frameWaitingCnt===undefined){trans._frameWaitingCnt=0;}function getTransitionOpts(i){if(Array.isArray(transitionOpts)){if(i>=transitionOpts.length){return transitionOpts[0];}else{return transitionOpts[i];}}else{return transitionOpts;}}function getFrameOpts(i){if(Array.isArray(frameOpts)){if(i>=frameOpts.length){return frameOpts[0];}else{return frameOpts[i];}}else{return frameOpts;}}// Execute a callback after the wrapper function has been called n times.\n// This is used to defer the resolution until a transition has resovled *and*\n// the frame has completed. If it's not done this way, then we get a race\n// condition in which the animation might resolve before a transition is complete\n// or vice versa.\nfunction callbackOnNthTime(cb,n){var cnt=0;return function(){if(cb&&++cnt===n){return cb();}};}return new Promise(function(resolve,reject){function discardExistingFrames(){if(trans._frameQueue.length===0){return;}while(trans._frameQueue.length){var next=trans._frameQueue.pop();if(next.onInterrupt){next.onInterrupt();}}gd.emit('plotly_animationinterrupted',[]);}function queueFrames(frameList){if(frameList.length===0)return;for(var i=0;i<frameList.length;i++){var computedFrame;if(frameList[i].type==='byname'){// If it's a named frame, compute it:\ncomputedFrame=Plots.computeFrame(gd,frameList[i].name);}else{// Otherwise we must have been given a simple object, so treat\n// the input itself as the computed frame.\ncomputedFrame=frameList[i].data;}var frameOpts=getFrameOpts(i);var transitionOpts=getTransitionOpts(i);// It doesn't make much sense for the transition duration to be greater than\n// the frame duration, so limit it:\ntransitionOpts.duration=Math.min(transitionOpts.duration,frameOpts.duration);var nextFrame={frame:computedFrame,name:frameList[i].name,frameOpts:frameOpts,transitionOpts:transitionOpts};if(i===frameList.length-1){// The last frame in this .animate call stores the promise resolve\n// and reject callbacks. This is how we ensure that the animation\n// loop (which may exist as a result of a *different* .animate call)\n// still resolves or rejecdts this .animate call's promise. once it's\n// complete.\nnextFrame.onComplete=callbackOnNthTime(resolve,2);nextFrame.onInterrupt=reject;}trans._frameQueue.push(nextFrame);}// Set it as never having transitioned to a frame. This will cause the animation\n// loop to immediately transition to the next frame (which, for immediate mode,\n// is the first frame in the list since all others would have been discarded\n// below)\nif(animationOpts.mode==='immediate'){trans._lastFrameAt=-Infinity;}// Only it's not already running, start a RAF loop. This could be avoided in the\n// case that there's only one frame, but it significantly complicated the logic\n// and only sped things up by about 5% or so for a lorenz attractor simulation.\n// It would be a fine thing to implement, but the benefit of that optimization\n// doesn't seem worth the extra complexity.\nif(!trans._animationRaf){beginAnimationLoop();}}function stopAnimationLoop(){gd.emit('plotly_animated');// Be sure to unset also since it's how we know whether a loop is already running:\nwindow.cancelAnimationFrame(trans._animationRaf);trans._animationRaf=null;}function nextFrame(){if(trans._currentFrame&&trans._currentFrame.onComplete){// Execute the callback and unset it to ensure it doesn't\n// accidentally get called twice\ntrans._currentFrame.onComplete();}var newFrame=trans._currentFrame=trans._frameQueue.shift();if(newFrame){// Since it's sometimes necessary to do deep digging into frame data,\n// we'll consider it not 100% impossible for nulls or numbers to sneak through,\n// so check when casting the name, just to be absolutely certain:\nvar stringName=newFrame.name?newFrame.name.toString():null;gd._fullLayout._currentFrame=stringName;trans._lastFrameAt=Date.now();trans._timeToNext=newFrame.frameOpts.duration;// This is simply called and it's left to .transition to decide how to manage\n// interrupting current transitions. That means we don't need to worry about\n// how it resolves or what happens after this:\nPlots.transition(gd,newFrame.frame.data,newFrame.frame.layout,helpers.coerceTraceIndices(gd,newFrame.frame.traces),newFrame.frameOpts,newFrame.transitionOpts).then(function(){if(newFrame.onComplete){newFrame.onComplete();}});gd.emit('plotly_animatingframe',{name:stringName,frame:newFrame.frame,animation:{frame:newFrame.frameOpts,transition:newFrame.transitionOpts}});}else{// If there are no more frames, then stop the RAF loop:\nstopAnimationLoop();}}function beginAnimationLoop(){gd.emit('plotly_animating');// If no timer is running, then set last frame = long ago so that the next\n// frame is immediately transitioned:\ntrans._lastFrameAt=-Infinity;trans._timeToNext=0;trans._runningTransitions=0;trans._currentFrame=null;var doFrame=function doFrame(){// This *must* be requested before nextFrame since nextFrame may decide\n// to cancel it if there's nothing more to animated:\ntrans._animationRaf=window.requestAnimationFrame(doFrame);// Check if we're ready for a new frame:\nif(Date.now()-trans._lastFrameAt>trans._timeToNext){nextFrame();}};doFrame();}// This is an animate-local counter that helps match up option input list\n// items with the particular frame.\nvar configCounter=0;function setTransitionConfig(frame){if(Array.isArray(transitionOpts)){if(configCounter>=transitionOpts.length){frame.transitionOpts=transitionOpts[configCounter];}else{frame.transitionOpts=transitionOpts[0];}}else{frame.transitionOpts=transitionOpts;}configCounter++;return frame;}// Disambiguate what's sort of frames have been received\nvar i,frame;var frameList=[];var allFrames=frameOrGroupNameOrFrameList===undefined||frameOrGroupNameOrFrameList===null;var isFrameArray=Array.isArray(frameOrGroupNameOrFrameList);var isSingleFrame=!allFrames&&!isFrameArray&&Lib.isPlainObject(frameOrGroupNameOrFrameList);if(isSingleFrame){// In this case, a simple object has been passed to animate.\nframeList.push({type:'object',data:setTransitionConfig(Lib.extendFlat({},frameOrGroupNameOrFrameList))});}else if(allFrames||['string','number'].indexOf(_typeof(frameOrGroupNameOrFrameList))!==-1){// In this case, null or undefined has been passed so that we want to\n// animate *all* currently defined frames\nfor(i=0;i<trans._frames.length;i++){frame=trans._frames[i];if(!frame)continue;if(allFrames||String(frame.group)===String(frameOrGroupNameOrFrameList)){frameList.push({type:'byname',name:String(frame.name),data:setTransitionConfig({name:frame.name})});}}}else if(isFrameArray){for(i=0;i<frameOrGroupNameOrFrameList.length;i++){var frameOrName=frameOrGroupNameOrFrameList[i];if(['number','string'].indexOf(_typeof(frameOrName))!==-1){frameOrName=String(frameOrName);// In this case, there's an array and this frame is a string name:\nframeList.push({type:'byname',name:frameOrName,data:setTransitionConfig({name:frameOrName})});}else if(Lib.isPlainObject(frameOrName)){frameList.push({type:'object',data:setTransitionConfig(Lib.extendFlat({},frameOrName))});}}}// Verify that all of these frames actually exist; return and reject if not:\nfor(i=0;i<frameList.length;i++){frame=frameList[i];if(frame.type==='byname'&&!trans._frameHash[frame.data.name]){Lib.warn('animate failure: frame not found: \"'+frame.data.name+'\"');reject();return;}}// If the mode is either next or immediate, then all currently queued frames must\n// be dumped and the corresponding .animate promises rejected.\nif(['next','immediate'].indexOf(animationOpts.mode)!==-1){discardExistingFrames();}if(animationOpts.direction==='reverse'){frameList.reverse();}var currentFrame=gd._fullLayout._currentFrame;if(currentFrame&&animationOpts.fromcurrent){var idx=-1;for(i=0;i<frameList.length;i++){frame=frameList[i];if(frame.type==='byname'&&frame.name===currentFrame){idx=i;break;}}if(idx>0&&idx<frameList.length-1){var filteredFrameList=[];for(i=0;i<frameList.length;i++){frame=frameList[i];if(frameList[i].type!=='byname'||i>idx){filteredFrameList.push(frame);}}frameList=filteredFrameList;}}if(frameList.length>0){queueFrames(frameList);}else{// This is the case where there were simply no frames. It's a little strange\n// since there's not much to do:\ngd.emit('plotly_animated');resolve();}});}/**\n * Register new frames\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {array of objects} frameList\n *      list of frame definitions, in which each object includes any of:\n *      - name: {string} name of frame to add\n *      - data: {array of objects} trace data\n *      - layout {object} layout definition\n *      - traces {array} trace indices\n *      - baseframe {string} name of frame from which this frame gets defaults\n *\n *  @param {array of integers} indices\n *      an array of integer indices matching the respective frames in `frameList`. If not\n *      provided, an index will be provided in serial order. If already used, the frame\n *      will be overwritten.\n */function addFrames(gd,frameList,indices){gd=Lib.getGraphDiv(gd);if(frameList===null||frameList===undefined){return Promise.resolve();}if(!Lib.isPlotDiv(gd)){throw new Error('This element is not a Plotly plot: '+gd+'. It\\'s likely that you\\'ve failed '+'to create a plot before adding frames. For more details, see '+'https://plot.ly/javascript/animations/');}var i,frame,j,idx;var _frames=gd._transitionData._frames;var _frameHash=gd._transitionData._frameHash;if(!Array.isArray(frameList)){throw new Error('addFrames failure: frameList must be an Array of frame definitions'+frameList);}// Create a sorted list of insertions since we run into lots of problems if these\n// aren't in ascending order of index:\n//\n// Strictly for sorting. Make sure this is guaranteed to never collide with any\n// already-exisisting indices:\nvar bigIndex=_frames.length+frameList.length*2;var insertions=[];var _frameHashLocal={};for(i=frameList.length-1;i>=0;i--){if(!Lib.isPlainObject(frameList[i]))continue;// The entire logic for checking for this type of name collision can be removed once we migrate to ES6 and\n// use a Map instead of an Object instance, as Map keys aren't converted to strings.\nvar lookupName=frameList[i].name;var name=(_frameHash[lookupName]||_frameHashLocal[lookupName]||{}).name;var newName=frameList[i].name;var collisionPresent=_frameHash[name]||_frameHashLocal[name];if(name&&newName&&typeof newName==='number'&&collisionPresent&&numericNameWarningCount<numericNameWarningCountLimit){numericNameWarningCount++;Lib.warn('addFrames: overwriting frame \"'+(_frameHash[name]||_frameHashLocal[name]).name+'\" with a frame whose name of type \"number\" also equates to \"'+name+'\". This is valid but may potentially lead to unexpected '+'behavior since all plotly.js frame names are stored internally '+'as strings.');if(numericNameWarningCount===numericNameWarningCountLimit){Lib.warn('addFrames: This API call has yielded too many of these warnings. '+'For the rest of this call, further warnings about numeric frame '+'names will be suppressed.');}}_frameHashLocal[lookupName]={name:lookupName};insertions.push({frame:Plots.supplyFrameDefaults(frameList[i]),index:indices&&indices[i]!==undefined&&indices[i]!==null?indices[i]:bigIndex+i});}// Sort this, taking note that undefined insertions end up at the end:\ninsertions.sort(function(a,b){if(a.index>b.index)return-1;if(a.index<b.index)return 1;return 0;});var ops=[];var revops=[];var frameCount=_frames.length;for(i=insertions.length-1;i>=0;i--){frame=insertions[i].frame;if(typeof frame.name==='number'){Lib.warn('Warning: addFrames accepts frames with numeric names, but the numbers are'+'implicitly cast to strings');}if(!frame.name){// Repeatedly assign a default name, incrementing the counter each time until\n// we get a name that's not in the hashed lookup table:\nwhile(_frameHash[frame.name='frame '+gd._transitionData._counter++]){;}}if(_frameHash[frame.name]){// If frame is present, overwrite its definition:\nfor(j=0;j<_frames.length;j++){if((_frames[j]||{}).name===frame.name)break;}ops.push({type:'replace',index:j,value:frame});revops.unshift({type:'replace',index:j,value:_frames[j]});}else{// Otherwise insert it at the end of the list:\nidx=Math.max(0,Math.min(insertions[i].index,frameCount));ops.push({type:'insert',index:idx,value:frame});revops.unshift({type:'delete',index:idx});frameCount++;}}var undoFunc=Plots.modifyFrames;var redoFunc=Plots.modifyFrames;var undoArgs=[gd,revops];var redoArgs=[gd,ops];if(Queue)Queue.add(gd,undoFunc,undoArgs,redoFunc,redoArgs);return Plots.modifyFrames(gd,ops);}/**\n * Delete frame\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {array of integers} frameList\n *      list of integer indices of frames to be deleted\n */function deleteFrames(gd,frameList){gd=Lib.getGraphDiv(gd);if(!Lib.isPlotDiv(gd)){throw new Error('This element is not a Plotly plot: '+gd);}var i,idx;var _frames=gd._transitionData._frames;var ops=[];var revops=[];if(!frameList){frameList=[];for(i=0;i<_frames.length;i++){frameList.push(i);}}frameList=frameList.slice(0);frameList.sort();for(i=frameList.length-1;i>=0;i--){idx=frameList[i];ops.push({type:'delete',index:idx});revops.unshift({type:'insert',index:idx,value:_frames[idx]});}var undoFunc=Plots.modifyFrames;var redoFunc=Plots.modifyFrames;var undoArgs=[gd,revops];var redoArgs=[gd,ops];if(Queue)Queue.add(gd,undoFunc,undoArgs,redoFunc,redoArgs);return Plots.modifyFrames(gd,ops);}/**\n * Purge a graph container div back to its initial pre-Plotly.plot state\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n */function purge(gd){gd=Lib.getGraphDiv(gd);var fullLayout=gd._fullLayout||{};var fullData=gd._fullData||[];// remove gl contexts\nPlots.cleanPlot([],{},fullData,fullLayout);// purge properties\nPlots.purge(gd);// purge event emitter methods\nEvents.purge(gd);// remove plot container\nif(fullLayout._container)fullLayout._container.remove();// in contrast to Plotly.Plots.purge which does NOT clear _context!\ndelete gd._context;return gd;}// -------------------------------------------------------\n// makePlotFramework: Create the plot container and axes\n// -------------------------------------------------------\nfunction makePlotFramework(gd){var gd3=d3.select(gd);var fullLayout=gd._fullLayout;// Plot container\nfullLayout._container=gd3.selectAll('.plot-container').data([0]);fullLayout._container.enter().insert('div',':first-child').classed('plot-container',true).classed('plotly',true);// Make the svg container\nfullLayout._paperdiv=fullLayout._container.selectAll('.svg-container').data([0]);fullLayout._paperdiv.enter().append('div').classed('svg-container',true).style('position','relative');// Make the graph containers\n// start fresh each time we get here, so we know the order comes out\n// right, rather than enter/exit which can muck up the order\n// TODO: sort out all the ordering so we don't have to\n// explicitly delete anything\n// FIXME: parcoords reuses this object, not the best pattern\nfullLayout._glcontainer=fullLayout._paperdiv.selectAll('.gl-container').data([{}]);fullLayout._glcontainer.enter().append('div').classed('gl-container',true);fullLayout._paperdiv.selectAll('.main-svg').remove();fullLayout._paperdiv.select('.modebar-container').remove();fullLayout._paper=fullLayout._paperdiv.insert('svg',':first-child').classed('main-svg',true);fullLayout._toppaper=fullLayout._paperdiv.append('svg').classed('main-svg',true);fullLayout._modebardiv=fullLayout._paperdiv.append('div');fullLayout._hoverpaper=fullLayout._paperdiv.append('svg').classed('main-svg',true);if(!fullLayout._uid){var otherUids={};d3.selectAll('defs').each(function(){if(this.id)otherUids[this.id.split('-')[1]]=1;});fullLayout._uid=Lib.randstr(otherUids);}fullLayout._paperdiv.selectAll('.main-svg').attr(xmlnsNamespaces.svgAttrs);fullLayout._defs=fullLayout._paper.append('defs').attr('id','defs-'+fullLayout._uid);fullLayout._clips=fullLayout._defs.append('g').classed('clips',true);fullLayout._topdefs=fullLayout._toppaper.append('defs').attr('id','topdefs-'+fullLayout._uid);fullLayout._topclips=fullLayout._topdefs.append('g').classed('clips',true);fullLayout._bgLayer=fullLayout._paper.append('g').classed('bglayer',true);fullLayout._draggers=fullLayout._paper.append('g').classed('draglayer',true);// lower shape/image layer - note that this is behind\n// all subplots data/grids but above the backgrounds\n// except inset subplots, whose backgrounds are drawn\n// inside their own group so that they appear above\n// the data for the main subplot\n// lower shapes and images which are fully referenced to\n// a subplot still get drawn within the subplot's group\n// so they will work correctly on insets\nvar layerBelow=fullLayout._paper.append('g').classed('layer-below',true);fullLayout._imageLowerLayer=layerBelow.append('g').classed('imagelayer',true);fullLayout._shapeLowerLayer=layerBelow.append('g').classed('shapelayer',true);// single cartesian layer for the whole plot\nfullLayout._cartesianlayer=fullLayout._paper.append('g').classed('cartesianlayer',true);// single polar layer for the whole plot\nfullLayout._polarlayer=fullLayout._paper.append('g').classed('polarlayer',true);// single ternary layer for the whole plot\nfullLayout._ternarylayer=fullLayout._paper.append('g').classed('ternarylayer',true);// single geo layer for the whole plot\nfullLayout._geolayer=fullLayout._paper.append('g').classed('geolayer',true);// single pie layer for the whole plot\nfullLayout._pielayer=fullLayout._paper.append('g').classed('pielayer',true);// single sunbursrt layer for the whole plot\nfullLayout._sunburstlayer=fullLayout._paper.append('g').classed('sunburstlayer',true);// fill in image server scrape-svg\nfullLayout._glimages=fullLayout._paper.append('g').classed('glimages',true);// lastly upper shapes, info (legend, annotations) and hover layers go on top\n// these are in a different svg element normally, but get collapsed into a single\n// svg when exporting (after inserting 3D)\n// upper shapes/images are only those drawn above the whole plot, including subplots\nvar layerAbove=fullLayout._toppaper.append('g').classed('layer-above',true);fullLayout._imageUpperLayer=layerAbove.append('g').classed('imagelayer',true);fullLayout._shapeUpperLayer=layerAbove.append('g').classed('shapelayer',true);fullLayout._infolayer=fullLayout._toppaper.append('g').classed('infolayer',true);fullLayout._menulayer=fullLayout._toppaper.append('g').classed('menulayer',true);fullLayout._zoomlayer=fullLayout._toppaper.append('g').classed('zoomlayer',true);fullLayout._hoverlayer=fullLayout._hoverpaper.append('g').classed('hoverlayer',true);// Make the modebar container\nfullLayout._modebardiv.classed('modebar-container',true).style('position','absolute').style('top','0px').style('right','0px');gd.emit('plotly_framework');}exports.animate=animate;exports.addFrames=addFrames;exports.deleteFrames=deleteFrames;exports.addTraces=addTraces;exports.deleteTraces=deleteTraces;exports.extendTraces=extendTraces;exports.moveTraces=moveTraces;exports.prependTraces=prependTraces;exports.newPlot=newPlot;exports.plot=plot;exports.purge=purge;exports.react=react;exports.redraw=redraw;exports.relayout=relayout;exports.restyle=restyle;exports.setPlotConfig=setPlotConfig;exports.update=update;exports._guiRelayout=guiEdit(relayout);exports._guiRestyle=guiEdit(restyle);exports._guiUpdate=guiEdit(update);exports._storeDirectGUIEdit=_storeDirectGUIEdit;},{\"../components/color\":43,\"../components/colorbar/connect\":45,\"../components/drawing\":64,\"../constants/xmlns_namespaces\":141,\"../lib\":159,\"../lib/events\":152,\"../lib/queue\":173,\"../lib/svg_text_utils\":180,\"../plots/cartesian/axes\":203,\"../plots/cartesian/constants\":209,\"../plots/cartesian/graph_interact\":212,\"../plots/cartesian/select\":220,\"../plots/plots\":235,\"../plots/polar/legacy\":238,\"../registry\":242,\"./edit_types\":186,\"./helpers\":187,\"./manage_arrays\":189,\"./plot_config\":191,\"./plot_schema\":192,\"./subroutines\":194,\"d3\":8,\"fast-isnumeric\":10,\"has-hover\":12}],191:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';/**\n * This will be transferred over to gd and overridden by\n * config args to Plotly.plot.\n *\n * The defaults are the appropriate settings for plotly.js,\n * so we get the right experience without any config argument.\n *\n * N.B. the config options are not coerced using Lib.coerce so keys\n * like `valType` and `values` are only set for documentation purposes\n * at the moment.\n */var configAttributes={staticPlot:{valType:'boolean',dflt:false},plotlyServerURL:{valType:'string',dflt:'https://plot.ly'},editable:{valType:'boolean',dflt:false},edits:{annotationPosition:{valType:'boolean',dflt:false},annotationTail:{valType:'boolean',dflt:false},annotationText:{valType:'boolean',dflt:false},axisTitleText:{valType:'boolean',dflt:false},colorbarPosition:{valType:'boolean',dflt:false},colorbarTitleText:{valType:'boolean',dflt:false},legendPosition:{valType:'boolean',dflt:false},legendText:{valType:'boolean',dflt:false},shapePosition:{valType:'boolean',dflt:false},titleText:{valType:'boolean',dflt:false}},autosizable:{valType:'boolean',dflt:false},responsive:{valType:'boolean',dflt:false},fillFrame:{valType:'boolean',dflt:false},frameMargins:{valType:'number',dflt:0,min:0,max:0.5},scrollZoom:{valType:'flaglist',flags:['cartesian','gl3d','geo','mapbox'],extras:[true,false],dflt:'gl3d+geo+mapbox'},doubleClick:{valType:'enumerated',values:[false,'reset','autosize','reset+autosize'],dflt:'reset+autosize'},showAxisDragHandles:{valType:'boolean',dflt:true},showAxisRangeEntryBoxes:{valType:'boolean',dflt:true},showTips:{valType:'boolean',dflt:true},showLink:{valType:'boolean',dflt:false},linkText:{valType:'string',dflt:'Edit chart',noBlank:true},sendData:{valType:'boolean',dflt:true},showSources:{valType:'any',dflt:false},displayModeBar:{valType:'enumerated',values:['hover',true,false],dflt:'hover'},showSendToCloud:{valType:'boolean',dflt:false},modeBarButtonsToRemove:{valType:'any',dflt:[]},modeBarButtonsToAdd:{valType:'any',dflt:[]},modeBarButtons:{valType:'any',dflt:false},toImageButtonOptions:{valType:'any',dflt:{}},displaylogo:{valType:'boolean',dflt:true},watermark:{valType:'boolean',dflt:false},plotGlPixelRatio:{valType:'number',dflt:2,min:1,max:4},setBackground:{valType:'any',dflt:'transparent'},topojsonURL:{valType:'string',noBlank:true,dflt:'https://cdn.plot.ly/'},mapboxAccessToken:{valType:'string',dflt:null},logging:{valType:'boolean',dflt:1},queueLength:{valType:'integer',min:0,dflt:0},globalTransforms:{valType:'any',dflt:[]},locale:{valType:'string',dflt:'en-US'},locales:{valType:'any',dflt:{}}};var dfltConfig={};function crawl(src,target){for(var k in src){var obj=src[k];if(obj.valType){target[k]=obj.dflt;}else{if(!target[k]){target[k]={};}crawl(obj,target[k]);}}}crawl(configAttributes,dfltConfig);module.exports={configAttributes:configAttributes,dfltConfig:dfltConfig};},{}],192:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Registry=_dereq_('../registry');var Lib=_dereq_('../lib');var baseAttributes=_dereq_('../plots/attributes');var baseLayoutAttributes=_dereq_('../plots/layout_attributes');var frameAttributes=_dereq_('../plots/frame_attributes');var animationAttributes=_dereq_('../plots/animation_attributes');var configAttributes=_dereq_('./plot_config').configAttributes;// polar attributes are not part of the Registry yet\nvar polarAreaAttrs=_dereq_('../plots/polar/legacy/area_attributes');var polarAxisAttrs=_dereq_('../plots/polar/legacy/axis_attributes');var editTypes=_dereq_('./edit_types');var extendFlat=Lib.extendFlat;var extendDeepAll=Lib.extendDeepAll;var isPlainObject=Lib.isPlainObject;var IS_SUBPLOT_OBJ='_isSubplotObj';var IS_LINKED_TO_ARRAY='_isLinkedToArray';var ARRAY_ATTR_REGEXPS='_arrayAttrRegexps';var DEPRECATED='_deprecated';var UNDERSCORE_ATTRS=[IS_SUBPLOT_OBJ,IS_LINKED_TO_ARRAY,ARRAY_ATTR_REGEXPS,DEPRECATED];exports.IS_SUBPLOT_OBJ=IS_SUBPLOT_OBJ;exports.IS_LINKED_TO_ARRAY=IS_LINKED_TO_ARRAY;exports.DEPRECATED=DEPRECATED;exports.UNDERSCORE_ATTRS=UNDERSCORE_ATTRS;/** Outputs the full plotly.js plot schema\n *\n * @return {object}\n *  - defs\n *  - traces\n *  - layout\n *  - transforms\n *  - frames\n *  - animations\n *  - config\n */exports.get=function(){var traces={};Registry.allTypes.concat('area').forEach(function(type){traces[type]=getTraceAttributes(type);});var transforms={};Object.keys(Registry.transformsRegistry).forEach(function(type){transforms[type]=getTransformAttributes(type);});return{defs:{valObjects:Lib.valObjectMeta,metaKeys:UNDERSCORE_ATTRS.concat(['description','role','editType','impliedEdits']),editType:{traces:editTypes.traces,layout:editTypes.layout},impliedEdits:{}},traces:traces,layout:getLayoutAttributes(),transforms:transforms,frames:getFramesAttributes(),animation:formatAttributes(animationAttributes),config:formatAttributes(configAttributes)};};/**\n * Crawl the attribute tree, recursively calling a callback function\n *\n * @param {object} attrs\n *  The node of the attribute tree (e.g. the root) from which recursion originates\n * @param {Function} callback\n *  A callback function with the signature:\n *          @callback callback\n *          @param {object} attr an attribute\n *          @param {String} attrName name string\n *          @param {object[]} attrs all the attributes\n *          @param {Number} level the recursion level, 0 at the root\n *          @param {String} fullAttrString full attribute name (ie 'marker.line')\n * @param {Number} [specifiedLevel]\n *  The level in the tree, in order to let the callback function detect descend or backtrack,\n *  typically unsupplied (implied 0), just used by the self-recursive call.\n *  The necessity arises because the tree traversal is not controlled by callback return values.\n *  The decision to not use callback return values for controlling tree pruning arose from\n *  the goal of keeping the crawler backwards compatible. Observe that one of the pruning conditions\n *  precedes the callback call.\n * @param {string} [attrString]\n *  the path to the current attribute, as an attribute string (ie 'marker.line')\n *  typically unsupplied, but you may supply it if you want to disambiguate which attrs tree you\n *  are starting from\n *\n * @return {object} transformOut\n *  copy of transformIn that contains attribute defaults\n */exports.crawl=function(attrs,callback,specifiedLevel,attrString){var level=specifiedLevel||0;attrString=attrString||'';Object.keys(attrs).forEach(function(attrName){var attr=attrs[attrName];if(UNDERSCORE_ATTRS.indexOf(attrName)!==-1)return;var fullAttrString=(attrString?attrString+'.':'')+attrName;callback(attr,attrName,attrs,level,fullAttrString);if(exports.isValObject(attr))return;if(isPlainObject(attr)&&attrName!=='impliedEdits'){exports.crawl(attr,callback,level+1,fullAttrString);}});};/** Is object a value object (or a container object)?\n *\n * @param {object} obj\n * @return {boolean}\n *  returns true for a valid value object and\n *  false for tree nodes in the attribute hierarchy\n */exports.isValObject=function(obj){return obj&&obj.valType!==undefined;};/**\n * Find all data array attributes in a given trace object - including\n * `arrayOk` attributes.\n *\n * @param {object} trace\n *  full trace object that contains a reference to `_module.attributes`\n *\n * @return {array} arrayAttributes\n *  list of array attributes for the given trace\n */exports.findArrayAttributes=function(trace){var arrayAttributes=[];var stack=[];var isArrayStack=[];var baseContainer,baseAttrName;function callback(attr,attrName,attrs,level){stack=stack.slice(0,level).concat([attrName]);isArrayStack=isArrayStack.slice(0,level).concat([attr&&attr._isLinkedToArray]);var splittableAttr=attr&&(attr.valType==='data_array'||attr.arrayOk===true)&&!(stack[level-1]==='colorbar'&&(attrName==='ticktext'||attrName==='tickvals'));// Manually exclude 'colorbar.tickvals' and 'colorbar.ticktext' for now\n// which are declared as `valType: 'data_array'` but scale independently of\n// the coordinate arrays.\n//\n// Down the road, we might want to add a schema field (e.g `uncorrelatedArray: true`)\n// to distinguish attributes of the likes.\nif(!splittableAttr)return;crawlIntoTrace(baseContainer,0,'');}function crawlIntoTrace(container,i,astrPartial){var item=container[stack[i]];var newAstrPartial=astrPartial+stack[i];if(i===stack.length-1){if(Lib.isArrayOrTypedArray(item)){arrayAttributes.push(baseAttrName+newAstrPartial);}}else{if(isArrayStack[i]){if(Array.isArray(item)){for(var j=0;j<item.length;j++){if(Lib.isPlainObject(item[j])){crawlIntoTrace(item[j],i+1,newAstrPartial+'['+j+'].');}}}}else if(Lib.isPlainObject(item)){crawlIntoTrace(item,i+1,newAstrPartial+'.');}}}baseContainer=trace;baseAttrName='';exports.crawl(baseAttributes,callback);if(trace._module&&trace._module.attributes){exports.crawl(trace._module.attributes,callback);}var transforms=trace.transforms;if(transforms){for(var i=0;i<transforms.length;i++){var transform=transforms[i];var module=transform._module;if(module){baseAttrName='transforms['+i+'].';baseContainer=transform;exports.crawl(module.attributes,callback);}}}return arrayAttributes;};/*\n * Find the valObject for one attribute in an existing trace\n *\n * @param {object} trace\n *  full trace object that contains a reference to `_module.attributes`\n * @param {object} parts\n *  an array of parts, like ['transforms', 1, 'value']\n *  typically from nestedProperty(...).parts\n *\n * @return {object|false}\n *  the valObject for this attribute, or the last found parent\n *  in some cases the innermost valObject will not exist, for example\n *  `valType: 'any'` attributes where we might set a part of the attribute.\n *  In that case, stop at the deepest valObject we *do* find.\n */exports.getTraceValObject=function(trace,parts){var head=parts[0];var i=1;// index to start recursing from\nvar moduleAttrs,valObject;if(head==='transforms'){if(parts.length===1){return baseAttributes.transforms;}var transforms=trace.transforms;if(!Array.isArray(transforms)||!transforms.length)return false;var tNum=parts[1];if(!isIndex(tNum)||tNum>=transforms.length){return false;}moduleAttrs=(Registry.transformsRegistry[transforms[tNum].type]||{}).attributes;valObject=moduleAttrs&&moduleAttrs[parts[2]];i=3;// start recursing only inside the transform\n}else if(trace.type==='area'){valObject=polarAreaAttrs[head];}else{// first look in the module for this trace\n// components have already merged their trace attributes in here\nvar _module=trace._module;if(!_module)_module=(Registry.modules[trace.type||baseAttributes.type.dflt]||{})._module;if(!_module)return false;moduleAttrs=_module.attributes;valObject=moduleAttrs&&moduleAttrs[head];// then look in the subplot attributes\nif(!valObject){var subplotModule=_module.basePlotModule;if(subplotModule&&subplotModule.attributes){valObject=subplotModule.attributes[head];}}// finally look in the global attributes\nif(!valObject)valObject=baseAttributes[head];}return recurseIntoValObject(valObject,parts,i);};/*\n * Find the valObject for one layout attribute\n *\n * @param {array} parts\n *  an array of parts, like ['annotations', 1, 'x']\n *  typically from nestedProperty(...).parts\n *\n * @return {object|false}\n *  the valObject for this attribute, or the last found parent\n *  in some cases the innermost valObject will not exist, for example\n *  `valType: 'any'` attributes where we might set a part of the attribute.\n *  In that case, stop at the deepest valObject we *do* find.\n */exports.getLayoutValObject=function(fullLayout,parts){var valObject=layoutHeadAttr(fullLayout,parts[0]);return recurseIntoValObject(valObject,parts,1);};function layoutHeadAttr(fullLayout,head){var i,key,_module,attributes;// look for attributes of the subplot types used on the plot\nvar basePlotModules=fullLayout._basePlotModules;if(basePlotModules){var out;for(i=0;i<basePlotModules.length;i++){_module=basePlotModules[i];if(_module.attrRegex&&_module.attrRegex.test(head)){// if a module defines overrides, these take precedence\n// initially this is to allow gl2d different editTypes from svg cartesian\nif(_module.layoutAttrOverrides)return _module.layoutAttrOverrides;// otherwise take the first attributes we find\nif(!out&&_module.layoutAttributes)out=_module.layoutAttributes;}// a module can also override the behavior of base (and component) module layout attrs\n// again see gl2d for initial use case\nvar baseOverrides=_module.baseLayoutAttrOverrides;if(baseOverrides&&head in baseOverrides)return baseOverrides[head];}if(out)return out;}// look for layout attributes contributed by traces on the plot\nvar modules=fullLayout._modules;if(modules){for(i=0;i<modules.length;i++){attributes=modules[i].layoutAttributes;if(attributes&&head in attributes){return attributes[head];}}}/*\n     * Next look in components.\n     * Components that define a schema have already merged this into\n     * base and subplot attribute defs, so ignore these.\n     * Others (older style) all put all their attributes\n     * inside a container matching the module `name`\n     * eg `attributes` (array) or `legend` (object)\n     */for(key in Registry.componentsRegistry){_module=Registry.componentsRegistry[key];if(!_module.schema&&head===_module.name){return _module.layoutAttributes;}}if(head in baseLayoutAttributes)return baseLayoutAttributes[head];// Polar doesn't populate _modules or _basePlotModules\n// just fall back on these when the others fail\nif(head==='radialaxis'||head==='angularaxis'){return polarAxisAttrs[head];}return polarAxisAttrs.layout[head]||false;}function recurseIntoValObject(valObject,parts,i){if(!valObject)return false;if(valObject._isLinkedToArray){// skip array index, abort if we try to dive into an array without an index\nif(isIndex(parts[i]))i++;else if(i<parts.length)return false;}// now recurse as far as we can. Occasionally we have an attribute\n// setting an internal part below what's in the schema; just return\n// the innermost schema item we find.\nfor(;i<parts.length;i++){var newValObject=valObject[parts[i]];if(isPlainObject(newValObject))valObject=newValObject;else break;if(i===parts.length-1)break;if(valObject._isLinkedToArray){i++;if(!isIndex(parts[i]))return false;}else if(valObject.valType==='info_array'){i++;var index=parts[i];if(!isIndex(index))return false;var items=valObject.items;if(Array.isArray(items)){if(index>=items.length)return false;if(valObject.dimensions===2){i++;if(parts.length===i)return valObject;var index2=parts[i];if(!isIndex(index2))return false;valObject=items[index][index2];}else valObject=items[index];}else{valObject=items;}}}return valObject;}// note: this is different from Lib.isIndex, this one doesn't accept numeric\n// strings, only actual numbers.\nfunction isIndex(val){return val===Math.round(val)&&val>=0;}function getTraceAttributes(type){var _module,basePlotModule;if(type==='area'){_module={attributes:polarAreaAttrs};basePlotModule={};}else{_module=Registry.modules[type]._module,basePlotModule=_module.basePlotModule;}var attributes={};// make 'type' the first attribute in the object\nattributes.type=null;var copyBaseAttributes=extendDeepAll({},baseAttributes);var copyModuleAttributes=extendDeepAll({},_module.attributes);// prune global-level trace attributes that are already defined in a trace\nexports.crawl(copyModuleAttributes,function(attr,attrName,attrs,level,fullAttrString){Lib.nestedProperty(copyBaseAttributes,fullAttrString).set(undefined);// Prune undefined attributes\nif(attr===undefined)Lib.nestedProperty(copyModuleAttributes,fullAttrString).set(undefined);});// base attributes (same for all trace types)\nextendDeepAll(attributes,copyBaseAttributes);// prune-out base attributes based on trace module categories\nif(Registry.traceIs(type,'noOpacity')){delete attributes.opacity;}if(!Registry.traceIs(type,'showLegend')){delete attributes.showlegend;delete attributes.legendgroup;}if(Registry.traceIs(type,'noHover')){delete attributes.hoverinfo;delete attributes.hoverlabel;}if(!_module.selectPoints){delete attributes.selectedpoints;}// module attributes\nextendDeepAll(attributes,copyModuleAttributes);// subplot attributes\nif(basePlotModule.attributes){extendDeepAll(attributes,basePlotModule.attributes);}// 'type' gets overwritten by baseAttributes; reset it here\nattributes.type=type;var out={meta:_module.meta||{},attributes:formatAttributes(attributes)};// trace-specific layout attributes\nif(_module.layoutAttributes){var layoutAttributes={};extendDeepAll(layoutAttributes,_module.layoutAttributes);out.layoutAttributes=formatAttributes(layoutAttributes);}return out;}function getLayoutAttributes(){var layoutAttributes={};var key,_module;// global layout attributes\nextendDeepAll(layoutAttributes,baseLayoutAttributes);// add base plot module layout attributes\nfor(key in Registry.subplotsRegistry){_module=Registry.subplotsRegistry[key];if(!_module.layoutAttributes)continue;if(Array.isArray(_module.attr)){for(var i=0;i<_module.attr.length;i++){handleBasePlotModule(layoutAttributes,_module,_module.attr[i]);}}else{var astr=_module.attr==='subplot'?_module.name:_module.attr;handleBasePlotModule(layoutAttributes,_module,astr);}}// polar layout attributes\nlayoutAttributes=assignPolarLayoutAttrs(layoutAttributes);// add registered components layout attributes\nfor(key in Registry.componentsRegistry){_module=Registry.componentsRegistry[key];var schema=_module.schema;if(schema&&(schema.subplots||schema.layout)){/*\n         * Components with defined schema have already been merged in at register time\n         * but a few components define attributes that apply only to xaxis\n         * not yaxis (rangeselector, rangeslider) - delete from y schema.\n         * Note that the input attributes for xaxis/yaxis are the same object\n         * so it's not possible to only add them to xaxis from the start.\n         * If we ever have such asymmetry the other way, or anywhere else,\n         * we will need to extend both this code and mergeComponentAttrsToSubplot\n         * (which will not find yaxis only for example)\n         */var subplots=schema.subplots;if(subplots&&subplots.xaxis&&!subplots.yaxis){for(var xkey in subplots.xaxis){delete layoutAttributes.yaxis[xkey];}}}else if(_module.layoutAttributes){// older style without schema need to be explicitly merged in now\ninsertAttrs(layoutAttributes,_module.layoutAttributes,_module.name);}}return{layoutAttributes:formatAttributes(layoutAttributes)};}function getTransformAttributes(type){var _module=Registry.transformsRegistry[type];var attributes=extendDeepAll({},_module.attributes);// add registered components transform attributes\nObject.keys(Registry.componentsRegistry).forEach(function(k){var _module=Registry.componentsRegistry[k];if(_module.schema&&_module.schema.transforms&&_module.schema.transforms[type]){Object.keys(_module.schema.transforms[type]).forEach(function(v){insertAttrs(attributes,_module.schema.transforms[type][v],v);});}});return{attributes:formatAttributes(attributes)};}function getFramesAttributes(){var attrs={frames:Lib.extendDeepAll({},frameAttributes)};formatAttributes(attrs);return attrs.frames;}function formatAttributes(attrs){mergeValTypeAndRole(attrs);formatArrayContainers(attrs);stringify(attrs);return attrs;}function mergeValTypeAndRole(attrs){function makeSrcAttr(attrName){return{valType:'string',editType:'none'};}function callback(attr,attrName,attrs){if(exports.isValObject(attr)){if(attr.valType==='data_array'){// all 'data_array' attrs have role 'data'\nattr.role='data';// all 'data_array' attrs have a corresponding 'src' attr\nattrs[attrName+'src']=makeSrcAttr(attrName);}else if(attr.arrayOk===true){// all 'arrayOk' attrs have a corresponding 'src' attr\nattrs[attrName+'src']=makeSrcAttr(attrName);}}else if(isPlainObject(attr)){// all attrs container objects get role 'object'\nattr.role='object';}}exports.crawl(attrs,callback);}function formatArrayContainers(attrs){function callback(attr,attrName,attrs){if(!attr)return;var itemName=attr[IS_LINKED_TO_ARRAY];if(!itemName)return;delete attr[IS_LINKED_TO_ARRAY];attrs[attrName]={items:{}};attrs[attrName].items[itemName]=attr;attrs[attrName].role='object';}exports.crawl(attrs,callback);}// this can take around 10ms and should only be run from PlotSchema.get(),\n// to ensure JSON.stringify(PlotSchema.get()) gives the intended result.\nfunction stringify(attrs){function walk(attr){for(var k in attr){if(isPlainObject(attr[k])){walk(attr[k]);}else if(Array.isArray(attr[k])){for(var i=0;i<attr[k].length;i++){walk(attr[k][i]);}}else{// as JSON.stringify(/test/) // => {}\nif(attr[k]instanceof RegExp){attr[k]=attr[k].toString();}}}}walk(attrs);}function assignPolarLayoutAttrs(layoutAttributes){extendFlat(layoutAttributes,{radialaxis:polarAxisAttrs.radialaxis,angularaxis:polarAxisAttrs.angularaxis});extendFlat(layoutAttributes,polarAxisAttrs.layout);return layoutAttributes;}function handleBasePlotModule(layoutAttributes,_module,astr){var np=Lib.nestedProperty(layoutAttributes,astr);var attrs=extendDeepAll({},_module.layoutAttributes);attrs[IS_SUBPLOT_OBJ]=true;np.set(attrs);}function insertAttrs(baseAttrs,newAttrs,astr){var np=Lib.nestedProperty(baseAttrs,astr);np.set(extendDeepAll(np.get()||{},newAttrs));}},{\"../lib\":159,\"../plots/animation_attributes\":198,\"../plots/attributes\":200,\"../plots/frame_attributes\":230,\"../plots/layout_attributes\":233,\"../plots/polar/legacy/area_attributes\":236,\"../plots/polar/legacy/axis_attributes\":237,\"../registry\":242,\"./edit_types\":186,\"./plot_config\":191}],193:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../lib');var plotAttributes=_dereq_('../plots/attributes');var TEMPLATEITEMNAME='templateitemname';var templateAttrs={name:{valType:'string',editType:'none'}};templateAttrs[TEMPLATEITEMNAME]={valType:'string',editType:'calc'};/**\n * templatedArray: decorate an attributes object with templating (and array)\n * properties.\n *\n * @param {string} name: the singular form of the array name. Sets\n *     `_isLinkedToArray` to this, so the schema knows to treat this as an array.\n * @param {object} attrs: the item attributes. Since all callers are expected\n *     to be constructing this object on the spot, we mutate it here for\n *     performance, rather than extending a new object with it.\n *\n * @returns {object}: the decorated `attrs` object\n */exports.templatedArray=function(name,attrs){attrs._isLinkedToArray=name;attrs.name=templateAttrs.name;attrs[TEMPLATEITEMNAME]=templateAttrs[TEMPLATEITEMNAME];return attrs;};/**\n * traceTemplater: logic for matching traces to trace templates\n *\n * @param {object} dataTemplate: collection of {traceType: [{template}, ...]}\n *     ie each type the template applies to contains a list of template objects,\n *     to be provided cyclically to data traces of that type.\n *\n * @returns {object}: {newTrace}, a function:\n *     newTrace(traceIn): that takes the input traceIn, coerces its type, then\n *         uses that type to find the next template to apply. returns the output\n *         traceOut with template attached, ready to continue supplyDefaults.\n */exports.traceTemplater=function(dataTemplate){var traceCounts={};var traceType,typeTemplates;for(traceType in dataTemplate){typeTemplates=dataTemplate[traceType];if(Array.isArray(typeTemplates)&&typeTemplates.length){traceCounts[traceType]=0;}}function newTrace(traceIn){traceType=Lib.coerce(traceIn,{},plotAttributes,'type');var traceOut={type:traceType,_template:null};if(traceType in traceCounts){typeTemplates=dataTemplate[traceType];// cycle through traces in the template set for this type\nvar typei=traceCounts[traceType]%typeTemplates.length;traceCounts[traceType]++;traceOut._template=typeTemplates[typei];}else{// TODO: anything we should do for types missing from the template?\n// try to apply some other type? Or just bail as we do here?\n// Actually I think yes, we should apply other types; would be nice\n// if all scatter* could inherit from each other, and if histogram\n// could inherit from bar, etc... but how to specify this? And do we\n// compose them, or if a type is present require it to be complete?\n// Actually this could apply to layout too - 3D annotations\n// inheriting from 2D, axes of different types inheriting from each\n// other...\n}return traceOut;}return{newTrace:newTrace// TODO: function to figure out what's left & what didn't work\n};};/**\n * newContainer: Create a new sub-container inside `container` and propagate any\n * applicable template to it. If there's no template, still propagates\n * `undefined` so relinkPrivate will not retain an old template!\n *\n * @param {object} container: the outer container, should already have _template\n *     if there *is* a template for this plot\n * @param {string} name: the key of the new container to make\n * @param {string} baseName: if applicable, a base attribute to take the\n *     template from, ie for xaxis3 the base would be xaxis\n *\n * @returns {object}: an object for inclusion _full*, empty except for the\n *     appropriate template piece\n */exports.newContainer=function(container,name,baseName){var template=container._template;var part=template&&(template[name]||baseName&&template[baseName]);if(!Lib.isPlainObject(part))part=null;var out=container[name]={_template:part};return out;};/**\n * arrayTemplater: special logic for templating both defaults and specific items\n * in a container array (annotations etc)\n *\n * @param {object} container: the outer container, should already have _template\n *     if there *is* a template for this plot\n * @param {string} name: the name of the array to template (ie 'annotations')\n *     will be used to find default ('annotationdefaults' object) and specific\n *     ('annotations' array) template specs.\n * @param {string} inclusionAttr: the attribute determining this item's\n *     inclusion in the output, usually 'visible' or 'enabled'\n *\n * @returns {object}: {newItem, defaultItems}, both functions:\n *     newItem(itemIn): create an output item, bare except for the correct\n *         template and name(s), as the base for supplyDefaults\n *     defaultItems(): to be called after all newItem calls, return any\n *         specific template items that have not already beeen included,\n *         also as bare output items ready for supplyDefaults.\n */exports.arrayTemplater=function(container,name,inclusionAttr){var template=container._template;var defaultsTemplate=template&&template[arrayDefaultKey(name)];var templateItems=template&&template[name];if(!Array.isArray(templateItems)||!templateItems.length){templateItems=[];}var usedNames={};function newItem(itemIn){// include name and templateitemname in the output object for ALL\n// container array items. Note: you could potentially use different\n// name and templateitemname, if you're using one template to make\n// another template. templateitemname would be the name in the original\n// template, and name is the new \"subclassed\" item name.\nvar out={name:itemIn.name,_input:itemIn};var templateItemName=out[TEMPLATEITEMNAME]=itemIn[TEMPLATEITEMNAME];// no itemname: use the default template\nif(!validItemName(templateItemName)){out._template=defaultsTemplate;return out;}// look for an item matching this itemname\n// note these do not inherit from the default template, only the item.\nfor(var i=0;i<templateItems.length;i++){var templateItem=templateItems[i];if(templateItem.name===templateItemName){// Note: it's OK to use a template item more than once\n// but using it at least once will stop it from generating\n// a default item at the end.\nusedNames[templateItemName]=1;out._template=templateItem;return out;}}// Didn't find a matching template item, so since this item is intended\n// to only be modifications it's most likely broken. Hide it unless\n// it's explicitly marked visible - in which case it gets NO template,\n// not even the default.\nout[inclusionAttr]=itemIn[inclusionAttr]||false;// special falsy value we can look for in validateTemplate\nout._template=false;return out;}function defaultItems(){var out=[];for(var i=0;i<templateItems.length;i++){var templateItem=templateItems[i];var name=templateItem.name;// only allow named items to be added as defaults,\n// and only allow each name once\nif(validItemName(name)&&!usedNames[name]){var outi={_template:templateItem,name:name,_input:{_templateitemname:name}};outi[TEMPLATEITEMNAME]=templateItem[TEMPLATEITEMNAME];out.push(outi);usedNames[name]=1;}}return out;}return{newItem:newItem,defaultItems:defaultItems};};function validItemName(name){return name&&typeof name==='string';}function arrayDefaultKey(name){var lastChar=name.length-1;if(name.charAt(lastChar)!=='s'){Lib.warn('bad argument to arrayDefaultKey: '+name);}return name.substr(0,name.length-1)+'defaults';}exports.arrayDefaultKey=arrayDefaultKey;/**\n * arrayEditor: helper for editing array items that may have come from\n *     template defaults (in which case they will not exist in the input yet)\n *\n * @param {object} parentIn: the input container (eg gd.layout)\n * @param {string} containerStr: the attribute string for the container inside\n *     `parentIn`.\n * @param {object} itemOut: the _full* item (eg gd._fullLayout.annotations[0])\n *     that we'll be editing. Assumed to have been created by `arrayTemplater`.\n *\n * @returns {object}: {modifyBase, modifyItem, getUpdateObj, applyUpdate}, all functions:\n *     modifyBase(attr, value): Add an update that's *not* related to the item.\n *         `attr` is the full attribute string.\n *     modifyItem(attr, value): Add an update to the item. `attr` is just the\n *         portion of the attribute string inside the item.\n *     getUpdateObj(): Get the final constructed update object, to use in\n *         `restyle` or `relayout`. Also resets the update object in case this\n *         update was canceled.\n *     applyUpdate(attr, value): optionally add an update `attr: value`,\n *         then apply it to `parent` which should be the parent of `containerIn`,\n *         ie the object to which `containerStr` is the attribute string.\n */exports.arrayEditor=function(parentIn,containerStr,itemOut){var lengthIn=(Lib.nestedProperty(parentIn,containerStr).get()||[]).length;var index=itemOut._index;// Check that we are indeed off the end of this container.\n// Otherwise a devious user could put a key `_templateitemname` in their\n// own input and break lots of things.\nvar templateItemName=index>=lengthIn&&(itemOut._input||{})._templateitemname;if(templateItemName)index=lengthIn;var itemStr=containerStr+'['+index+']';var update;function resetUpdate(){update={};if(templateItemName){update[itemStr]={};update[itemStr][TEMPLATEITEMNAME]=templateItemName;}}resetUpdate();function modifyBase(attr,value){update[attr]=value;}function modifyItem(attr,value){if(templateItemName){// we're making a new object: edit that object\nLib.nestedProperty(update[itemStr],attr).set(value);}else{// we're editing an existing object: include *just* the edit\nupdate[itemStr+'.'+attr]=value;}}function getUpdateObj(){var updateOut=update;resetUpdate();return updateOut;}function applyUpdate(attr,value){if(attr)modifyItem(attr,value);var updateToApply=getUpdateObj();for(var key in updateToApply){Lib.nestedProperty(parentIn,key).set(updateToApply[key]);}}return{modifyBase:modifyBase,modifyItem:modifyItem,getUpdateObj:getUpdateObj,applyUpdate:applyUpdate};};},{\"../lib\":159,\"../plots/attributes\":200}],194:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var Registry=_dereq_('../registry');var Plots=_dereq_('../plots/plots');var Lib=_dereq_('../lib');var clearGlCanvases=_dereq_('../lib/clear_gl_canvases');var Color=_dereq_('../components/color');var Drawing=_dereq_('../components/drawing');var Titles=_dereq_('../components/titles');var ModeBar=_dereq_('../components/modebar');var Axes=_dereq_('../plots/cartesian/axes');var alignmentConstants=_dereq_('../constants/alignment');var axisConstraints=_dereq_('../plots/cartesian/constraints');var enforceAxisConstraints=axisConstraints.enforce;var cleanAxisConstraints=axisConstraints.clean;var doAutoRange=_dereq_('../plots/cartesian/autorange').doAutoRange;var SVG_TEXT_ANCHOR_START='start';var SVG_TEXT_ANCHOR_MIDDLE='middle';var SVG_TEXT_ANCHOR_END='end';exports.layoutStyles=function(gd){return Lib.syncOrAsync([Plots.doAutoMargin,lsInner],gd);};function overlappingDomain(xDomain,yDomain,domains){for(var i=0;i<domains.length;i++){var existingX=domains[i][0];var existingY=domains[i][1];if(existingX[0]>=xDomain[1]||existingX[1]<=xDomain[0]){continue;}if(existingY[0]<yDomain[1]&&existingY[1]>yDomain[0]){return true;}}return false;}function lsInner(gd){var fullLayout=gd._fullLayout;var gs=fullLayout._size;var pad=gs.p;var axList=Axes.list(gd,'',true);var i,subplot,plotinfo,ax,xa,ya;fullLayout._paperdiv.style({width:gd._context.responsive&&fullLayout.autosize&&!gd._context._hasZeroWidth&&!gd.layout.width?'100%':fullLayout.width+'px',height:gd._context.responsive&&fullLayout.autosize&&!gd._context._hasZeroHeight&&!gd.layout.height?'100%':fullLayout.height+'px'}).selectAll('.main-svg').call(Drawing.setSize,fullLayout.width,fullLayout.height);gd._context.setBackground(gd,fullLayout.paper_bgcolor);exports.drawMainTitle(gd);ModeBar.manage(gd);// _has('cartesian') means SVG specifically, not GL2D - but GL2D\n// can still get here because it makes some of the SVG structure\n// for shared features like selections.\nif(!fullLayout._has('cartesian')){return gd._promises.length&&Promise.all(gd._promises);}function getLinePosition(ax,counterAx,side){var lwHalf=ax._lw/2;if(ax._id.charAt(0)==='x'){if(!counterAx)return gs.t+gs.h*(1-(ax.position||0))+lwHalf%1;else if(side==='top')return counterAx._offset-pad-lwHalf;return counterAx._offset+counterAx._length+pad+lwHalf;}if(!counterAx)return gs.l+gs.w*(ax.position||0)+lwHalf%1;else if(side==='right')return counterAx._offset+counterAx._length+pad+lwHalf;return counterAx._offset-pad-lwHalf;}// some preparation of axis position info\nfor(i=0;i<axList.length;i++){ax=axList[i];var counterAx=ax._anchorAxis;// clear axis line positions, to be set in the subplot loop below\nax._linepositions={};// stash crispRounded linewidth so we don't need to pass gd all over the place\nax._lw=Drawing.crispRound(gd,ax.linewidth,1);// figure out the main axis line and main mirror line position.\n// it's easier to follow the logic if we handle these separately from\n// ax._linepositions, which are only used by mirror=allticks\n// for non-main-subplot ticks, and mirror=all(ticks)? for zero line\n// hiding logic\nax._mainLinePosition=getLinePosition(ax,counterAx,ax.side);ax._mainMirrorPosition=ax.mirror&&counterAx?getLinePosition(ax,counterAx,alignmentConstants.OPPOSITE_SIDE[ax.side]):null;}// figure out which backgrounds we need to draw,\n// and in which layers to put them\nvar lowerBackgroundIDs=[];var backgroundIds=[];var lowerDomains=[];// no need to draw background when paper and plot color are the same color,\n// activate mode just for large splom (which benefit the most from this\n// optimization), but this could apply to all cartesian subplots.\nvar noNeedForBg=Color.opacity(fullLayout.paper_bgcolor)===1&&Color.opacity(fullLayout.plot_bgcolor)===1&&fullLayout.paper_bgcolor===fullLayout.plot_bgcolor;for(subplot in fullLayout._plots){plotinfo=fullLayout._plots[subplot];if(plotinfo.mainplot){// mainplot is a reference to the main plot this one is overlaid on\n// so if it exists, this is an overlaid plot and we don't need to\n// give it its own background\nif(plotinfo.bg){plotinfo.bg.remove();}plotinfo.bg=undefined;}else{var xDomain=plotinfo.xaxis.domain;var yDomain=plotinfo.yaxis.domain;var plotgroup=plotinfo.plotgroup;if(overlappingDomain(xDomain,yDomain,lowerDomains)){var pgNode=plotgroup.node();var plotgroupBg=plotinfo.bg=Lib.ensureSingle(plotgroup,'rect','bg');pgNode.insertBefore(plotgroupBg.node(),pgNode.childNodes[0]);backgroundIds.push(subplot);}else{plotgroup.select('rect.bg').remove();lowerDomains.push([xDomain,yDomain]);if(!noNeedForBg){lowerBackgroundIDs.push(subplot);backgroundIds.push(subplot);}}}}// now create all the lower-layer backgrounds at once now that\n// we have the list of subplots that need them\nvar lowerBackgrounds=fullLayout._bgLayer.selectAll('.bg').data(lowerBackgroundIDs);lowerBackgrounds.enter().append('rect').classed('bg',true);lowerBackgrounds.exit().remove();lowerBackgrounds.each(function(subplot){fullLayout._plots[subplot].bg=d3.select(this);});// style all backgrounds\nfor(i=0;i<backgroundIds.length;i++){plotinfo=fullLayout._plots[backgroundIds[i]];xa=plotinfo.xaxis;ya=plotinfo.yaxis;if(plotinfo.bg){plotinfo.bg.call(Drawing.setRect,xa._offset-pad,ya._offset-pad,xa._length+2*pad,ya._length+2*pad).call(Color.fill,fullLayout.plot_bgcolor).style('stroke-width',0);}}if(!fullLayout._hasOnlyLargeSploms){for(subplot in fullLayout._plots){plotinfo=fullLayout._plots[subplot];xa=plotinfo.xaxis;ya=plotinfo.yaxis;// Clip so that data only shows up on the plot area.\nvar clipId=plotinfo.clipId='clip'+fullLayout._uid+subplot+'plot';var plotClip=Lib.ensureSingleById(fullLayout._clips,'clipPath',clipId,function(s){s.classed('plotclip',true).append('rect');});plotinfo.clipRect=plotClip.select('rect').attr({width:xa._length,height:ya._length});Drawing.setTranslate(plotinfo.plot,xa._offset,ya._offset);var plotClipId;var layerClipId;if(plotinfo._hasClipOnAxisFalse){plotClipId=null;layerClipId=clipId;}else{plotClipId=clipId;layerClipId=null;}Drawing.setClipUrl(plotinfo.plot,plotClipId,gd);// stash layer clipId value (null or same as clipId)\n// to DRY up Drawing.setClipUrl calls on trace-module and trace layers\n// downstream\nplotinfo.layerClipId=layerClipId;}}var xLinesXLeft,xLinesXRight,xLinesYBottom,xLinesYTop,leftYLineWidth,rightYLineWidth;var yLinesYBottom,yLinesYTop,yLinesXLeft,yLinesXRight,connectYBottom,connectYTop;var extraSubplot;function xLinePath(y){return'M'+xLinesXLeft+','+y+'H'+xLinesXRight;}function xLinePathFree(y){return'M'+xa._offset+','+y+'h'+xa._length;}function yLinePath(x){return'M'+x+','+yLinesYTop+'V'+yLinesYBottom;}function yLinePathFree(x){return'M'+x+','+ya._offset+'v'+ya._length;}function mainPath(ax,pathFn,pathFnFree){if(!ax.showline||subplot!==ax._mainSubplot)return'';if(!ax._anchorAxis)return pathFnFree(ax._mainLinePosition);var out=pathFn(ax._mainLinePosition);if(ax.mirror)out+=pathFn(ax._mainMirrorPosition);return out;}for(subplot in fullLayout._plots){plotinfo=fullLayout._plots[subplot];xa=plotinfo.xaxis;ya=plotinfo.yaxis;/*\n         * x lines get longer where they meet y lines, to make a crisp corner.\n         * The x lines get the padding (margin.pad) plus the y line width to\n         * fill up the corner nicely. Free x lines are excluded - they always\n         * span exactly the data area of the plot\n         *\n         *  | XXXXX\n         *  | XXXXX\n         *  |\n         *  +------\n         *     x1\n         *    -----\n         *     x2\n         */var xPath='M0,0';if(shouldShowLinesOrTicks(xa,subplot)){leftYLineWidth=findCounterAxisLineWidth(xa,'left',ya,axList);xLinesXLeft=xa._offset-(leftYLineWidth?pad+leftYLineWidth:0);rightYLineWidth=findCounterAxisLineWidth(xa,'right',ya,axList);xLinesXRight=xa._offset+xa._length+(rightYLineWidth?pad+rightYLineWidth:0);xLinesYBottom=getLinePosition(xa,ya,'bottom');xLinesYTop=getLinePosition(xa,ya,'top');// save axis line positions for extra ticks to reference\n// each subplot that gets ticks from \"allticks\" gets an entry:\n//    [left or bottom, right or top]\nextraSubplot=!xa._anchorAxis||subplot!==xa._mainSubplot;if(extraSubplot&&(xa.mirror==='allticks'||xa.mirror==='all')){xa._linepositions[subplot]=[xLinesYBottom,xLinesYTop];}xPath=mainPath(xa,xLinePath,xLinePathFree);if(extraSubplot&&xa.showline&&(xa.mirror==='all'||xa.mirror==='allticks')){xPath+=xLinePath(xLinesYBottom)+xLinePath(xLinesYTop);}plotinfo.xlines.style('stroke-width',xa._lw+'px').call(Color.stroke,xa.showline?xa.linecolor:'rgba(0,0,0,0)');}plotinfo.xlines.attr('d',xPath);/*\n         * y lines that meet x axes get longer only by margin.pad, because\n         * the x axes fill in the corner space. Free y axes, like free x axes,\n         * always span exactly the data area of the plot\n         *\n         *   |   | XXXX\n         * y2| y1| XXXX\n         *   |   | XXXX\n         *       |\n         *       +-----\n         */var yPath='M0,0';if(shouldShowLinesOrTicks(ya,subplot)){connectYBottom=findCounterAxisLineWidth(ya,'bottom',xa,axList);yLinesYBottom=ya._offset+ya._length+(connectYBottom?pad:0);connectYTop=findCounterAxisLineWidth(ya,'top',xa,axList);yLinesYTop=ya._offset-(connectYTop?pad:0);yLinesXLeft=getLinePosition(ya,xa,'left');yLinesXRight=getLinePosition(ya,xa,'right');extraSubplot=!ya._anchorAxis||subplot!==ya._mainSubplot;if(extraSubplot&&(ya.mirror==='allticks'||ya.mirror==='all')){ya._linepositions[subplot]=[yLinesXLeft,yLinesXRight];}yPath=mainPath(ya,yLinePath,yLinePathFree);if(extraSubplot&&ya.showline&&(ya.mirror==='all'||ya.mirror==='allticks')){yPath+=yLinePath(yLinesXLeft)+yLinePath(yLinesXRight);}plotinfo.ylines.style('stroke-width',ya._lw+'px').call(Color.stroke,ya.showline?ya.linecolor:'rgba(0,0,0,0)');}plotinfo.ylines.attr('d',yPath);}Axes.makeClipPaths(gd);return gd._promises.length&&Promise.all(gd._promises);}function shouldShowLinesOrTicks(ax,subplot){return(ax.ticks||ax.showline)&&(subplot===ax._mainSubplot||ax.mirror==='all'||ax.mirror==='allticks');}/*\n * should we draw a line on counterAx at this side of ax?\n * It's assumed that counterAx is known to overlay the subplot we're working on\n * but it may not be its main axis.\n */function shouldShowLineThisSide(ax,side,counterAx){// does counterAx get a line at all?\nif(!counterAx.showline||!counterAx._lw)return false;// are we drawing *all* lines for counterAx?\nif(counterAx.mirror==='all'||counterAx.mirror==='allticks')return true;var anchorAx=counterAx._anchorAxis;// is this a free axis? free axes can only have a subplot side-line with all(ticks)? mirroring\nif(!anchorAx)return false;// in order to handle cases where the user forgot to anchor this axis correctly\n// (because its default anchor has the same domain on the relevant end)\n// check whether the relevant position is the same.\nvar sideIndex=alignmentConstants.FROM_BL[side];if(counterAx.side===side){return anchorAx.domain[sideIndex]===ax.domain[sideIndex];}return counterAx.mirror&&anchorAx.domain[1-sideIndex]===ax.domain[1-sideIndex];}/*\n * Is there another axis intersecting `side` end of `ax`?\n * First look at `counterAx` (the axis for this subplot),\n * then at all other potential counteraxes on or overlaying this subplot.\n * Take the line width from the first one that has a line.\n */function findCounterAxisLineWidth(ax,side,counterAx,axList){if(shouldShowLineThisSide(ax,side,counterAx)){return counterAx._lw;}for(var i=0;i<axList.length;i++){var axi=axList[i];if(axi._mainAxis===counterAx._mainAxis&&shouldShowLineThisSide(ax,side,axi)){return axi._lw;}}return 0;}exports.drawMainTitle=function(gd){var fullLayout=gd._fullLayout;var textAnchor=getMainTitleTextAnchor(fullLayout);var dy=getMainTitleDy(fullLayout);Titles.draw(gd,'gtitle',{propContainer:fullLayout,propName:'title.text',placeholder:fullLayout._dfltTitle.plot,attributes:{x:getMainTitleX(fullLayout,textAnchor),y:getMainTitleY(fullLayout,dy),'text-anchor':textAnchor,dy:dy}});};function getMainTitleX(fullLayout,textAnchor){var title=fullLayout.title;var gs=fullLayout._size;var hPadShift=0;if(textAnchor===SVG_TEXT_ANCHOR_START){hPadShift=title.pad.l;}else if(textAnchor===SVG_TEXT_ANCHOR_END){hPadShift=-title.pad.r;}switch(title.xref){case'paper':return gs.l+gs.w*title.x+hPadShift;case'container':default:return fullLayout.width*title.x+hPadShift;}}function getMainTitleY(fullLayout,dy){var title=fullLayout.title;var gs=fullLayout._size;var vPadShift=0;if(dy==='0em'||!dy){vPadShift=-title.pad.b;}else if(dy===alignmentConstants.CAP_SHIFT+'em'){vPadShift=title.pad.t;}if(title.y==='auto'){return gs.t/2;}else{switch(title.yref){case'paper':return gs.t+gs.h-gs.h*title.y+vPadShift;case'container':default:return fullLayout.height-fullLayout.height*title.y+vPadShift;}}}function getMainTitleTextAnchor(fullLayout){var title=fullLayout.title;var textAnchor=SVG_TEXT_ANCHOR_MIDDLE;if(Lib.isRightAnchor(title)){textAnchor=SVG_TEXT_ANCHOR_END;}else if(Lib.isLeftAnchor(title)){textAnchor=SVG_TEXT_ANCHOR_START;}return textAnchor;}function getMainTitleDy(fullLayout){var title=fullLayout.title;var dy='0em';if(Lib.isTopAnchor(title)){dy=alignmentConstants.CAP_SHIFT+'em';}else if(Lib.isMiddleAnchor(title)){dy=alignmentConstants.MID_SHIFT+'em';}return dy;}exports.doTraceStyle=function(gd){var calcdata=gd.calcdata;var editStyleCalls=[];var i;for(i=0;i<calcdata.length;i++){var cd=calcdata[i];var cd0=cd[0]||{};var trace=cd0.trace||{};var _module=trace._module||{};// See if we need to do arraysToCalcdata\n// call it regardless of what change we made, in case\n// supplyDefaults brought in an array that was already\n// in gd.data but not in gd._fullData previously\nvar arraysToCalcdata=_module.arraysToCalcdata;if(arraysToCalcdata)arraysToCalcdata(cd,trace);var editStyle=_module.editStyle;if(editStyle)editStyleCalls.push({fn:editStyle,cd0:cd0});}if(editStyleCalls.length){for(i=0;i<editStyleCalls.length;i++){var edit=editStyleCalls[i];edit.fn(gd,edit.cd0);}clearGlCanvases(gd);exports.redrawReglTraces(gd);}Plots.style(gd);Registry.getComponentMethod('legend','draw')(gd);return Plots.previousPromises(gd);};exports.doColorBars=function(gd){for(var i=0;i<gd.calcdata.length;i++){var cdi0=gd.calcdata[i][0];if((cdi0.t||{}).cb){var trace=cdi0.trace;var cb=cdi0.t.cb;if(Registry.traceIs(trace,'contour')){cb.line({width:trace.contours.showlines!==false?trace.line.width:0,dash:trace.line.dash,color:trace.contours.coloring==='line'?cb._opts.line.color:trace.line.color});}var moduleOpts=trace._module.colorbar;var containerName=moduleOpts.container;var opts=(containerName?trace[containerName]:trace).colorbar;cb.options(opts)();}}return Plots.previousPromises(gd);};// force plot() to redo the layout and replot with the modified layout\nexports.layoutReplot=function(gd){var layout=gd.layout;gd.layout=undefined;return Registry.call('plot',gd,'',layout);};exports.doLegend=function(gd){Registry.getComponentMethod('legend','draw')(gd);return Plots.previousPromises(gd);};exports.doTicksRelayout=function(gd){Axes.draw(gd,'redraw');if(gd._fullLayout._hasOnlyLargeSploms){Registry.subplotsRegistry.splom.updateGrid(gd);clearGlCanvases(gd);exports.redrawReglTraces(gd);}exports.drawMainTitle(gd);return Plots.previousPromises(gd);};exports.doModeBar=function(gd){var fullLayout=gd._fullLayout;ModeBar.manage(gd);for(var i=0;i<fullLayout._basePlotModules.length;i++){var updateFx=fullLayout._basePlotModules[i].updateFx;if(updateFx)updateFx(gd);}return Plots.previousPromises(gd);};exports.doCamera=function(gd){var fullLayout=gd._fullLayout;var sceneIds=fullLayout._subplots.gl3d;for(var i=0;i<sceneIds.length;i++){var sceneLayout=fullLayout[sceneIds[i]];var scene=sceneLayout._scene;var cameraData=sceneLayout.camera;scene.setCamera(cameraData);}};exports.drawData=function(gd){var fullLayout=gd._fullLayout;var calcdata=gd.calcdata;var i;// remove old colorbars explicitly\nfor(i=0;i<calcdata.length;i++){var trace=calcdata[i][0].trace;if(trace.visible!==true||!trace._module.colorbar){fullLayout._infolayer.select('.cb'+trace.uid).remove();}}clearGlCanvases(gd);// loop over the base plot modules present on graph\nvar basePlotModules=fullLayout._basePlotModules;for(i=0;i<basePlotModules.length;i++){basePlotModules[i].plot(gd);}exports.redrawReglTraces(gd);// styling separate from drawing\nPlots.style(gd);// show annotations and shapes\nRegistry.getComponentMethod('shapes','draw')(gd);Registry.getComponentMethod('annotations','draw')(gd);// Mark the first render as complete\nfullLayout._replotting=false;return Plots.previousPromises(gd);};// Draw (or redraw) all regl-based traces in one go,\n// useful during drag and selection where buffers of targeted traces are updated,\n// but all traces need to be redrawn following clearGlCanvases.\n//\n// Note that _module.plot for regl trace does NOT draw things\n// on the canvas, they only update the buffers.\n// Drawing is perform here.\n//\n// TODO try adding per-subplot option using gl.SCISSOR_TEST for\n// non-overlaying, disjoint subplots.\n//\n// TODO try to include parcoords in here.\n// https://github.com/plotly/plotly.js/issues/3069\nexports.redrawReglTraces=function(gd){var fullLayout=gd._fullLayout;if(fullLayout._has('regl')){var fullData=gd._fullData;var cartesianIds=[];var polarIds=[];var i,sp;if(fullLayout._hasOnlyLargeSploms){fullLayout._splomGrid.draw();}// N.B.\n// - Loop over fullData (not _splomScenes) to preserve splom trace-to-trace ordering\n// - Fill list if subplot ids (instead of fullLayout._subplots) to handle cases where all traces\n//   of a given module are `visible !== true`\nfor(i=0;i<fullData.length;i++){var trace=fullData[i];if(trace.visible===true){if(trace.type==='splom'){fullLayout._splomScenes[trace.uid].draw();}else if(trace.type==='scattergl'){Lib.pushUnique(cartesianIds,trace.xaxis+trace.yaxis);}else if(trace.type==='scatterpolargl'){Lib.pushUnique(polarIds,trace.subplot);}}}for(i=0;i<cartesianIds.length;i++){sp=fullLayout._plots[cartesianIds[i]];if(sp._scene)sp._scene.draw();}for(i=0;i<polarIds.length;i++){sp=fullLayout[polarIds[i]]._subplot;if(sp._scene)sp._scene.draw();}}};exports.doAutoRangeAndConstraints=function(gd){var fullLayout=gd._fullLayout;var axList=Axes.list(gd,'',true);var matchGroups=fullLayout._axisMatchGroups||[];var ax;var axRng;for(var i=0;i<axList.length;i++){ax=axList[i];cleanAxisConstraints(gd,ax);doAutoRange(gd,ax);}enforceAxisConstraints(gd);groupLoop:for(var j=0;j<matchGroups.length;j++){var group=matchGroups[j];var rng=null;var id;for(id in group){ax=Axes.getFromId(gd,id);if(ax.autorange===false)continue groupLoop;axRng=Lib.simpleMap(ax.range,ax.r2l);if(rng){if(rng[0]<rng[1]){rng[0]=Math.min(rng[0],axRng[0]);rng[1]=Math.max(rng[1],axRng[1]);}else{rng[0]=Math.max(rng[0],axRng[0]);rng[1]=Math.min(rng[1],axRng[1]);}}else{rng=axRng;}}for(id in group){ax=Axes.getFromId(gd,id);ax.range=Lib.simpleMap(rng,ax.l2r);ax._input.range=ax.range.slice();ax.setScale();}}};// An initial paint must be completed before these components can be\n// correctly sized and the whole plot re-margined. fullLayout._replotting must\n// be set to false before these will work properly.\nexports.finalDraw=function(gd){Registry.getComponentMethod('shapes','draw')(gd);Registry.getComponentMethod('images','draw')(gd);Registry.getComponentMethod('annotations','draw')(gd);// TODO: rangesliders really belong in marginPushers but they need to be\n// drawn after data - can we at least get the margin pushing part separated\n// out and done earlier?\nRegistry.getComponentMethod('rangeslider','draw')(gd);// TODO: rangeselector only needs to be here (in addition to drawMarginPushers)\n// because the margins need to be fully determined before we can call\n// autorange and update axis ranges (which rangeselector needs to know which\n// button is active). Can we break out its automargin step from its draw step?\nRegistry.getComponentMethod('rangeselector','draw')(gd);};exports.drawMarginPushers=function(gd){Registry.getComponentMethod('legend','draw')(gd);Registry.getComponentMethod('rangeselector','draw')(gd);Registry.getComponentMethod('sliders','draw')(gd);Registry.getComponentMethod('updatemenus','draw')(gd);};},{\"../components/color\":43,\"../components/drawing\":64,\"../components/modebar\":102,\"../components/titles\":131,\"../constants/alignment\":138,\"../lib\":159,\"../lib/clear_gl_canvases\":148,\"../plots/cartesian/autorange\":202,\"../plots/cartesian/axes\":203,\"../plots/cartesian/constraints\":210,\"../plots/plots\":235,\"../registry\":242,\"d3\":8}],195:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../lib');var isPlainObject=Lib.isPlainObject;var PlotSchema=_dereq_('./plot_schema');var Plots=_dereq_('../plots/plots');var plotAttributes=_dereq_('../plots/attributes');var Template=_dereq_('./plot_template');var dfltConfig=_dereq_('./plot_config').dfltConfig;/**\n * Plotly.makeTemplate: create a template off an existing figure to reuse\n * style attributes on other figures.\n *\n * Note: separated from the rest of templates because otherwise we get circular\n * references due to PlotSchema.\n *\n * @param {object|DOM element|string} figure: The figure to base the template on\n *     should contain a trace array `figure.data`\n *     and a layout object `figure.layout`\n * @returns {object} template: the extracted template - can then be used as\n *     `layout.template` in another figure.\n */exports.makeTemplate=function(figure){figure=Lib.isPlainObject(figure)?figure:Lib.getGraphDiv(figure);figure=Lib.extendDeep({_context:dfltConfig},{data:figure.data,layout:figure.layout});Plots.supplyDefaults(figure);var data=figure.data||[];var layout=figure.layout||{};// copy over a few items to help follow the schema\nlayout._basePlotModules=figure._fullLayout._basePlotModules;layout._modules=figure._fullLayout._modules;var template={data:{},layout:{}};/*\n     * Note: we do NOT validate template values, we just take what's in the\n     * user inputs data and layout, not the validated values in fullData and\n     * fullLayout. Even if we were to validate here, there's no guarantee that\n     * these values would still be valid when applied to a new figure, which\n     * may contain different trace modes, different axes, etc. So it's\n     * important that when applying a template we still validate the template\n     * values, rather than just using them as defaults.\n     */data.forEach(function(trace){// TODO: What if no style info is extracted for this trace. We may\n// not want an empty object as the null value.\n// TODO: allow transforms to contribute to templates?\n// as it stands they are ignored, which may be for the best...\nvar traceTemplate={};walkStyleKeys(trace,traceTemplate,getTraceInfo.bind(null,trace));var traceType=Lib.coerce(trace,{},plotAttributes,'type');var typeTemplates=template.data[traceType];if(!typeTemplates)typeTemplates=template.data[traceType]=[];typeTemplates.push(traceTemplate);});walkStyleKeys(layout,template.layout,getLayoutInfo.bind(null,layout));/*\n     * Compose the new template with an existing one to the same effect\n     *\n     * NOTE: there's a possibility of slightly different behavior: if the plot\n     * has an invalid value and the old template has a valid value for the same\n     * attribute, the plot will use the old template value but this routine\n     * will pull the invalid value (resulting in the original default).\n     * In the general case it's not possible to solve this with a single value,\n     * since valid options can be context-dependent. It could be solved with\n     * a *list* of values, but that would be huge complexity for little gain.\n     */delete template.layout.template;var oldTemplate=layout.template;if(isPlainObject(oldTemplate)){var oldLayoutTemplate=oldTemplate.layout;var i,traceType,oldTypeTemplates,oldTypeLen,typeTemplates,typeLen;if(isPlainObject(oldLayoutTemplate)){mergeTemplates(oldLayoutTemplate,template.layout);}var oldDataTemplate=oldTemplate.data;if(isPlainObject(oldDataTemplate)){for(traceType in template.data){oldTypeTemplates=oldDataTemplate[traceType];if(Array.isArray(oldTypeTemplates)){typeTemplates=template.data[traceType];typeLen=typeTemplates.length;oldTypeLen=oldTypeTemplates.length;for(i=0;i<typeLen;i++){mergeTemplates(oldTypeTemplates[i%oldTypeLen],typeTemplates[i]);}for(i=typeLen;i<oldTypeLen;i++){typeTemplates.push(Lib.extendDeep({},oldTypeTemplates[i]));}}}for(traceType in oldDataTemplate){if(!(traceType in template.data)){template.data[traceType]=Lib.extendDeep([],oldDataTemplate[traceType]);}}}}return template;};function mergeTemplates(oldTemplate,newTemplate){// we don't care about speed here, just make sure we have a totally\n// distinct object from the previous template\noldTemplate=Lib.extendDeep({},oldTemplate);// sort keys so we always get annotationdefaults before annotations etc\n// so arrayTemplater will work right\nvar oldKeys=Object.keys(oldTemplate).sort();var i,j;function mergeOne(oldVal,newVal,key){if(isPlainObject(newVal)&&isPlainObject(oldVal)){mergeTemplates(oldVal,newVal);}else if(Array.isArray(newVal)&&Array.isArray(oldVal)){// Note: omitted `inclusionAttr` from arrayTemplater here,\n// it's irrelevant as we only want the resulting `_template`.\nvar templater=Template.arrayTemplater({_template:oldTemplate},key);for(j=0;j<newVal.length;j++){var item=newVal[j];var oldItem=templater.newItem(item)._template;if(oldItem)mergeTemplates(oldItem,item);}var defaultItems=templater.defaultItems();for(j=0;j<defaultItems.length;j++){newVal.push(defaultItems[j]._template);}// templateitemname only applies to receiving plots\nfor(j=0;j<newVal.length;j++){delete newVal[j].templateitemname;}}}for(i=0;i<oldKeys.length;i++){var key=oldKeys[i];var oldVal=oldTemplate[key];if(key in newTemplate){mergeOne(oldVal,newTemplate[key],key);}else newTemplate[key]=oldVal;// if this is a base key from the old template (eg xaxis), look for\n// extended keys (eg xaxis2) in the new template to merge into\nif(getBaseKey(key)===key){for(var key2 in newTemplate){var baseKey2=getBaseKey(key2);if(key2!==baseKey2&&baseKey2===key&&!(key2 in oldTemplate)){mergeOne(oldVal,newTemplate[key2],key);}}}}}function getBaseKey(key){return key.replace(/[0-9]+$/,'');}function walkStyleKeys(parent,templateOut,getAttributeInfo,path,basePath){var pathAttr=basePath&&getAttributeInfo(basePath);for(var key in parent){var child=parent[key];var nextPath=getNextPath(parent,key,path);var nextBasePath=getNextPath(parent,key,basePath);var attr=getAttributeInfo(nextBasePath);if(!attr){var baseKey=getBaseKey(key);if(baseKey!==key){nextBasePath=getNextPath(parent,baseKey,basePath);attr=getAttributeInfo(nextBasePath);}}// we'll get an attr if path starts with a valid part, then has an\n// invalid ending. Make sure we got all the way to the end.\nif(pathAttr&&pathAttr===attr)continue;if(!attr||attr._noTemplating||attr.valType==='data_array'||attr.arrayOk&&Array.isArray(child)){continue;}if(!attr.valType&&isPlainObject(child)){walkStyleKeys(child,templateOut,getAttributeInfo,nextPath,nextBasePath);}else if(attr._isLinkedToArray&&Array.isArray(child)){var dfltDone=false;var namedIndex=0;var usedNames={};for(var i=0;i<child.length;i++){var item=child[i];if(isPlainObject(item)){var name=item.name;if(name){if(!usedNames[name]){// named array items: allow all attributes except data arrays\nwalkStyleKeys(item,templateOut,getAttributeInfo,getNextPath(child,namedIndex,nextPath),getNextPath(child,namedIndex,nextBasePath));namedIndex++;usedNames[name]=1;}}else if(!dfltDone){var dfltKey=Template.arrayDefaultKey(key);var dfltPath=getNextPath(parent,dfltKey,path);// getAttributeInfo will fail if we try to use dfltKey directly.\n// Instead put this item into the next array element, then\n// pull it out and move it to dfltKey.\nvar pathInArray=getNextPath(child,namedIndex,nextPath);walkStyleKeys(item,templateOut,getAttributeInfo,pathInArray,getNextPath(child,namedIndex,nextBasePath));var itemPropInArray=Lib.nestedProperty(templateOut,pathInArray);var dfltProp=Lib.nestedProperty(templateOut,dfltPath);dfltProp.set(itemPropInArray.get());itemPropInArray.set(null);dfltDone=true;}}}}else{var templateProp=Lib.nestedProperty(templateOut,nextPath);templateProp.set(child);}}}function getLayoutInfo(layout,path){return PlotSchema.getLayoutValObject(layout,Lib.nestedProperty({},path).parts);}function getTraceInfo(trace,path){return PlotSchema.getTraceValObject(trace,Lib.nestedProperty({},path).parts);}function getNextPath(parent,key,path){var nextPath;if(!path)nextPath=key;else if(Array.isArray(parent))nextPath=path+'['+key+']';else nextPath=path+'.'+key;return nextPath;}/**\n * validateTemplate: Test for consistency between the given figure and\n * a template, either already included in the figure or given separately.\n * Note that not every issue we identify here is necessarily a problem,\n * it depends on what you're using the template for.\n *\n * @param {object|DOM element} figure: the plot, with {data, layout} members,\n *     to test the template against\n * @param {Optional(object)} template: the template, with its own {data, layout},\n *     to test. If omitted, we will look for a template already attached as the\n *     plot's `layout.template` attribute.\n *\n * @returns {array} array of error objects each containing:\n *  - {string} code\n *      error code ('missing', 'unused', 'reused', 'noLayout', 'noData')\n *  - {string} msg\n *      a full readable description of the issue.\n */exports.validateTemplate=function(figureIn,template){var figure=Lib.extendDeep({},{_context:dfltConfig,data:figureIn.data,layout:figureIn.layout});var layout=figure.layout||{};if(!isPlainObject(template))template=layout.template||{};var layoutTemplate=template.layout;var dataTemplate=template.data;var errorList=[];figure.layout=layout;figure.layout.template=template;Plots.supplyDefaults(figure);var fullLayout=figure._fullLayout;var fullData=figure._fullData;var layoutPaths={};function crawlLayoutForContainers(obj,paths){for(var key in obj){if(key.charAt(0)!=='_'&&isPlainObject(obj[key])){var baseKey=getBaseKey(key);var nextPaths=[];var i;for(i=0;i<paths.length;i++){nextPaths.push(getNextPath(obj,key,paths[i]));if(baseKey!==key)nextPaths.push(getNextPath(obj,baseKey,paths[i]));}for(i=0;i<nextPaths.length;i++){layoutPaths[nextPaths[i]]=1;}crawlLayoutForContainers(obj[key],nextPaths);}}}function crawlLayoutTemplateForContainers(obj,path){for(var key in obj){if(key.indexOf('defaults')===-1&&isPlainObject(obj[key])){var nextPath=getNextPath(obj,key,path);if(layoutPaths[nextPath]){crawlLayoutTemplateForContainers(obj[key],nextPath);}else{errorList.push({code:'unused',path:nextPath});}}}}if(!isPlainObject(layoutTemplate)){errorList.push({code:'layout'});}else{crawlLayoutForContainers(fullLayout,['layout']);crawlLayoutTemplateForContainers(layoutTemplate,'layout');}if(!isPlainObject(dataTemplate)){errorList.push({code:'data'});}else{var typeCount={};var traceType;for(var i=0;i<fullData.length;i++){var fullTrace=fullData[i];traceType=fullTrace.type;typeCount[traceType]=(typeCount[traceType]||0)+1;if(!fullTrace._fullInput._template){// this takes care of the case of traceType in the data but not\n// the template\nerrorList.push({code:'missing',index:fullTrace._fullInput.index,traceType:traceType});}}for(traceType in dataTemplate){var templateCount=dataTemplate[traceType].length;var dataCount=typeCount[traceType]||0;if(templateCount>dataCount){errorList.push({code:'unused',traceType:traceType,templateCount:templateCount,dataCount:dataCount});}else if(dataCount>templateCount){errorList.push({code:'reused',traceType:traceType,templateCount:templateCount,dataCount:dataCount});}}}// _template: false is when someone tried to modify an array item\n// but there was no template with matching name\nfunction crawlForMissingTemplates(obj,path){for(var key in obj){if(key.charAt(0)==='_')continue;var val=obj[key];var nextPath=getNextPath(obj,key,path);if(isPlainObject(val)){if(Array.isArray(obj)&&val._template===false&&val.templateitemname){errorList.push({code:'missing',path:nextPath,templateitemname:val.templateitemname});}crawlForMissingTemplates(val,nextPath);}else if(Array.isArray(val)&&hasPlainObject(val)){crawlForMissingTemplates(val,nextPath);}}}crawlForMissingTemplates({data:fullData,layout:fullLayout},'');if(errorList.length)return errorList.map(format);};function hasPlainObject(arr){for(var i=0;i<arr.length;i++){if(isPlainObject(arr[i]))return true;}}function format(opts){var msg;switch(opts.code){case'data':msg='The template has no key data.';break;case'layout':msg='The template has no key layout.';break;case'missing':if(opts.path){msg='There are no templates for item '+opts.path+' with name '+opts.templateitemname;}else{msg='There are no templates for trace '+opts.index+', of type '+opts.traceType+'.';}break;case'unused':if(opts.path){msg='The template item at '+opts.path+' was not used in constructing the plot.';}else if(opts.dataCount){msg='Some of the templates of type '+opts.traceType+' were not used. The template has '+opts.templateCount+' traces, the data only has '+opts.dataCount+' of this type.';}else{msg='The template has '+opts.templateCount+' traces of type '+opts.traceType+' but there are none in the data.';}break;case'reused':msg='Some of the templates of type '+opts.traceType+' were used more than once. The template has '+opts.templateCount+' traces, the data has '+opts.dataCount+' of this type.';break;}opts.msg=msg;return opts;}},{\"../lib\":159,\"../plots/attributes\":200,\"../plots/plots\":235,\"./plot_config\":191,\"./plot_schema\":192,\"./plot_template\":193}],196:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var isNumeric=_dereq_('fast-isnumeric');var plotApi=_dereq_('./plot_api');var Lib=_dereq_('../lib');var helpers=_dereq_('../snapshot/helpers');var toSVG=_dereq_('../snapshot/tosvg');var svgToImg=_dereq_('../snapshot/svgtoimg');var attrs={format:{valType:'enumerated',values:['png','jpeg','webp','svg'],dflt:'png'},width:{valType:'number',min:1},height:{valType:'number',min:1},scale:{valType:'number',min:0,dflt:1},setBackground:{valType:'any',dflt:false},imageDataOnly:{valType:'boolean',dflt:false}};var IMAGE_URL_PREFIX=/^data:image\\/\\w+;base64,/;/** Plotly.toImage\n *\n * @param {object | string | HTML div} gd\n *   can either be a data/layout/config object\n *   or an existing graph <div>\n *   or an id to an existing graph <div>\n * @param {object} opts (see above)\n * @return {promise}\n */function toImage(gd,opts){opts=opts||{};var data;var layout;var config;var fullLayout;if(Lib.isPlainObject(gd)){data=gd.data||[];layout=gd.layout||{};config=gd.config||{};fullLayout={};}else{gd=Lib.getGraphDiv(gd);data=Lib.extendDeep([],gd.data);layout=Lib.extendDeep({},gd.layout);config=gd._context;fullLayout=gd._fullLayout||{};}function isImpliedOrValid(attr){return!(attr in opts)||Lib.validate(opts[attr],attrs[attr]);}if(!isImpliedOrValid('width')&&opts.width!==null||!isImpliedOrValid('height')&&opts.height!==null){throw new Error('Height and width should be pixel values.');}if(!isImpliedOrValid('format')){throw new Error('Image format is not jpeg, png, svg or webp.');}var fullOpts={};function coerce(attr,dflt){return Lib.coerce(opts,fullOpts,attrs,attr,dflt);}var format=coerce('format');var width=coerce('width');var height=coerce('height');var scale=coerce('scale');var setBackground=coerce('setBackground');var imageDataOnly=coerce('imageDataOnly');// put the cloned div somewhere off screen before attaching to DOM\nvar clonedGd=document.createElement('div');clonedGd.style.position='absolute';clonedGd.style.left='-5000px';document.body.appendChild(clonedGd);// extend layout with image options\nvar layoutImage=Lib.extendFlat({},layout);if(width){layoutImage.width=width;}else if(opts.width===null&&isNumeric(fullLayout.width)){layoutImage.width=fullLayout.width;}if(height){layoutImage.height=height;}else if(opts.height===null&&isNumeric(fullLayout.height)){layoutImage.height=fullLayout.height;}// extend config for static plot\nvar configImage=Lib.extendFlat({},config,{_exportedPlot:true,staticPlot:true,setBackground:setBackground});var redrawFunc=helpers.getRedrawFunc(clonedGd);function wait(){return new Promise(function(resolve){setTimeout(resolve,helpers.getDelay(clonedGd._fullLayout));});}function convert(){return new Promise(function(resolve,reject){var svg=toSVG(clonedGd,format,scale);var width=clonedGd._fullLayout.width;var height=clonedGd._fullLayout.height;plotApi.purge(clonedGd);document.body.removeChild(clonedGd);if(format==='svg'){if(imageDataOnly){return resolve(svg);}else{return resolve('data:image/svg+xml,'+encodeURIComponent(svg));}}var canvas=document.createElement('canvas');canvas.id=Lib.randstr();svgToImg({format:format,width:width,height:height,scale:scale,canvas:canvas,svg:svg,// ask svgToImg to return a Promise\n//  rather than EventEmitter\n//  leave EventEmitter for backward\n//  compatibility\npromise:true}).then(resolve)[\"catch\"](reject);});}function urlToImageData(url){if(imageDataOnly){return url.replace(IMAGE_URL_PREFIX,'');}else{return url;}}return new Promise(function(resolve,reject){plotApi.plot(clonedGd,data,layoutImage,configImage).then(redrawFunc).then(wait).then(convert).then(function(url){resolve(urlToImageData(url));})[\"catch\"](function(err){reject(err);});});}module.exports=toImage;},{\"../lib\":159,\"../snapshot/helpers\":246,\"../snapshot/svgtoimg\":248,\"../snapshot/tosvg\":250,\"./plot_api\":190,\"fast-isnumeric\":10}],197:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../lib');var Plots=_dereq_('../plots/plots');var PlotSchema=_dereq_('./plot_schema');var dfltConfig=_dereq_('./plot_config').dfltConfig;var isPlainObject=Lib.isPlainObject;var isArray=Array.isArray;var isArrayOrTypedArray=Lib.isArrayOrTypedArray;/**\n * Validate a data array and layout object.\n *\n * @param {array} data\n * @param {object} layout\n *\n * @return {array} array of error objects each containing:\n *  - {string} code\n *      error code ('object', 'array', 'schema', 'unused', 'invisible' or 'value')\n *  - {string} container\n *      container where the error occurs ('data' or 'layout')\n *  - {number} trace\n *      trace index of the 'data' container where the error occurs\n *  - {array} path\n *      nested path to the key that causes the error\n *  - {string} astr\n *      attribute string variant of 'path' compatible with Plotly.restyle and\n *      Plotly.relayout.\n *  - {string} msg\n *      error message (shown in console in logger config argument is enable)\n */module.exports=function validate(data,layout){var schema=PlotSchema.get();var errorList=[];var gd={_context:Lib.extendFlat({},dfltConfig)};var dataIn,layoutIn;if(isArray(data)){gd.data=Lib.extendDeep([],data);dataIn=data;}else{gd.data=[];dataIn=[];errorList.push(format('array','data'));}if(isPlainObject(layout)){gd.layout=Lib.extendDeep({},layout);layoutIn=layout;}else{gd.layout={};layoutIn={};if(arguments.length>1){errorList.push(format('object','layout'));}}// N.B. dataIn and layoutIn are in general not the same as\n// gd.data and gd.layout after supplyDefaults as some attributes\n// in gd.data and gd.layout (still) get mutated during this step.\nPlots.supplyDefaults(gd);var dataOut=gd._fullData;var len=dataIn.length;for(var i=0;i<len;i++){var traceIn=dataIn[i];var base=['data',i];if(!isPlainObject(traceIn)){errorList.push(format('object',base));continue;}var traceOut=dataOut[i];var traceType=traceOut.type;var traceSchema=schema.traces[traceType].attributes;// PlotSchema does something fancy with trace 'type', reset it here\n// to make the trace schema compatible with Lib.validate.\ntraceSchema.type={valType:'enumerated',values:[traceType]};if(traceOut.visible===false&&traceIn.visible!==false){errorList.push(format('invisible',base));}crawl(traceIn,traceOut,traceSchema,errorList,base);var transformsIn=traceIn.transforms;var transformsOut=traceOut.transforms;if(transformsIn){if(!isArray(transformsIn)){errorList.push(format('array',base,['transforms']));}base.push('transforms');for(var j=0;j<transformsIn.length;j++){var path=['transforms',j];var transformType=transformsIn[j].type;if(!isPlainObject(transformsIn[j])){errorList.push(format('object',base,path));continue;}var transformSchema=schema.transforms[transformType]?schema.transforms[transformType].attributes:{};// add 'type' to transform schema to validate the transform type\ntransformSchema.type={valType:'enumerated',values:Object.keys(schema.transforms)};crawl(transformsIn[j],transformsOut[j],transformSchema,errorList,base,path);}}}var layoutOut=gd._fullLayout;var layoutSchema=fillLayoutSchema(schema,dataOut);crawl(layoutIn,layoutOut,layoutSchema,errorList,'layout');// return undefined if no validation errors were found\nreturn errorList.length===0?void 0:errorList;};function crawl(objIn,objOut,schema,list,base,path){path=path||[];var keys=Object.keys(objIn);for(var i=0;i<keys.length;i++){var k=keys[i];// transforms are handled separately\nif(k==='transforms')continue;var p=path.slice();p.push(k);var valIn=objIn[k];var valOut=objOut[k];var nestedSchema=getNestedSchema(schema,k);var isInfoArray=(nestedSchema||{}).valType==='info_array';var isColorscale=(nestedSchema||{}).valType==='colorscale';var items=(nestedSchema||{}).items;if(!isInSchema(schema,k)){list.push(format('schema',base,p));}else if(isPlainObject(valIn)&&isPlainObject(valOut)){crawl(valIn,valOut,nestedSchema,list,base,p);}else if(isInfoArray&&isArray(valIn)){if(valIn.length>valOut.length){list.push(format('unused',base,p.concat(valOut.length)));}var len=valOut.length;var arrayItems=Array.isArray(items);if(arrayItems)len=Math.min(len,items.length);var m,n,item,valInPart,valOutPart;if(nestedSchema.dimensions===2){for(n=0;n<len;n++){if(isArray(valIn[n])){if(valIn[n].length>valOut[n].length){list.push(format('unused',base,p.concat(n,valOut[n].length)));}var len2=valOut[n].length;for(m=0;m<(arrayItems?Math.min(len2,items[n].length):len2);m++){item=arrayItems?items[n][m]:items;valInPart=valIn[n][m];valOutPart=valOut[n][m];if(!Lib.validate(valInPart,item)){list.push(format('value',base,p.concat(n,m),valInPart));}else if(valOutPart!==valInPart&&valOutPart!==+valInPart){list.push(format('dynamic',base,p.concat(n,m),valInPart,valOutPart));}}}else{list.push(format('array',base,p.concat(n),valIn[n]));}}}else{for(n=0;n<len;n++){item=arrayItems?items[n]:items;valInPart=valIn[n];valOutPart=valOut[n];if(!Lib.validate(valInPart,item)){list.push(format('value',base,p.concat(n),valInPart));}else if(valOutPart!==valInPart&&valOutPart!==+valInPart){list.push(format('dynamic',base,p.concat(n),valInPart,valOutPart));}}}}else if(nestedSchema.items&&!isInfoArray&&isArray(valIn)){var _nestedSchema=items[Object.keys(items)[0]];var indexList=[];var j,_p;// loop over valOut items while keeping track of their\n// corresponding input container index (given by _index)\nfor(j=0;j<valOut.length;j++){var _index=valOut[j]._index||j;_p=p.slice();_p.push(_index);if(isPlainObject(valIn[_index])&&isPlainObject(valOut[j])){indexList.push(_index);var valInj=valIn[_index];var valOutj=valOut[j];if(isPlainObject(valInj)&&valInj.visible!==false&&valOutj.visible===false){list.push(format('invisible',base,_p));}else crawl(valInj,valOutj,_nestedSchema,list,base,_p);}}// loop over valIn to determine where it went wrong for some items\nfor(j=0;j<valIn.length;j++){_p=p.slice();_p.push(j);if(!isPlainObject(valIn[j])){list.push(format('object',base,_p,valIn[j]));}else if(indexList.indexOf(j)===-1){list.push(format('unused',base,_p));}}}else if(!isPlainObject(valIn)&&isPlainObject(valOut)){list.push(format('object',base,p,valIn));}else if(!isArrayOrTypedArray(valIn)&&isArrayOrTypedArray(valOut)&&!isInfoArray&&!isColorscale){list.push(format('array',base,p,valIn));}else if(!(k in objOut)){list.push(format('unused',base,p,valIn));}else if(!Lib.validate(valIn,nestedSchema)){list.push(format('value',base,p,valIn));}else if(nestedSchema.valType==='enumerated'&&(nestedSchema.coerceNumber&&valIn!==+valOut||valIn!==valOut)){list.push(format('dynamic',base,p,valIn,valOut));}}return list;}// the 'full' layout schema depends on the traces types presents\nfunction fillLayoutSchema(schema,dataOut){var layoutSchema=schema.layout.layoutAttributes;for(var i=0;i<dataOut.length;i++){var traceOut=dataOut[i];var traceSchema=schema.traces[traceOut.type];var traceLayoutAttr=traceSchema.layoutAttributes;if(traceLayoutAttr){if(traceOut.subplot){Lib.extendFlat(layoutSchema[traceSchema.attributes.subplot.dflt],traceLayoutAttr);}else{Lib.extendFlat(layoutSchema,traceLayoutAttr);}}}return layoutSchema;}// validation error codes\nvar code2msgFunc={object:function object(base,astr){var prefix;if(base==='layout'&&astr==='')prefix='The layout argument';else if(base[0]==='data'&&astr===''){prefix='Trace '+base[1]+' in the data argument';}else prefix=inBase(base)+'key '+astr;return prefix+' must be linked to an object container';},array:function array(base,astr){var prefix;if(base==='data')prefix='The data argument';else prefix=inBase(base)+'key '+astr;return prefix+' must be linked to an array container';},schema:function schema(base,astr){return inBase(base)+'key '+astr+' is not part of the schema';},unused:function unused(base,astr,valIn){var target=isPlainObject(valIn)?'container':'key';return inBase(base)+target+' '+astr+' did not get coerced';},dynamic:function dynamic(base,astr,valIn,valOut){return[inBase(base)+'key',astr,'(set to \\''+valIn+'\\')','got reset to','\\''+valOut+'\\'','during defaults.'].join(' ');},invisible:function invisible(base,astr){return(astr?inBase(base)+'item '+astr:'Trace '+base[1])+' got defaulted to be not visible';},value:function value(base,astr,valIn){return[inBase(base)+'key '+astr,'is set to an invalid value ('+valIn+')'].join(' ');}};function inBase(base){if(isArray(base))return'In data trace '+base[1]+', ';return'In '+base+', ';}function format(code,base,path,valIn,valOut){path=path||'';var container,trace;// container is either 'data' or 'layout\n// trace is the trace index if 'data', null otherwise\nif(isArray(base)){container=base[0];trace=base[1];}else{container=base;trace=null;}var astr=convertPathToAttributeString(path);var msg=code2msgFunc[code](base,astr,valIn,valOut);// log to console if logger config option is enabled\nLib.log(msg);return{code:code,container:container,trace:trace,path:path,astr:astr,msg:msg};}function isInSchema(schema,key){var parts=splitKey(key);var keyMinusId=parts.keyMinusId;var id=parts.id;if(keyMinusId in schema&&schema[keyMinusId]._isSubplotObj&&id){return true;}return key in schema;}function getNestedSchema(schema,key){if(key in schema)return schema[key];var parts=splitKey(key);return schema[parts.keyMinusId];}var idRegex=Lib.counterRegex('([a-z]+)');function splitKey(key){var idMatch=key.match(idRegex);return{keyMinusId:idMatch&&idMatch[1],id:idMatch&&idMatch[2]};}function convertPathToAttributeString(path){if(!isArray(path))return String(path);var astr='';for(var i=0;i<path.length;i++){var p=path[i];if(typeof p==='number'){astr=astr.substr(0,astr.length-1)+'['+p+']';}else{astr+=p;}if(i<path.length-1)astr+='.';}return astr;}},{\"../lib\":159,\"../plots/plots\":235,\"./plot_config\":191,\"./plot_schema\":192}],198:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports={mode:{valType:'enumerated',dflt:'afterall',values:['immediate','next','afterall']},direction:{valType:'enumerated',values:['forward','reverse'],dflt:'forward'},fromcurrent:{valType:'boolean',dflt:false},frame:{duration:{valType:'number',min:0,dflt:500},redraw:{valType:'boolean',dflt:true}},transition:{duration:{valType:'number',min:0,dflt:500,editType:'none'},easing:{valType:'enumerated',dflt:'cubic-in-out',values:['linear','quad','cubic','sin','exp','circle','elastic','back','bounce','linear-in','quad-in','cubic-in','sin-in','exp-in','circle-in','elastic-in','back-in','bounce-in','linear-out','quad-out','cubic-out','sin-out','exp-out','circle-out','elastic-out','back-out','bounce-out','linear-in-out','quad-in-out','cubic-in-out','sin-in-out','exp-in-out','circle-in-out','elastic-in-out','back-in-out','bounce-in-out'],editType:'none'},ordering:{valType:'enumerated',values:['layout first','traces first'],dflt:'layout first',editType:'none'}}};},{}],199:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../lib');var Template=_dereq_('../plot_api/plot_template');/** Convenience wrapper for making array container logic DRY and consistent\n *\n * @param {object} parentObjIn\n *  user input object where the container in question is linked\n *  (i.e. either a user trace object or the user layout object)\n *\n * @param {object} parentObjOut\n *  full object where the coerced container will be linked\n *  (i.e. either a full trace object or the full layout object)\n *\n * @param {object} opts\n *  options object:\n *   - name {string}\n *      name of the key linking the container in question\n *   - inclusionAttr {string}\n *      name of the item attribute for inclusion/exclusion. Default is 'visible'.\n *      Since inclusion is true, use eg 'enabled' instead of 'disabled'.\n *   - handleItemDefaults {function}\n *      defaults method to be called on each item in the array container in question\n *\n *      Its arguments are:\n *          - itemIn {object} item in user layout\n *          - itemOut {object} item in full layout\n *          - parentObj {object} (as in closure)\n *          - opts {object} (as in closure)\n * N.B.\n *\n *  - opts is passed to handleItemDefaults so it can also store\n *    links to supplementary data (e.g. fullData for layout components)\n *\n */module.exports=function handleArrayContainerDefaults(parentObjIn,parentObjOut,opts){var name=opts.name;var inclusionAttr=opts.inclusionAttr||'visible';var previousContOut=parentObjOut[name];var contIn=Lib.isArrayOrTypedArray(parentObjIn[name])?parentObjIn[name]:[];var contOut=parentObjOut[name]=[];var templater=Template.arrayTemplater(parentObjOut,name,inclusionAttr);var i,itemOut;for(i=0;i<contIn.length;i++){var itemIn=contIn[i];if(!Lib.isPlainObject(itemIn)){itemOut=templater.newItem({});itemOut[inclusionAttr]=false;}else{itemOut=templater.newItem(itemIn);}itemOut._index=i;if(itemOut[inclusionAttr]!==false){opts.handleItemDefaults(itemIn,itemOut,parentObjOut,opts);}contOut.push(itemOut);}var defaultItems=templater.defaultItems();for(i=0;i<defaultItems.length;i++){itemOut=defaultItems[i];itemOut._index=contOut.length;opts.handleItemDefaults({},itemOut,parentObjOut,opts,{});contOut.push(itemOut);}// in case this array gets its defaults rebuilt independent of the whole layout,\n// relink the private keys just for this array.\nif(Lib.isArrayOrTypedArray(previousContOut)){var len=Math.min(previousContOut.length,contOut.length);for(i=0;i<len;i++){Lib.relinkPrivateKeys(contOut[i],previousContOut[i]);}}return contOut;};},{\"../lib\":159,\"../plot_api/plot_template\":193}],200:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var fxAttrs=_dereq_('../components/fx/attributes');module.exports={type:{valType:'enumerated',values:[],// listed dynamically\ndflt:'scatter',editType:'calc+clearAxisTypes',_noTemplating:true// we handle this at a higher level\n},visible:{valType:'enumerated',values:[true,false,'legendonly'],dflt:true,editType:'calc'},showlegend:{valType:'boolean',dflt:true,editType:'style'},legendgroup:{valType:'string',dflt:'',editType:'style'},opacity:{valType:'number',min:0,max:1,dflt:1,editType:'style'},name:{valType:'string',editType:'style'},uid:{valType:'string',editType:'plot',anim:true},ids:{valType:'data_array',editType:'calc',anim:true},customdata:{valType:'data_array',editType:'calc'},// N.B. these cannot be 'data_array' as they do not have the same length as\n// other data arrays and arrayOk attributes in general\n//\n// Maybe add another valType:\n// https://github.com/plotly/plotly.js/issues/1894\nselectedpoints:{valType:'any',editType:'calc'},hoverinfo:{valType:'flaglist',flags:['x','y','z','text','name'],extras:['all','none','skip'],arrayOk:true,dflt:'all',editType:'none'},hoverlabel:fxAttrs.hoverlabel,stream:{token:{valType:'string',noBlank:true,strict:true,editType:'calc'},maxpoints:{valType:'number',min:0,max:10000,dflt:500,editType:'calc'},editType:'calc'},transforms:{_isLinkedToArray:'transform',editType:'calc'},uirevision:{valType:'any',editType:'none'}};},{\"../components/fx/attributes\":73}],201:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports={xaxis:{valType:'subplotid',dflt:'x',editType:'calc+clearAxisTypes'},yaxis:{valType:'subplotid',dflt:'y',editType:'calc+clearAxisTypes'}};},{}],202:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var isNumeric=_dereq_('fast-isnumeric');var Lib=_dereq_('../../lib');var FP_SAFE=_dereq_('../../constants/numerical').FP_SAFE;var Registry=_dereq_('../../registry');module.exports={getAutoRange:getAutoRange,makePadFn:makePadFn,doAutoRange:doAutoRange,findExtremes:findExtremes,concatExtremes:concatExtremes};/**\n * getAutoRange\n *\n * Collects all _extremes values corresponding to a given axis\n * and computes its auto range.\n *\n * Note that getAutoRange uses return values from findExtremes.\n *\n * @param {object} gd:\n *   graph div object with filled-in fullData and fullLayout, in particular\n *   with filled-in '_extremes' containers:\n *   {\n *      val: calcdata value,\n *      pad: extra pixels beyond this value,\n *      extrapad: bool, does this point want 5% extra padding\n *   }\n * @param {object} ax:\n *   full axis object, in particular with filled-in '_traceIndices'\n *   and '_annIndices' / '_shapeIndices' if applicable\n * @return {array}\n *   an array of [min, max]. These are calcdata for log and category axes\n *   and data for linear and date axes.\n *\n * TODO: we want to change log to data as well, but it's hard to do this\n * maintaining backward compatibility. category will always have to use calcdata\n * though, because otherwise values between categories (or outside all categories)\n * would be impossible.\n */function getAutoRange(gd,ax){var i,j;var newRange=[];var getPad=makePadFn(ax);var extremes=concatExtremes(gd,ax);var minArray=extremes.min;var maxArray=extremes.max;if(minArray.length===0||maxArray.length===0){return Lib.simpleMap(ax.range,ax.r2l);}var minmin=minArray[0].val;var maxmax=maxArray[0].val;for(i=1;i<minArray.length;i++){if(minmin!==maxmax)break;minmin=Math.min(minmin,minArray[i].val);}for(i=1;i<maxArray.length;i++){if(minmin!==maxmax)break;maxmax=Math.max(maxmax,maxArray[i].val);}var axReverse=false;if(ax.range){var rng=Lib.simpleMap(ax.range,ax.r2l);axReverse=rng[1]<rng[0];}// one-time setting to easily reverse the axis\n// when plotting from code\nif(ax.autorange==='reversed'){axReverse=true;ax.autorange=true;}var rangeMode=ax.rangemode;var toZero=rangeMode==='tozero';var nonNegative=rangeMode==='nonnegative';var axLen=ax._length;// don't allow padding to reduce the data to < 10% of the length\nvar minSpan=axLen/10;var mbest=0;var minpt,maxpt,minbest,maxbest,dp,dv;for(i=0;i<minArray.length;i++){minpt=minArray[i];for(j=0;j<maxArray.length;j++){maxpt=maxArray[j];dv=maxpt.val-minpt.val;if(dv>0){dp=axLen-getPad(minpt)-getPad(maxpt);if(dp>minSpan){if(dv/dp>mbest){minbest=minpt;maxbest=maxpt;mbest=dv/dp;}}else if(dv/axLen>mbest){// in case of padding longer than the axis\n// at least include the unpadded data values.\nminbest={val:minpt.val,pad:0};maxbest={val:maxpt.val,pad:0};mbest=dv/axLen;}}}}function getMaxPad(prev,pt){return Math.max(prev,getPad(pt));}if(minmin===maxmax){var lower=minmin-1;var upper=minmin+1;if(toZero){if(minmin===0){// The only value we have on this axis is 0, and we want to\n// autorange so zero is one end.\n// In principle this could be [0, 1] or [-1, 0] but usually\n// 'tozero' pins 0 to the low end, so follow that.\nnewRange=[0,1];}else{var maxPad=(minmin>0?maxArray:minArray).reduce(getMaxPad,0);// we're pushing a single value away from the edge due to its\n// padding, with the other end clamped at zero\n// 0.5 means don't push it farther than the center.\nvar rangeEnd=minmin/(1-Math.min(0.5,maxPad/axLen));newRange=minmin>0?[0,rangeEnd]:[rangeEnd,0];}}else if(nonNegative){newRange=[Math.max(0,lower),Math.max(1,upper)];}else{newRange=[lower,upper];}}else{if(toZero){if(minbest.val>=0){minbest={val:0,pad:0};}if(maxbest.val<=0){maxbest={val:0,pad:0};}}else if(nonNegative){if(minbest.val-mbest*getPad(minbest)<0){minbest={val:0,pad:0};}if(maxbest.val<=0){maxbest={val:1,pad:0};}}// in case it changed again...\nmbest=(maxbest.val-minbest.val)/(axLen-getPad(minbest)-getPad(maxbest));newRange=[minbest.val-mbest*getPad(minbest),maxbest.val+mbest*getPad(maxbest)];}// maintain reversal\nif(axReverse)newRange.reverse();return Lib.simpleMap(newRange,ax.l2r||Number);}/*\n * calculate the pixel padding for ax._min and ax._max entries with\n * optional extrapad as 5% of the total axis length\n */function makePadFn(ax){// 5% padding for points that specify extrapad: true\nvar extrappad=ax._length/20;// domain-constrained axes: base extrappad on the unconstrained\n// domain so it's consistent as the domain changes\nif(ax.constrain==='domain'&&ax._inputDomain){extrappad*=(ax._inputDomain[1]-ax._inputDomain[0])/(ax.domain[1]-ax.domain[0]);}return function getPad(pt){return pt.pad+(pt.extrapad?extrappad:0);};}function concatExtremes(gd,ax){var axId=ax._id;var fullData=gd._fullData;var fullLayout=gd._fullLayout;var minArray=[];var maxArray=[];var i,j,d;function _concat(cont,indices){for(i=0;i<indices.length;i++){var item=cont[indices[i]];var extremes=(item._extremes||{})[axId];if(item.visible===true&&extremes){for(j=0;j<extremes.min.length;j++){d=extremes.min[j];collapseMinArray(minArray,d.val,d.pad,{extrapad:d.extrapad});}for(j=0;j<extremes.max.length;j++){d=extremes.max[j];collapseMaxArray(maxArray,d.val,d.pad,{extrapad:d.extrapad});}}}}_concat(fullData,ax._traceIndices);_concat(fullLayout.annotations||[],ax._annIndices||[]);_concat(fullLayout.shapes||[],ax._shapeIndices||[]);return{min:minArray,max:maxArray};}function doAutoRange(gd,ax){ax.setScale();if(ax.autorange){ax.range=getAutoRange(gd,ax);ax._r=ax.range.slice();ax._rl=Lib.simpleMap(ax._r,ax.r2l);// doAutoRange will get called on fullLayout,\n// but we want to report its results back to layout\nvar axIn=ax._input;// before we edit _input, store preGUI values\nvar edits={};edits[ax._attr+'.range']=ax.range;edits[ax._attr+'.autorange']=ax.autorange;Registry.call('_storeDirectGUIEdit',gd.layout,gd._fullLayout._preGUI,edits);axIn.range=ax.range.slice();axIn.autorange=ax.autorange;}var anchorAx=ax._anchorAxis;if(anchorAx&&anchorAx.rangeslider){var axeRangeOpts=anchorAx.rangeslider[ax._name];if(axeRangeOpts){if(axeRangeOpts.rangemode==='auto'){axeRangeOpts.range=getAutoRange(gd,ax);}}anchorAx._input.rangeslider[ax._name]=Lib.extendFlat({},axeRangeOpts);}}/**\n * findExtremes\n *\n * Find min/max extremes of an array of coordinates on a given axis.\n *\n * Note that findExtremes is called during `calc`, when we don't yet know the axis\n * length; all the inputs should be based solely on the trace data, nothing\n * about the axis layout.\n *\n * Note that `ppad` and `vpad` as well as their asymmetric variants refer to\n * the before and after padding of the passed `data` array, not to the whole axis.\n *\n * @param {object} ax: full axis object\n *   relies on\n *   - ax.type\n *   - ax._m (just its sign)\n *   - ax.d2l\n * @param {array} data:\n *  array of numbers (i.e. already run though ax.d2c)\n * @param {object} opts:\n *  available keys are:\n *      vpad: (number or number array) pad values (data value +-vpad)\n *      ppad: (number or number array) pad pixels (pixel location +-ppad)\n *      ppadplus, ppadminus, vpadplus, vpadminus:\n *          separate padding for each side, overrides symmetric\n *      padded: (boolean) add 5% padding to both ends\n *          (unless one end is overridden by tozero)\n *      tozero: (boolean) make sure to include zero if axis is linear,\n *          and make it a tight bound if possible\n *\n * @return {object}\n *  - min {array of objects}\n *  - max {array of objects}\n *  each object item has fields:\n *    - val {number}\n *    - pad {number}\n *    - extrappad {number}\n *  - opts {object}: a ref to the passed \"options\" object\n */function findExtremes(ax,data,opts){if(!opts)opts={};if(!ax._m)ax.setScale();var minArray=[];var maxArray=[];var len=data.length;var extrapad=opts.padded||false;var tozero=opts.tozero&&(ax.type==='linear'||ax.type==='-');var isLog=ax.type==='log';var hasArrayOption=false;var i,v,di,dmin,dmax,ppadiplus,ppadiminus,vmin,vmax;function makePadAccessor(item){if(Array.isArray(item)){hasArrayOption=true;return function(i){return Math.max(Number(item[i]||0),0);};}else{var v=Math.max(Number(item||0),0);return function(){return v;};}}var ppadplus=makePadAccessor((ax._m>0?opts.ppadplus:opts.ppadminus)||opts.ppad||0);var ppadminus=makePadAccessor((ax._m>0?opts.ppadminus:opts.ppadplus)||opts.ppad||0);var vpadplus=makePadAccessor(opts.vpadplus||opts.vpad);var vpadminus=makePadAccessor(opts.vpadminus||opts.vpad);if(!hasArrayOption){// with no arrays other than `data` we don't need to consider\n// every point, only the extreme data points\nvmin=Infinity;vmax=-Infinity;if(isLog){for(i=0;i<len;i++){v=data[i];// data is not linearized yet so we still have to filter out negative logs\nif(v<vmin&&v>0)vmin=v;if(v>vmax&&v<FP_SAFE)vmax=v;}}else{for(i=0;i<len;i++){v=data[i];if(v<vmin&&v>-FP_SAFE)vmin=v;if(v>vmax&&v<FP_SAFE)vmax=v;}}data=[vmin,vmax];len=2;}var collapseOpts={tozero:tozero,extrapad:extrapad};function addItem(i){di=data[i];if(!isNumeric(di))return;ppadiplus=ppadplus(i);ppadiminus=ppadminus(i);vmin=di-vpadminus(i);vmax=di+vpadplus(i);// special case for log axes: if vpad makes this object span\n// more than an order of mag, clip it to one order. This is so\n// we don't have non-positive errors or absurdly large lower\n// range due to rounding errors\nif(isLog&&vmin<vmax/10)vmin=vmax/10;dmin=ax.c2l(vmin);dmax=ax.c2l(vmax);if(tozero){dmin=Math.min(0,dmin);dmax=Math.max(0,dmax);}if(goodNumber(dmin)){collapseMinArray(minArray,dmin,ppadiminus,collapseOpts);}if(goodNumber(dmax)){collapseMaxArray(maxArray,dmax,ppadiplus,collapseOpts);}}// For efficiency covering monotonic or near-monotonic data,\n// check a few points at both ends first and then sweep\n// through the middle\nvar iMax=Math.min(6,len);for(i=0;i<iMax;i++){addItem(i);}for(i=len-1;i>=iMax;i--){addItem(i);}return{min:minArray,max:maxArray,opts:opts};}function collapseMinArray(array,newVal,newPad,opts){collapseArray(array,newVal,newPad,opts,lessOrEqual);}function collapseMaxArray(array,newVal,newPad,opts){collapseArray(array,newVal,newPad,opts,greaterOrEqual);}/**\n * collapseArray\n *\n * Takes items from 'array' and compares them to 'newVal', 'newPad'.\n *\n * @param {array} array:\n *  current set of min or max extremes\n * @param {number} newVal:\n *  new value to compare against\n * @param {number} newPad:\n *  pad value associated with 'newVal'\n * @param {object} opts:\n *  - tozero {boolean}\n *  - extrapad {number}\n * @param {function} atLeastAsExtreme:\n *  comparison function, use\n *  - lessOrEqual for min 'array' and\n *  - greaterOrEqual for max 'array'\n *\n * In practice, 'array' is either\n *  - 'extremes[ax._id].min' or\n *  - 'extremes[ax._id].max\n *  found in traces and layout items that affect autorange.\n *\n * Since we don't yet know the relationship between pixels and values\n * (that's what we're trying to figure out!) AND we don't yet know how\n * many pixels `extrapad` represents (it's going to be 5% of the length,\n * but we don't want to have to redo calc just because length changed)\n * two point must satisfy three criteria simultaneously for one to supersede the other:\n *  - at least as extreme a `val`\n *  - at least as big a `pad`\n *  - an unpadded point cannot supersede a padded point, but any other combination can\n *\n * Then:\n * - If the item supersedes the new point, set includeThis false\n * - If the new pt supersedes the item, delete it from 'array'\n */function collapseArray(array,newVal,newPad,opts,atLeastAsExtreme){var tozero=opts.tozero;var extrapad=opts.extrapad;var includeThis=true;for(var j=0;j<array.length&&includeThis;j++){var v=array[j];if(atLeastAsExtreme(v.val,newVal)&&v.pad>=newPad&&(v.extrapad||!extrapad)){includeThis=false;break;}else if(atLeastAsExtreme(newVal,v.val)&&v.pad<=newPad&&(extrapad||!v.extrapad)){array.splice(j,1);j--;}}if(includeThis){var clipAtZero=tozero&&newVal===0;array.push({val:newVal,pad:clipAtZero?0:newPad,extrapad:clipAtZero?false:extrapad});}}// In order to stop overflow errors, don't consider points\n// too close to the limits of js floating point\nfunction goodNumber(v){return isNumeric(v)&&Math.abs(v)<FP_SAFE;}function lessOrEqual(v0,v1){return v0<=v1;}function greaterOrEqual(v0,v1){return v0>=v1;}},{\"../../constants/numerical\":140,\"../../lib\":159,\"../../registry\":242,\"fast-isnumeric\":10}],203:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var isNumeric=_dereq_('fast-isnumeric');var Plots=_dereq_('../../plots/plots');var Registry=_dereq_('../../registry');var Lib=_dereq_('../../lib');var svgTextUtils=_dereq_('../../lib/svg_text_utils');var Titles=_dereq_('../../components/titles');var Color=_dereq_('../../components/color');var Drawing=_dereq_('../../components/drawing');var axAttrs=_dereq_('./layout_attributes');var cleanTicks=_dereq_('./clean_ticks');var constants=_dereq_('../../constants/numerical');var ONEAVGYEAR=constants.ONEAVGYEAR;var ONEAVGMONTH=constants.ONEAVGMONTH;var ONEDAY=constants.ONEDAY;var ONEHOUR=constants.ONEHOUR;var ONEMIN=constants.ONEMIN;var ONESEC=constants.ONESEC;var MINUS_SIGN=constants.MINUS_SIGN;var BADNUM=constants.BADNUM;var MID_SHIFT=_dereq_('../../constants/alignment').MID_SHIFT;var LINE_SPACING=_dereq_('../../constants/alignment').LINE_SPACING;var axes=module.exports={};axes.setConvert=_dereq_('./set_convert');var autoType=_dereq_('./axis_autotype');var axisIds=_dereq_('./axis_ids');axes.id2name=axisIds.id2name;axes.name2id=axisIds.name2id;axes.cleanId=axisIds.cleanId;axes.list=axisIds.list;axes.listIds=axisIds.listIds;axes.getFromId=axisIds.getFromId;axes.getFromTrace=axisIds.getFromTrace;var autorange=_dereq_('./autorange');axes.getAutoRange=autorange.getAutoRange;axes.findExtremes=autorange.findExtremes;/*\n * find the list of possible axes to reference with an xref or yref attribute\n * and coerce it to that list\n *\n * attr: the attribute we're generating a reference for. Should end in 'x' or 'y'\n *     but can be prefixed, like 'ax' for annotation's arrow x\n * dflt: the default to coerce to, or blank to use the first axis (falling back on\n *     extraOption if there is no axis)\n * extraOption: aside from existing axes with this letter, what non-axis value is allowed?\n *     Only required if it's different from `dflt`\n */axes.coerceRef=function(containerIn,containerOut,gd,attr,dflt,extraOption){var axLetter=attr.charAt(attr.length-1);var axlist=gd._fullLayout._subplots[axLetter+'axis'];var refAttr=attr+'ref';var attrDef={};if(!dflt)dflt=axlist[0]||extraOption;if(!extraOption)extraOption=dflt;// data-ref annotations are not supported in gl2d yet\nattrDef[refAttr]={valType:'enumerated',values:axlist.concat(extraOption?[extraOption]:[]),dflt:dflt};// xref, yref\nreturn Lib.coerce(containerIn,containerOut,attrDef,refAttr);};/*\n * coerce position attributes (range-type) that can be either on axes or absolute\n * (paper or pixel) referenced. The biggest complication here is that we don't know\n * before looking at the axis whether the value must be a number or not (it may be\n * a date string), so we can't use the regular valType='number' machinery\n *\n * axRef (string): the axis this position is referenced to, or:\n *     paper: fraction of the plot area\n *     pixel: pixels relative to some starting position\n * attr (string): the attribute in containerOut we are coercing\n * dflt (number): the default position, as a fraction or pixels. If the attribute\n *     is to be axis-referenced, this will be converted to an axis data value\n *\n * Also cleans the values, since the attribute definition itself has to say\n * valType: 'any' to handle date axes. This allows us to accept:\n * - for category axes: category names, and convert them here into serial numbers.\n *   Note that this will NOT work for axis range endpoints, because we don't know\n *   the category list yet (it's set by ax.makeCalcdata during calc)\n *   but it works for component (note, shape, images) positions.\n * - for date axes: JS Dates or milliseconds, and convert to date strings\n * - for other types: coerce them to numbers\n */axes.coercePosition=function(containerOut,gd,coerce,axRef,attr,dflt){var cleanPos,pos;if(axRef==='paper'||axRef==='pixel'){cleanPos=Lib.ensureNumber;pos=coerce(attr,dflt);}else{var ax=axes.getFromId(gd,axRef);dflt=ax.fraction2r(dflt);pos=coerce(attr,dflt);cleanPos=ax.cleanPos;}containerOut[attr]=cleanPos(pos);};axes.cleanPosition=function(pos,gd,axRef){var cleanPos=axRef==='paper'||axRef==='pixel'?Lib.ensureNumber:axes.getFromId(gd,axRef).cleanPos;return cleanPos(pos);};axes.redrawComponents=function(gd,axIds){axIds=axIds?axIds:axes.listIds(gd);var fullLayout=gd._fullLayout;function _redrawOneComp(moduleName,methodName,stashName,shortCircuit){var method=Registry.getComponentMethod(moduleName,methodName);var stash={};for(var i=0;i<axIds.length;i++){var ax=fullLayout[axes.id2name(axIds[i])];var indices=ax[stashName];for(var j=0;j<indices.length;j++){var ind=indices[j];if(!stash[ind]){method(gd,ind);stash[ind]=1;// once is enough for images (which doesn't use the `i` arg anyway)\nif(shortCircuit)return;}}}}// annotations and shapes 'draw' method is slow,\n// use the finer-grained 'drawOne' method instead\n_redrawOneComp('annotations','drawOne','_annIndices');_redrawOneComp('shapes','drawOne','_shapeIndices');_redrawOneComp('images','draw','_imgIndices',true);};var getDataConversions=axes.getDataConversions=function(gd,trace,target,targetArray){var ax;// If target points to an axis, use the type we already have for that\n// axis to find the data type. Otherwise use the values to autotype.\nvar d2cTarget=target==='x'||target==='y'||target==='z'?target:targetArray;// In the case of an array target, make a mock data array\n// and call supplyDefaults to the data type and\n// setup the data-to-calc method.\nif(Array.isArray(d2cTarget)){ax={type:autoType(targetArray),_categories:[]};axes.setConvert(ax);// build up ax._categories (usually done during ax.makeCalcdata()\nif(ax.type==='category'){for(var i=0;i<targetArray.length;i++){ax.d2c(targetArray[i]);}}// TODO what to do for transforms?\n}else{ax=axes.getFromTrace(gd,trace,d2cTarget);}// if 'target' has corresponding axis\n// -> use setConvert method\nif(ax)return{d2c:ax.d2c,c2d:ax.c2d};// special case for 'ids'\n// -> cast to String\nif(d2cTarget==='ids')return{d2c:toString,c2d:toString};// otherwise (e.g. numeric-array of 'marker.color' or 'marker.size')\n// -> cast to Number\nreturn{d2c:toNum,c2d:toNum};};function toNum(v){return+v;}function toString(v){return String(v);}axes.getDataToCoordFunc=function(gd,trace,target,targetArray){return getDataConversions(gd,trace,target,targetArray).d2c;};// get counteraxis letter for this axis (name or id)\n// this can also be used as the id for default counter axis\naxes.counterLetter=function(id){var axLetter=id.charAt(0);if(axLetter==='x')return'y';if(axLetter==='y')return'x';};// incorporate a new minimum difference and first tick into\n// forced\n// note that _forceTick0 is linearized, so needs to be turned into\n// a range value for setting tick0\naxes.minDtick=function(ax,newDiff,newFirst,allow){// doesn't make sense to do forced min dTick on log or category axes,\n// and the plot itself may decide to cancel (ie non-grouped bars)\nif(['log','category','multicategory'].indexOf(ax.type)!==-1||!allow){ax._minDtick=0;}else if(ax._minDtick===undefined){// undefined means there's nothing there yet\nax._minDtick=newDiff;ax._forceTick0=newFirst;}else if(ax._minDtick){if((ax._minDtick/newDiff+1e-6)%1<2e-6&&// existing minDtick is an integer multiple of newDiff\n// (within rounding err)\n// and forceTick0 can be shifted to newFirst\n((newFirst-ax._forceTick0)/newDiff%1+1.000001)%1<2e-6){ax._minDtick=newDiff;ax._forceTick0=newFirst;}else if((newDiff/ax._minDtick+1e-6)%1>2e-6||// if the converse is true (newDiff is a multiple of minDtick and\n// newFirst can be shifted to forceTick0) then do nothing - same\n// forcing stands. Otherwise, cancel forced minimum\n((newFirst-ax._forceTick0)/ax._minDtick%1+1.000001)%1>2e-6){ax._minDtick=0;}}};// save a copy of the initial axis ranges in fullLayout\n// use them in mode bar and dblclick events\naxes.saveRangeInitial=function(gd,overwrite){var axList=axes.list(gd,'',true);var hasOneAxisChanged=false;for(var i=0;i<axList.length;i++){var ax=axList[i];var isNew=ax._rangeInitial===undefined;var hasChanged=isNew||!(ax.range[0]===ax._rangeInitial[0]&&ax.range[1]===ax._rangeInitial[1]);if(isNew&&ax.autorange===false||overwrite&&hasChanged){ax._rangeInitial=ax.range.slice();hasOneAxisChanged=true;}}return hasOneAxisChanged;};// save a copy of the initial spike visibility\naxes.saveShowSpikeInitial=function(gd,overwrite){var axList=axes.list(gd,'',true);var hasOneAxisChanged=false;var allSpikesEnabled='on';for(var i=0;i<axList.length;i++){var ax=axList[i];var isNew=ax._showSpikeInitial===undefined;var hasChanged=isNew||!(ax.showspikes===ax._showspikes);if(isNew||overwrite&&hasChanged){ax._showSpikeInitial=ax.showspikes;hasOneAxisChanged=true;}if(allSpikesEnabled==='on'&&!ax.showspikes){allSpikesEnabled='off';}}gd._fullLayout._cartesianSpikesEnabled=allSpikesEnabled;return hasOneAxisChanged;};axes.autoBin=function(data,ax,nbins,is2d,calendar,size){var dataMin=Lib.aggNums(Math.min,null,data);var dataMax=Lib.aggNums(Math.max,null,data);if(ax.type==='category'||ax.type==='multicategory'){return{start:dataMin-0.5,end:dataMax+0.5,size:Math.max(1,Math.round(size)||1),_dataSpan:dataMax-dataMin};}if(!calendar)calendar=ax.calendar;// piggyback off tick code to make \"nice\" bin sizes and edges\nvar dummyAx;if(ax.type==='log'){dummyAx={type:'linear',range:[dataMin,dataMax]};}else{dummyAx={type:ax.type,range:Lib.simpleMap([dataMin,dataMax],ax.c2r,0,calendar),calendar:calendar};}axes.setConvert(dummyAx);size=size&&cleanTicks.dtick(size,dummyAx.type);if(size){dummyAx.dtick=size;dummyAx.tick0=cleanTicks.tick0(undefined,dummyAx.type,calendar);}else{var size0;if(nbins)size0=(dataMax-dataMin)/nbins;else{// totally auto: scale off std deviation so the highest bin is\n// somewhat taller than the total number of bins, but don't let\n// the size get smaller than the 'nice' rounded down minimum\n// difference between values\nvar distinctData=Lib.distinctVals(data);var msexp=Math.pow(10,Math.floor(Math.log(distinctData.minDiff)/Math.LN10));var minSize=msexp*Lib.roundUp(distinctData.minDiff/msexp,[0.9,1.9,4.9,9.9],true);size0=Math.max(minSize,2*Lib.stdev(data)/Math.pow(data.length,is2d?0.25:0.4));// fallback if ax.d2c output BADNUMs\n// e.g. when user try to plot categorical bins\n// on a layout.xaxis.type: 'linear'\nif(!isNumeric(size0))size0=1;}axes.autoTicks(dummyAx,size0);}var finalSize=dummyAx.dtick;var binStart=axes.tickIncrement(axes.tickFirst(dummyAx),finalSize,'reverse',calendar);var binEnd,bincount;// check for too many data points right at the edges of bins\n// (>50% within 1% of bin edges) or all data points integral\n// and offset the bins accordingly\nif(typeof finalSize==='number'){binStart=autoShiftNumericBins(binStart,data,dummyAx,dataMin,dataMax);bincount=1+Math.floor((dataMax-binStart)/finalSize);binEnd=binStart+bincount*finalSize;}else{// month ticks - should be the only nonlinear kind we have at this point.\n// dtick (as supplied by axes.autoTick) only has nonlinear values on\n// date and log axes, but even if you display a histogram on a log axis\n// we bin it on a linear axis (which one could argue against, but that's\n// a separate issue)\nif(dummyAx.dtick.charAt(0)==='M'){binStart=autoShiftMonthBins(binStart,data,finalSize,dataMin,calendar);}// calculate the endpoint for nonlinear ticks - you have to\n// just increment until you're done\nbinEnd=binStart;bincount=0;while(binEnd<=dataMax){binEnd=axes.tickIncrement(binEnd,finalSize,false,calendar);bincount++;}}return{start:ax.c2r(binStart,0,calendar),end:ax.c2r(binEnd,0,calendar),size:finalSize,_dataSpan:dataMax-dataMin};};function autoShiftNumericBins(binStart,data,ax,dataMin,dataMax){var edgecount=0;var midcount=0;var intcount=0;var blankCount=0;function nearEdge(v){// is a value within 1% of a bin edge?\nreturn(1+(v-binStart)*100/ax.dtick)%100<2;}for(var i=0;i<data.length;i++){if(data[i]%1===0)intcount++;else if(!isNumeric(data[i]))blankCount++;if(nearEdge(data[i]))edgecount++;if(nearEdge(data[i]+ax.dtick/2))midcount++;}var dataCount=data.length-blankCount;if(intcount===dataCount&&ax.type!=='date'){if(ax.dtick<1){// all integers: if bin size is <1, it's because\n// that was specifically requested (large nbins)\n// so respect that... but center the bins containing\n// integers on those integers\nbinStart=dataMin-0.5*ax.dtick;}else{// otherwise start half an integer down regardless of\n// the bin size, just enough to clear up endpoint\n// ambiguity about which integers are in which bins.\nbinStart-=0.5;if(binStart+ax.dtick<dataMin)binStart+=ax.dtick;}}else if(midcount<dataCount*0.1){if(edgecount>dataCount*0.3||nearEdge(dataMin)||nearEdge(dataMax)){// lots of points at the edge, not many in the middle\n// shift half a bin\nvar binshift=ax.dtick/2;binStart+=binStart+binshift<dataMin?binshift:-binshift;}}return binStart;}function autoShiftMonthBins(binStart,data,dtick,dataMin,calendar){var stats=Lib.findExactDates(data,calendar);// number of data points that needs to be an exact value\n// to shift that increment to (near) the bin center\nvar threshold=0.8;if(stats.exactDays>threshold){var numMonths=Number(dtick.substr(1));if(stats.exactYears>threshold&&numMonths%12===0){// The exact middle of a non-leap-year is 1.5 days into July\n// so if we start the bins here, all but leap years will\n// get hover-labeled as exact years.\nbinStart=axes.tickIncrement(binStart,'M6','reverse')+ONEDAY*1.5;}else if(stats.exactMonths>threshold){// Months are not as clean, but if we shift half the *longest*\n// month (31/2 days) then 31-day months will get labeled exactly\n// and shorter months will get labeled with the correct month\n// but shifted 12-36 hours into it.\nbinStart=axes.tickIncrement(binStart,'M1','reverse')+ONEDAY*15.5;}else{// Shifting half a day is exact, but since these are month bins it\n// will always give a somewhat odd-looking label, until we do something\n// smarter like showing the bin boundaries (or the bounds of the actual\n// data in each bin)\nbinStart-=ONEDAY/2;}var nextBinStart=axes.tickIncrement(binStart,dtick);if(nextBinStart<=dataMin)return nextBinStart;}return binStart;}// ----------------------------------------------------\n// Ticks and grids\n// ----------------------------------------------------\n// ensure we have tick0, dtick, and tick rounding calculated\naxes.prepTicks=function(ax){var rng=Lib.simpleMap(ax.range,ax.r2l);// calculate max number of (auto) ticks to display based on plot size\nif(ax.tickmode==='auto'||!ax.dtick){var nt=ax.nticks;var minPx;if(!nt){if(ax.type==='category'||ax.type==='multicategory'){minPx=ax.tickfont?(ax.tickfont.size||12)*1.2:15;nt=ax._length/minPx;}else{minPx=ax._id.charAt(0)==='y'?40:80;nt=Lib.constrain(ax._length/minPx,4,9)+1;}// radial axes span half their domain,\n// multiply nticks value by two to get correct number of auto ticks.\nif(ax._name==='radialaxis')nt*=2;}// add a couple of extra digits for filling in ticks when we\n// have explicit tickvals without tick text\nif(ax.tickmode==='array')nt*=100;axes.autoTicks(ax,Math.abs(rng[1]-rng[0])/nt);// check for a forced minimum dtick\nif(ax._minDtick>0&&ax.dtick<ax._minDtick*2){ax.dtick=ax._minDtick;ax.tick0=ax.l2r(ax._forceTick0);}}// check for missing tick0\nif(!ax.tick0){ax.tick0=ax.type==='date'?'2000-01-01':0;}// ensure we don't try to make ticks below our minimum precision\n// see https://github.com/plotly/plotly.js/issues/2892\nif(ax.type==='date'&&ax.dtick<0.1)ax.dtick=0.1;// now figure out rounding of tick values\nautoTickRound(ax);};// calculate the ticks: text, values, positioning\n// if ticks are set to automatic, determine the right values (tick0,dtick)\n// in any case, set tickround to # of digits to round tick labels to,\n// or codes to this effect for log and date scales\naxes.calcTicks=function calcTicks(ax){axes.prepTicks(ax);var rng=Lib.simpleMap(ax.range,ax.r2l);// now that we've figured out the auto values for formatting\n// in case we're missing some ticktext, we can break out for array ticks\nif(ax.tickmode==='array')return arrayTicks(ax);// find the first tick\nax._tmin=axes.tickFirst(ax);// add a tiny bit so we get ticks which may have rounded out\nvar startTick=rng[0]*1.0001-rng[1]*0.0001;var endTick=rng[1]*1.0001-rng[0]*0.0001;// check for reversed axis\nvar axrev=rng[1]<rng[0];// No visible ticks? Quit.\n// I've only seen this on category axes with all categories off the edge.\nif(ax._tmin<startTick!==axrev)return[];// return the full set of tick vals\nvar vals=[];if(ax.type==='category'||ax.type==='multicategory'){endTick=axrev?Math.max(-0.5,endTick):Math.min(ax._categories.length-0.5,endTick);}var xPrevious=null;var maxTicks=Math.max(1000,ax._length||0);for(var x=ax._tmin;axrev?x>=endTick:x<=endTick;x=axes.tickIncrement(x,ax.dtick,axrev,ax.calendar)){// prevent infinite loops - no more than one tick per pixel,\n// and make sure each value is different from the previous\nif(vals.length>maxTicks||x===xPrevious)break;xPrevious=x;vals.push(x);}// If same angle over a full circle, the last tick vals is a duplicate.\n// TODO must do something similar for angular date axes.\nif(isAngular(ax)&&Math.abs(rng[1]-rng[0])===360){vals.pop();}// save the last tick as well as first, so we can\n// show the exponent only on the last one\nax._tmax=vals[vals.length-1];// for showing the rest of a date when the main tick label is only the\n// latter part: ax._prevDateHead holds what we showed most recently.\n// Start with it cleared and mark that we're in calcTicks (ie calculating a\n// whole string of these so we should care what the previous date head was!)\nax._prevDateHead='';ax._inCalcTicks=true;var ticksOut=new Array(vals.length);for(var i=0;i<vals.length;i++){ticksOut[i]=axes.tickText(ax,vals[i]);}ax._inCalcTicks=false;return ticksOut;};function arrayTicks(ax){var vals=ax.tickvals;var text=ax.ticktext;var ticksOut=new Array(vals.length);var rng=Lib.simpleMap(ax.range,ax.r2l);var r0expanded=rng[0]*1.0001-rng[1]*0.0001;var r1expanded=rng[1]*1.0001-rng[0]*0.0001;var tickMin=Math.min(r0expanded,r1expanded);var tickMax=Math.max(r0expanded,r1expanded);var j=0;// without a text array, just format the given values as any other ticks\n// except with more precision to the numbers\nif(!Array.isArray(text))text=[];// make sure showing ticks doesn't accidentally add new categories\n// TODO multicategory, if we allow ticktext / tickvals\nvar tickVal2l=ax.type==='category'?ax.d2l_noadd:ax.d2l;// array ticks on log axes always show the full number\n// (if no explicit ticktext overrides it)\nif(ax.type==='log'&&String(ax.dtick).charAt(0)!=='L'){ax.dtick='L'+Math.pow(10,Math.floor(Math.min(ax.range[0],ax.range[1]))-1);}for(var i=0;i<vals.length;i++){var vali=tickVal2l(vals[i]);if(vali>tickMin&&vali<tickMax){if(text[i]===undefined)ticksOut[j]=axes.tickText(ax,vali);else ticksOut[j]=tickTextObj(ax,vali,String(text[i]));j++;}}if(j<vals.length)ticksOut.splice(j,vals.length-j);return ticksOut;}var roundBase10=[2,5,10];var roundBase24=[1,2,3,6,12];var roundBase60=[1,2,5,10,15,30];// 2&3 day ticks are weird, but need something btwn 1&7\nvar roundDays=[1,2,3,7,14];// approx. tick positions for log axes, showing all (1) and just 1, 2, 5 (2)\n// these don't have to be exact, just close enough to round to the right value\nvar roundLog1=[-0.046,0,0.301,0.477,0.602,0.699,0.778,0.845,0.903,0.954,1];var roundLog2=[-0.301,0,0.301,0.699,1];// N.B. `thetaunit; 'radians' angular axes must be converted to degrees\nvar roundAngles=[15,30,45,90,180];function roundDTick(roughDTick,base,roundingSet){return base*Lib.roundUp(roughDTick/base,roundingSet);}// autoTicks: calculate best guess at pleasant ticks for this axis\n// inputs:\n//      ax - an axis object\n//      roughDTick - rough tick spacing (to be turned into a nice round number)\n// outputs (into ax):\n//   tick0: starting point for ticks (not necessarily on the graph)\n//      usually 0 for numeric (=10^0=1 for log) or jan 1, 2000 for dates\n//   dtick: the actual, nice round tick spacing, usually a little larger than roughDTick\n//      if the ticks are spaced linearly (linear scale, categories,\n//          log with only full powers, date ticks < month),\n//          this will just be a number\n//      months: M#\n//      years: M# where # is 12*number of years\n//      log with linear ticks: L# where # is the linear tick spacing\n//      log showing powers plus some intermediates:\n//          D1 shows all digits, D2 shows 2 and 5\naxes.autoTicks=function(ax,roughDTick){var base;function getBase(v){return Math.pow(v,Math.floor(Math.log(roughDTick)/Math.LN10));}if(ax.type==='date'){ax.tick0=Lib.dateTick0(ax.calendar);// the criteria below are all based on the rough spacing we calculate\n// being > half of the final unit - so precalculate twice the rough val\nvar roughX2=2*roughDTick;if(roughX2>ONEAVGYEAR){roughDTick/=ONEAVGYEAR;base=getBase(10);ax.dtick='M'+12*roundDTick(roughDTick,base,roundBase10);}else if(roughX2>ONEAVGMONTH){roughDTick/=ONEAVGMONTH;ax.dtick='M'+roundDTick(roughDTick,1,roundBase24);}else if(roughX2>ONEDAY){ax.dtick=roundDTick(roughDTick,ONEDAY,roundDays);// get week ticks on sunday\n// this will also move the base tick off 2000-01-01 if dtick is\n// 2 or 3 days... but that's a weird enough case that we'll ignore it.\nax.tick0=Lib.dateTick0(ax.calendar,true);}else if(roughX2>ONEHOUR){ax.dtick=roundDTick(roughDTick,ONEHOUR,roundBase24);}else if(roughX2>ONEMIN){ax.dtick=roundDTick(roughDTick,ONEMIN,roundBase60);}else if(roughX2>ONESEC){ax.dtick=roundDTick(roughDTick,ONESEC,roundBase60);}else{// milliseconds\nbase=getBase(10);ax.dtick=roundDTick(roughDTick,base,roundBase10);}}else if(ax.type==='log'){ax.tick0=0;var rng=Lib.simpleMap(ax.range,ax.r2l);if(roughDTick>0.7){// only show powers of 10\nax.dtick=Math.ceil(roughDTick);}else if(Math.abs(rng[1]-rng[0])<1){// span is less than one power of 10\nvar nt=1.5*Math.abs((rng[1]-rng[0])/roughDTick);// ticks on a linear scale, labeled fully\nroughDTick=Math.abs(Math.pow(10,rng[1])-Math.pow(10,rng[0]))/nt;base=getBase(10);ax.dtick='L'+roundDTick(roughDTick,base,roundBase10);}else{// include intermediates between powers of 10,\n// labeled with small digits\n// ax.dtick = \"D2\" (show 2 and 5) or \"D1\" (show all digits)\nax.dtick=roughDTick>0.3?'D2':'D1';}}else if(ax.type==='category'||ax.type==='multicategory'){ax.tick0=0;ax.dtick=Math.ceil(Math.max(roughDTick,1));}else if(isAngular(ax)){ax.tick0=0;base=1;ax.dtick=roundDTick(roughDTick,base,roundAngles);}else{// auto ticks always start at 0\nax.tick0=0;base=getBase(10);ax.dtick=roundDTick(roughDTick,base,roundBase10);}// prevent infinite loops\nif(ax.dtick===0)ax.dtick=1;// TODO: this is from log axis histograms with autorange off\nif(!isNumeric(ax.dtick)&&typeof ax.dtick!=='string'){var olddtick=ax.dtick;ax.dtick=1;throw'ax.dtick error: '+String(olddtick);}};// after dtick is already known, find tickround = precision\n// to display in tick labels\n//   for numeric ticks, integer # digits after . to round to\n//   for date ticks, the last date part to show (y,m,d,H,M,S)\n//      or an integer # digits past seconds\nfunction autoTickRound(ax){var dtick=ax.dtick;ax._tickexponent=0;if(!isNumeric(dtick)&&typeof dtick!=='string'){dtick=1;}if(ax.type==='category'||ax.type==='multicategory'){ax._tickround=null;}if(ax.type==='date'){// If tick0 is unusual, give tickround a bit more information\n// not necessarily *all* the information in tick0 though, if it's really odd\n// minimal string length for tick0: 'd' is 10, 'M' is 16, 'S' is 19\n// take off a leading minus (year < 0) and i (intercalary month) so length is consistent\nvar tick0ms=ax.r2l(ax.tick0);var tick0str=ax.l2r(tick0ms).replace(/(^-|i)/g,'');var tick0len=tick0str.length;if(String(dtick).charAt(0)==='M'){// any tick0 more specific than a year: alway show the full date\nif(tick0len>10||tick0str.substr(5)!=='01-01')ax._tickround='d';// show the month unless ticks are full multiples of a year\nelse ax._tickround=+dtick.substr(1)%12===0?'y':'m';}else if(dtick>=ONEDAY&&tick0len<=10||dtick>=ONEDAY*15)ax._tickround='d';else if(dtick>=ONEMIN&&tick0len<=16||dtick>=ONEHOUR)ax._tickround='M';else if(dtick>=ONESEC&&tick0len<=19||dtick>=ONEMIN)ax._tickround='S';else{// tickround is a number of digits of fractional seconds\n// of any two adjacent ticks, at least one will have the maximum fractional digits\n// of all possible ticks - so take the max. length of tick0 and the next one\nvar tick1len=ax.l2r(tick0ms+dtick).replace(/^-/,'').length;ax._tickround=Math.max(tick0len,tick1len)-20;// We shouldn't get here... but in case there's a situation I'm\n// not thinking of where tick0str and tick1str are identical or\n// something, fall back on maximum precision\nif(ax._tickround<0)ax._tickround=4;}}else if(isNumeric(dtick)||dtick.charAt(0)==='L'){// linear or log (except D1, D2)\nvar rng=ax.range.map(ax.r2d||Number);if(!isNumeric(dtick))dtick=Number(dtick.substr(1));// 2 digits past largest digit of dtick\nax._tickround=2-Math.floor(Math.log(dtick)/Math.LN10+0.01);var maxend=Math.max(Math.abs(rng[0]),Math.abs(rng[1]));var rangeexp=Math.floor(Math.log(maxend)/Math.LN10+0.01);if(Math.abs(rangeexp)>3){if(isSIFormat(ax.exponentformat)&&!beyondSI(rangeexp)){ax._tickexponent=3*Math.round((rangeexp-1)/3);}else ax._tickexponent=rangeexp;}}else{// D1 or D2 (log)\nax._tickround=null;}}// months and years don't have constant millisecond values\n// (but a year is always 12 months so we only need months)\n// log-scale ticks are also not consistently spaced, except\n// for pure powers of 10\n// numeric ticks always have constant differences, other datetime ticks\n// can all be calculated as constant number of milliseconds\naxes.tickIncrement=function(x,dtick,axrev,calendar){var axSign=axrev?-1:1;// includes linear, all dates smaller than month, and pure 10^n in log\nif(isNumeric(dtick))return x+axSign*dtick;// everything else is a string, one character plus a number\nvar tType=dtick.charAt(0);var dtSigned=axSign*Number(dtick.substr(1));// Dates: months (or years - see Lib.incrementMonth)\nif(tType==='M')return Lib.incrementMonth(x,dtSigned,calendar);// Log scales: Linear, Digits\nelse if(tType==='L')return Math.log(Math.pow(10,x)+dtSigned)/Math.LN10;// log10 of 2,5,10, or all digits (logs just have to be\n// close enough to round)\nelse if(tType==='D'){var tickset=dtick==='D2'?roundLog2:roundLog1;var x2=x+axSign*0.01;var frac=Lib.roundUp(Lib.mod(x2,1),tickset,axrev);return Math.floor(x2)+Math.log(d3.round(Math.pow(10,frac),1))/Math.LN10;}else throw'unrecognized dtick '+String(dtick);};// calculate the first tick on an axis\naxes.tickFirst=function(ax){var r2l=ax.r2l||Number;var rng=Lib.simpleMap(ax.range,r2l);var axrev=rng[1]<rng[0];var sRound=axrev?Math.floor:Math.ceil;// add a tiny extra bit to make sure we get ticks\n// that may have been rounded out\nvar r0=rng[0]*1.0001-rng[1]*0.0001;var dtick=ax.dtick;var tick0=r2l(ax.tick0);if(isNumeric(dtick)){var tmin=sRound((r0-tick0)/dtick)*dtick+tick0;// make sure no ticks outside the category list\nif(ax.type==='category'||ax.type==='multicategory'){tmin=Lib.constrain(tmin,0,ax._categories.length-1);}return tmin;}var tType=dtick.charAt(0);var dtNum=Number(dtick.substr(1));// Dates: months (or years)\nif(tType==='M'){var cnt=0;var t0=tick0;var t1,mult,newDTick;// This algorithm should work for *any* nonlinear (but close to linear!)\n// tick spacing. Limit to 10 iterations, for gregorian months it's normally <=3.\nwhile(cnt<10){t1=axes.tickIncrement(t0,dtick,axrev,ax.calendar);if((t1-r0)*(t0-r0)<=0){// t1 and t0 are on opposite sides of r0! we've succeeded!\nif(axrev)return Math.min(t0,t1);return Math.max(t0,t1);}mult=(r0-(t0+t1)/2)/(t1-t0);newDTick=tType+(Math.abs(Math.round(mult))||1)*dtNum;t0=axes.tickIncrement(t0,newDTick,mult<0?!axrev:axrev,ax.calendar);cnt++;}Lib.error('tickFirst did not converge',ax);return t0;}else if(tType==='L'){// Log scales: Linear, Digits\nreturn Math.log(sRound((Math.pow(10,r0)-tick0)/dtNum)*dtNum+tick0)/Math.LN10;}else if(tType==='D'){var tickset=dtick==='D2'?roundLog2:roundLog1;var frac=Lib.roundUp(Lib.mod(r0,1),tickset,axrev);return Math.floor(r0)+Math.log(d3.round(Math.pow(10,frac),1))/Math.LN10;}else throw'unrecognized dtick '+String(dtick);};// draw the text for one tick.\n// px,py are the location on gd.paper\n// prefix is there so the x axis ticks can be dropped a line\n// ax is the axis layout, x is the tick value\n// hover is a (truthy) flag for whether to show numbers with a bit\n// more precision for hovertext\naxes.tickText=function(ax,x,hover){var out=tickTextObj(ax,x);var arrayMode=ax.tickmode==='array';var extraPrecision=hover||arrayMode;var axType=ax.type;// TODO multicategory, if we allow ticktext / tickvals\nvar tickVal2l=axType==='category'?ax.d2l_noadd:ax.d2l;var i;if(arrayMode&&Array.isArray(ax.ticktext)){var rng=Lib.simpleMap(ax.range,ax.r2l);var minDiff=Math.abs(rng[1]-rng[0])/10000;for(i=0;i<ax.ticktext.length;i++){if(Math.abs(x-tickVal2l(ax.tickvals[i]))<minDiff)break;}if(i<ax.ticktext.length){out.text=String(ax.ticktext[i]);return out;}}function isHidden(showAttr){if(showAttr===undefined)return true;if(hover)return showAttr==='none';var firstOrLast={first:ax._tmin,last:ax._tmax}[showAttr];return showAttr!=='all'&&x!==firstOrLast;}var hideexp=hover?'never':ax.exponentformat!=='none'&&isHidden(ax.showexponent)?'hide':'';if(axType==='date')formatDate(ax,out,hover,extraPrecision);else if(axType==='log')formatLog(ax,out,hover,extraPrecision,hideexp);else if(axType==='category')formatCategory(ax,out);else if(axType==='multicategory')formatMultiCategory(ax,out,hover);else if(isAngular(ax))formatAngle(ax,out,hover,extraPrecision,hideexp);else formatLinear(ax,out,hover,extraPrecision,hideexp);// add prefix and suffix\nif(ax.tickprefix&&!isHidden(ax.showtickprefix))out.text=ax.tickprefix+out.text;if(ax.ticksuffix&&!isHidden(ax.showticksuffix))out.text+=ax.ticksuffix;// Setup ticks and grid lines boundaries\n// at 1/2 a 'category' to the left/bottom\nif(ax.tickson==='boundaries'||ax.showdividers){var inbounds=function inbounds(v){var p=ax.l2p(v);return p>=0&&p<=ax._length?v:null;};out.xbnd=[inbounds(out.x-0.5),inbounds(out.x+ax.dtick-0.5)];}return out;};/**\n * create text for a hover label on this axis, with special handling of\n * log axes (where negative values can't be displayed but can appear in hover text)\n *\n * @param {object} ax: the axis to format text for\n * @param {number} val: calcdata value to format\n * @param {Optional(number)} val2: a second value to display\n *\n * @returns {string} `val` formatted as a string appropriate to this axis, or\n *     `val` and `val2` as a range (ie '<val> - <val2>') if `val2` is provided and\n *     it's different from `val`.\n */axes.hoverLabelText=function(ax,val,val2){if(val2!==BADNUM&&val2!==val){return axes.hoverLabelText(ax,val)+' - '+axes.hoverLabelText(ax,val2);}var logOffScale=ax.type==='log'&&val<=0;var tx=axes.tickText(ax,ax.c2l(logOffScale?-val:val),'hover').text;if(logOffScale){return val===0?'0':MINUS_SIGN+tx;}// TODO: should we do something special if the axis calendar and\n// the data calendar are different? Somehow display both dates with\n// their system names? Right now it will just display in the axis calendar\n// but users could add the other one as text.\nreturn tx;};function tickTextObj(ax,x,text){var tf=ax.tickfont||{};return{x:x,dx:0,dy:0,text:text||'',fontSize:tf.size,font:tf.family,fontColor:tf.color};}function formatDate(ax,out,hover,extraPrecision){var tr=ax._tickround;var fmt=hover&&ax.hoverformat||axes.getTickFormat(ax);if(extraPrecision){// second or sub-second precision: extra always shows max digits.\n// for other fields, extra precision just adds one field.\nif(isNumeric(tr))tr=4;else tr={y:'m',m:'d',d:'M',M:'S',S:4}[tr];}var dateStr=Lib.formatDate(out.x,fmt,tr,ax._dateFormat,ax.calendar,ax._extraFormat);var headStr;var splitIndex=dateStr.indexOf('\\n');if(splitIndex!==-1){headStr=dateStr.substr(splitIndex+1);dateStr=dateStr.substr(0,splitIndex);}if(extraPrecision){// if extraPrecision led to trailing zeros, strip them off\n// actually, this can lead to removing even more zeros than\n// in the original rounding, but that's fine because in these\n// contexts uniformity is not so important (if there's even\n// anything to be uniform with!)\n// can we remove the whole time part?\nif(dateStr==='00:00:00'||dateStr==='00:00'){dateStr=headStr;headStr='';}else if(dateStr.length===8){// strip off seconds if they're zero (zero fractional seconds\n// are already omitted)\n// but we never remove minutes and leave just hours\ndateStr=dateStr.replace(/:00$/,'');}}if(headStr){if(hover){// hover puts it all on one line, so headPart works best up front\n// except for year headPart: turn this into \"Jan 1, 2000\" etc.\nif(tr==='d')dateStr+=', '+headStr;else dateStr=headStr+(dateStr?', '+dateStr:'');}else if(!ax._inCalcTicks||headStr!==ax._prevDateHead){dateStr+='<br>'+headStr;ax._prevDateHead=headStr;}}out.text=dateStr;}function formatLog(ax,out,hover,extraPrecision,hideexp){var dtick=ax.dtick;var x=out.x;var tickformat=ax.tickformat;var dtChar0=typeof dtick==='string'&&dtick.charAt(0);if(hideexp==='never'){// If this is a hover label, then we must *never* hide the exponent\n// for the sake of display, which could give the wrong value by\n// potentially many orders of magnitude. If hideexp was 'never', then\n// it's now succeeded by preventing the other condition from automating\n// this choice. Thus we can unset it so that the axis formatting takes\n// precedence.\nhideexp='';}if(extraPrecision&&dtChar0!=='L'){dtick='L3';dtChar0='L';}if(tickformat||dtChar0==='L'){out.text=numFormat(Math.pow(10,x),ax,hideexp,extraPrecision);}else if(isNumeric(dtick)||dtChar0==='D'&&Lib.mod(x+0.01,1)<0.1){var p=Math.round(x);var absP=Math.abs(p);var exponentFormat=ax.exponentformat;if(exponentFormat==='power'||isSIFormat(exponentFormat)&&beyondSI(p)){if(p===0)out.text=1;else if(p===1)out.text='10';else out.text='10<sup>'+(p>1?'':MINUS_SIGN)+absP+'</sup>';out.fontSize*=1.25;}else if((exponentFormat==='e'||exponentFormat==='E')&&absP>2){out.text='1'+exponentFormat+(p>0?'+':MINUS_SIGN)+absP;}else{out.text=numFormat(Math.pow(10,x),ax,'','fakehover');if(dtick==='D1'&&ax._id.charAt(0)==='y'){out.dy-=out.fontSize/6;}}}else if(dtChar0==='D'){out.text=String(Math.round(Math.pow(10,Lib.mod(x,1))));out.fontSize*=0.75;}else throw'unrecognized dtick '+String(dtick);// if 9's are printed on log scale, move the 10's away a bit\nif(ax.dtick==='D1'){var firstChar=String(out.text).charAt(0);if(firstChar==='0'||firstChar==='1'){if(ax._id.charAt(0)==='y'){out.dx-=out.fontSize/4;}else{out.dy+=out.fontSize/2;out.dx+=(ax.range[1]>ax.range[0]?1:-1)*out.fontSize*(x<0?0.5:0.25);}}}}function formatCategory(ax,out){var tt=ax._categories[Math.round(out.x)];if(tt===undefined)tt='';out.text=String(tt);}function formatMultiCategory(ax,out,hover){var v=Math.round(out.x);var cats=ax._categories[v]||[];var tt=cats[1]===undefined?'':String(cats[1]);var tt2=cats[0]===undefined?'':String(cats[0]);if(hover){// TODO is this what we want?\nout.text=tt2+' - '+tt;}else{// setup for secondary labels\nout.text=tt;out.text2=tt2;}}function formatLinear(ax,out,hover,extraPrecision,hideexp){if(hideexp==='never'){// If this is a hover label, then we must *never* hide the exponent\n// for the sake of display, which could give the wrong value by\n// potentially many orders of magnitude. If hideexp was 'never', then\n// it's now succeeded by preventing the other condition from automating\n// this choice. Thus we can unset it so that the axis formatting takes\n// precedence.\nhideexp='';}else if(ax.showexponent==='all'&&Math.abs(out.x/ax.dtick)<1e-6){// don't add an exponent to zero if we're showing all exponents\n// so the only reason you'd show an exponent on zero is if it's the\n// ONLY tick to get an exponent (first or last)\nhideexp='hide';}out.text=numFormat(out.x,ax,hideexp,extraPrecision);}function formatAngle(ax,out,hover,extraPrecision,hideexp){if(ax.thetaunit==='radians'&&!hover){var num=out.x/180;if(num===0){out.text='0';}else{var frac=num2frac(num);if(frac[1]>=100){out.text=numFormat(Lib.deg2rad(out.x),ax,hideexp,extraPrecision);}else{var isNeg=out.x<0;if(frac[1]===1){if(frac[0]===1)out.text='';else out.text=frac[0]+'';}else{out.text=['<sup>',frac[0],'</sup>','','<sub>',frac[1],'</sub>',''].join('');}if(isNeg)out.text=MINUS_SIGN+out.text;}}}else{out.text=numFormat(out.x,ax,hideexp,extraPrecision);}}// inspired by\n// https://github.com/yisibl/num2fraction/blob/master/index.js\nfunction num2frac(num){function almostEq(a,b){return Math.abs(a-b)<=1e-6;}function findGCD(a,b){return almostEq(b,0)?a:findGCD(b,a%b);}function findPrecision(n){var e=1;while(!almostEq(Math.round(n*e)/e,n)){e*=10;}return e;}var precision=findPrecision(num);var number=num*precision;var gcd=Math.abs(findGCD(number,precision));return[// numerator\nMath.round(number/gcd),// denominator\nMath.round(precision/gcd)];}// format a number (tick value) according to the axis settings\n// new, more reliable procedure than d3.round or similar:\n// add half the rounding increment, then stringify and truncate\n// also automatically switch to sci. notation\nvar SIPREFIXES=['f','p','n','','m','','k','M','G','T'];function isSIFormat(exponentFormat){return exponentFormat==='SI'||exponentFormat==='B';}// are we beyond the range of common SI prefixes?\n// 10^-16 -> 1x10^-16\n// 10^-15 -> 1f\n// ...\n// 10^14 -> 100T\n// 10^15 -> 1x10^15\n// 10^16 -> 1x10^16\nfunction beyondSI(exponent){return exponent>14||exponent<-15;}function numFormat(v,ax,fmtoverride,hover){var isNeg=v<0;// max number of digits past decimal point to show\nvar tickRound=ax._tickround;var exponentFormat=fmtoverride||ax.exponentformat||'B';var exponent=ax._tickexponent;var tickformat=axes.getTickFormat(ax);var separatethousands=ax.separatethousands;// special case for hover: set exponent just for this value, and\n// add a couple more digits of precision over tick labels\nif(hover){// make a dummy axis obj to get the auto rounding and exponent\nvar ah={exponentformat:exponentFormat,dtick:ax.showexponent==='none'?ax.dtick:isNumeric(v)?Math.abs(v)||1:1,// if not showing any exponents, don't change the exponent\n// from what we calculate\nrange:ax.showexponent==='none'?ax.range.map(ax.r2d):[0,v||1]};autoTickRound(ah);tickRound=(Number(ah._tickround)||0)+4;exponent=ah._tickexponent;if(ax.hoverformat)tickformat=ax.hoverformat;}if(tickformat)return ax._numFormat(tickformat)(v).replace(/-/g,MINUS_SIGN);// 'epsilon' - rounding increment\nvar e=Math.pow(10,-tickRound)/2;// exponentFormat codes:\n// 'e' (1.2e+6, default)\n// 'E' (1.2E+6)\n// 'SI' (1.2M)\n// 'B' (same as SI except 10^9=B not G)\n// 'none' (1200000)\n// 'power' (1.2x10^6)\n// 'hide' (1.2, use 3rd argument=='hide' to eg\n//      only show exponent on last tick)\nif(exponentFormat==='none')exponent=0;// take the sign out, put it back manually at the end\n// - makes cases easier\nv=Math.abs(v);if(v<e){// 0 is just 0, but may get exponent if it's the last tick\nv='0';isNeg=false;}else{v+=e;// take out a common exponent, if any\nif(exponent){v*=Math.pow(10,-exponent);tickRound+=exponent;}// round the mantissa\nif(tickRound===0)v=String(Math.floor(v));else if(tickRound<0){v=String(Math.round(v));v=v.substr(0,v.length+tickRound);for(var i=tickRound;i<0;i++){v+='0';}}else{v=String(v);var dp=v.indexOf('.')+1;if(dp)v=v.substr(0,dp+tickRound).replace(/\\.?0+$/,'');}// insert appropriate decimal point and thousands separator\nv=Lib.numSeparate(v,ax._separators,separatethousands);}// add exponent\nif(exponent&&exponentFormat!=='hide'){if(isSIFormat(exponentFormat)&&beyondSI(exponent))exponentFormat='power';var signedExponent;if(exponent<0)signedExponent=MINUS_SIGN+-exponent;else if(exponentFormat!=='power')signedExponent='+'+exponent;else signedExponent=String(exponent);if(exponentFormat==='e'||exponentFormat==='E'){v+=exponentFormat+signedExponent;}else if(exponentFormat==='power'){v+='10<sup>'+signedExponent+'</sup>';}else if(exponentFormat==='B'&&exponent===9){v+='B';}else if(isSIFormat(exponentFormat)){v+=SIPREFIXES[exponent/3+5];}}// put sign back in and return\n// replace standard minus character (which is technically a hyphen)\n// with a true minus sign\nif(isNeg)return MINUS_SIGN+v;return v;}axes.getTickFormat=function(ax){var i;function convertToMs(dtick){return typeof dtick!=='string'?dtick:Number(dtick.replace('M',''))*ONEAVGMONTH;}function compareLogTicks(left,right){var priority=['L','D'];if(_typeof(left)===_typeof(right)){if(typeof left==='number'){return left-right;}else{var leftPriority=priority.indexOf(left.charAt(0));var rightPriority=priority.indexOf(right.charAt(0));if(leftPriority===rightPriority){return Number(left.replace(/(L|D)/g,''))-Number(right.replace(/(L|D)/g,''));}else{return leftPriority-rightPriority;}}}else{return typeof left==='number'?1:-1;}}function isProperStop(dtick,range,convert){var convertFn=convert||function(x){return x;};var leftDtick=range[0];var rightDtick=range[1];return(!leftDtick&&typeof leftDtick!=='number'||convertFn(leftDtick)<=convertFn(dtick))&&(!rightDtick&&typeof rightDtick!=='number'||convertFn(rightDtick)>=convertFn(dtick));}function isProperLogStop(dtick,range){var isLeftDtickNull=range[0]===null;var isRightDtickNull=range[1]===null;var isDtickInRangeLeft=compareLogTicks(dtick,range[0])>=0;var isDtickInRangeRight=compareLogTicks(dtick,range[1])<=0;return(isLeftDtickNull||isDtickInRangeLeft)&&(isRightDtickNull||isDtickInRangeRight);}var tickstop,stopi;if(ax.tickformatstops&&ax.tickformatstops.length>0){switch(ax.type){case'date':case'linear':{for(i=0;i<ax.tickformatstops.length;i++){stopi=ax.tickformatstops[i];if(stopi.enabled&&isProperStop(ax.dtick,stopi.dtickrange,convertToMs)){tickstop=stopi;break;}}break;}case'log':{for(i=0;i<ax.tickformatstops.length;i++){stopi=ax.tickformatstops[i];if(stopi.enabled&&isProperLogStop(ax.dtick,stopi.dtickrange)){tickstop=stopi;break;}}break;}default:}}return tickstop?tickstop.value:ax.tickformat;};// getSubplots - extract all subplot IDs we need\n// as an array of items like 'xy', 'x2y', 'x2y2'...\n// sorted by x (x,x2,x3...) then y\n// optionally restrict to only subplots containing axis object ax\n//\n// NOTE: this is currently only used OUTSIDE plotly.js (toolpanel, webapp)\n// ideally we get rid of it there (or just copy this there) and remove it here\naxes.getSubplots=function(gd,ax){var subplotObj=gd._fullLayout._subplots;var allSubplots=subplotObj.cartesian.concat(subplotObj.gl2d||[]);var out=ax?axes.findSubplotsWithAxis(allSubplots,ax):allSubplots;out.sort(function(a,b){var aParts=a.substr(1).split('y');var bParts=b.substr(1).split('y');if(aParts[0]===bParts[0])return+aParts[1]-+bParts[1];return+aParts[0]-+bParts[0];});return out;};// find all subplots with axis 'ax'\n// NOTE: this is only used in axes.getSubplots (only used outside plotly.js) and\n// gl2d/convert (where it restricts axis subplots to only those with gl2d)\naxes.findSubplotsWithAxis=function(subplots,ax){var axMatch=new RegExp(ax._id.charAt(0)==='x'?'^'+ax._id+'y':ax._id+'$');var subplotsWithAx=[];for(var i=0;i<subplots.length;i++){var sp=subplots[i];if(axMatch.test(sp))subplotsWithAx.push(sp);}return subplotsWithAx;};// makeClipPaths: prepare clipPaths for all single axes and all possible xy pairings\naxes.makeClipPaths=function(gd){var fullLayout=gd._fullLayout;// for more info: https://github.com/plotly/plotly.js/issues/2595\nif(fullLayout._hasOnlyLargeSploms)return;var fullWidth={_offset:0,_length:fullLayout.width,_id:''};var fullHeight={_offset:0,_length:fullLayout.height,_id:''};var xaList=axes.list(gd,'x',true);var yaList=axes.list(gd,'y',true);var clipList=[];var i,j;for(i=0;i<xaList.length;i++){clipList.push({x:xaList[i],y:fullHeight});for(j=0;j<yaList.length;j++){if(i===0)clipList.push({x:fullWidth,y:yaList[j]});clipList.push({x:xaList[i],y:yaList[j]});}}// selectors don't work right with camelCase tags,\n// have to use class instead\n// https://groups.google.com/forum/#!topic/d3-js/6EpAzQ2gU9I\nvar axClips=fullLayout._clips.selectAll('.axesclip').data(clipList,function(d){return d.x._id+d.y._id;});axClips.enter().append('clipPath').classed('axesclip',true).attr('id',function(d){return'clip'+fullLayout._uid+d.x._id+d.y._id;}).append('rect');axClips.exit().remove();axClips.each(function(d){d3.select(this).select('rect').attr({x:d.x._offset||0,y:d.y._offset||0,width:d.x._length||1,height:d.y._length||1});});};/**\n * Main multi-axis drawing routine!\n *\n * @param {DOM element} gd : graph div\n * @param {string or array of strings} arg : polymorphic argument\n * @param {object} opts:\n * - @param {boolean} skipTitle : optional flag to skip axis title draw/update\n *\n * Signature 1: Axes.draw(gd, 'redraw')\n *   use this to clear and redraw all axes on graph\n *\n * Signature 2: Axes.draw(gd, '')\n *   use this to draw all axes on graph w/o the selectAll().remove()\n *   of the 'redraw' signature\n *\n * Signature 3: Axes.draw(gd, [axId, axId2, ...])\n *   where the items are axis id string,\n *   use this to update multiple axes in one call\n *\n * N.B draw updates:\n * - ax._r (stored range for use by zoom/pan)\n * - ax._rl (stored linearized range for use by zoom/pan)\n */axes.draw=function(gd,arg,opts){var fullLayout=gd._fullLayout;if(arg==='redraw'){fullLayout._paper.selectAll('g.subplot').each(function(d){var id=d[0];var plotinfo=fullLayout._plots[id];var xa=plotinfo.xaxis;var ya=plotinfo.yaxis;plotinfo.xaxislayer.selectAll('.'+xa._id+'tick').remove();plotinfo.yaxislayer.selectAll('.'+ya._id+'tick').remove();plotinfo.xaxislayer.selectAll('.'+xa._id+'tick2').remove();plotinfo.yaxislayer.selectAll('.'+ya._id+'tick2').remove();plotinfo.xaxislayer.selectAll('.'+xa._id+'divider').remove();plotinfo.yaxislayer.selectAll('.'+ya._id+'divider').remove();if(plotinfo.gridlayer)plotinfo.gridlayer.selectAll('path').remove();if(plotinfo.zerolinelayer)plotinfo.zerolinelayer.selectAll('path').remove();fullLayout._infolayer.select('.g-'+xa._id+'title').remove();fullLayout._infolayer.select('.g-'+ya._id+'title').remove();});}var axList=!arg||arg==='redraw'?axes.listIds(gd):arg;return Lib.syncOrAsync(axList.map(function(axId){return function(){if(!axId)return;var ax=axes.getFromId(gd,axId);var axDone=axes.drawOne(gd,ax,opts);ax._r=ax.range.slice();ax._rl=Lib.simpleMap(ax._r,ax.r2l);return axDone;};}));};/**\n * Draw one cartesian axis\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n * @param {object} opts\n * - @param {boolean} skipTitle (set to true to skip axis title draw call)\n */axes.drawOne=function(gd,ax,opts){opts=opts||{};var i,sp,plotinfo;ax.setScale();var fullLayout=gd._fullLayout;var axId=ax._id;var axLetter=axId.charAt(0);var counterLetter=axes.counterLetter(axId);var mainSubplot=ax._mainSubplot;var mainLinePosition=ax._mainLinePosition;var mainMirrorPosition=ax._mainMirrorPosition;var mainPlotinfo=fullLayout._plots[mainSubplot];var mainAxLayer=mainPlotinfo[axLetter+'axislayer'];var subplotsWithAx=ax._subplotsWith;var vals=ax._vals=axes.calcTicks(ax);// Add a couple of axis properties that should cause us to recreate\n// elements. Used in d3 data function.\nvar axInfo=[ax.mirror,mainLinePosition,mainMirrorPosition].join('_');for(i=0;i<vals.length;i++){vals[i].axInfo=axInfo;}if(!ax.visible)return;// stash selections to avoid DOM queries e.g.\n// - stash tickLabels selection, so that drawTitle can use it to scoot title\nax._selections={};// stash tick angle (including the computed 'auto' values) per tick-label class\nax._tickAngles={};var transFn=axes.makeTransFn(ax);var tickVals;// We remove zero lines, grid lines, and inside ticks if they're within 1px of the end\n// The key case here is removing zero lines when the axis bound is zero\nvar valsClipped;if(ax.tickson==='boundaries'){var boundaryVals=getBoundaryVals(ax,vals);valsClipped=axes.clipEnds(ax,boundaryVals);tickVals=ax.ticks==='inside'?valsClipped:boundaryVals;}else{valsClipped=axes.clipEnds(ax,vals);tickVals=ax.ticks==='inside'?valsClipped:vals;}var gridVals=ax._gridVals=valsClipped;var dividerVals=getDividerVals(ax,vals);if(!fullLayout._hasOnlyLargeSploms){// keep track of which subplots (by main conteraxis) we've already\n// drawn grids for, so we don't overdraw overlaying subplots\nvar finishedGrids={};for(i=0;i<subplotsWithAx.length;i++){sp=subplotsWithAx[i];plotinfo=fullLayout._plots[sp];var counterAxis=plotinfo[counterLetter+'axis'];var mainCounterID=counterAxis._mainAxis._id;if(finishedGrids[mainCounterID])continue;finishedGrids[mainCounterID]=1;var gridPath=axLetter==='x'?'M0,'+counterAxis._offset+'v'+counterAxis._length:'M'+counterAxis._offset+',0h'+counterAxis._length;axes.drawGrid(gd,ax,{vals:gridVals,counterAxis:counterAxis,layer:plotinfo.gridlayer.select('.'+axId),path:gridPath,transFn:transFn});axes.drawZeroLine(gd,ax,{counterAxis:counterAxis,layer:plotinfo.zerolinelayer,path:gridPath,transFn:transFn});}}var tickSigns=axes.getTickSigns(ax);var tickSubplots=[];if(ax.ticks){var mainTickPath=axes.makeTickPath(ax,mainLinePosition,tickSigns[2]);var mirrorTickPath;var fullTickPath;if(ax._anchorAxis&&ax.mirror&&ax.mirror!==true){mirrorTickPath=axes.makeTickPath(ax,mainMirrorPosition,tickSigns[3]);fullTickPath=mainTickPath+mirrorTickPath;}else{mirrorTickPath='';fullTickPath=mainTickPath;}var tickPath;if(ax.showdividers&&ax.ticks==='outside'&&ax.tickson==='boundaries'){var dividerLookup={};for(i=0;i<dividerVals.length;i++){dividerLookup[dividerVals[i].x]=1;}tickPath=function tickPath(d){return dividerLookup[d.x]?mirrorTickPath:fullTickPath;};}else{tickPath=fullTickPath;}axes.drawTicks(gd,ax,{vals:tickVals,layer:mainAxLayer,path:tickPath,transFn:transFn});tickSubplots=Object.keys(ax._linepositions||{});}for(i=0;i<tickSubplots.length;i++){sp=tickSubplots[i];plotinfo=fullLayout._plots[sp];// [bottom or left, top or right], free and main are handled above\nvar linepositions=ax._linepositions[sp]||[];var spTickPath=axes.makeTickPath(ax,linepositions[0],tickSigns[0])+axes.makeTickPath(ax,linepositions[1],tickSigns[1]);axes.drawTicks(gd,ax,{vals:tickVals,layer:plotinfo[axLetter+'axislayer'],path:spTickPath,transFn:transFn});}var seq=[];// tick labels - for now just the main labels.\n// TODO: mirror labels, esp for subplots\nseq.push(function(){return axes.drawLabels(gd,ax,{vals:vals,layer:mainAxLayer,transFn:transFn,labelFns:axes.makeLabelFns(ax,mainLinePosition)});});if(ax.type==='multicategory'){var labelLength=0;var pad={x:2,y:10}[axLetter];var sgn=tickSigns[2]*(ax.ticks==='inside'?-1:1);seq.push(function(){labelLength+=getLabelLevelSpan(ax,axId+'tick')+pad;labelLength+=ax._tickAngles[axId+'tick']?ax.tickfont.size*LINE_SPACING:0;return axes.drawLabels(gd,ax,{vals:getSecondaryLabelVals(ax,vals),layer:mainAxLayer,cls:axId+'tick2',repositionOnUpdate:true,secondary:true,transFn:transFn,labelFns:axes.makeLabelFns(ax,mainLinePosition+labelLength*sgn)});});seq.push(function(){labelLength+=getLabelLevelSpan(ax,axId+'tick2');ax._labelLength=labelLength;return drawDividers(gd,ax,{vals:dividerVals,layer:mainAxLayer,path:axes.makeTickPath(ax,mainLinePosition,sgn,labelLength),transFn:transFn});});}function extendRange(range,newRange){range[0]=Math.min(range[0],newRange[0]);range[1]=Math.max(range[1],newRange[1]);}function calcBoundingBox(){if(ax.showticklabels){var gdBB=gd.getBoundingClientRect();var bBox=mainAxLayer.node().getBoundingClientRect();/*\n             * the way we're going to use this, the positioning that matters\n             * is relative to the origin of gd. This is important particularly\n             * if gd is scrollable, and may have been scrolled between the time\n             * we calculate this and the time we use it\n             */ax._boundingBox={width:bBox.width,height:bBox.height,left:bBox.left-gdBB.left,right:bBox.right-gdBB.left,top:bBox.top-gdBB.top,bottom:bBox.bottom-gdBB.top};}else{var gs=fullLayout._size;var pos;// set dummy bbox for ticklabel-less axes\nif(axLetter==='x'){pos=ax.anchor==='free'?gs.t+gs.h*(1-ax.position):gs.t+gs.h*(1-ax._anchorAxis.domain[{bottom:0,top:1}[ax.side]]);ax._boundingBox={top:pos,bottom:pos,left:ax._offset,right:ax._offset+ax._length,width:ax._length,height:0};}else{pos=ax.anchor==='free'?gs.l+gs.w*ax.position:gs.l+gs.w*ax._anchorAxis.domain[{left:0,right:1}[ax.side]];ax._boundingBox={left:pos,right:pos,bottom:ax._offset+ax._length,top:ax._offset,height:ax._length,width:0};}}/*\n         * for spikelines: what's the full domain of positions in the\n         * opposite direction that are associated with this axis?\n         * This means any axes that we make a subplot with, plus the\n         * position of the axis itself if it's free.\n         */if(subplotsWithAx){var fullRange=ax._counterSpan=[Infinity,-Infinity];for(var i=0;i<subplotsWithAx.length;i++){var plotinfo=fullLayout._plots[subplotsWithAx[i]];var counterAxis=plotinfo[axLetter==='x'?'yaxis':'xaxis'];extendRange(fullRange,[counterAxis._offset,counterAxis._offset+counterAxis._length]);}if(ax.anchor==='free'){extendRange(fullRange,axLetter==='x'?[ax._boundingBox.bottom,ax._boundingBox.top]:[ax._boundingBox.right,ax._boundingBox.left]);}}}var hasRangeSlider=Registry.getComponentMethod('rangeslider','isVisible')(ax);function doAutoMargins(){var s=ax.side.charAt(0);var push;var rangeSliderPush;if(hasRangeSlider){rangeSliderPush=Registry.getComponentMethod('rangeslider','autoMarginOpts')(gd,ax);}Plots.autoMargin(gd,rangeSliderAutoMarginID(ax),rangeSliderPush);if(ax.automargin&&(!hasRangeSlider||s!=='b')){push={x:0,y:0,r:0,l:0,t:0,b:0};var bbox=ax._boundingBox;var titleOffset=getTitleOffset(gd,ax);var anchorAxDomainIndex;var offset;switch(axLetter+s){case'xb':anchorAxDomainIndex=0;offset=bbox.top-titleOffset;push[s]=bbox.height;break;case'xt':anchorAxDomainIndex=1;offset=titleOffset-bbox.bottom;push[s]=bbox.height;break;case'yl':anchorAxDomainIndex=0;offset=titleOffset-bbox.right;push[s]=bbox.width;break;case'yr':anchorAxDomainIndex=1;offset=bbox.left-titleOffset;push[s]=bbox.width;break;}push[counterLetter]=ax.anchor==='free'?ax.position:ax._anchorAxis.domain[anchorAxDomainIndex];if(push[s]>0){push[s]+=offset;}if(ax.title.text!==fullLayout._dfltTitle[axLetter]){push[s]+=ax.title.font.size;}if(axLetter==='x'&&bbox.width>0){var rExtra=bbox.right-(ax._offset+ax._length);if(rExtra>0){push.x=1;push.r=rExtra;}var lExtra=ax._offset-bbox.left;if(lExtra>0){push.x=0;push.l=lExtra;}}else if(axLetter==='y'&&bbox.height>0){var bExtra=bbox.bottom-(ax._offset+ax._length);if(bExtra>0){push.y=0;push.b=bExtra;}var tExtra=ax._offset-bbox.top;if(tExtra>0){push.y=1;push.t=tExtra;}}}Plots.autoMargin(gd,axAutoMarginID(ax),push);}seq.push(calcBoundingBox,doAutoMargins);if(!opts.skipTitle&&!(hasRangeSlider&&ax._boundingBox&&ax.side==='bottom')){seq.push(function(){return drawTitle(gd,ax);});}return Lib.syncOrAsync(seq);};function getBoundaryVals(ax,vals){var out=[];var i;// boundaryVals are never used for labels;\n// no need to worry about the other tickTextObj keys\nvar _push=function _push(d,bndIndex){var xb=d.xbnd[bndIndex];if(xb!==null){out.push(Lib.extendFlat({},d,{x:xb}));}};if(vals.length){for(i=0;i<vals.length;i++){_push(vals[i],0);}_push(vals[i-1],1);}return out;}function getSecondaryLabelVals(ax,vals){var out=[];var lookup={};for(var i=0;i<vals.length;i++){var d=vals[i];if(lookup[d.text2]){lookup[d.text2].push(d.x);}else{lookup[d.text2]=[d.x];}}for(var k in lookup){out.push(tickTextObj(ax,Lib.interp(lookup[k],0.5),k));}return out;}function getDividerVals(ax,vals){var out=[];var i,current;// never used for labels;\n// no need to worry about the other tickTextObj keys\nvar _push=function _push(d,bndIndex){var xb=d.xbnd[bndIndex];if(xb!==null){out.push(Lib.extendFlat({},d,{x:xb}));}};if(ax.showdividers&&vals.length){for(i=0;i<vals.length;i++){var d=vals[i];if(d.text2!==current){_push(d,0);}current=d.text2;}_push(vals[i-1],1);}return out;}function getLabelLevelSpan(ax,cls){var axLetter=ax._id.charAt(0);var angle=ax._tickAngles[cls]||0;var rad=Lib.deg2rad(angle);var sinA=Math.sin(rad);var cosA=Math.cos(rad);var maxX=0;var maxY=0;// N.B. Drawing.bBox does not take into account rotate transforms\nax._selections[cls].each(function(){var thisLabel=selectTickLabel(this);var bb=Drawing.bBox(thisLabel.node());var w=bb.width;var h=bb.height;maxX=Math.max(maxX,cosA*w,sinA*h);maxY=Math.max(maxY,sinA*w,cosA*h);});return{x:maxY,y:maxX}[axLetter];}/**\n * Which direction do the 'ax.side' values, and free ticks go?\n *\n * @param {object} ax (full) axis object\n *  - {string} _id (starting with 'x' or 'y')\n *  - {string} side\n *  - {string} ticks\n * @return {array} all entries are either -1 or 1\n *  - [0]: sign for top/right ticks (i.e. negative SVG direction)\n *  - [1]: sign for bottom/left ticks (i.e. positive SVG direction)\n *  - [2]: sign for ticks corresponding to 'ax.side'\n *  - [3]: sign for ticks mirroring 'ax.side'\n */axes.getTickSigns=function(ax){var axLetter=ax._id.charAt(0);var sideOpposite={x:'top',y:'right'}[axLetter];var main=ax.side===sideOpposite?1:-1;var out=[-1,1,main,-main];// then we flip if outside XOR y axis\nif(ax.ticks!=='inside'===(axLetter==='x')){out=out.map(function(v){return-v;});}return out;};/**\n * Make axis translate transform function\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {number} _offset\n *  - {fn} l2p\n * @return {fn} function of calcTicks items\n */axes.makeTransFn=function(ax){var axLetter=ax._id.charAt(0);var offset=ax._offset;return axLetter==='x'?function(d){return'translate('+(offset+ax.l2p(d.x))+',0)';}:function(d){return'translate(0,'+(offset+ax.l2p(d.x))+')';};};/**\n * Make axis tick path string\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {number} ticklen\n *  - {number} linewidth\n * @param {number} shift along direction of ticklen\n * @param {1 or -1} sng tick sign\n * @param {number (optional)} len tick length\n * @return {string}\n */axes.makeTickPath=function(ax,shift,sgn,len){len=len!==undefined?len:ax.ticklen;var axLetter=ax._id.charAt(0);var pad=(ax.linewidth||1)/2;return axLetter==='x'?'M0,'+(shift+pad*sgn)+'v'+len*sgn:'M'+(shift+pad*sgn)+',0h'+len*sgn;};/**\n * Make axis tick label x, y and anchor functions\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} ticks\n *  - {number} ticklen\n *  - {string} side\n *  - {number} linewidth\n *  - {number} tickfont.size\n *  - {boolean} showline\n * @param {number} shift\n * @param {number} angle [in degrees] ...\n * @return {object}\n *  - {fn} xFn\n *  - {fn} yFn\n *  - {fn} anchorFn\n *  - {fn} heightFn\n *  - {number} labelStandoff (gap parallel to ticks)\n *  - {number} labelShift (gap perpendicular to ticks)\n */axes.makeLabelFns=function(ax,shift,angle){var axLetter=ax._id.charAt(0);var ticksOnOutsideLabels=ax.tickson!=='boundaries'&&ax.ticks==='outside';var labelStandoff=0;var labelShift=0;if(ticksOnOutsideLabels){labelStandoff+=ax.ticklen;}if(angle&&ax.ticks==='outside'){var rad=Lib.deg2rad(angle);labelStandoff=ax.ticklen*Math.cos(rad)+1;labelShift=ax.ticklen*Math.sin(rad);}if(ax.showticklabels&&(ticksOnOutsideLabels||ax.showline)){labelStandoff+=0.2*ax.tickfont.size;}labelStandoff+=(ax.linewidth||1)/2;var out={labelStandoff:labelStandoff,labelShift:labelShift};var x0,y0,ff,flipIt;if(axLetter==='x'){flipIt=ax.side==='bottom'?1:-1;x0=labelShift*flipIt;y0=shift+labelStandoff*flipIt;ff=ax.side==='bottom'?1:-0.2;out.xFn=function(d){return d.dx+x0;};out.yFn=function(d){return d.dy+y0+d.fontSize*ff;};out.anchorFn=function(d,a){if(!isNumeric(a)||a===0||a===180){return'middle';}return a*flipIt<0?'end':'start';};out.heightFn=function(d,a,h){return a<-60||a>60?-0.5*h:ax.side==='top'?-h:0;};}else if(axLetter==='y'){flipIt=ax.side==='right'?1:-1;x0=labelStandoff;y0=-labelShift*flipIt;ff=Math.abs(ax.tickangle)===90?0.5:0;out.xFn=function(d){return d.dx+shift+(x0+d.fontSize*ff)*flipIt;};out.yFn=function(d){return d.dy+y0+d.fontSize*MID_SHIFT;};out.anchorFn=function(d,a){if(isNumeric(a)&&Math.abs(a)===90){return'middle';}return ax.side==='right'?'start':'end';};out.heightFn=function(d,a,h){a*=ax.side==='left'?1:-1;return a<-30?-h:a<30?-0.5*h:0;};}return out;};function tickDataFn(d){return[d.text,d.x,d.axInfo,d.font,d.fontSize,d.fontColor].join('_');}/**\n * Draw axis ticks\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} ticks\n *  - {number} linewidth\n *  - {string} tickcolor\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */axes.drawTicks=function(gd,ax,opts){opts=opts||{};var cls=ax._id+'tick';var ticks=opts.layer.selectAll('path.'+cls).data(ax.ticks?opts.vals:[],tickDataFn);ticks.exit().remove();ticks.enter().append('path').classed(cls,1).classed('ticks',1).classed('crisp',opts.crisp!==false).call(Color.stroke,ax.tickcolor).style('stroke-width',Drawing.crispRound(gd,ax.tickwidth,1)+'px').attr('d',opts.path);ticks.attr('transform',opts.transFn);};/**\n * Draw axis grid\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} showgrid\n *  - {string} gridcolor\n *  - {string} gridwidth\n *  - {boolean} zeroline\n *  - {string} type\n *  - {string} dtick\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {object} counterAxis (full axis object corresponding to counter axis)\n *     optional - only required if this axis supports zero lines\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */axes.drawGrid=function(gd,ax,opts){opts=opts||{};var cls=ax._id+'grid';var vals=opts.vals;var counterAx=opts.counterAxis;if(ax.showgrid===false){vals=[];}else if(counterAx&&axes.shouldShowZeroLine(gd,ax,counterAx)){var isArrayMode=ax.tickmode==='array';for(var i=0;i<vals.length;i++){var xi=vals[i].x;if(isArrayMode?!xi:Math.abs(xi)<ax.dtick/100){vals=vals.slice(0,i).concat(vals.slice(i+1));// In array mode you can in principle have multiple\n// ticks at 0, so test them all. Otherwise once we found\n// one we can stop.\nif(isArrayMode)i--;else break;}}}var grid=opts.layer.selectAll('path.'+cls).data(vals,tickDataFn);grid.exit().remove();grid.enter().append('path').classed(cls,1).classed('crisp',opts.crisp!==false);ax._gw=Drawing.crispRound(gd,ax.gridwidth,1);grid.attr('transform',opts.transFn).attr('d',opts.path).call(Color.stroke,ax.gridcolor||'#ddd').style('stroke-width',ax._gw+'px');if(typeof opts.path==='function')grid.attr('d',opts.path);};/**\n * Draw axis zero-line\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} zeroline\n *  - {number} zerolinewidth\n *  - {string} zerolinecolor\n *  - {number (optional)} _gridWidthCrispRound\n * @param {object} opts\n * - {d3 selection} layer\n * - {object} counterAxis (full axis object corresponding to counter axis)\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */axes.drawZeroLine=function(gd,ax,opts){opts=opts||opts;var cls=ax._id+'zl';var show=axes.shouldShowZeroLine(gd,ax,opts.counterAxis);var zl=opts.layer.selectAll('path.'+cls).data(show?[{x:0,id:ax._id}]:[]);zl.exit().remove();zl.enter().append('path').classed(cls,1).classed('zl',1).classed('crisp',opts.crisp!==false).each(function(){// use the fact that only one element can enter to trigger a sort.\n// If several zerolines enter at the same time we will sort once per,\n// but generally this should be a minimal overhead.\nopts.layer.selectAll('path').sort(function(da,db){return axisIds.idSort(da.id,db.id);});});zl.attr('transform',opts.transFn).attr('d',opts.path).call(Color.stroke,ax.zerolinecolor||Color.defaultLine).style('stroke-width',Drawing.crispRound(gd,ax.zerolinewidth,ax._gw||1)+'px');};/**\n * Draw axis tick labels\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} showticklabels\n *  - {number} tickangle\n *  - {object (optional)} _selections\n *  - {object} (optional)} _tickAngles\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {string (optional)} cls (node className)\n * - {boolean} repositionOnUpdate (set to true to reposition update selection)\n * - {boolean} secondary\n * - {fn} transFn\n * - {object} labelFns\n *  + {fn} xFn\n *  + {fn} yFn\n *  + {fn} anchorFn\n *  + {fn} heightFn\n */axes.drawLabels=function(gd,ax,opts){opts=opts||{};var axId=ax._id;var axLetter=axId.charAt(0);var cls=opts.cls||axId+'tick';var vals=opts.vals;var labelFns=opts.labelFns;var tickAngle=opts.secondary?0:ax.tickangle;var lastAngle=(ax._tickAngles||{})[cls];var tickLabels=opts.layer.selectAll('g.'+cls).data(ax.showticklabels?vals:[],tickDataFn);var labelsReady=[];tickLabels.enter().append('g').classed(cls,1).append('text')// only so tex has predictable alignment that we can\n// alter later\n.attr('text-anchor','middle').each(function(d){var thisLabel=d3.select(this);var newPromise=gd._promises.length;thisLabel.call(svgTextUtils.positionText,labelFns.xFn(d),labelFns.yFn(d)).call(Drawing.font,d.font,d.fontSize,d.fontColor).text(d.text).call(svgTextUtils.convertToTspans,gd);if(gd._promises[newPromise]){// if we have an async label, we'll deal with that\n// all here so take it out of gd._promises and\n// instead position the label and promise this in\n// labelsReady\nlabelsReady.push(gd._promises.pop().then(function(){positionLabels(thisLabel,tickAngle);}));}else{// sync label: just position it now.\npositionLabels(thisLabel,tickAngle);}});tickLabels.exit().remove();if(opts.repositionOnUpdate){tickLabels.each(function(d){d3.select(this).select('text').call(svgTextUtils.positionText,labelFns.xFn(d),labelFns.yFn(d));});}function positionLabels(s,angle){s.each(function(d){var thisLabel=d3.select(this);var mathjaxGroup=thisLabel.select('.text-math-group');var anchor=labelFns.anchorFn(d,angle);var transform=opts.transFn.call(thisLabel.node(),d)+(isNumeric(angle)&&+angle!==0?' rotate('+angle+','+labelFns.xFn(d)+','+(labelFns.yFn(d)-d.fontSize/2)+')':'');// how much to shift a multi-line label to center it vertically.\nvar nLines=svgTextUtils.lineCount(thisLabel);var lineHeight=LINE_SPACING*d.fontSize;var anchorHeight=labelFns.heightFn(d,isNumeric(angle)?+angle:0,(nLines-1)*lineHeight);if(anchorHeight){transform+=' translate(0, '+anchorHeight+')';}if(mathjaxGroup.empty()){thisLabel.select('text').attr({transform:transform,'text-anchor':anchor});}else{var mjWidth=Drawing.bBox(mathjaxGroup.node()).width;var mjShift=mjWidth*{end:-0.5,start:0.5}[anchor];mathjaxGroup.attr('transform',transform+(mjShift?'translate('+mjShift+',0)':''));}});}// make sure all labels are correctly positioned at their base angle\n// the positionLabels call above is only for newly drawn labels.\n// do this without waiting, using the last calculated angle to\n// minimize flicker, then do it again when we know all labels are\n// there, putting back the prescribed angle to check for overlaps.\npositionLabels(tickLabels,lastAngle||tickAngle);function allLabelsReady(){return labelsReady.length&&Promise.all(labelsReady);}function fixLabelOverlaps(){positionLabels(tickLabels,tickAngle);var autoangle=null;// check for auto-angling if x labels overlap\n// don't auto-angle at all for log axes with\n// base and digit format\nif(vals.length&&axLetter==='x'&&!isNumeric(tickAngle)&&(ax.type!=='log'||String(ax.dtick).charAt(0)!=='D')){autoangle=0;var maxFontSize=0;var lbbArray=[];var i;tickLabels.each(function(d){maxFontSize=Math.max(maxFontSize,d.fontSize);var x=ax.l2p(d.x);var thisLabel=selectTickLabel(this);var bb=Drawing.bBox(thisLabel.node());lbbArray.push({// ignore about y, just deal with x overlaps\ntop:0,bottom:10,height:10,left:x-bb.width/2,// impose a 2px gap\nright:x+bb.width/2+2,width:bb.width+2});});if((ax.tickson==='boundaries'||ax.showdividers)&&!opts.secondary){var gap=2;if(ax.ticks)gap+=ax.tickwidth/2;// TODO should secondary labels also fall into this fix-overlap regime?\nfor(i=0;i<lbbArray.length;i++){var xbnd=vals[i].xbnd;var lbb=lbbArray[i];if(xbnd[0]!==null&&lbb.left-ax.l2p(xbnd[0])<gap||xbnd[1]!==null&&ax.l2p(xbnd[1])-lbb.right<gap){autoangle=90;break;}}}else{var vLen=vals.length;var tickSpacing=Math.abs((vals[vLen-1].x-vals[0].x)*ax._m)/(vLen-1);var rotate90=tickSpacing<maxFontSize*2.5||ax.type==='multicategory';// any overlap at all - set 30 degrees or 90 degrees\nfor(i=0;i<lbbArray.length-1;i++){if(Lib.bBoxIntersect(lbbArray[i],lbbArray[i+1])){autoangle=rotate90?90:30;break;}}}if(autoangle){positionLabels(tickLabels,autoangle);}}if(ax._tickAngles){ax._tickAngles[cls]=autoangle===null?isNumeric(tickAngle)?tickAngle:0:autoangle;}}if(ax._selections){ax._selections[cls]=tickLabels;}var done=Lib.syncOrAsync([allLabelsReady,fixLabelOverlaps]);if(done&&done.then)gd._promises.push(done);return done;};/**\n * Draw axis dividers\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} showdividers\n *  - {number} dividerwidth\n *  - {string} dividercolor\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {fn} path\n * - {fn} transFn\n */function drawDividers(gd,ax,opts){var cls=ax._id+'divider';var vals=opts.vals;var dividers=opts.layer.selectAll('path.'+cls).data(vals,tickDataFn);dividers.exit().remove();dividers.enter().insert('path',':first-child').classed(cls,1).classed('crisp',1).call(Color.stroke,ax.dividercolor).style('stroke-width',Drawing.crispRound(gd,ax.dividerwidth,1)+'px');dividers.attr('transform',opts.transFn).attr('d',opts.path);}function getTitleOffset(gd,ax){var gs=gd._fullLayout._size;var axLetter=ax._id.charAt(0);var side=ax.side;var anchorAxis;if(ax.anchor!=='free'){anchorAxis=axisIds.getFromId(gd,ax.anchor);}else if(axLetter==='x'){anchorAxis={_offset:gs.t+(1-(ax.position||0))*gs.h,_length:0};}else if(axLetter==='y'){anchorAxis={_offset:gs.l+(ax.position||0)*gs.w,_length:0};}if(side==='top'||side==='left'){return anchorAxis._offset;}else if(side==='bottom'||side==='right'){return anchorAxis._offset+anchorAxis._length;}}function drawTitle(gd,ax){var fullLayout=gd._fullLayout;var axId=ax._id;var axLetter=axId.charAt(0);var fontSize=ax.title.font.size;var titleStandoff;if(ax.type==='multicategory'){titleStandoff=ax._labelLength;}else{var offsetBase=1.5;titleStandoff=10+fontSize*offsetBase+(ax.linewidth?ax.linewidth-1:0);}var titleOffset=getTitleOffset(gd,ax);var transform,x,y;if(axLetter==='x'){x=ax._offset+ax._length/2;if(ax.side==='top'){y=-titleStandoff-fontSize*(ax.showticklabels?1:0);}else{y=titleStandoff+fontSize*(ax.showticklabels?1.5:0.5);}y+=titleOffset;}else{y=ax._offset+ax._length/2;if(ax.side==='right'){x=titleStandoff+fontSize*(ax.showticklabels?1:0.5);}else{x=-titleStandoff-fontSize*(ax.showticklabels?0.5:0);}x+=titleOffset;transform={rotate:'-90',offset:0};}var avoid;if(ax.type!=='multicategory'){var tickLabels=ax._selections[ax._id+'tick'];avoid={selection:tickLabels,side:ax.side};if(tickLabels&&tickLabels.node()&&tickLabels.node().parentNode){var translation=Drawing.getTranslate(tickLabels.node().parentNode);avoid.offsetLeft=translation.x;avoid.offsetTop=translation.y;}}return Titles.draw(gd,axId+'title',{propContainer:ax,propName:ax._name+'.title.text',placeholder:fullLayout._dfltTitle[axLetter],avoid:avoid,transform:transform,attributes:{x:x,y:y,'text-anchor':'middle'}});}axes.shouldShowZeroLine=function(gd,ax,counterAxis){var rng=Lib.simpleMap(ax.range,ax.r2l);return rng[0]*rng[1]<=0&&ax.zeroline&&(ax.type==='linear'||ax.type==='-')&&ax._gridVals.length&&(clipEnds(ax,0)||!anyCounterAxLineAtZero(gd,ax,counterAxis,rng)||hasBarsOrFill(gd,ax));};axes.clipEnds=function(ax,vals){return vals.filter(function(d){return clipEnds(ax,d.x);});};function clipEnds(ax,l){var p=ax.l2p(l);return p>1&&p<ax._length-1;}function anyCounterAxLineAtZero(gd,ax,counterAxis,rng){var mainCounterAxis=counterAxis._mainAxis;if(!mainCounterAxis)return;var fullLayout=gd._fullLayout;var axLetter=ax._id.charAt(0);var counterLetter=axes.counterLetter(ax._id);var zeroPosition=ax._offset+(Math.abs(rng[0])<Math.abs(rng[1])===(axLetter==='x')?0:ax._length);function lineNearZero(ax2){if(!ax2.showline||!ax2.linewidth)return false;var tolerance=Math.max((ax2.linewidth+ax.zerolinewidth)/2,1);function closeEnough(pos2){return typeof pos2==='number'&&Math.abs(pos2-zeroPosition)<tolerance;}if(closeEnough(ax2._mainLinePosition)||closeEnough(ax2._mainMirrorPosition)){return true;}var linePositions=ax2._linepositions||{};for(var k in linePositions){if(closeEnough(linePositions[k][0])||closeEnough(linePositions[k][1])){return true;}}}var plotinfo=fullLayout._plots[counterAxis._mainSubplot];if(!(plotinfo.mainplotinfo||plotinfo).overlays.length){return lineNearZero(counterAxis,zeroPosition);}var counterLetterAxes=axes.list(gd,counterLetter);for(var i=0;i<counterLetterAxes.length;i++){var counterAxis2=counterLetterAxes[i];if(counterAxis2._mainAxis===mainCounterAxis&&lineNearZero(counterAxis2,zeroPosition)){return true;}}}function hasBarsOrFill(gd,ax){var fullData=gd._fullData;var subplot=ax._mainSubplot;var axLetter=ax._id.charAt(0);for(var i=0;i<fullData.length;i++){var trace=fullData[i];if(trace.visible===true&&trace.xaxis+trace.yaxis===subplot){if((Registry.traceIs(trace,'bar')||trace.type==='waterfall')&&trace.orientation==={x:'h',y:'v'}[axLetter])return true;if(trace.fill&&trace.fill.charAt(trace.fill.length-1)===axLetter)return true;}}return false;}function selectTickLabel(gTick){var s=d3.select(gTick);var mj=s.select('.text-math-group');return mj.empty()?s.select('text'):mj;}/**\n * Find all margin pushers for 2D axes and reserve them for later use\n * Both label and rangeslider automargin calculations happen later so\n * we need to explicitly allow their ids in order to not delete them.\n *\n * TODO: can we pull the actual automargin calls forward to avoid this hack?\n * We're probably also doing multiple redraws in this case, would be faster\n * if we can just do the whole calculation ahead of time and draw once.\n */axes.allowAutoMargin=function(gd){var axList=axes.list(gd,'',true);for(var i=0;i<axList.length;i++){var ax=axList[i];if(ax.automargin){Plots.allowAutoMargin(gd,axAutoMarginID(ax));}if(Registry.getComponentMethod('rangeslider','isVisible')(ax)){Plots.allowAutoMargin(gd,rangeSliderAutoMarginID(ax));}}};function axAutoMarginID(ax){return ax._id+'.automargin';}function rangeSliderAutoMarginID(ax){return ax._id+'.rangeslider';}// swap all the presentation attributes of the axes showing these traces\naxes.swap=function(gd,traces){var axGroups=makeAxisGroups(gd,traces);for(var i=0;i<axGroups.length;i++){swapAxisGroup(gd,axGroups[i].x,axGroups[i].y);}};function makeAxisGroups(gd,traces){var groups=[];var i,j;for(i=0;i<traces.length;i++){var groupsi=[];var xi=gd._fullData[traces[i]].xaxis;var yi=gd._fullData[traces[i]].yaxis;if(!xi||!yi)continue;// not a 2D cartesian trace?\nfor(j=0;j<groups.length;j++){if(groups[j].x.indexOf(xi)!==-1||groups[j].y.indexOf(yi)!==-1){groupsi.push(j);}}if(!groupsi.length){groups.push({x:[xi],y:[yi]});continue;}var group0=groups[groupsi[0]];var groupj;if(groupsi.length>1){for(j=1;j<groupsi.length;j++){groupj=groups[groupsi[j]];mergeAxisGroups(group0.x,groupj.x);mergeAxisGroups(group0.y,groupj.y);}}mergeAxisGroups(group0.x,[xi]);mergeAxisGroups(group0.y,[yi]);}return groups;}function mergeAxisGroups(intoSet,fromSet){for(var i=0;i<fromSet.length;i++){if(intoSet.indexOf(fromSet[i])===-1)intoSet.push(fromSet[i]);}}function swapAxisGroup(gd,xIds,yIds){var xFullAxes=[];var yFullAxes=[];var layout=gd.layout;var i,j;for(i=0;i<xIds.length;i++){xFullAxes.push(axes.getFromId(gd,xIds[i]));}for(i=0;i<yIds.length;i++){yFullAxes.push(axes.getFromId(gd,yIds[i]));}var allAxKeys=Object.keys(axAttrs);var noSwapAttrs=['anchor','domain','overlaying','position','side','tickangle','editType'];var numericTypes=['linear','log'];for(i=0;i<allAxKeys.length;i++){var keyi=allAxKeys[i];var xVal=xFullAxes[0][keyi];var yVal=yFullAxes[0][keyi];var allEqual=true;var coerceLinearX=false;var coerceLinearY=false;if(keyi.charAt(0)==='_'||typeof xVal==='function'||noSwapAttrs.indexOf(keyi)!==-1){continue;}for(j=1;j<xFullAxes.length&&allEqual;j++){var xVali=xFullAxes[j][keyi];if(keyi==='type'&&numericTypes.indexOf(xVal)!==-1&&numericTypes.indexOf(xVali)!==-1&&xVal!==xVali){// type is special - if we find a mixture of linear and log,\n// coerce them all to linear on flipping\ncoerceLinearX=true;}else if(xVali!==xVal)allEqual=false;}for(j=1;j<yFullAxes.length&&allEqual;j++){var yVali=yFullAxes[j][keyi];if(keyi==='type'&&numericTypes.indexOf(yVal)!==-1&&numericTypes.indexOf(yVali)!==-1&&yVal!==yVali){// type is special - if we find a mixture of linear and log,\n// coerce them all to linear on flipping\ncoerceLinearY=true;}else if(yFullAxes[j][keyi]!==yVal)allEqual=false;}if(allEqual){if(coerceLinearX)layout[xFullAxes[0]._name].type='linear';if(coerceLinearY)layout[yFullAxes[0]._name].type='linear';swapAxisAttrs(layout,keyi,xFullAxes,yFullAxes,gd._fullLayout._dfltTitle);}}// now swap x&y for any annotations anchored to these x & y\nfor(i=0;i<gd._fullLayout.annotations.length;i++){var ann=gd._fullLayout.annotations[i];if(xIds.indexOf(ann.xref)!==-1&&yIds.indexOf(ann.yref)!==-1){Lib.swapAttrs(layout.annotations[i],['?']);}}}function swapAxisAttrs(layout,key,xFullAxes,yFullAxes,dfltTitle){// in case the value is the default for either axis,\n// look at the first axis in each list and see if\n// this key's value is undefined\nvar np=Lib.nestedProperty;var xVal=np(layout[xFullAxes[0]._name],key).get();var yVal=np(layout[yFullAxes[0]._name],key).get();var i;if(key==='title'){// special handling of placeholder titles\nif(xVal&&xVal.text===dfltTitle.x){xVal.text=dfltTitle.y;}if(yVal&&yVal.text===dfltTitle.y){yVal.text=dfltTitle.x;}}for(i=0;i<xFullAxes.length;i++){np(layout,xFullAxes[i]._name+'.'+key).set(yVal);}for(i=0;i<yFullAxes.length;i++){np(layout,yFullAxes[i]._name+'.'+key).set(xVal);}}function isAngular(ax){return ax._id==='angularaxis';}},{\"../../components/color\":43,\"../../components/drawing\":64,\"../../components/titles\":131,\"../../constants/alignment\":138,\"../../constants/numerical\":140,\"../../lib\":159,\"../../lib/svg_text_utils\":180,\"../../plots/plots\":235,\"../../registry\":242,\"./autorange\":202,\"./axis_autotype\":204,\"./axis_ids\":206,\"./clean_ticks\":208,\"./layout_attributes\":215,\"./set_convert\":221,\"d3\":8,\"fast-isnumeric\":10}],204:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var isNumeric=_dereq_('fast-isnumeric');var Lib=_dereq_('../../lib');var BADNUM=_dereq_('../../constants/numerical').BADNUM;module.exports=function autoType(array,calendar,opts){opts=opts||{};if(!opts.noMultiCategory&&multiCategory(array))return'multicategory';if(moreDates(array,calendar))return'date';if(category(array))return'category';if(linearOK(array))return'linear';else return'-';};// is there at least one number in array? If not, we should leave\n// ax.type empty so it can be autoset later\nfunction linearOK(array){if(!array)return false;for(var i=0;i<array.length;i++){if(isNumeric(array[i]))return true;}return false;}// does the array a have mostly dates rather than numbers?\n// note: some values can be neither (such as blanks, text)\n// 2- or 4-digit integers can be both, so require twice as many\n// dates as non-dates, to exclude cases with mostly 2 & 4 digit\n// numbers and a few dates\n// as with categories, consider DISTINCT values only.\nfunction moreDates(a,calendar){// test at most 1000 points, evenly spaced\nvar inc=Math.max(1,(a.length-1)/1000);var dcnt=0;var ncnt=0;var seen={};for(var i=0;i<a.length;i+=inc){var ai=a[Math.round(i)];var stri=String(ai);if(seen[stri])continue;seen[stri]=1;if(Lib.isDateTime(ai,calendar))dcnt+=1;if(isNumeric(ai))ncnt+=1;}return dcnt>ncnt*2;}// are the (x,y)-values in gd.data mostly text?\n// require twice as many DISTINCT categories as distinct numbers\nfunction category(a){// test at most 1000 points\nvar inc=Math.max(1,(a.length-1)/1000);var curvenums=0;var curvecats=0;var seen={};for(var i=0;i<a.length;i+=inc){var ai=a[Math.round(i)];var stri=String(ai);if(seen[stri])continue;seen[stri]=1;if(typeof ai==='boolean')curvecats++;else if(Lib.cleanNumber(ai)!==BADNUM)curvenums++;else if(typeof ai==='string')curvecats++;}return curvecats>curvenums*2;}// very-loose requirements for multicategory,\n// trace modules that should never auto-type to multicategory\n// should be declared with 'noMultiCategory'\nfunction multiCategory(a){return Lib.isArrayOrTypedArray(a[0])&&Lib.isArrayOrTypedArray(a[1]);}},{\"../../constants/numerical\":140,\"../../lib\":159,\"fast-isnumeric\":10}],205:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Registry=_dereq_('../../registry');var Lib=_dereq_('../../lib');var layoutAttributes=_dereq_('./layout_attributes');var handleTickValueDefaults=_dereq_('./tick_value_defaults');var handleTickMarkDefaults=_dereq_('./tick_mark_defaults');var handleTickLabelDefaults=_dereq_('./tick_label_defaults');var handleCategoryOrderDefaults=_dereq_('./category_order_defaults');var handleLineGridDefaults=_dereq_('./line_grid_defaults');var setConvert=_dereq_('./set_convert');/**\n * options: object containing:\n *\n *  letter: 'x' or 'y'\n *  title: name of the axis (ie 'Colorbar') to go in default title\n *  font: the default font to inherit\n *  outerTicks: boolean, should ticks default to outside?\n *  showGrid: boolean, should gridlines be shown by default?\n *  noHover: boolean, this axis doesn't support hover effects?\n *  noTickson: boolean, this axis doesn't support 'tickson'\n *  data: the plot data, used to manage categories\n *  bgColor: the plot background color, to calculate default gridline colors\n */module.exports=function handleAxisDefaults(containerIn,containerOut,coerce,options,layoutOut){var letter=options.letter;var font=options.font||{};var splomStash=options.splomStash||{};var visible=coerce('visible',!options.cheateronly);var axType=containerOut.type;if(axType==='date'){var handleCalendarDefaults=Registry.getComponentMethod('calendars','handleDefaults');handleCalendarDefaults(containerIn,containerOut,'calendar',options.calendar);}setConvert(containerOut,layoutOut);var autoRange=coerce('autorange',!containerOut.isValidRange(containerIn.range));if(autoRange&&(axType==='linear'||axType==='-'))coerce('rangemode');coerce('range');containerOut.cleanRange();handleCategoryOrderDefaults(containerIn,containerOut,coerce,options);if(axType!=='category'&&!options.noHover)coerce('hoverformat');if(!visible)return containerOut;var dfltColor=coerce('color');// if axis.color was provided, use it for fonts too; otherwise,\n// inherit from global font color in case that was provided.\n// Compare to dflt rather than to containerIn, so we can provide color via\n// template too.\nvar dfltFontColor=dfltColor!==layoutAttributes.color.dflt?dfltColor:font.color;// try to get default title from splom trace, fallback to graph-wide value\nvar dfltTitle=splomStash.label||layoutOut._dfltTitle[letter];coerce('title.text',dfltTitle);Lib.coerceFont(coerce,'title.font',{family:font.family,size:Math.round(font.size*1.2),color:dfltFontColor});handleTickValueDefaults(containerIn,containerOut,coerce,axType);handleTickLabelDefaults(containerIn,containerOut,coerce,axType,options);handleTickMarkDefaults(containerIn,containerOut,coerce,options);handleLineGridDefaults(containerIn,containerOut,coerce,{dfltColor:dfltColor,bgColor:options.bgColor,showGrid:options.showGrid,attributes:layoutAttributes});if(containerOut.showline||containerOut.ticks)coerce('mirror');if(options.automargin)coerce('automargin');var isMultiCategory=containerOut.type==='multicategory';if(!options.noTickson&&(containerOut.type==='category'||isMultiCategory)&&(containerOut.ticks||containerOut.showgrid)){var ticksonDflt;if(isMultiCategory)ticksonDflt='boundaries';coerce('tickson',ticksonDflt);}if(isMultiCategory){var showDividers=coerce('showdividers');if(showDividers){coerce('dividercolor');coerce('dividerwidth');}}return containerOut;};},{\"../../lib\":159,\"../../registry\":242,\"./category_order_defaults\":207,\"./layout_attributes\":215,\"./line_grid_defaults\":217,\"./set_convert\":221,\"./tick_label_defaults\":222,\"./tick_mark_defaults\":223,\"./tick_value_defaults\":224}],206:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Registry=_dereq_('../../registry');var constants=_dereq_('./constants');// convert between axis names (xaxis, xaxis2, etc, elements of gd.layout)\n// and axis id's (x, x2, etc). Would probably have ditched 'xaxis'\n// completely in favor of just 'x' if it weren't ingrained in the API etc.\nexports.id2name=function id2name(id){if(typeof id!=='string'||!id.match(constants.AX_ID_PATTERN))return;var axNum=id.substr(1);if(axNum==='1')axNum='';return id.charAt(0)+'axis'+axNum;};exports.name2id=function name2id(name){if(!name.match(constants.AX_NAME_PATTERN))return;var axNum=name.substr(5);if(axNum==='1')axNum='';return name.charAt(0)+axNum;};exports.cleanId=function cleanId(id,axLetter){if(!id.match(constants.AX_ID_PATTERN))return;if(axLetter&&id.charAt(0)!==axLetter)return;var axNum=id.substr(1).replace(/^0+/,'');if(axNum==='1')axNum='';return id.charAt(0)+axNum;};// get all axis objects, as restricted in listNames\nexports.list=function(gd,axLetter,only2d){var fullLayout=gd._fullLayout;if(!fullLayout)return[];var idList=exports.listIds(gd,axLetter);var out=new Array(idList.length);var i;for(i=0;i<idList.length;i++){var idi=idList[i];out[i]=fullLayout[idi.charAt(0)+'axis'+idi.substr(1)];}if(!only2d){var sceneIds3D=fullLayout._subplots.gl3d||[];for(i=0;i<sceneIds3D.length;i++){var scene=fullLayout[sceneIds3D[i]];if(axLetter)out.push(scene[axLetter+'axis']);else out.push(scene.xaxis,scene.yaxis,scene.zaxis);}}return out;};// get all axis ids, optionally restricted by letter\n// this only makes sense for 2d axes\nexports.listIds=function(gd,axLetter){var fullLayout=gd._fullLayout;if(!fullLayout)return[];var subplotLists=fullLayout._subplots;if(axLetter)return subplotLists[axLetter+'axis'];return subplotLists.xaxis.concat(subplotLists.yaxis);};// get an axis object from its id 'x','x2' etc\n// optionally, id can be a subplot (ie 'x2y3') and type gets x or y from it\nexports.getFromId=function(gd,id,type){var fullLayout=gd._fullLayout;if(type==='x')id=id.replace(/y[0-9]*/,'');else if(type==='y')id=id.replace(/x[0-9]*/,'');return fullLayout[exports.id2name(id)];};// get an axis object of specified type from the containing trace\nexports.getFromTrace=function(gd,fullTrace,type){var fullLayout=gd._fullLayout;var ax=null;if(Registry.traceIs(fullTrace,'gl3d')){var scene=fullTrace.scene;if(scene.substr(0,5)==='scene'){ax=fullLayout[scene][type+'axis'];}}else{ax=exports.getFromId(gd,fullTrace[type+'axis']||type);}return ax;};// sort x, x2, x10, y, y2, y10...\nexports.idSort=function(id1,id2){var letter1=id1.charAt(0);var letter2=id2.charAt(0);if(letter1!==letter2)return letter1>letter2?1:-1;return+(id1.substr(1)||1)-+(id2.substr(1)||1);};exports.getAxisGroup=function getAxisGroup(fullLayout,axId){var matchGroups=fullLayout._axisMatchGroups;for(var i=0;i<matchGroups.length;i++){var group=matchGroups[i];if(group[axId])return'g'+i;}return axId;};},{\"../../registry\":242,\"./constants\":209}],207:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';function findCategories(ax,opts){var dataAttr=opts.dataAttr||ax._id.charAt(0);var lookup={};var axData;var i,j;if(opts.axData){// non-x/y case\naxData=opts.axData;}else{// x/y case\naxData=[];for(i=0;i<opts.data.length;i++){var trace=opts.data[i];if(trace[dataAttr+'axis']===ax._id){axData.push(trace);}}}for(i=0;i<axData.length;i++){var vals=axData[i][dataAttr];for(j=0;j<vals.length;j++){var v=vals[j];if(v!==null&&v!==undefined){lookup[v]=1;}}}return Object.keys(lookup);}/**\n * Fills in category* default and initial categories.\n *\n * @param {object} containerIn : input axis object\n * @param {object} containerOut : full axis object\n * @param {function} coerce : Lib.coerce fn wrapper\n * @param {object} opts :\n *   - data {array} : (full) data trace\n * OR\n *   - axData {array} : (full) data associated with axis being coerced here\n *   - dataAttr {string} : attribute name corresponding to coordinate array\n */module.exports=function handleCategoryOrderDefaults(containerIn,containerOut,coerce,opts){if(containerOut.type!=='category')return;var arrayIn=containerIn.categoryarray;var isValidArray=Array.isArray(arrayIn)&&arrayIn.length>0;// override default 'categoryorder' value when non-empty array is supplied\nvar orderDefault;if(isValidArray)orderDefault='array';var order=coerce('categoryorder',orderDefault);var array;// coerce 'categoryarray' only in array order case\nif(order==='array'){array=coerce('categoryarray');}// cannot set 'categoryorder' to 'array' with an invalid 'categoryarray'\nif(!isValidArray&&order==='array'){order=containerOut.categoryorder='trace';}// set up things for makeCalcdata\nif(order==='trace'){containerOut._initialCategories=[];}else if(order==='array'){containerOut._initialCategories=array.slice();}else{array=findCategories(containerOut,opts).sort();if(order==='category ascending'){containerOut._initialCategories=array;}else if(order==='category descending'){containerOut._initialCategories=array.reverse();}}};},{}],208:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var isNumeric=_dereq_('fast-isnumeric');var Lib=_dereq_('../../lib');var ONEDAY=_dereq_('../../constants/numerical').ONEDAY;/**\n * Return a validated dtick value for this axis\n *\n * @param {any} dtick: the candidate dtick. valid values are numbers and strings,\n *     and further constrained depending on the axis type.\n * @param {string} axType: the axis type\n */exports.dtick=function(dtick,axType){var isLog=axType==='log';var isDate=axType==='date';var isCat=axType==='category';var dtickDflt=isDate?ONEDAY:1;if(!dtick)return dtickDflt;if(isNumeric(dtick)){dtick=Number(dtick);if(dtick<=0)return dtickDflt;if(isCat){// category dtick must be positive integers\nreturn Math.max(1,Math.round(dtick));}if(isDate){// date dtick must be at least 0.1ms (our current precision)\nreturn Math.max(0.1,dtick);}return dtick;}if(typeof dtick!=='string'||!(isDate||isLog)){return dtickDflt;}var prefix=dtick.charAt(0);var dtickNum=dtick.substr(1);dtickNum=isNumeric(dtickNum)?Number(dtickNum):0;if(dtickNum<=0||!(// \"M<n>\" gives ticks every (integer) n months\nisDate&&prefix==='M'&&dtickNum===Math.round(dtickNum)||// \"L<f>\" gives ticks linearly spaced in data (not in position) every (float) f\nisLog&&prefix==='L'||// \"D1\" gives powers of 10 with all small digits between, \"D2\" gives only 2 and 5\nisLog&&prefix==='D'&&(dtickNum===1||dtickNum===2))){return dtickDflt;}return dtick;};/**\n * Return a validated tick0 for this axis\n *\n * @param {any} tick0: the candidate tick0. Valid values are numbers and strings,\n *     further constrained depending on the axis type\n * @param {string} axType: the axis type\n * @param {string} calendar: for date axes, the calendar to validate/convert with\n * @param {any} dtick: an already valid dtick. Only used for D1 and D2 log dticks,\n *     which do not support tick0 at all.\n */exports.tick0=function(tick0,axType,calendar,dtick){if(axType==='date'){return Lib.cleanDate(tick0,Lib.dateTick0(calendar));}if(dtick==='D1'||dtick==='D2'){// D1 and D2 modes ignore tick0 entirely\nreturn undefined;}// Aside from date axes, tick0 must be numeric\nreturn isNumeric(tick0)?Number(tick0):0;};},{\"../../constants/numerical\":140,\"../../lib\":159,\"fast-isnumeric\":10}],209:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var counterRegex=_dereq_('../../lib/regex').counter;module.exports={idRegex:{x:counterRegex('x'),y:counterRegex('y')},attrRegex:counterRegex('[xy]axis'),// axis match regular expression\nxAxisMatch:counterRegex('xaxis'),yAxisMatch:counterRegex('yaxis'),// pattern matching axis ids and names\n// note that this is more permissive than counterRegex, as\n// id2name, name2id, and cleanId accept \"x1\" etc\nAX_ID_PATTERN:/^[xyz][0-9]*$/,AX_NAME_PATTERN:/^[xyz]axis[0-9]*$/,// and for 2D subplots\nSUBPLOT_PATTERN:/^x([0-9]*)y([0-9]*)$/,// pixels to move mouse before you stop clamping to starting point\nMINDRAG:8,// smallest dimension allowed for a select box\nMINSELECT:12,// smallest dimension allowed for a zoombox\nMINZOOM:20,// width of axis drag regions\nDRAGGERSIZE:20,// max pixels off straight before a lasso select line counts as bent\nBENDPX:1.5,// delay before a redraw (relayout) after smooth panning and zooming\nREDRAWDELAY:50,// throttling limit (ms) for selectPoints calls\nSELECTDELAY:100,// cache ID suffix for throttle\nSELECTID:'-select',// last resort axis ranges for x and y axes if we have no data\nDFLTRANGEX:[-1,6],DFLTRANGEY:[-1,4],// Layers to keep trace types in the right order\n// N.B. each  'unique' plot method must have its own layer\ntraceLayerClasses:['heatmaplayer','contourcarpetlayer','contourlayer','waterfalllayer','barlayer','carpetlayer','violinlayer','boxlayer','ohlclayer','scattercarpetlayer','scatterlayer'],layerValue2layerClass:{'above traces':'above','below traces':'below'}};},{\"../../lib/regex\":174}],210:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var id2name=_dereq_('./axis_ids').id2name;var scaleZoom=_dereq_('./scale_zoom');var makePadFn=_dereq_('./autorange').makePadFn;var concatExtremes=_dereq_('./autorange').concatExtremes;var ALMOST_EQUAL=_dereq_('../../constants/numerical').ALMOST_EQUAL;var FROM_BL=_dereq_('../../constants/alignment').FROM_BL;exports.handleConstraintDefaults=function(containerIn,containerOut,coerce,allAxisIds,layoutOut){var constraintGroups=layoutOut._axisConstraintGroups;var matchGroups=layoutOut._axisMatchGroups;var axId=containerOut._id;var axLetter=axId.charAt(0);var splomStash=((layoutOut._splomAxes||{})[axLetter]||{})[axId]||{};var thisID=containerOut._id;var letter=thisID.charAt(0);// coerce the constraint mechanics even if this axis has no scaleanchor\n// because it may be the anchor of another axis.\nvar constrain=coerce('constrain');Lib.coerce(containerIn,containerOut,{constraintoward:{valType:'enumerated',values:letter==='x'?['left','center','right']:['bottom','middle','top'],dflt:letter==='x'?'center':'middle'}},'constraintoward');var matches,matchOpts;if((containerIn.matches||splomStash.matches)&&!containerOut.fixedrange){matchOpts=getConstraintOpts(matchGroups,thisID,allAxisIds,layoutOut);matches=Lib.coerce(containerIn,containerOut,{matches:{valType:'enumerated',values:matchOpts.linkableAxes||[],dflt:splomStash.matches}},'matches');}// 'matches' wins over 'scaleanchor' (for now)\nvar scaleanchor,scaleOpts;if(!matches&&containerIn.scaleanchor&&!(containerOut.fixedrange&&constrain!=='domain')){scaleOpts=getConstraintOpts(constraintGroups,thisID,allAxisIds,layoutOut,constrain);scaleanchor=Lib.coerce(containerIn,containerOut,{scaleanchor:{valType:'enumerated',values:scaleOpts.linkableAxes||[]}},'scaleanchor');}if(matches){delete containerOut.constrain;updateConstraintGroups(matchGroups,matchOpts.thisGroup,thisID,matches,1);}else if(allAxisIds.indexOf(containerIn.matches)!==-1){Lib.warn('ignored '+containerOut._name+'.matches: \"'+containerIn.matches+'\" to avoid either an infinite loop '+'or because the target axis has fixed range.');}if(scaleanchor){var scaleratio=coerce('scaleratio');// TODO: I suppose I could do attribute.min: Number.MIN_VALUE to avoid zero,\n// but that seems hacky. Better way to say \"must be a positive number\"?\n// Of course if you use several super-tiny values you could eventually\n// force a product of these to zero and all hell would break loose...\n// Likewise with super-huge values.\nif(!scaleratio)scaleratio=containerOut.scaleratio=1;updateConstraintGroups(constraintGroups,scaleOpts.thisGroup,thisID,scaleanchor,scaleratio);}else if(allAxisIds.indexOf(containerIn.scaleanchor)!==-1){Lib.warn('ignored '+containerOut._name+'.scaleanchor: \"'+containerIn.scaleanchor+'\" to avoid either an infinite loop '+'and possibly inconsistent scaleratios, or because the target '+'axis has fixed range or this axis declares a *matches* constraint.');}};// If this axis is already part of a constraint group, we can't\n// scaleanchor any other axis in that group, or we'd make a loop.\n// Filter allAxisIds to enforce this, also matching axis types.\nfunction getConstraintOpts(groups,thisID,allAxisIds,layoutOut,constrain){var doesNotConstrainRange=constrain!=='range';var thisType=layoutOut[id2name(thisID)].type;var i,j,idj,axj;var linkableAxes=[];for(j=0;j<allAxisIds.length;j++){idj=allAxisIds[j];if(idj===thisID)continue;axj=layoutOut[id2name(idj)];if(axj.type===thisType){if(!axj.fixedrange){linkableAxes.push(idj);}else if(doesNotConstrainRange&&axj.anchor){// allow domain constraints on subplots where\n// BOTH axes have fixedrange:true and constrain:domain\nvar counterAxj=layoutOut[id2name(axj.anchor)];if(counterAxj.fixedrange){linkableAxes.push(idj);}}}}for(i=0;i<groups.length;i++){if(groups[i][thisID]){var thisGroup=groups[i];var linkableAxesNoLoops=[];for(j=0;j<linkableAxes.length;j++){idj=linkableAxes[j];if(!thisGroup[idj])linkableAxesNoLoops.push(idj);}return{linkableAxes:linkableAxesNoLoops,thisGroup:thisGroup};}}return{linkableAxes:linkableAxes,thisGroup:null};}/*\n * Add this axis to the axis constraint groups, which is the collection\n * of axes that are all constrained together on scale.\n *\n * constraintGroups: a list of objects. each object is\n * {axis_id: scale_within_group}, where scale_within_group is\n * only important relative to the rest of the group, and defines\n * the relative scales between all axes in the group\n *\n * thisGroup: the group the current axis is already in\n * thisID: the id if the current axis\n * scaleanchor: the id of the axis to scale it with\n * scaleratio: the ratio of this axis to the scaleanchor axis\n */function updateConstraintGroups(constraintGroups,thisGroup,thisID,scaleanchor,scaleratio){var i,j,groupi,keyj,thisGroupIndex;if(thisGroup===null){thisGroup={};thisGroup[thisID]=1;thisGroupIndex=constraintGroups.length;constraintGroups.push(thisGroup);}else{thisGroupIndex=constraintGroups.indexOf(thisGroup);}var thisGroupKeys=Object.keys(thisGroup);// we know that this axis isn't in any other groups, but we don't know\n// about the scaleanchor axis. If it is, we need to merge the groups.\nfor(i=0;i<constraintGroups.length;i++){groupi=constraintGroups[i];if(i!==thisGroupIndex&&groupi[scaleanchor]){var baseScale=groupi[scaleanchor];for(j=0;j<thisGroupKeys.length;j++){keyj=thisGroupKeys[j];groupi[keyj]=baseScale*scaleratio*thisGroup[keyj];}constraintGroups.splice(thisGroupIndex,1);return;}}// otherwise, we insert the new scaleanchor axis as the base scale (1)\n// in its group, and scale the rest of the group to it\nif(scaleratio!==1){for(j=0;j<thisGroupKeys.length;j++){thisGroup[thisGroupKeys[j]]*=scaleratio;}}thisGroup[scaleanchor]=1;}exports.enforce=function enforce(gd){var fullLayout=gd._fullLayout;var constraintGroups=fullLayout._axisConstraintGroups||[];var i,j,axisID,ax,normScale,mode,factor;for(i=0;i<constraintGroups.length;i++){var group=constraintGroups[i];var axisIDs=Object.keys(group);var minScale=Infinity;var maxScale=0;// mostly matchScale will be the same as minScale\n// ie we expand axis ranges to encompass *everything*\n// that's currently in any of their ranges, but during\n// autorange of a subset of axes we will ignore other\n// axes for this purpose.\nvar matchScale=Infinity;var normScales={};var axes={};var hasAnyDomainConstraint=false;// find the (normalized) scale of each axis in the group\nfor(j=0;j<axisIDs.length;j++){axisID=axisIDs[j];axes[axisID]=ax=fullLayout[id2name(axisID)];if(ax._inputDomain)ax.domain=ax._inputDomain.slice();else ax._inputDomain=ax.domain.slice();if(!ax._inputRange)ax._inputRange=ax.range.slice();// set axis scale here so we can use _m rather than\n// having to calculate it from length and range\nax.setScale();// abs: inverted scales still satisfy the constraint\nnormScales[axisID]=normScale=Math.abs(ax._m)/group[axisID];minScale=Math.min(minScale,normScale);if(ax.constrain==='domain'||!ax._constraintShrinkable){matchScale=Math.min(matchScale,normScale);}// this has served its purpose, so remove it\ndelete ax._constraintShrinkable;maxScale=Math.max(maxScale,normScale);if(ax.constrain==='domain')hasAnyDomainConstraint=true;}// Do we have a constraint mismatch? Give a small buffer for rounding errors\nif(minScale>ALMOST_EQUAL*maxScale&&!hasAnyDomainConstraint)continue;// now increase any ranges we need to until all normalized scales are equal\nfor(j=0;j<axisIDs.length;j++){axisID=axisIDs[j];normScale=normScales[axisID];ax=axes[axisID];mode=ax.constrain;// even if the scale didn't change, if we're shrinking domain\n// we need to recalculate in case `constraintoward` changed\nif(normScale!==matchScale||mode==='domain'){factor=normScale/matchScale;if(mode==='range'){scaleZoom(ax,factor);}else{// mode === 'domain'\nvar inputDomain=ax._inputDomain;var domainShrunk=(ax.domain[1]-ax.domain[0])/(inputDomain[1]-inputDomain[0]);var rangeShrunk=(ax.r2l(ax.range[1])-ax.r2l(ax.range[0]))/(ax.r2l(ax._inputRange[1])-ax.r2l(ax._inputRange[0]));factor/=domainShrunk;if(factor*rangeShrunk<1){// we've asked to magnify the axis more than we can just by\n// enlarging the domain - so we need to constrict range\nax.domain=ax._input.domain=inputDomain.slice();scaleZoom(ax,factor);continue;}if(rangeShrunk<1){// the range has previously been constricted by ^^, but we've\n// switched to the domain-constricted regime, so reset range\nax.range=ax._input.range=ax._inputRange.slice();factor*=rangeShrunk;}if(ax.autorange){/*\n                         * range & factor may need to change because range was\n                         * calculated for the larger scaling, so some pixel\n                         * paddings may get cut off when we reduce the domain.\n                         *\n                         * This is easier than the regular autorange calculation\n                         * because we already know the scaling `m`, but we still\n                         * need to cut out impossible constraints (like\n                         * annotations with super-long arrows). That's what\n                         * outerMin/Max are for - if the expansion was going to\n                         * go beyond the original domain, it must be impossible\n                         */var rl0=ax.r2l(ax.range[0]);var rl1=ax.r2l(ax.range[1]);var rangeCenter=(rl0+rl1)/2;var rangeMin=rangeCenter;var rangeMax=rangeCenter;var halfRange=Math.abs(rl1-rangeCenter);// extra tiny bit for rounding errors, in case we actually\n// *are* expanding to the full domain\nvar outerMin=rangeCenter-halfRange*factor*1.0001;var outerMax=rangeCenter+halfRange*factor*1.0001;var getPad=makePadFn(ax);updateDomain(ax,factor);var m=Math.abs(ax._m);var extremes=concatExtremes(gd,ax);var minArray=extremes.min;var maxArray=extremes.max;var newVal;var k;for(k=0;k<minArray.length;k++){newVal=minArray[k].val-getPad(minArray[k])/m;if(newVal>outerMin&&newVal<rangeMin){rangeMin=newVal;}}for(k=0;k<maxArray.length;k++){newVal=maxArray[k].val+getPad(maxArray[k])/m;if(newVal<outerMax&&newVal>rangeMax){rangeMax=newVal;}}var domainExpand=(rangeMax-rangeMin)/(2*halfRange);factor/=domainExpand;rangeMin=ax.l2r(rangeMin);rangeMax=ax.l2r(rangeMax);ax.range=ax._input.range=rl0<rl1?[rangeMin,rangeMax]:[rangeMax,rangeMin];}updateDomain(ax,factor);}}}}};// For use before autoranging, check if this axis was previously constrained\n// by domain but no longer is\nexports.clean=function clean(gd,ax){if(ax._inputDomain){var isConstrained=false;var axId=ax._id;var constraintGroups=gd._fullLayout._axisConstraintGroups;for(var j=0;j<constraintGroups.length;j++){if(constraintGroups[j][axId]){isConstrained=true;break;}}if(!isConstrained||ax.constrain!=='domain'){ax._input.domain=ax.domain=ax._inputDomain;delete ax._inputDomain;}}};function updateDomain(ax,factor){var inputDomain=ax._inputDomain;var centerFraction=FROM_BL[ax.constraintoward];var center=inputDomain[0]+(inputDomain[1]-inputDomain[0])*centerFraction;ax.domain=ax._input.domain=[center+(inputDomain[0]-center)/factor,center+(inputDomain[1]-center)/factor];ax.setScale();}},{\"../../constants/alignment\":138,\"../../constants/numerical\":140,\"../../lib\":159,\"./autorange\":202,\"./axis_ids\":206,\"./scale_zoom\":219}],211:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var tinycolor=_dereq_('tinycolor2');var supportsPassive=_dereq_('has-passive-events');var Registry=_dereq_('../../registry');var Lib=_dereq_('../../lib');var svgTextUtils=_dereq_('../../lib/svg_text_utils');var Color=_dereq_('../../components/color');var Drawing=_dereq_('../../components/drawing');var Fx=_dereq_('../../components/fx');var Axes=_dereq_('./axes');var setCursor=_dereq_('../../lib/setcursor');var dragElement=_dereq_('../../components/dragelement');var FROM_TL=_dereq_('../../constants/alignment').FROM_TL;var clearGlCanvases=_dereq_('../../lib/clear_gl_canvases');var redrawReglTraces=_dereq_('../../plot_api/subroutines').redrawReglTraces;var Plots=_dereq_('../plots');var getFromId=_dereq_('./axis_ids').getFromId;var prepSelect=_dereq_('./select').prepSelect;var clearSelect=_dereq_('./select').clearSelect;var selectOnClick=_dereq_('./select').selectOnClick;var scaleZoom=_dereq_('./scale_zoom');var constants=_dereq_('./constants');var MINDRAG=constants.MINDRAG;var MINZOOM=constants.MINZOOM;// flag for showing \"doubleclick to zoom out\" only at the beginning\nvar SHOWZOOMOUTTIP=true;// dragBox: create an element to drag one or more axis ends\n// inputs:\n//      plotinfo - which subplot are we making dragboxes on?\n//      x,y,w,h - left, top, width, height of the box\n//      ns - how does this drag the vertical axis?\n//          'n' - top only\n//          's' - bottom only\n//          'ns' - top and bottom together, difference unchanged\n//      ew - same for horizontal axis\nfunction makeDragBox(gd,plotinfo,x,y,w,h,ns,ew){// mouseDown stores ms of first mousedown event in the last\n// DBLCLICKDELAY ms on the drag bars\n// numClicks stores how many mousedowns have been seen\n// within DBLCLICKDELAY so we can check for click or doubleclick events\n// dragged stores whether a drag has occurred, so we don't have to\n// redraw unnecessarily, ie if no move bigger than MINDRAG or MINZOOM px\nvar zoomlayer=gd._fullLayout._zoomlayer;var isMainDrag=ns+ew==='nsew';var singleEnd=(ns+ew).length===1;// main subplot x and y (i.e. found in plotinfo - the main ones)\nvar xa0,ya0;// {ax._id: ax} hash objects\nvar xaHash,yaHash;// xaHash/yaHash values (arrays)\nvar xaxes,yaxes;// main axis offsets\nvar xs,ys;// main axis lengths\nvar pw,ph;// contains keys 'xaHash', 'yaHash', 'xaxes', and 'yaxes'\n// which are the x/y {ax._id: ax} hash objects and their values\n// for linked axis relative to this subplot\nvar links;// similar to `links` but for matching axes\nvar matches;// set to ew/ns val when active, set to '' when inactive\nvar xActive,yActive;// are all axes in this subplot are fixed?\nvar allFixedRanges;// do we need to edit x/y ranges?\nvar editX,editY;// graph-wide optimization flags\nvar hasScatterGl,hasSplom,hasSVG;// collected changes to be made to the plot by relayout at the end\nvar updates;function recomputeAxisLists(){xa0=plotinfo.xaxis;ya0=plotinfo.yaxis;pw=xa0._length;ph=ya0._length;xs=xa0._offset;ys=ya0._offset;xaHash={};xaHash[xa0._id]=xa0;yaHash={};yaHash[ya0._id]=ya0;// if we're dragging two axes at once, also drag overlays\nif(ns&&ew){var overlays=plotinfo.overlays;for(var i=0;i<overlays.length;i++){var xa=overlays[i].xaxis;xaHash[xa._id]=xa;var ya=overlays[i].yaxis;yaHash[ya._id]=ya;}}xaxes=hashValues(xaHash);yaxes=hashValues(yaHash);xActive=isDirectionActive(xaxes,ew);yActive=isDirectionActive(yaxes,ns);allFixedRanges=!yActive&&!xActive;links=calcLinks(gd,gd._fullLayout._axisConstraintGroups,xaHash,yaHash);matches=calcLinks(gd,gd._fullLayout._axisMatchGroups,xaHash,yaHash);editX=ew||links.isSubplotConstrained||matches.isSubplotConstrained;editY=ns||links.isSubplotConstrained||matches.isSubplotConstrained;var fullLayout=gd._fullLayout;hasScatterGl=fullLayout._has('scattergl');hasSplom=fullLayout._has('splom');hasSVG=fullLayout._has('svg');}recomputeAxisLists();var cursor=getDragCursor(yActive+xActive,gd._fullLayout.dragmode,isMainDrag);var dragger=makeRectDragger(plotinfo,ns+ew+'drag',cursor,x,y,w,h);// still need to make the element if the axes are disabled\n// but nuke its events (except for maindrag which needs them for hover)\n// and stop there\nif(allFixedRanges&&!isMainDrag){dragger.onmousedown=null;dragger.style.pointerEvents='none';return dragger;}var dragOptions={element:dragger,gd:gd,plotinfo:plotinfo};dragOptions.prepFn=function(e,startX,startY){var dragModePrev=dragOptions.dragmode;var dragModeNow=gd._fullLayout.dragmode;if(dragModeNow!==dragModePrev){dragOptions.dragmode=dragModeNow;}recomputeAxisLists();if(!allFixedRanges){if(isMainDrag){// main dragger handles all drag modes, and changes\n// to pan (or to zoom if it already is pan) on shift\nif(e.shiftKey){if(dragModeNow==='pan')dragModeNow='zoom';else if(!isSelectOrLasso(dragModeNow))dragModeNow='pan';}else if(e.ctrlKey){dragModeNow='pan';}}else{// all other draggers just pan\ndragModeNow='pan';}}if(dragModeNow==='lasso')dragOptions.minDrag=1;else dragOptions.minDrag=undefined;if(isSelectOrLasso(dragModeNow)){dragOptions.xaxes=xaxes;dragOptions.yaxes=yaxes;// this attaches moveFn, clickFn, doneFn on dragOptions\nprepSelect(e,startX,startY,dragOptions,dragModeNow);}else{dragOptions.clickFn=clickFn;if(isSelectOrLasso(dragModePrev)){// TODO Fix potential bug\n// Note: clearing / resetting selection state only happens, when user\n// triggers at least one interaction in pan/zoom mode. Otherwise, the\n// select/lasso outlines are deleted (in plots.js.cleanPlot) but the selection\n// cache isn't cleared. So when the user switches back to select/lasso and\n// 'adds to a selection' with Shift, the \"old\", seemingly removed outlines\n// are redrawn again because the selection cache still holds their coordinates.\n// However, this isn't easily solved, since plots.js would need\n// to have a reference to the dragOptions object (which holds the\n// selection cache).\nclearAndResetSelect();}if(!allFixedRanges){if(dragModeNow==='zoom'){dragOptions.moveFn=zoomMove;dragOptions.doneFn=zoomDone;// zoomMove takes care of the threshold, but we need to\n// minimize this so that constrained zoom boxes will flip\n// orientation at the right place\ndragOptions.minDrag=1;zoomPrep(e,startX,startY);}else if(dragModeNow==='pan'){dragOptions.moveFn=plotDrag;dragOptions.doneFn=dragTail;}}}gd._fullLayout._redrag=function(){var dragDataNow=gd._dragdata;if(dragDataNow&&dragDataNow.element===dragger){var dragModeNow=gd._fullLayout.dragmode;if(!isSelectOrLasso(dragModeNow)){recomputeAxisLists();updateSubplots([0,0,pw,ph]);dragOptions.moveFn(dragDataNow.dx,dragDataNow.dy);}// TODO should we try to \"re-select\" under select/lasso modes?\n// probably best to wait for https://github.com/plotly/plotly.js/issues/1851\n}};};function clearAndResetSelect(){// clear selection polygon cache (if any)\ndragOptions.plotinfo.selection=false;// clear selection outlines\nclearSelect(gd);}function clickFn(numClicks,evt){var clickmode=gd._fullLayout.clickmode;removeZoombox(gd);if(numClicks===2&&!singleEnd)doubleClick();if(isMainDrag){if(clickmode.indexOf('select')>-1){selectOnClick(evt,gd,xaxes,yaxes,plotinfo.id,dragOptions);}if(clickmode.indexOf('event')>-1){Fx.click(gd,evt,plotinfo.id);}}else if(numClicks===1&&singleEnd){var ax=ns?ya0:xa0;var end=ns==='s'||ew==='w'?0:1;var attrStr=ax._name+'.range['+end+']';var initialText=getEndText(ax,end);var hAlign='left';var vAlign='middle';if(ax.fixedrange)return;if(ns){vAlign=ns==='n'?'top':'bottom';if(ax.side==='right')hAlign='right';}else if(ew==='e')hAlign='right';if(gd._context.showAxisRangeEntryBoxes){d3.select(dragger).call(svgTextUtils.makeEditable,{gd:gd,immediate:true,background:gd._fullLayout.paper_bgcolor,text:String(initialText),fill:ax.tickfont?ax.tickfont.color:'#444',horizontalAlign:hAlign,verticalAlign:vAlign}).on('edit',function(text){var v=ax.d2r(text);if(v!==undefined){Registry.call('_guiRelayout',gd,attrStr,v);}});}}}dragElement.init(dragOptions);// x/y px position at start of drag\nvar x0,y0;// bbox object of the zoombox\nvar box;// luminance of bg behind zoombox\nvar lum;// zoombox path outline\nvar path0;// is zoombox dimmed (during drag)\nvar dimmed;// 'x'-only, 'y' or 'xy' zooming\nvar zoomMode;// zoombox d3 selection\nvar zb;// zoombox corner d3 selection\nvar corners;// zoom takes over minDrag, so it also has to take over gd._dragged\nvar zoomDragged;function zoomPrep(e,startX,startY){var dragBBox=dragger.getBoundingClientRect();x0=startX-dragBBox.left;y0=startY-dragBBox.top;box={l:x0,r:x0,w:0,t:y0,b:y0,h:0};lum=gd._hmpixcount?gd._hmlumcount/gd._hmpixcount:tinycolor(gd._fullLayout.plot_bgcolor).getLuminance();path0='M0,0H'+pw+'V'+ph+'H0V0';dimmed=false;zoomMode='xy';zoomDragged=false;zb=makeZoombox(zoomlayer,lum,xs,ys,path0);corners=makeCorners(zoomlayer,xs,ys);}function zoomMove(dx0,dy0){if(gd._transitioningWithDuration){return false;}var x1=Math.max(0,Math.min(pw,dx0+x0));var y1=Math.max(0,Math.min(ph,dy0+y0));var dx=Math.abs(x1-x0);var dy=Math.abs(y1-y0);box.l=Math.min(x0,x1);box.r=Math.max(x0,x1);box.t=Math.min(y0,y1);box.b=Math.max(y0,y1);function noZoom(){zoomMode='';box.r=box.l;box.t=box.b;corners.attr('d','M0,0Z');}if(links.isSubplotConstrained){if(dx>MINZOOM||dy>MINZOOM){zoomMode='xy';if(dx/pw>dy/ph){dy=dx*ph/pw;if(y0>y1)box.t=y0-dy;else box.b=y0+dy;}else{dx=dy*pw/ph;if(x0>x1)box.l=x0-dx;else box.r=x0+dx;}corners.attr('d',xyCorners(box));}else{noZoom();}}else if(matches.isSubplotConstrained){if(dx>MINZOOM||dy>MINZOOM){zoomMode='xy';var r0=Math.min(box.l/pw,(ph-box.b)/ph);var r1=Math.max(box.r/pw,(ph-box.t)/ph);box.l=r0*pw;box.r=r1*pw;box.b=(1-r0)*ph;box.t=(1-r1)*ph;corners.attr('d',xyCorners(box));}else{noZoom();}}else if(!yActive||dy<Math.min(Math.max(dx*0.6,MINDRAG),MINZOOM)){// look for small drags in one direction or the other,\n// and only drag the other axis\nif(dx<MINDRAG||!xActive){noZoom();}else{box.t=0;box.b=ph;zoomMode='x';corners.attr('d',xCorners(box,y0));}}else if(!xActive||dx<Math.min(dy*0.6,MINZOOM)){box.l=0;box.r=pw;zoomMode='y';corners.attr('d',yCorners(box,x0));}else{zoomMode='xy';corners.attr('d',xyCorners(box));}box.w=box.r-box.l;box.h=box.b-box.t;if(zoomMode)zoomDragged=true;gd._dragged=zoomDragged;updateZoombox(zb,corners,box,path0,dimmed,lum);dimmed=true;}function zoomDone(){updates={};// more strict than dragged, which allows you to come back to where you started\n// and still count as dragged\nif(Math.min(box.h,box.w)<MINDRAG*2){return removeZoombox(gd);}// TODO: edit linked axes in zoomAxRanges and in dragTail\nif(zoomMode==='xy'||zoomMode==='x'){zoomAxRanges(xaxes,box.l/pw,box.r/pw,updates,links.xaxes);updateMatchedAxRange('x',updates);}if(zoomMode==='xy'||zoomMode==='y'){zoomAxRanges(yaxes,(ph-box.b)/ph,(ph-box.t)/ph,updates,links.yaxes);updateMatchedAxRange('y',updates);}removeZoombox(gd);dragTail();showDoubleClickNotifier(gd);}// scroll zoom, on all draggers except corners\nvar scrollViewBox=[0,0,pw,ph];// wait a little after scrolling before redrawing\nvar redrawTimer=null;var REDRAWDELAY=constants.REDRAWDELAY;var mainplot=plotinfo.mainplot?gd._fullLayout._plots[plotinfo.mainplot]:plotinfo;function zoomWheel(e){// deactivate mousewheel scrolling on embedded graphs\n// devs can override this with layout._enablescrollzoom,\n// but _ ensures this setting won't leave their page\nif(!gd._context._scrollZoom.cartesian&&!gd._fullLayout._enablescrollzoom){return;}clearAndResetSelect();// If a transition is in progress, then disable any behavior:\nif(gd._transitioningWithDuration){e.preventDefault();e.stopPropagation();return;}recomputeAxisLists();clearTimeout(redrawTimer);var wheelDelta=-e.deltaY;if(!isFinite(wheelDelta))wheelDelta=e.wheelDelta/10;if(!isFinite(wheelDelta)){Lib.log('Did not find wheel motion attributes: ',e);return;}var zoom=Math.exp(-Math.min(Math.max(wheelDelta,-20),20)/200);var gbb=mainplot.draglayer.select('.nsewdrag').node().getBoundingClientRect();var xfrac=(e.clientX-gbb.left)/gbb.width;var yfrac=(gbb.bottom-e.clientY)/gbb.height;var i;function zoomWheelOneAxis(ax,centerFraction,zoom){if(ax.fixedrange)return;var axRange=Lib.simpleMap(ax.range,ax.r2l);var v0=axRange[0]+(axRange[1]-axRange[0])*centerFraction;function doZoom(v){return ax.l2r(v0+(v-v0)*zoom);}ax.range=axRange.map(doZoom);}if(editX){// if we're only zooming this axis because of constraints,\n// zoom it about the center\nif(!ew)xfrac=0.5;for(i=0;i<xaxes.length;i++){zoomWheelOneAxis(xaxes[i],xfrac,zoom);}updateMatchedAxRange('x');scrollViewBox[2]*=zoom;scrollViewBox[0]+=scrollViewBox[2]*xfrac*(1/zoom-1);}if(editY){if(!ns)yfrac=0.5;for(i=0;i<yaxes.length;i++){zoomWheelOneAxis(yaxes[i],yfrac,zoom);}updateMatchedAxRange('y');scrollViewBox[3]*=zoom;scrollViewBox[1]+=scrollViewBox[3]*(1-yfrac)*(1/zoom-1);}// viewbox redraw at first\nupdateSubplots(scrollViewBox);ticksAndAnnotations();// then replot after a delay to make sure\n// no more scrolling is coming\nredrawTimer=setTimeout(function(){scrollViewBox=[0,0,pw,ph];dragTail();},REDRAWDELAY);e.preventDefault();return;}// everything but the corners gets wheel zoom\nif(ns.length*ew.length!==1){attachWheelEventHandler(dragger,zoomWheel);}// plotDrag: move the plot in response to a drag\nfunction plotDrag(dx,dy){// If a transition is in progress, then disable any behavior:\nif(gd._transitioningWithDuration){return;}// prevent axis drawing from monkeying with margins until we're done\ngd._fullLayout._replotting=true;if(xActive==='ew'||yActive==='ns'){if(xActive){dragAxList(xaxes,dx);updateMatchedAxRange('x');}if(yActive){dragAxList(yaxes,dy);updateMatchedAxRange('y');}updateSubplots([xActive?-dx:0,yActive?-dy:0,pw,ph]);ticksAndAnnotations();return;}// dz: set a new value for one end (0 or 1) of an axis array axArray,\n// and return a pixel shift for that end for the viewbox\n// based on pixel drag distance d\n// TODO: this makes (generally non-fatal) errors when you get\n// near floating point limits\nfunction dz(axArray,end,d){var otherEnd=1-end;var movedAx;var newLinearizedEnd;for(var i=0;i<axArray.length;i++){var axi=axArray[i];if(axi.fixedrange)continue;movedAx=axi;newLinearizedEnd=axi._rl[otherEnd]+(axi._rl[end]-axi._rl[otherEnd])/dZoom(d/axi._length);var newEnd=axi.l2r(newLinearizedEnd);// if l2r comes back false or undefined, it means we've dragged off\n// the end of valid ranges - so stop.\nif(newEnd!==false&&newEnd!==undefined)axi.range[end]=newEnd;}return movedAx._length*(movedAx._rl[end]-newLinearizedEnd)/(movedAx._rl[end]-movedAx._rl[otherEnd]);}if(links.isSubplotConstrained&&xActive&&yActive){// dragging a corner of a constrained subplot:\n// respect the fixed corner, but harmonize dx and dy\nvar dxySign=xActive==='w'===(yActive==='n')?1:-1;var dxyFraction=(dx/pw+dxySign*dy/ph)/2;dx=dxyFraction*pw;dy=dxySign*dxyFraction*ph;}if(xActive==='w')dx=dz(xaxes,0,dx);else if(xActive==='e')dx=dz(xaxes,1,-dx);else if(!xActive)dx=0;if(yActive==='n')dy=dz(yaxes,1,dy);else if(yActive==='s')dy=dz(yaxes,0,-dy);else if(!yActive)dy=0;var xStart=xActive==='w'?dx:0;var yStart=yActive==='n'?dy:0;if(links.isSubplotConstrained){var i;if(!xActive&&yActive.length===1){// dragging one end of the y axis of a constrained subplot\n// scale the other axis the same about its middle\nfor(i=0;i<xaxes.length;i++){xaxes[i].range=xaxes[i]._r.slice();scaleZoom(xaxes[i],1-dy/ph);}dx=dy*pw/ph;xStart=dx/2;}if(!yActive&&xActive.length===1){for(i=0;i<yaxes.length;i++){yaxes[i].range=yaxes[i]._r.slice();scaleZoom(yaxes[i],1-dx/pw);}dy=dx*ph/pw;yStart=dy/2;}}updateMatchedAxRange('x');updateMatchedAxRange('y');updateSubplots([xStart,yStart,pw-dx,ph-dy]);ticksAndAnnotations();}function updateMatchedAxRange(axLetter,out){var matchedAxes=matches.isSubplotConstrained?{x:yaxes,y:xaxes}[axLetter]:matches[axLetter+'axes'];var constrainedAxes=matches.isSubplotConstrained?{x:xaxes,y:yaxes}[axLetter]:[];for(var i=0;i<matchedAxes.length;i++){var ax=matchedAxes[i];var axId=ax._id;var axId2=matches.xLinks[axId]||matches.yLinks[axId];var ax2=constrainedAxes[0]||xaHash[axId2]||yaHash[axId2];if(ax2){var rng=ax2.range;if(out){out[ax._name+'.range[0]']=rng[0];out[ax._name+'.range[1]']=rng[1];}else{ax.range=rng;}}}}// Draw ticks and annotations (and other components) when ranges change.\n// Also records the ranges that have changed for use by update at the end.\nfunction ticksAndAnnotations(){var activeAxIds=[];var i;function pushActiveAxIds(axList){for(i=0;i<axList.length;i++){if(!axList[i].fixedrange)activeAxIds.push(axList[i]._id);}}if(editX){pushActiveAxIds(xaxes);pushActiveAxIds(links.xaxes);pushActiveAxIds(matches.xaxes);}if(editY){pushActiveAxIds(yaxes);pushActiveAxIds(links.yaxes);pushActiveAxIds(matches.yaxes);}updates={};for(i=0;i<activeAxIds.length;i++){var axId=activeAxIds[i];var ax=getFromId(gd,axId);Axes.drawOne(gd,ax,{skipTitle:true});updates[ax._name+'.range[0]']=ax.range[0];updates[ax._name+'.range[1]']=ax.range[1];}Axes.redrawComponents(gd,activeAxIds);}function doubleClick(){if(gd._transitioningWithDuration)return;var doubleClickConfig=gd._context.doubleClick;var axList=[];if(xActive)axList=axList.concat(xaxes);if(yActive)axList=axList.concat(yaxes);if(matches.xaxes)axList=axList.concat(matches.xaxes);if(matches.yaxes)axList=axList.concat(matches.yaxes);var attrs={};var ax,i,rangeInitial;// For reset+autosize mode:\n// If *any* of the main axes is not at its initial range\n// (or autoranged, if we have no initial range, to match the logic in\n// doubleClickConfig === 'reset' below), we reset.\n// If they are *all* at their initial ranges, then we autosize.\nif(doubleClickConfig==='reset+autosize'){doubleClickConfig='autosize';for(i=0;i<axList.length;i++){ax=axList[i];if(ax._rangeInitial&&(ax.range[0]!==ax._rangeInitial[0]||ax.range[1]!==ax._rangeInitial[1])||!ax._rangeInitial&&!ax.autorange){doubleClickConfig='reset';break;}}}if(doubleClickConfig==='autosize'){// don't set the linked axes here, so relayout marks them as shrinkable\n// and we autosize just to the requested axis/axes\nfor(i=0;i<axList.length;i++){ax=axList[i];if(!ax.fixedrange)attrs[ax._name+'.autorange']=true;}}else if(doubleClickConfig==='reset'){// when we're resetting, reset all linked axes too, so we get back\n// to the fully-auto-with-constraints situation\nif(xActive||links.isSubplotConstrained)axList=axList.concat(links.xaxes);if(yActive&&!links.isSubplotConstrained)axList=axList.concat(links.yaxes);if(links.isSubplotConstrained){if(!xActive)axList=axList.concat(xaxes);else if(!yActive)axList=axList.concat(yaxes);}for(i=0;i<axList.length;i++){ax=axList[i];if(!ax.fixedrange){if(!ax._rangeInitial){attrs[ax._name+'.autorange']=true;}else{rangeInitial=ax._rangeInitial;attrs[ax._name+'.range[0]']=rangeInitial[0];attrs[ax._name+'.range[1]']=rangeInitial[1];}}}}gd.emit('plotly_doubleclick',null);Registry.call('_guiRelayout',gd,attrs);}// dragTail - finish a drag event with a redraw\nfunction dragTail(){// put the subplot viewboxes back to default (Because we're going to)\n// be repositioning the data in the relayout. But DON'T call\n// ticksAndAnnotations again - it's unnecessary and would overwrite `updates`\nupdateSubplots([0,0,pw,ph]);// since we may have been redrawing some things during the drag, we may have\n// accumulated MathJax promises - wait for them before we relayout.\nLib.syncOrAsync([Plots.previousPromises,function(){gd._fullLayout._replotting=false;Registry.call('_guiRelayout',gd,updates);}],gd);}// updateSubplots - find all plot viewboxes that should be\n// affected by this drag, and update them. look for all plots\n// sharing an affected axis (including the one being dragged),\n// includes also scattergl and splom logic.\nfunction updateSubplots(viewBox){var fullLayout=gd._fullLayout;var plotinfos=fullLayout._plots;var subplots=fullLayout._subplots.cartesian;var i,sp,xa,ya;if(hasSplom){Registry.subplotsRegistry.splom.drag(gd);}if(hasScatterGl){for(i=0;i<subplots.length;i++){sp=plotinfos[subplots[i]];xa=sp.xaxis;ya=sp.yaxis;if(sp._scene){var xrng=Lib.simpleMap(xa.range,xa.r2l);var yrng=Lib.simpleMap(ya.range,ya.r2l);sp._scene.update({range:[xrng[0],yrng[0],xrng[1],yrng[1]]});}}}if(hasSplom||hasScatterGl){clearGlCanvases(gd);redrawReglTraces(gd);}if(hasSVG){var xScaleFactor=viewBox[2]/xa0._length;var yScaleFactor=viewBox[3]/ya0._length;for(i=0;i<subplots.length;i++){sp=plotinfos[subplots[i]];xa=sp.xaxis;ya=sp.yaxis;var editX2=editX&&!xa.fixedrange&&xaHash[xa._id];var editY2=editY&&!ya.fixedrange&&yaHash[ya._id];var xScaleFactor2,yScaleFactor2;var clipDx,clipDy;if(editX2){xScaleFactor2=xScaleFactor;clipDx=ew?viewBox[0]:getShift(xa,xScaleFactor2);}else if(matches.xaHash[xa._id]){xScaleFactor2=xScaleFactor;clipDx=viewBox[0]*xa._length/xa0._length;}else if(matches.yaHash[xa._id]){xScaleFactor2=yScaleFactor;clipDx=yActive==='ns'?-viewBox[1]*xa._length/ya0._length:getShift(xa,xScaleFactor2,{n:'top',s:'bottom'}[yActive]);}else{xScaleFactor2=getLinkedScaleFactor(xa,xScaleFactor,yScaleFactor);clipDx=scaleAndGetShift(xa,xScaleFactor2);}if(editY2){yScaleFactor2=yScaleFactor;clipDy=ns?viewBox[1]:getShift(ya,yScaleFactor2);}else if(matches.yaHash[ya._id]){yScaleFactor2=yScaleFactor;clipDy=viewBox[1]*ya._length/ya0._length;}else if(matches.xaHash[ya._id]){yScaleFactor2=xScaleFactor;clipDy=xActive==='ew'?-viewBox[0]*ya._length/xa0._length:getShift(ya,yScaleFactor2,{e:'right',w:'left'}[xActive]);}else{yScaleFactor2=getLinkedScaleFactor(ya,xScaleFactor,yScaleFactor);clipDy=scaleAndGetShift(ya,yScaleFactor2);}// don't scale at all if neither axis is scalable here\nif(!xScaleFactor2&&!yScaleFactor2){continue;}// but if only one is, reset the other axis scaling\nif(!xScaleFactor2)xScaleFactor2=1;if(!yScaleFactor2)yScaleFactor2=1;var plotDx=xa._offset-clipDx/xScaleFactor2;var plotDy=ya._offset-clipDy/yScaleFactor2;// TODO could be more efficient here:\n// setTranslate and setScale do a lot of extra work\n// when working independently, should perhaps combine\n// them into a single routine.\nsp.clipRect.call(Drawing.setTranslate,clipDx,clipDy).call(Drawing.setScale,xScaleFactor2,yScaleFactor2);sp.plot.call(Drawing.setTranslate,plotDx,plotDy).call(Drawing.setScale,1/xScaleFactor2,1/yScaleFactor2);// apply an inverse scale to individual points to counteract\n// the scale of the trace group.\n// apply only when scale changes, as adjusting the scale of\n// all the points can be expansive.\nif(xScaleFactor2!==sp.xScaleFactor||yScaleFactor2!==sp.yScaleFactor){Drawing.setPointGroupScale(sp.zoomScalePts,xScaleFactor2,yScaleFactor2);Drawing.setTextPointsScale(sp.zoomScaleTxt,xScaleFactor2,yScaleFactor2);}Drawing.hideOutsideRangePoints(sp.clipOnAxisFalseTraces,sp);// update x/y scaleFactor stash\nsp.xScaleFactor=xScaleFactor2;sp.yScaleFactor=yScaleFactor2;}}}// Find the appropriate scaling for this axis, if it's linked to the\n// dragged axes by constraints. 0 is special, it means this axis shouldn't\n// ever be scaled (will be converted to 1 if the other axis is scaled)\nfunction getLinkedScaleFactor(ax,xScaleFactor,yScaleFactor){if(ax.fixedrange)return 0;if(editX&&links.xaHash[ax._id]){return xScaleFactor;}if(editY&&(links.isSubplotConstrained?links.xaHash:links.yaHash)[ax._id]){return yScaleFactor;}return 0;}function scaleAndGetShift(ax,scaleFactor){if(scaleFactor){ax.range=ax._r.slice();scaleZoom(ax,scaleFactor);return getShift(ax,scaleFactor);}return 0;}function getShift(ax,scaleFactor,from){return ax._length*(1-scaleFactor)*FROM_TL[from||ax.constraintoward||'middle'];}return dragger;}function makeDragger(plotinfo,nodeName,dragClass,cursor){var dragger3=Lib.ensureSingle(plotinfo.draglayer,nodeName,dragClass,function(s){s.classed('drag',true).style({fill:'transparent','stroke-width':0}).attr('data-subplot',plotinfo.id);});dragger3.call(setCursor,cursor);return dragger3.node();}function makeRectDragger(plotinfo,dragClass,cursor,x,y,w,h){var dragger=makeDragger(plotinfo,'rect',dragClass,cursor);d3.select(dragger).call(Drawing.setRect,x,y,w,h);return dragger;}function isDirectionActive(axList,activeVal){for(var i=0;i<axList.length;i++){if(!axList[i].fixedrange)return activeVal;}return'';}function getEndText(ax,end){var initialVal=ax.range[end];var diff=Math.abs(initialVal-ax.range[1-end]);var dig;// TODO: this should basically be ax.r2d but we're doing extra\n// rounding here... can we clean up at all?\nif(ax.type==='date'){return initialVal;}else if(ax.type==='log'){dig=Math.ceil(Math.max(0,-Math.log(diff)/Math.LN10))+3;return d3.format('.'+dig+'g')(Math.pow(10,initialVal));}else{// linear numeric (or category... but just show numbers here)\ndig=Math.floor(Math.log(Math.abs(initialVal))/Math.LN10)-Math.floor(Math.log(diff)/Math.LN10)+4;return d3.format('.'+String(dig)+'g')(initialVal);}}function zoomAxRanges(axList,r0Fraction,r1Fraction,updates,linkedAxes){for(var i=0;i<axList.length;i++){var axi=axList[i];if(axi.fixedrange)continue;var axRangeLinear0=axi._rl[0];var axRangeLinearSpan=axi._rl[1]-axRangeLinear0;axi.range=[axi.l2r(axRangeLinear0+axRangeLinearSpan*r0Fraction),axi.l2r(axRangeLinear0+axRangeLinearSpan*r1Fraction)];updates[axi._name+'.range[0]']=axi.range[0];updates[axi._name+'.range[1]']=axi.range[1];}// zoom linked axes about their centers\nif(linkedAxes&&linkedAxes.length){var linkedR0Fraction=(r0Fraction+(1-r1Fraction))/2;zoomAxRanges(linkedAxes,linkedR0Fraction,1-linkedR0Fraction,updates,[],[]);}}function dragAxList(axList,pix){for(var i=0;i<axList.length;i++){var axi=axList[i];if(!axi.fixedrange){axi.range=[axi.l2r(axi._rl[0]-pix/axi._m),axi.l2r(axi._rl[1]-pix/axi._m)];}}}// common transform for dragging one end of an axis\n// d>0 is compressing scale (cursor is over the plot,\n//  the axis end should move with the cursor)\n// d<0 is expanding (cursor is off the plot, axis end moves\n//  nonlinearly so you can expand far)\nfunction dZoom(d){return 1-(d>=0?Math.min(d,0.9):1/(1/Math.max(d,-0.3)+3.222));}function getDragCursor(nsew,dragmode,isMainDrag){if(!nsew)return'pointer';if(nsew==='nsew'){// in this case here, clear cursor and\n// use the cursor style set on <g .draglayer>\nif(isMainDrag)return'';if(dragmode==='pan')return'move';return'crosshair';}return nsew.toLowerCase()+'-resize';}function makeZoombox(zoomlayer,lum,xs,ys,path0){return zoomlayer.append('path').attr('class','zoombox').style({'fill':lum>0.2?'rgba(0,0,0,0)':'rgba(255,255,255,0)','stroke-width':0}).attr('transform','translate('+xs+', '+ys+')').attr('d',path0+'Z');}function makeCorners(zoomlayer,xs,ys){return zoomlayer.append('path').attr('class','zoombox-corners').style({fill:Color.background,stroke:Color.defaultLine,'stroke-width':1,opacity:0}).attr('transform','translate('+xs+', '+ys+')').attr('d','M0,0Z');}function updateZoombox(zb,corners,box,path0,dimmed,lum){zb.attr('d',path0+'M'+box.l+','+box.t+'v'+box.h+'h'+box.w+'v-'+box.h+'h-'+box.w+'Z');transitionZoombox(zb,corners,dimmed,lum);}function transitionZoombox(zb,corners,dimmed,lum){if(!dimmed){zb.transition().style('fill',lum>0.2?'rgba(0,0,0,0.4)':'rgba(255,255,255,0.3)').duration(200);corners.transition().style('opacity',1).duration(200);}}function removeZoombox(gd){d3.select(gd).selectAll('.zoombox,.js-zoombox-backdrop,.js-zoombox-menu,.zoombox-corners').remove();}function showDoubleClickNotifier(gd){if(SHOWZOOMOUTTIP&&gd.data&&gd._context.showTips){Lib.notifier(Lib._(gd,'Double-click to zoom back out'),'long');SHOWZOOMOUTTIP=false;}}function isSelectOrLasso(dragmode){return dragmode==='lasso'||dragmode==='select';}function xCorners(box,y0){return'M'+(box.l-0.5)+','+(y0-MINZOOM-0.5)+'h-3v'+(2*MINZOOM+1)+'h3ZM'+(box.r+0.5)+','+(y0-MINZOOM-0.5)+'h3v'+(2*MINZOOM+1)+'h-3Z';}function yCorners(box,x0){return'M'+(x0-MINZOOM-0.5)+','+(box.t-0.5)+'v-3h'+(2*MINZOOM+1)+'v3ZM'+(x0-MINZOOM-0.5)+','+(box.b+0.5)+'v3h'+(2*MINZOOM+1)+'v-3Z';}function xyCorners(box){var clen=Math.floor(Math.min(box.b-box.t,box.r-box.l,MINZOOM)/2);return'M'+(box.l-3.5)+','+(box.t-0.5+clen)+'h3v'+-clen+'h'+clen+'v-3h-'+(clen+3)+'ZM'+(box.r+3.5)+','+(box.t-0.5+clen)+'h-3v'+-clen+'h'+-clen+'v-3h'+(clen+3)+'ZM'+(box.r+3.5)+','+(box.b+0.5-clen)+'h-3v'+clen+'h'+-clen+'v3h'+(clen+3)+'ZM'+(box.l-3.5)+','+(box.b+0.5-clen)+'h3v'+clen+'h'+clen+'v3h-'+(clen+3)+'Z';}function calcLinks(gd,groups,xaHash,yaHash){var isSubplotConstrained=false;var xLinks={};var yLinks={};var xID,yID,xLinkID,yLinkID;for(var i=0;i<groups.length;i++){var group=groups[i];// check if any of the x axes we're dragging is in this constraint group\nfor(xID in xaHash){if(group[xID]){// put the rest of these axes into xLinks, if we're not already\n// dragging them, so we know to scale these axes automatically too\n// to match the changes in the dragged x axes\nfor(xLinkID in group){if(!(xLinkID.charAt(0)==='x'?xaHash:yaHash)[xLinkID]){xLinks[xLinkID]=xID;}}// check if the x and y axes of THIS drag are linked\nfor(yID in yaHash){if(group[yID])isSubplotConstrained=true;}}}// now check if any of the y axes we're dragging is in this constraint group\n// only look for outside links, as we've already checked for links within the dragger\nfor(yID in yaHash){if(group[yID]){for(yLinkID in group){if(!(yLinkID.charAt(0)==='x'?xaHash:yaHash)[yLinkID]){yLinks[yLinkID]=yID;}}}}}if(isSubplotConstrained){// merge xLinks and yLinks if the subplot is constrained,\n// since we'll always apply both anyway and the two will contain\n// duplicates\nLib.extendFlat(xLinks,yLinks);yLinks={};}var xaHashLinked={};var xaxesLinked=[];for(xLinkID in xLinks){var xa=getFromId(gd,xLinkID);xaxesLinked.push(xa);xaHashLinked[xa._id]=xa;}var yaHashLinked={};var yaxesLinked=[];for(yLinkID in yLinks){var ya=getFromId(gd,yLinkID);yaxesLinked.push(ya);yaHashLinked[ya._id]=ya;}return{xaHash:xaHashLinked,yaHash:yaHashLinked,xaxes:xaxesLinked,yaxes:yaxesLinked,xLinks:xLinks,yLinks:yLinks,isSubplotConstrained:isSubplotConstrained};}// still seems to be some confusion about onwheel vs onmousewheel...\nfunction attachWheelEventHandler(element,handler){if(!supportsPassive){if(element.onwheel!==undefined)element.onwheel=handler;else if(element.onmousewheel!==undefined)element.onmousewheel=handler;}else{var wheelEventName=element.onwheel!==undefined?'wheel':'mousewheel';if(element._onwheel){element.removeEventListener(wheelEventName,element._onwheel);}element._onwheel=handler;element.addEventListener(wheelEventName,handler,{passive:false});}}function hashValues(hash){var out=[];for(var k in hash){out.push(hash[k]);}return out;}module.exports={makeDragBox:makeDragBox,makeDragger:makeDragger,makeRectDragger:makeRectDragger,makeZoombox:makeZoombox,makeCorners:makeCorners,updateZoombox:updateZoombox,xyCorners:xyCorners,transitionZoombox:transitionZoombox,removeZoombox:removeZoombox,showDoubleClickNotifier:showDoubleClickNotifier,attachWheelEventHandler:attachWheelEventHandler};},{\"../../components/color\":43,\"../../components/dragelement\":61,\"../../components/drawing\":64,\"../../components/fx\":82,\"../../constants/alignment\":138,\"../../lib\":159,\"../../lib/clear_gl_canvases\":148,\"../../lib/setcursor\":178,\"../../lib/svg_text_utils\":180,\"../../plot_api/subroutines\":194,\"../../registry\":242,\"../plots\":235,\"./axes\":203,\"./axis_ids\":206,\"./constants\":209,\"./scale_zoom\":219,\"./select\":220,\"d3\":8,\"has-passive-events\":13,\"tinycolor2\":26}],212:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var Fx=_dereq_('../../components/fx');var dragElement=_dereq_('../../components/dragelement');var setCursor=_dereq_('../../lib/setcursor');var makeDragBox=_dereq_('./dragbox').makeDragBox;var DRAGGERSIZE=_dereq_('./constants').DRAGGERSIZE;exports.initInteractions=function initInteractions(gd){var fullLayout=gd._fullLayout;if(gd._context.staticPlot){// this sweeps up more than just cartesian drag elements...\nd3.select(gd).selectAll('.drag').remove();return;}if(!fullLayout._has('cartesian')&&!fullLayout._has('splom'))return;var subplots=Object.keys(fullLayout._plots||{}).sort(function(a,b){// sort overlays last, then by x axis number, then y axis number\nif((fullLayout._plots[a].mainplot&&true)===(fullLayout._plots[b].mainplot&&true)){var aParts=a.split('y');var bParts=b.split('y');return aParts[0]===bParts[0]?Number(aParts[1]||1)-Number(bParts[1]||1):Number(aParts[0]||1)-Number(bParts[0]||1);}return fullLayout._plots[a].mainplot?1:-1;});subplots.forEach(function(subplot){var plotinfo=fullLayout._plots[subplot];var xa=plotinfo.xaxis;var ya=plotinfo.yaxis;// main and corner draggers need not be repeated for\n// overlaid subplots - these draggers drag them all\nif(!plotinfo.mainplot){// main dragger goes over the grids and data, so we use its\n// mousemove events for all data hover effects\nvar maindrag=makeDragBox(gd,plotinfo,xa._offset,ya._offset,xa._length,ya._length,'ns','ew');maindrag.onmousemove=function(evt){// This is on `gd._fullLayout`, *not* fullLayout because the reference\n// changes by the time this is called again.\ngd._fullLayout._rehover=function(){if(gd._fullLayout._hoversubplot===subplot){Fx.hover(gd,evt,subplot);}};Fx.hover(gd,evt,subplot);// Note that we have *not* used the cached fullLayout variable here\n// since that may be outdated when this is called as a callback later on\ngd._fullLayout._lasthover=maindrag;gd._fullLayout._hoversubplot=subplot;};/*\n             * IMPORTANT:\n             * We must check for the presence of the drag cover here.\n             * If we don't, a 'mouseout' event is triggered on the\n             * maindrag before each 'click' event, which has the effect\n             * of clearing the hoverdata; thus, cancelling the click event.\n             */maindrag.onmouseout=function(evt){if(gd._dragging)return;// When the mouse leaves this maindrag, unset the hovered subplot.\n// This may cause problems if it leaves the subplot directly *onto*\n// another subplot, but that's a tiny corner case at the moment.\ngd._fullLayout._hoversubplot=null;dragElement.unhover(gd,evt);};// corner draggers\nif(gd._context.showAxisDragHandles){makeDragBox(gd,plotinfo,xa._offset-DRAGGERSIZE,ya._offset-DRAGGERSIZE,DRAGGERSIZE,DRAGGERSIZE,'n','w');makeDragBox(gd,plotinfo,xa._offset+xa._length,ya._offset-DRAGGERSIZE,DRAGGERSIZE,DRAGGERSIZE,'n','e');makeDragBox(gd,plotinfo,xa._offset-DRAGGERSIZE,ya._offset+ya._length,DRAGGERSIZE,DRAGGERSIZE,'s','w');makeDragBox(gd,plotinfo,xa._offset+xa._length,ya._offset+ya._length,DRAGGERSIZE,DRAGGERSIZE,'s','e');}}if(gd._context.showAxisDragHandles){// x axis draggers - if you have overlaid plots,\n// these drag each axis separately\nif(subplot===xa._mainSubplot){// the y position of the main x axis line\nvar y0=xa._mainLinePosition;if(xa.side==='top')y0-=DRAGGERSIZE;makeDragBox(gd,plotinfo,xa._offset+xa._length*0.1,y0,xa._length*0.8,DRAGGERSIZE,'','ew');makeDragBox(gd,plotinfo,xa._offset,y0,xa._length*0.1,DRAGGERSIZE,'','w');makeDragBox(gd,plotinfo,xa._offset+xa._length*0.9,y0,xa._length*0.1,DRAGGERSIZE,'','e');}// y axis draggers\nif(subplot===ya._mainSubplot){// the x position of the main y axis line\nvar x0=ya._mainLinePosition;if(ya.side!=='right')x0-=DRAGGERSIZE;makeDragBox(gd,plotinfo,x0,ya._offset+ya._length*0.1,DRAGGERSIZE,ya._length*0.8,'ns','');makeDragBox(gd,plotinfo,x0,ya._offset+ya._length*0.9,DRAGGERSIZE,ya._length*0.1,'s','');makeDragBox(gd,plotinfo,x0,ya._offset,DRAGGERSIZE,ya._length*0.1,'n','');}}});// In case you mousemove over some hovertext, send it to Fx.hover too\n// we do this so that we can put the hover text in front of everything,\n// but still be able to interact with everything as if it isn't there\nvar hoverLayer=fullLayout._hoverlayer.node();hoverLayer.onmousemove=function(evt){evt.target=gd._fullLayout._lasthover;Fx.hover(gd,evt,fullLayout._hoversubplot);};hoverLayer.onclick=function(evt){evt.target=gd._fullLayout._lasthover;Fx.click(gd,evt);};// also delegate mousedowns... TODO: does this actually work?\nhoverLayer.onmousedown=function(evt){gd._fullLayout._lasthover.onmousedown(evt);};exports.updateFx(gd);};// Minimal set of update needed on 'modebar' edits.\n// We only need to update the <g .draglayer> cursor style.\n//\n// Note that changing the axis configuration and/or the fixedrange attribute\n// should trigger a full initInteractions.\nexports.updateFx=function(gd){var fullLayout=gd._fullLayout;var cursor=fullLayout.dragmode==='pan'?'move':'crosshair';setCursor(fullLayout._draggers,cursor);};},{\"../../components/dragelement\":61,\"../../components/fx\":82,\"../../lib/setcursor\":178,\"./constants\":209,\"./dragbox\":211,\"d3\":8}],213:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Registry=_dereq_('../../registry');var Lib=_dereq_('../../lib');/**\n * Factory function for checking component arrays for subplot references.\n *\n * @param {string} containerArrayName: the top-level array in gd.layout to check\n *   If an item in this container is found that references a cartesian x and/or y axis,\n *   ensure cartesian is marked as a base plot module and record the axes (and subplot\n *   if both refs are axes) in gd._fullLayout\n *\n * @return {function}: with args layoutIn (gd.layout) and layoutOut (gd._fullLayout)\n * as expected of a component includeBasePlot method\n */module.exports=function makeIncludeComponents(containerArrayName){return function includeComponents(layoutIn,layoutOut){var array=layoutIn[containerArrayName];if(!Array.isArray(array))return;var Cartesian=Registry.subplotsRegistry.cartesian;var idRegex=Cartesian.idRegex;var subplots=layoutOut._subplots;var xaList=subplots.xaxis;var yaList=subplots.yaxis;var cartesianList=subplots.cartesian;var hasCartesianOrGL2D=layoutOut._has('cartesian')||layoutOut._has('gl2d');for(var i=0;i<array.length;i++){var itemi=array[i];if(!Lib.isPlainObject(itemi))continue;var xref=itemi.xref;var yref=itemi.yref;var hasXref=idRegex.x.test(xref);var hasYref=idRegex.y.test(yref);if(hasXref||hasYref){if(!hasCartesianOrGL2D)Lib.pushUnique(layoutOut._basePlotModules,Cartesian);var newAxis=false;if(hasXref&&xaList.indexOf(xref)===-1){xaList.push(xref);newAxis=true;}if(hasYref&&yaList.indexOf(yref)===-1){yaList.push(yref);newAxis=true;}/*\n                 * Notice the logic here: only add a subplot for a component if\n                 * it's referencing both x and y axes AND it's creating a new axis\n                 * so for example if your plot already has xy and x2y2, an annotation\n                 * on x2y or xy2 will not create a new subplot.\n                 */if(newAxis&&hasXref&&hasYref){cartesianList.push(xref+yref);}}}};};},{\"../../lib\":159,\"../../registry\":242}],214:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var Registry=_dereq_('../../registry');var Lib=_dereq_('../../lib');var Plots=_dereq_('../plots');var Drawing=_dereq_('../../components/drawing');var getModuleCalcData=_dereq_('../get_data').getModuleCalcData;var axisIds=_dereq_('./axis_ids');var constants=_dereq_('./constants');var xmlnsNamespaces=_dereq_('../../constants/xmlns_namespaces');var ensureSingle=Lib.ensureSingle;function ensureSingleAndAddDatum(parent,nodeType,className){return Lib.ensureSingle(parent,nodeType,className,function(s){s.datum(className);});}exports.name='cartesian';exports.attr=['xaxis','yaxis'];exports.idRoot=['x','y'];exports.idRegex=constants.idRegex;exports.attrRegex=constants.attrRegex;exports.attributes=_dereq_('./attributes');exports.layoutAttributes=_dereq_('./layout_attributes');exports.supplyLayoutDefaults=_dereq_('./layout_defaults');exports.transitionAxes=_dereq_('./transition_axes');exports.finalizeSubplots=function(layoutIn,layoutOut){var subplots=layoutOut._subplots;var xList=subplots.xaxis;var yList=subplots.yaxis;var spSVG=subplots.cartesian;var spAll=spSVG.concat(subplots.gl2d||[]);var allX={};var allY={};var i,xi,yi;for(i=0;i<spAll.length;i++){var parts=spAll[i].split('y');allX[parts[0]]=1;allY['y'+parts[1]]=1;}// check for x axes with no subplot, and make one from the anchor of that x axis\nfor(i=0;i<xList.length;i++){xi=xList[i];if(!allX[xi]){yi=(layoutIn[axisIds.id2name(xi)]||{}).anchor;if(!constants.idRegex.y.test(yi))yi='y';spSVG.push(xi+yi);spAll.push(xi+yi);if(!allY[yi]){allY[yi]=1;Lib.pushUnique(yList,yi);}}}// same for y axes with no subplot\nfor(i=0;i<yList.length;i++){yi=yList[i];if(!allY[yi]){xi=(layoutIn[axisIds.id2name(yi)]||{}).anchor;if(!constants.idRegex.x.test(xi))xi='x';spSVG.push(xi+yi);spAll.push(xi+yi);if(!allX[xi]){allX[xi]=1;Lib.pushUnique(xList,xi);}}}// finally, if we've gotten here we're supposed to show cartesian...\n// so if there are NO subplots at all, make one from the first\n// x & y axes in the input layout\nif(!spAll.length){xi='';yi='';for(var ki in layoutIn){if(constants.attrRegex.test(ki)){var axLetter=ki.charAt(0);if(axLetter==='x'){if(!xi||+ki.substr(5)<+xi.substr(5)){xi=ki;}}else if(!yi||+ki.substr(5)<+yi.substr(5)){yi=ki;}}}xi=xi?axisIds.name2id(xi):'x';yi=yi?axisIds.name2id(yi):'y';xList.push(xi);yList.push(yi);spSVG.push(xi+yi);}};/**\n * Cartesian.plot\n *\n * @param {DOM div | object} gd\n * @param {array | null} (optional) traces\n *  array of traces indices to plot\n *  if undefined, plots all cartesian traces,\n *  if null, plots no traces\n * @param {object} (optional) transitionOpts\n *  transition option object\n * @param {function} (optional) makeOnCompleteCallback\n *  transition make callback function from Plots.transition\n */exports.plot=function(gd,traces,transitionOpts,makeOnCompleteCallback){var fullLayout=gd._fullLayout;var subplots=fullLayout._subplots.cartesian;var calcdata=gd.calcdata;var i;if(traces===null){// this means no updates required, must return here\n// so that plotOne doesn't remove the trace layers\nreturn;}else if(!Array.isArray(traces)){// If traces is not provided, then it's a complete replot and missing\n// traces are removed\ntraces=[];for(i=0;i<calcdata.length;i++){traces.push(i);}}for(i=0;i<subplots.length;i++){var subplot=subplots[i];var subplotInfo=fullLayout._plots[subplot];// Get all calcdata for this subplot:\nvar cdSubplot=[];var pcd;for(var j=0;j<calcdata.length;j++){var cd=calcdata[j];var trace=cd[0].trace;// Skip trace if whitelist provided and it's not whitelisted:\n// if (Array.isArray(traces) && traces.indexOf(i) === -1) continue;\nif(trace.xaxis+trace.yaxis===subplot){// XXX: Should trace carpet dependencies. Only replot all carpet plots if the carpet\n// axis has actually changed:\n//\n// If this trace is specifically requested, add it to the list:\nif(traces.indexOf(trace.index)!==-1||trace.carpet){// Okay, so example: traces 0, 1, and 2 have fill = tonext. You animate\n// traces 0 and 2. Trace 1 also needs to be updated, otherwise its fill\n// is outdated. So this retroactively adds the previous trace if the\n// traces are interdependent.\nif(pcd&&pcd[0].trace.xaxis+pcd[0].trace.yaxis===subplot&&['tonextx','tonexty','tonext'].indexOf(trace.fill)!==-1&&cdSubplot.indexOf(pcd)===-1){cdSubplot.push(pcd);}cdSubplot.push(cd);}// Track the previous trace on this subplot for the retroactive-add step\n// above:\npcd=cd;}}plotOne(gd,subplotInfo,cdSubplot,transitionOpts,makeOnCompleteCallback);}};function plotOne(gd,plotinfo,cdSubplot,transitionOpts,makeOnCompleteCallback){var traceLayerClasses=constants.traceLayerClasses;var fullLayout=gd._fullLayout;var modules=fullLayout._modules;var _module,cdModuleAndOthers,cdModule;var layerData=[];var zoomScaleQueryParts=[];for(var i=0;i<modules.length;i++){_module=modules[i];var name=_module.name;var categories=Registry.modules[name].categories;if(categories.svg){var className=_module.layerName||name+'layer';var plotMethod=_module.plot;// plot all visible traces of this type on this subplot at once\ncdModuleAndOthers=getModuleCalcData(cdSubplot,plotMethod);cdModule=cdModuleAndOthers[0];// don't need to search the found traces again - in fact we need to NOT\n// so that if two modules share the same plotter we don't double-plot\ncdSubplot=cdModuleAndOthers[1];if(cdModule.length){layerData.push({i:traceLayerClasses.indexOf(className),className:className,plotMethod:plotMethod,cdModule:cdModule});}if(categories.zoomScale){zoomScaleQueryParts.push('.'+className);}}}layerData.sort(function(a,b){return a.i-b.i;});var layers=plotinfo.plot.selectAll('g.mlayer').data(layerData,function(d){return d.className;});layers.enter().append('g').attr('class',function(d){return d.className;}).classed('mlayer',true);layers.exit().remove();layers.order();layers.each(function(d){var sel=d3.select(this);var className=d.className;d.plotMethod(gd,plotinfo,d.cdModule,sel,transitionOpts,makeOnCompleteCallback);// layers that allow `cliponaxis: false`\nif(className!=='scatterlayer'&&className!=='barlayer'&&className!=='waterfalllayer'){Drawing.setClipUrl(sel,plotinfo.layerClipId,gd);}});// call Scattergl.plot separately\nif(fullLayout._has('scattergl')){_module=Registry.getModule('scattergl');cdModule=getModuleCalcData(cdSubplot,_module)[0];_module.plot(gd,plotinfo,cdModule);}// stash \"hot\" selections for faster interaction on drag and scroll\nif(!gd._context.staticPlot){if(plotinfo._hasClipOnAxisFalse){plotinfo.clipOnAxisFalseTraces=plotinfo.plot.selectAll('.scatterlayer, .barlayer, .waterfalllayer').selectAll('.trace');}if(zoomScaleQueryParts.length){var traces=plotinfo.plot.selectAll(zoomScaleQueryParts.join(',')).selectAll('.trace');plotinfo.zoomScalePts=traces.selectAll('path.point');plotinfo.zoomScaleTxt=traces.selectAll('.textpoint');}}}exports.clean=function(newFullData,newFullLayout,oldFullData,oldFullLayout){var oldPlots=oldFullLayout._plots||{};var newPlots=newFullLayout._plots||{};var oldSubplotList=oldFullLayout._subplots||{};var plotinfo;var i,k;// when going from a large splom graph to something else,\n// we need to clear <g subplot> so that the new cartesian subplot\n// can have the correct layer ordering\nif(oldFullLayout._hasOnlyLargeSploms&&!newFullLayout._hasOnlyLargeSploms){for(k in oldPlots){plotinfo=oldPlots[k];if(plotinfo.plotgroup)plotinfo.plotgroup.remove();}}var hadGl=oldFullLayout._has&&oldFullLayout._has('gl');var hasGl=newFullLayout._has&&newFullLayout._has('gl');if(hadGl&&!hasGl){for(k in oldPlots){plotinfo=oldPlots[k];if(plotinfo._scene)plotinfo._scene.destroy();}}// delete any titles we don't need anymore\n// check if axis list has changed, and if so clear old titles\nif(oldSubplotList.xaxis&&oldSubplotList.yaxis){var oldAxIDs=axisIds.listIds({_fullLayout:oldFullLayout});for(i=0;i<oldAxIDs.length;i++){var oldAxId=oldAxIDs[i];if(!newFullLayout[axisIds.id2name(oldAxId)]){oldFullLayout._infolayer.selectAll('.g-'+oldAxId+'title').remove();}}}var hadCartesian=oldFullLayout._has&&oldFullLayout._has('cartesian');var hasCartesian=newFullLayout._has&&newFullLayout._has('cartesian');if(hadCartesian&&!hasCartesian){// if we've gotten rid of all cartesian traces, remove all the subplot svg items\npurgeSubplotLayers(oldFullLayout._cartesianlayer.selectAll('.subplot'),oldFullLayout);oldFullLayout._defs.selectAll('.axesclip').remove();delete oldFullLayout._axisConstraintGroups;}else if(oldSubplotList.cartesian){// otherwise look for subplots we need to remove\nfor(i=0;i<oldSubplotList.cartesian.length;i++){var oldSubplotId=oldSubplotList.cartesian[i];if(!newPlots[oldSubplotId]){var selector='.'+oldSubplotId+',.'+oldSubplotId+'-x,.'+oldSubplotId+'-y';oldFullLayout._cartesianlayer.selectAll(selector).remove();removeSubplotExtras(oldSubplotId,oldFullLayout);}}}};exports.drawFramework=function(gd){var fullLayout=gd._fullLayout;var subplotData=makeSubplotData(gd);var subplotLayers=fullLayout._cartesianlayer.selectAll('.subplot').data(subplotData,String);subplotLayers.enter().append('g').attr('class',function(d){return'subplot '+d[0];});subplotLayers.order();subplotLayers.exit().call(purgeSubplotLayers,fullLayout);subplotLayers.each(function(d){var id=d[0];var plotinfo=fullLayout._plots[id];plotinfo.plotgroup=d3.select(this);makeSubplotLayer(gd,plotinfo);// make separate drag layers for each subplot,\n// but append them to paper rather than the plot groups,\n// so they end up on top of the rest\nplotinfo.draglayer=ensureSingle(fullLayout._draggers,'g',id);});};exports.rangePlot=function(gd,plotinfo,cdSubplot){makeSubplotLayer(gd,plotinfo);plotOne(gd,plotinfo,cdSubplot);Plots.style(gd);};function makeSubplotData(gd){var fullLayout=gd._fullLayout;var ids=fullLayout._subplots.cartesian;var len=ids.length;var i,j,id,plotinfo,xa,ya;// split 'regular' and 'overlaying' subplots\nvar regulars=[];var overlays=[];for(i=0;i<len;i++){id=ids[i];plotinfo=fullLayout._plots[id];xa=plotinfo.xaxis;ya=plotinfo.yaxis;var xa2=xa._mainAxis;var ya2=ya._mainAxis;var mainplot=xa2._id+ya2._id;var mainplotinfo=fullLayout._plots[mainplot];plotinfo.overlays=[];if(mainplot!==id&&mainplotinfo){plotinfo.mainplot=mainplot;plotinfo.mainplotinfo=mainplotinfo;overlays.push(id);}else{plotinfo.mainplot=undefined;plotinfo.mainPlotinfo=undefined;regulars.push(id);}}// fill in list of overlaying subplots in 'main plot'\nfor(i=0;i<overlays.length;i++){id=overlays[i];plotinfo=fullLayout._plots[id];plotinfo.mainplotinfo.overlays.push(plotinfo);}// put 'regular' subplot data before 'overlaying'\nvar subplotIds=regulars.concat(overlays);var subplotData=new Array(len);for(i=0;i<len;i++){id=subplotIds[i];plotinfo=fullLayout._plots[id];xa=plotinfo.xaxis;ya=plotinfo.yaxis;// use info about axis layer and overlaying pattern\n// to clean what need to be cleaned up in exit selection\nvar d=[id,xa.layer,ya.layer,xa.overlaying||'',ya.overlaying||''];for(j=0;j<plotinfo.overlays.length;j++){d.push(plotinfo.overlays[j].id);}subplotData[i]=d;}return subplotData;}function makeSubplotLayer(gd,plotinfo){var plotgroup=plotinfo.plotgroup;var id=plotinfo.id;var xLayer=constants.layerValue2layerClass[plotinfo.xaxis.layer];var yLayer=constants.layerValue2layerClass[plotinfo.yaxis.layer];var hasOnlyLargeSploms=gd._fullLayout._hasOnlyLargeSploms;if(!plotinfo.mainplot){if(hasOnlyLargeSploms){// TODO could do even better\n// - we don't need plot (but we would have to mock it in lsInner\n//   and other places\n// - we don't (x|y)lines and (x|y)axislayer for most subplots\n//   usually just the bottom x and left y axes.\nplotinfo.xlines=ensureSingle(plotgroup,'path','xlines-above');plotinfo.ylines=ensureSingle(plotgroup,'path','ylines-above');plotinfo.xaxislayer=ensureSingle(plotgroup,'g','xaxislayer-above');plotinfo.yaxislayer=ensureSingle(plotgroup,'g','yaxislayer-above');}else{var backLayer=ensureSingle(plotgroup,'g','layer-subplot');plotinfo.shapelayer=ensureSingle(backLayer,'g','shapelayer');plotinfo.imagelayer=ensureSingle(backLayer,'g','imagelayer');plotinfo.gridlayer=ensureSingle(plotgroup,'g','gridlayer');plotinfo.zerolinelayer=ensureSingle(plotgroup,'g','zerolinelayer');ensureSingle(plotgroup,'path','xlines-below');ensureSingle(plotgroup,'path','ylines-below');plotinfo.overlinesBelow=ensureSingle(plotgroup,'g','overlines-below');ensureSingle(plotgroup,'g','xaxislayer-below');ensureSingle(plotgroup,'g','yaxislayer-below');plotinfo.overaxesBelow=ensureSingle(plotgroup,'g','overaxes-below');plotinfo.plot=ensureSingle(plotgroup,'g','plot');plotinfo.overplot=ensureSingle(plotgroup,'g','overplot');plotinfo.xlines=ensureSingle(plotgroup,'path','xlines-above');plotinfo.ylines=ensureSingle(plotgroup,'path','ylines-above');plotinfo.overlinesAbove=ensureSingle(plotgroup,'g','overlines-above');ensureSingle(plotgroup,'g','xaxislayer-above');ensureSingle(plotgroup,'g','yaxislayer-above');plotinfo.overaxesAbove=ensureSingle(plotgroup,'g','overaxes-above');// set refs to correct layers as determined by 'axis.layer'\nplotinfo.xlines=plotgroup.select('.xlines-'+xLayer);plotinfo.ylines=plotgroup.select('.ylines-'+yLayer);plotinfo.xaxislayer=plotgroup.select('.xaxislayer-'+xLayer);plotinfo.yaxislayer=plotgroup.select('.yaxislayer-'+yLayer);}}else{var mainplotinfo=plotinfo.mainplotinfo;var mainplotgroup=mainplotinfo.plotgroup;var xId=id+'-x';var yId=id+'-y';// now make the components of overlaid subplots\n// overlays don't have backgrounds, and append all\n// their other components to the corresponding\n// extra groups of their main plots.\nplotinfo.gridlayer=mainplotinfo.gridlayer;plotinfo.zerolinelayer=mainplotinfo.zerolinelayer;ensureSingle(mainplotinfo.overlinesBelow,'path',xId);ensureSingle(mainplotinfo.overlinesBelow,'path',yId);ensureSingle(mainplotinfo.overaxesBelow,'g',xId);ensureSingle(mainplotinfo.overaxesBelow,'g',yId);plotinfo.plot=ensureSingle(mainplotinfo.overplot,'g',id);ensureSingle(mainplotinfo.overlinesAbove,'path',xId);ensureSingle(mainplotinfo.overlinesAbove,'path',yId);ensureSingle(mainplotinfo.overaxesAbove,'g',xId);ensureSingle(mainplotinfo.overaxesAbove,'g',yId);// set refs to correct layers as determined by 'abovetraces'\nplotinfo.xlines=mainplotgroup.select('.overlines-'+xLayer).select('.'+xId);plotinfo.ylines=mainplotgroup.select('.overlines-'+yLayer).select('.'+yId);plotinfo.xaxislayer=mainplotgroup.select('.overaxes-'+xLayer).select('.'+xId);plotinfo.yaxislayer=mainplotgroup.select('.overaxes-'+yLayer).select('.'+yId);}// common attributes for all subplots, overlays or not\nif(!hasOnlyLargeSploms){ensureSingleAndAddDatum(plotinfo.gridlayer,'g',plotinfo.xaxis._id);ensureSingleAndAddDatum(plotinfo.gridlayer,'g',plotinfo.yaxis._id);plotinfo.gridlayer.selectAll('g').map(function(d){return d[0];}).sort(axisIds.idSort);}plotinfo.xlines.style('fill','none').classed('crisp',true);plotinfo.ylines.style('fill','none').classed('crisp',true);}function purgeSubplotLayers(layers,fullLayout){if(!layers)return;var overlayIdsToRemove={};layers.each(function(d){var id=d[0];var plotgroup=d3.select(this);plotgroup.remove();removeSubplotExtras(id,fullLayout);overlayIdsToRemove[id]=true;// do not remove individual axis <clipPath>s here\n// as other subplots may need them\n});// must remove overlaid subplot trace layers 'manually'\nfor(var k in fullLayout._plots){var subplotInfo=fullLayout._plots[k];var overlays=subplotInfo.overlays||[];for(var j=0;j<overlays.length;j++){var overlayInfo=overlays[j];if(overlayIdsToRemove[overlayInfo.id]){overlayInfo.plot.selectAll('.trace').remove();}}}}function removeSubplotExtras(subplotId,fullLayout){fullLayout._draggers.selectAll('g.'+subplotId).remove();fullLayout._defs.select('#clip'+fullLayout._uid+subplotId+'plot').remove();}exports.toSVG=function(gd){var imageRoot=gd._fullLayout._glimages;var root=d3.select(gd).selectAll('.svg-container');var canvases=root.filter(function(d,i){return i===root.size()-1;}).selectAll('.gl-canvas-context, .gl-canvas-focus');function canvasToImage(){var canvas=this;var imageData=canvas.toDataURL('image/png');var image=imageRoot.append('svg:image');image.attr({xmlns:xmlnsNamespaces.svg,'xlink:href':imageData,preserveAspectRatio:'none',x:0,y:0,width:canvas.width,height:canvas.height});}canvases.each(canvasToImage);};exports.updateFx=_dereq_('./graph_interact').updateFx;},{\"../../components/drawing\":64,\"../../constants/xmlns_namespaces\":141,\"../../lib\":159,\"../../registry\":242,\"../get_data\":231,\"../plots\":235,\"./attributes\":201,\"./axis_ids\":206,\"./constants\":209,\"./graph_interact\":212,\"./layout_attributes\":215,\"./layout_defaults\":216,\"./transition_axes\":225,\"d3\":8}],215:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var fontAttrs=_dereq_('../font_attributes');var colorAttrs=_dereq_('../../components/color/attributes');var dash=_dereq_('../../components/drawing/attributes').dash;var extendFlat=_dereq_('../../lib/extend').extendFlat;var templatedArray=_dereq_('../../plot_api/plot_template').templatedArray;var constants=_dereq_('./constants');module.exports={visible:{valType:'boolean',editType:'plot'},color:{valType:'color',dflt:colorAttrs.defaultLine,editType:'ticks'},title:{text:{valType:'string',editType:'ticks'},font:fontAttrs({editType:'ticks'}),editType:'ticks'},type:{valType:'enumerated',// '-' means we haven't yet run autotype or couldn't find any data\n// it gets turned into linear in gd._fullLayout but not copied back\n// to gd.data like the others are.\nvalues:['-','linear','log','date','category','multicategory'],dflt:'-',editType:'calc',// we forget when an axis has been autotyped, just writing the auto\n// value back to the input - so it doesn't make sense to template this.\n// Note: we do NOT prohibit this in `coerce`, so if someone enters a\n// type in the template explicitly it will be honored as the default.\n_noTemplating:true},autorange:{valType:'enumerated',values:[true,false,'reversed'],dflt:true,editType:'axrange',impliedEdits:{'range[0]':undefined,'range[1]':undefined}},rangemode:{valType:'enumerated',values:['normal','tozero','nonnegative'],dflt:'normal',editType:'plot'},range:{valType:'info_array',items:[{valType:'any',editType:'axrange',impliedEdits:{'^autorange':false},anim:true},{valType:'any',editType:'axrange',impliedEdits:{'^autorange':false},anim:true}],editType:'axrange',impliedEdits:{'autorange':false},anim:true},fixedrange:{valType:'boolean',dflt:false,editType:'calc'},// scaleanchor: not used directly, just put here for reference\n// values are any opposite-letter axis id\nscaleanchor:{valType:'enumerated',values:[constants.idRegex.x.toString(),constants.idRegex.y.toString()],editType:'plot'},scaleratio:{valType:'number',min:0,dflt:1,editType:'plot'},constrain:{valType:'enumerated',values:['range','domain'],dflt:'range',editType:'plot'},// constraintoward: not used directly, just put here for reference\nconstraintoward:{valType:'enumerated',values:['left','center','right','top','middle','bottom'],editType:'plot'},matches:{valType:'enumerated',values:[constants.idRegex.x.toString(),constants.idRegex.y.toString()],editType:'calc'},// ticks\ntickmode:{valType:'enumerated',values:['auto','linear','array'],editType:'ticks',impliedEdits:{tick0:undefined,dtick:undefined}},nticks:{valType:'integer',min:0,dflt:0,editType:'ticks'},tick0:{valType:'any',editType:'ticks',impliedEdits:{tickmode:'linear'}},dtick:{valType:'any',editType:'ticks',impliedEdits:{tickmode:'linear'}},tickvals:{valType:'data_array',editType:'ticks'},ticktext:{valType:'data_array',editType:'ticks'},ticks:{valType:'enumerated',values:['outside','inside',''],editType:'ticks'},tickson:{valType:'enumerated',values:['labels','boundaries'],dflt:'labels',editType:'ticks'},mirror:{valType:'enumerated',values:[true,'ticks',false,'all','allticks'],dflt:false,editType:'ticks+layoutstyle'},ticklen:{valType:'number',min:0,dflt:5,editType:'ticks'},tickwidth:{valType:'number',min:0,dflt:1,editType:'ticks'},tickcolor:{valType:'color',dflt:colorAttrs.defaultLine,editType:'ticks'},showticklabels:{valType:'boolean',dflt:true,editType:'ticks'},automargin:{valType:'boolean',dflt:false,editType:'ticks'},showspikes:{valType:'boolean',dflt:false,editType:'modebar'},spikecolor:{valType:'color',dflt:null,editType:'none'},spikethickness:{valType:'number',dflt:3,editType:'none'},spikedash:extendFlat({},dash,{dflt:'dash',editType:'none'}),spikemode:{valType:'flaglist',flags:['toaxis','across','marker'],dflt:'toaxis',editType:'none'},spikesnap:{valType:'enumerated',values:['data','cursor'],dflt:'data',editType:'none'},tickfont:fontAttrs({editType:'ticks'}),tickangle:{valType:'angle',dflt:'auto',editType:'ticks'},tickprefix:{valType:'string',dflt:'',editType:'ticks'},showtickprefix:{valType:'enumerated',values:['all','first','last','none'],dflt:'all',editType:'ticks'},ticksuffix:{valType:'string',dflt:'',editType:'ticks'},showticksuffix:{valType:'enumerated',values:['all','first','last','none'],dflt:'all',editType:'ticks'},showexponent:{valType:'enumerated',values:['all','first','last','none'],dflt:'all',editType:'ticks'},exponentformat:{valType:'enumerated',values:['none','e','E','power','SI','B'],dflt:'B',editType:'ticks'},separatethousands:{valType:'boolean',dflt:false,editType:'ticks'},tickformat:{valType:'string',dflt:'',editType:'ticks'},tickformatstops:templatedArray('tickformatstop',{enabled:{valType:'boolean',dflt:true,editType:'ticks'},dtickrange:{valType:'info_array',items:[{valType:'any',editType:'ticks'},{valType:'any',editType:'ticks'}],editType:'ticks'},value:{valType:'string',dflt:'',editType:'ticks'},editType:'ticks'}),hoverformat:{valType:'string',dflt:'',editType:'none'},// lines and grids\nshowline:{valType:'boolean',dflt:false,editType:'ticks+layoutstyle'},linecolor:{valType:'color',dflt:colorAttrs.defaultLine,editType:'layoutstyle'},linewidth:{valType:'number',min:0,dflt:1,editType:'ticks+layoutstyle'},showgrid:{valType:'boolean',editType:'ticks'},gridcolor:{valType:'color',dflt:colorAttrs.lightLine,editType:'ticks'},gridwidth:{valType:'number',min:0,dflt:1,editType:'ticks'},zeroline:{valType:'boolean',editType:'ticks'},zerolinecolor:{valType:'color',dflt:colorAttrs.defaultLine,editType:'ticks'},zerolinewidth:{valType:'number',dflt:1,editType:'ticks'},showdividers:{valType:'boolean',dflt:true,editType:'ticks'},dividercolor:{valType:'color',dflt:colorAttrs.defaultLine,editType:'ticks'},dividerwidth:{valType:'number',dflt:1,editType:'ticks'},// TODO dividerlen: that would override \"to label base\" length?\n// positioning attributes\n// anchor: not used directly, just put here for reference\n// values are any opposite-letter axis id\nanchor:{valType:'enumerated',values:['free',constants.idRegex.x.toString(),constants.idRegex.y.toString()],editType:'plot'},// side: not used directly, as values depend on direction\n// values are top, bottom for x axes, and left, right for y\nside:{valType:'enumerated',values:['top','bottom','left','right'],editType:'plot'},// overlaying: not used directly, just put here for reference\n// values are false and any other same-letter axis id that's not\n// itself overlaying anything\noverlaying:{valType:'enumerated',values:['free',constants.idRegex.x.toString(),constants.idRegex.y.toString()],editType:'plot'},layer:{valType:'enumerated',values:['above traces','below traces'],dflt:'above traces',editType:'plot'},domain:{valType:'info_array',items:[{valType:'number',min:0,max:1,editType:'plot'},{valType:'number',min:0,max:1,editType:'plot'}],dflt:[0,1],editType:'plot'},position:{valType:'number',min:0,max:1,dflt:0,editType:'plot'},categoryorder:{valType:'enumerated',values:['trace','category ascending','category descending','array'/* , 'value ascending', 'value descending'*/ // value ascending / descending to be implemented later\n],dflt:'trace',editType:'calc'},categoryarray:{valType:'data_array',editType:'calc'},uirevision:{valType:'any',editType:'none'},editType:'calc',_deprecated:{autotick:{valType:'boolean',editType:'ticks'},title:{valType:'string',editType:'ticks'},titlefont:fontAttrs({editType:'ticks'})}};},{\"../../components/color/attributes\":42,\"../../components/drawing/attributes\":63,\"../../lib/extend\":153,\"../../plot_api/plot_template\":193,\"../font_attributes\":229,\"./constants\":209}],216:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var Color=_dereq_('../../components/color');var Template=_dereq_('../../plot_api/plot_template');var basePlotLayoutAttributes=_dereq_('../layout_attributes');var layoutAttributes=_dereq_('./layout_attributes');var handleTypeDefaults=_dereq_('./type_defaults');var handleAxisDefaults=_dereq_('./axis_defaults');var handleConstraintDefaults=_dereq_('./constraints').handleConstraintDefaults;var handlePositionDefaults=_dereq_('./position_defaults');var axisIds=_dereq_('./axis_ids');var id2name=axisIds.id2name;var name2id=axisIds.name2id;var Registry=_dereq_('../../registry');var traceIs=Registry.traceIs;var getComponentMethod=Registry.getComponentMethod;function appendList(cont,k,item){if(Array.isArray(cont[k]))cont[k].push(item);else cont[k]=[item];}module.exports=function supplyLayoutDefaults(layoutIn,layoutOut,fullData){var ax2traces={};var xaCheater={};var xaNonCheater={};var outerTicks={};var noGrids={};var i,j;// look for axes in the data\nfor(i=0;i<fullData.length;i++){var trace=fullData[i];if(!traceIs(trace,'cartesian')&&!traceIs(trace,'gl2d'))continue;var xaName;if(trace.xaxis){xaName=id2name(trace.xaxis);appendList(ax2traces,xaName,trace);}else if(trace.xaxes){for(j=0;j<trace.xaxes.length;j++){appendList(ax2traces,id2name(trace.xaxes[j]),trace);}}var yaName;if(trace.yaxis){yaName=id2name(trace.yaxis);appendList(ax2traces,yaName,trace);}else if(trace.yaxes){for(j=0;j<trace.yaxes.length;j++){appendList(ax2traces,id2name(trace.yaxes[j]),trace);}}// Two things trigger axis visibility:\n// 1. is not carpet\n// 2. carpet that's not cheater\nif(!traceIs(trace,'carpet')||trace.type==='carpet'&&!trace._cheater){if(xaName)xaNonCheater[xaName]=1;}// The above check for definitely-not-cheater is not adequate. This\n// second list tracks which axes *could* be a cheater so that the\n// full condition triggering hiding is:\n//   *could* be a cheater and *is not definitely visible*\nif(trace.type==='carpet'&&trace._cheater){if(xaName)xaCheater[xaName]=1;}// check for default formatting tweaks\nif(traceIs(trace,'2dMap')){outerTicks[xaName]=1;outerTicks[yaName]=1;}if(traceIs(trace,'oriented')){var positionAxis=trace.orientation==='h'?yaName:xaName;noGrids[positionAxis]=1;}}var subplots=layoutOut._subplots;var xIds=subplots.xaxis;var yIds=subplots.yaxis;var xNames=Lib.simpleMap(xIds,id2name);var yNames=Lib.simpleMap(yIds,id2name);var axNames=xNames.concat(yNames);// plot_bgcolor only makes sense if there's a (2D) plot!\n// TODO: bgcolor for each subplot, to inherit from the main one\nvar plotBgColor=Color.background;if(xIds.length&&yIds.length){plotBgColor=Lib.coerce(layoutIn,layoutOut,basePlotLayoutAttributes,'plot_bgcolor');}var bgColor=Color.combine(plotBgColor,layoutOut.paper_bgcolor);var axName,axLetter,axLayoutIn,axLayoutOut;function coerce(attr,dflt){return Lib.coerce(axLayoutIn,axLayoutOut,layoutAttributes,attr,dflt);}function coerce2(attr,dflt){return Lib.coerce2(axLayoutIn,axLayoutOut,layoutAttributes,attr,dflt);}function getCounterAxes(axLetter){return axLetter==='x'?yIds:xIds;}var counterAxes={x:getCounterAxes('x'),y:getCounterAxes('y')};var allAxisIds=counterAxes.x.concat(counterAxes.y);function getOverlayableAxes(axLetter,axName){var list=axLetter==='x'?xNames:yNames;var out=[];for(var j=0;j<list.length;j++){var axName2=list[j];if(axName2!==axName&&!(layoutIn[axName2]||{}).overlaying){out.push(name2id(axName2));}}return out;}// first pass creates the containers, determines types, and handles most of the settings\nfor(i=0;i<axNames.length;i++){axName=axNames[i];axLetter=axName.charAt(0);if(!Lib.isPlainObject(layoutIn[axName])){layoutIn[axName]={};}axLayoutIn=layoutIn[axName];axLayoutOut=Template.newContainer(layoutOut,axName,axLetter+'axis');var traces=ax2traces[axName]||[];axLayoutOut._traceIndices=traces.map(function(t){return t._expandedIndex;});axLayoutOut._annIndices=[];axLayoutOut._shapeIndices=[];axLayoutOut._imgIndices=[];axLayoutOut._subplotsWith=[];axLayoutOut._counterAxes=[];// set up some private properties\naxLayoutOut._name=axLayoutOut._attr=axName;var id=axLayoutOut._id=name2id(axName);var overlayableAxes=getOverlayableAxes(axLetter,axName);var defaultOptions={letter:axLetter,font:layoutOut.font,outerTicks:outerTicks[axName],showGrid:!noGrids[axName],data:traces,bgColor:bgColor,calendar:layoutOut.calendar,automargin:true,cheateronly:axLetter==='x'&&xaCheater[axName]&&!xaNonCheater[axName],splomStash:((layoutOut._splomAxes||{})[axLetter]||{})[id]};coerce('uirevision',layoutOut.uirevision);handleTypeDefaults(axLayoutIn,axLayoutOut,coerce,defaultOptions);handleAxisDefaults(axLayoutIn,axLayoutOut,coerce,defaultOptions,layoutOut);var spikecolor=coerce2('spikecolor');var spikethickness=coerce2('spikethickness');var spikedash=coerce2('spikedash');var spikemode=coerce2('spikemode');var spikesnap=coerce2('spikesnap');var showSpikes=coerce('showspikes',!!spikecolor||!!spikethickness||!!spikedash||!!spikemode||!!spikesnap);if(!showSpikes){delete axLayoutOut.spikecolor;delete axLayoutOut.spikethickness;delete axLayoutOut.spikedash;delete axLayoutOut.spikemode;delete axLayoutOut.spikesnap;}handlePositionDefaults(axLayoutIn,axLayoutOut,coerce,{letter:axLetter,counterAxes:counterAxes[axLetter],overlayableAxes:overlayableAxes,grid:layoutOut.grid});axLayoutOut._input=axLayoutIn;}// quick second pass for range slider and selector defaults\nvar rangeSliderDefaults=getComponentMethod('rangeslider','handleDefaults');var rangeSelectorDefaults=getComponentMethod('rangeselector','handleDefaults');for(i=0;i<xNames.length;i++){axName=xNames[i];axLayoutIn=layoutIn[axName];axLayoutOut=layoutOut[axName];rangeSliderDefaults(layoutIn,layoutOut,axName);if(axLayoutOut.type==='date'){rangeSelectorDefaults(axLayoutIn,axLayoutOut,layoutOut,yNames,axLayoutOut.calendar);}coerce('fixedrange');}for(i=0;i<yNames.length;i++){axName=yNames[i];axLayoutIn=layoutIn[axName];axLayoutOut=layoutOut[axName];var anchoredAxis=layoutOut[id2name(axLayoutOut.anchor)];var fixedRangeDflt=getComponentMethod('rangeslider','isVisible')(anchoredAxis);coerce('fixedrange',fixedRangeDflt);}// Finally, handle scale constraints and matching axes.\n//\n// We need to do this after all axes have coerced both `type`\n// (so we link only axes of the same type) and\n// `fixedrange` (so we can avoid linking from OR TO a fixed axis).\n// sets of axes linked by `scaleanchor` along with the scaleratios compounded\n// together, populated in handleConstraintDefaults\nvar constraintGroups=layoutOut._axisConstraintGroups=[];// similar to _axisConstraintGroups, but for matching axes\nvar matchGroups=layoutOut._axisMatchGroups=[];for(i=0;i<axNames.length;i++){axName=axNames[i];axLetter=axName.charAt(0);axLayoutIn=layoutIn[axName];axLayoutOut=layoutOut[axName];handleConstraintDefaults(axLayoutIn,axLayoutOut,coerce,allAxisIds,layoutOut);}for(i=0;i<matchGroups.length;i++){var group=matchGroups[i];var rng=null;var autorange=null;var axId;// find 'matching' range attrs\nfor(axId in group){axLayoutOut=layoutOut[id2name(axId)];if(!axLayoutOut.matches){rng=axLayoutOut.range;autorange=axLayoutOut.autorange;}}// if `ax.matches` values are reciprocal,\n// pick values of first axis in group\nif(rng===null||autorange===null){for(axId in group){axLayoutOut=layoutOut[id2name(axId)];rng=axLayoutOut.range;autorange=axLayoutOut.autorange;break;}}// apply matching range attrs\nfor(axId in group){axLayoutOut=layoutOut[id2name(axId)];if(axLayoutOut.matches){axLayoutOut.range=rng.slice();axLayoutOut.autorange=autorange;}axLayoutOut._matchGroup=group;}// remove matching axis from scaleanchor constraint groups (for now)\nif(constraintGroups.length){for(axId in group){for(j=0;j<constraintGroups.length;j++){var group2=constraintGroups[j];for(var axId2 in group2){if(axId===axId2){Lib.warn('Axis '+axId2+' is set with both '+'a *scaleanchor* and *matches* constraint; '+'ignoring the scale constraint.');delete group2[axId2];if(Object.keys(group2).length<2){constraintGroups.splice(j,1);}}}}}}}};},{\"../../components/color\":43,\"../../lib\":159,\"../../plot_api/plot_template\":193,\"../../registry\":242,\"../layout_attributes\":233,\"./axis_defaults\":205,\"./axis_ids\":206,\"./constraints\":210,\"./layout_attributes\":215,\"./position_defaults\":218,\"./type_defaults\":226}],217:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var colorMix=_dereq_('tinycolor2').mix;var lightFraction=_dereq_('../../components/color/attributes').lightFraction;var Lib=_dereq_('../../lib');/**\n * @param {object} opts :\n *   - dfltColor {string} : default axis color\n *   - bgColor {string} : combined subplot bg color\n *   - blend {number, optional} : blend percentage (to compute dflt grid color)\n *   - showLine {boolean} : show line by default\n *   - showGrid {boolean} : show grid by default\n *   - noZeroLine {boolean} : don't coerce zeroline* attributes\n *   - attributes {object} : attribute object associated with input containers\n */module.exports=function handleLineGridDefaults(containerIn,containerOut,coerce,opts){opts=opts||{};var dfltColor=opts.dfltColor;function coerce2(attr,dflt){return Lib.coerce2(containerIn,containerOut,opts.attributes,attr,dflt);}var lineColor=coerce2('linecolor',dfltColor);var lineWidth=coerce2('linewidth');var showLine=coerce('showline',opts.showLine||!!lineColor||!!lineWidth);if(!showLine){delete containerOut.linecolor;delete containerOut.linewidth;}var gridColorDflt=colorMix(dfltColor,opts.bgColor,opts.blend||lightFraction).toRgbString();var gridColor=coerce2('gridcolor',gridColorDflt);var gridWidth=coerce2('gridwidth');var showGridLines=coerce('showgrid',opts.showGrid||!!gridColor||!!gridWidth);if(!showGridLines){delete containerOut.gridcolor;delete containerOut.gridwidth;}if(!opts.noZeroLine){var zeroLineColor=coerce2('zerolinecolor',dfltColor);var zeroLineWidth=coerce2('zerolinewidth');var showZeroLine=coerce('zeroline',opts.showGrid||!!zeroLineColor||!!zeroLineWidth);if(!showZeroLine){delete containerOut.zerolinecolor;delete containerOut.zerolinewidth;}}};},{\"../../components/color/attributes\":42,\"../../lib\":159,\"tinycolor2\":26}],218:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var isNumeric=_dereq_('fast-isnumeric');var Lib=_dereq_('../../lib');module.exports=function handlePositionDefaults(containerIn,containerOut,coerce,options){var counterAxes=options.counterAxes||[];var overlayableAxes=options.overlayableAxes||[];var letter=options.letter;var grid=options.grid;var dfltAnchor,dfltDomain,dfltSide,dfltPosition;if(grid){dfltDomain=grid._domains[letter][grid._axisMap[containerOut._id]];dfltAnchor=grid._anchors[containerOut._id];if(dfltDomain){dfltSide=grid[letter+'side'].split(' ')[0];dfltPosition=grid.domain[letter][dfltSide==='right'||dfltSide==='top'?1:0];}}// Even if there's a grid, this axis may not be in it - fall back on non-grid defaults\ndfltDomain=dfltDomain||[0,1];dfltAnchor=dfltAnchor||(isNumeric(containerIn.position)?'free':counterAxes[0]||'free');dfltSide=dfltSide||(letter==='x'?'bottom':'left');dfltPosition=dfltPosition||0;var anchor=Lib.coerce(containerIn,containerOut,{anchor:{valType:'enumerated',values:['free'].concat(counterAxes),dflt:dfltAnchor}},'anchor');if(anchor==='free')coerce('position',dfltPosition);Lib.coerce(containerIn,containerOut,{side:{valType:'enumerated',values:letter==='x'?['bottom','top']:['left','right'],dflt:dfltSide}},'side');var overlaying=false;if(overlayableAxes.length){overlaying=Lib.coerce(containerIn,containerOut,{overlaying:{valType:'enumerated',values:[false].concat(overlayableAxes),dflt:false}},'overlaying');}if(!overlaying){// TODO: right now I'm copying this domain over to overlaying axes\n// in ax.setscale()... but this means we still need (imperfect) logic\n// in the axes popover to hide domain for the overlaying axis.\n// perhaps I should make a private version _domain that all axes get???\nvar domain=coerce('domain',dfltDomain);// according to https://www.npmjs.com/package/canvas-size\n// the minimum value of max canvas width across browsers and devices is 4096\n// which applied in the calculation below:\nif(domain[0]>domain[1]-1/4096)containerOut.domain=dfltDomain;Lib.noneOrAll(containerIn.domain,containerOut.domain,dfltDomain);}coerce('layer');return containerOut;};},{\"../../lib\":159,\"fast-isnumeric\":10}],219:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var FROM_BL=_dereq_('../../constants/alignment').FROM_BL;module.exports=function scaleZoom(ax,factor,centerFraction){if(centerFraction===undefined){centerFraction=FROM_BL[ax.constraintoward||'center'];}var rangeLinear=[ax.r2l(ax.range[0]),ax.r2l(ax.range[1])];var center=rangeLinear[0]+(rangeLinear[1]-rangeLinear[0])*centerFraction;ax.range=ax._input.range=[ax.l2r(center+(rangeLinear[0]-center)*factor),ax.l2r(center+(rangeLinear[1]-center)*factor)];};},{\"../../constants/alignment\":138}],220:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var polybool=_dereq_('polybooljs');var Registry=_dereq_('../../registry');var Color=_dereq_('../../components/color');var Fx=_dereq_('../../components/fx');var Lib=_dereq_('../../lib');var polygon=_dereq_('../../lib/polygon');var throttle=_dereq_('../../lib/throttle');var makeEventData=_dereq_('../../components/fx/helpers').makeEventData;var getFromId=_dereq_('./axis_ids').getFromId;var clearGlCanvases=_dereq_('../../lib/clear_gl_canvases');var redrawReglTraces=_dereq_('../../plot_api/subroutines').redrawReglTraces;var constants=_dereq_('./constants');var MINSELECT=constants.MINSELECT;var filteredPolygon=polygon.filter;var polygonTester=polygon.tester;function getAxId(ax){return ax._id;}function prepSelect(e,startX,startY,dragOptions,mode){var gd=dragOptions.gd;var fullLayout=gd._fullLayout;var zoomLayer=fullLayout._zoomlayer;var dragBBox=dragOptions.element.getBoundingClientRect();var plotinfo=dragOptions.plotinfo;var xs=plotinfo.xaxis._offset;var ys=plotinfo.yaxis._offset;var x0=startX-dragBBox.left;var y0=startY-dragBBox.top;var x1=x0;var y1=y0;var path0='M'+x0+','+y0;var pw=dragOptions.xaxes[0]._length;var ph=dragOptions.yaxes[0]._length;var allAxes=dragOptions.xaxes.concat(dragOptions.yaxes);var subtract=e.altKey;var filterPoly,selectionTester,mergedPolygons,currentPolygon;var i,searchInfo,eventData;coerceSelectionsCache(e,gd,dragOptions);if(mode==='lasso'){filterPoly=filteredPolygon([[x0,y0]],constants.BENDPX);}var outlines=zoomLayer.selectAll('path.select-outline-'+plotinfo.id).data([1,2]);outlines.enter().append('path').attr('class',function(d){return'select-outline select-outline-'+d+' select-outline-'+plotinfo.id;}).attr('transform','translate('+xs+', '+ys+')').attr('d',path0+'Z');var corners=zoomLayer.append('path').attr('class','zoombox-corners').style({fill:Color.background,stroke:Color.defaultLine,'stroke-width':1}).attr('transform','translate('+xs+', '+ys+')').attr('d','M0,0Z');var throttleID=fullLayout._uid+constants.SELECTID;var selection=[];// find the traces to search for selection points\nvar searchTraces=determineSearchTraces(gd,dragOptions.xaxes,dragOptions.yaxes,dragOptions.subplot);function axValue(ax){var index=ax._id.charAt(0)==='y'?1:0;return function(v){return ax.p2d(v[index]);};}function ascending(a,b){return a-b;}// allow subplots to override fillRangeItems routine\nvar fillRangeItems;if(plotinfo.fillRangeItems){fillRangeItems=plotinfo.fillRangeItems;}else{if(mode==='select'){fillRangeItems=function fillRangeItems(eventData,poly){var ranges=eventData.range={};for(i=0;i<allAxes.length;i++){var ax=allAxes[i];var axLetter=ax._id.charAt(0);ranges[ax._id]=[ax.p2d(poly[axLetter+'min']),ax.p2d(poly[axLetter+'max'])].sort(ascending);}};}else{fillRangeItems=function fillRangeItems(eventData,poly,filterPoly){var dataPts=eventData.lassoPoints={};for(i=0;i<allAxes.length;i++){var ax=allAxes[i];dataPts[ax._id]=filterPoly.filtered.map(axValue(ax));}};}}dragOptions.moveFn=function(dx0,dy0){x1=Math.max(0,Math.min(pw,dx0+x0));y1=Math.max(0,Math.min(ph,dy0+y0));var dx=Math.abs(x1-x0);var dy=Math.abs(y1-y0);if(mode==='select'){var direction=fullLayout.selectdirection;if(fullLayout.selectdirection==='any'){if(dy<Math.min(dx*0.6,MINSELECT))direction='h';else if(dx<Math.min(dy*0.6,MINSELECT))direction='v';else direction='d';}else{direction=fullLayout.selectdirection;}if(direction==='h'){// horizontal motion: make a vertical box\ncurrentPolygon=[[x0,0],[x0,ph],[x1,ph],[x1,0]];currentPolygon.xmin=Math.min(x0,x1);currentPolygon.xmax=Math.max(x0,x1);currentPolygon.ymin=Math.min(0,ph);currentPolygon.ymax=Math.max(0,ph);// extras to guide users in keeping a straight selection\ncorners.attr('d','M'+currentPolygon.xmin+','+(y0-MINSELECT)+'h-4v'+2*MINSELECT+'h4Z'+'M'+(currentPolygon.xmax-1)+','+(y0-MINSELECT)+'h4v'+2*MINSELECT+'h-4Z');}else if(direction==='v'){// vertical motion: make a horizontal box\ncurrentPolygon=[[0,y0],[0,y1],[pw,y1],[pw,y0]];currentPolygon.xmin=Math.min(0,pw);currentPolygon.xmax=Math.max(0,pw);currentPolygon.ymin=Math.min(y0,y1);currentPolygon.ymax=Math.max(y0,y1);corners.attr('d','M'+(x0-MINSELECT)+','+currentPolygon.ymin+'v-4h'+2*MINSELECT+'v4Z'+'M'+(x0-MINSELECT)+','+(currentPolygon.ymax-1)+'v4h'+2*MINSELECT+'v-4Z');}else if(direction==='d'){// diagonal motion\ncurrentPolygon=[[x0,y0],[x0,y1],[x1,y1],[x1,y0]];currentPolygon.xmin=Math.min(x0,x1);currentPolygon.xmax=Math.max(x0,x1);currentPolygon.ymin=Math.min(y0,y1);currentPolygon.ymax=Math.max(y0,y1);corners.attr('d','M0,0Z');}}else if(mode==='lasso'){filterPoly.addPt([x1,y1]);currentPolygon=filterPoly.filtered;}// create outline & tester\nif(dragOptions.selectionDefs&&dragOptions.selectionDefs.length){mergedPolygons=mergePolygons(dragOptions.mergedPolygons,currentPolygon,subtract);currentPolygon.subtract=subtract;selectionTester=multiTester(dragOptions.selectionDefs.concat([currentPolygon]));}else{mergedPolygons=[currentPolygon];selectionTester=polygonTester(currentPolygon);}// draw selection\ndrawSelection(mergedPolygons,outlines);throttle.throttle(throttleID,constants.SELECTDELAY,function(){selection=[];var thisSelection;var traceSelections=[];var traceSelection;for(i=0;i<searchTraces.length;i++){searchInfo=searchTraces[i];traceSelection=searchInfo._module.selectPoints(searchInfo,selectionTester);traceSelections.push(traceSelection);thisSelection=fillSelectionItem(traceSelection,searchInfo);if(selection.length){for(var j=0;j<thisSelection.length;j++){selection.push(thisSelection[j]);}}else selection=thisSelection;}eventData={points:selection};updateSelectedState(gd,searchTraces,eventData);fillRangeItems(eventData,currentPolygon,filterPoly);dragOptions.gd.emit('plotly_selecting',eventData);});};dragOptions.clickFn=function(numClicks,evt){var clickmode=fullLayout.clickmode;corners.remove();throttle.done(throttleID).then(function(){throttle.clear(throttleID);if(numClicks===2){// clear selection on doubleclick\noutlines.remove();for(i=0;i<searchTraces.length;i++){searchInfo=searchTraces[i];searchInfo._module.selectPoints(searchInfo,false);}updateSelectedState(gd,searchTraces);clearSelectionsCache(dragOptions);gd.emit('plotly_deselect',null);}else{if(clickmode.indexOf('select')>-1){selectOnClick(evt,gd,dragOptions.xaxes,dragOptions.yaxes,dragOptions.subplot,dragOptions,outlines);}if(clickmode==='event'){// TODO: remove in v2 - this was probably never intended to work as it does,\n// but in case anyone depends on it we don't want to break it now.\n// Note that click-to-select introduced pre v2 also emitts proper\n// event data when clickmode is having 'select' in its flag list.\ngd.emit('plotly_selected',undefined);}}Fx.click(gd,evt);})[\"catch\"](Lib.error);};dragOptions.doneFn=function(){corners.remove();throttle.done(throttleID).then(function(){throttle.clear(throttleID);dragOptions.gd.emit('plotly_selected',eventData);if(currentPolygon&&dragOptions.selectionDefs){// save last polygons\ncurrentPolygon.subtract=subtract;dragOptions.selectionDefs.push(currentPolygon);// we have to keep reference to arrays container\ndragOptions.mergedPolygons.length=0;[].push.apply(dragOptions.mergedPolygons,mergedPolygons);}if(dragOptions.doneFnCompleted){dragOptions.doneFnCompleted(selection);}})[\"catch\"](Lib.error);};}function selectOnClick(evt,gd,xAxes,yAxes,subplot,dragOptions,polygonOutlines){var hoverData=gd._hoverdata;var clickmode=gd._fullLayout.clickmode;var sendEvents=clickmode.indexOf('event')>-1;var selection=[];var searchTraces,searchInfo,currentSelectionDef,selectionTester,traceSelection;var thisTracesSelection,pointOrBinSelected,subtract,eventData,i;if(isHoverDataSet(hoverData)){coerceSelectionsCache(evt,gd,dragOptions);searchTraces=determineSearchTraces(gd,xAxes,yAxes,subplot);var clickedPtInfo=extractClickedPtInfo(hoverData,searchTraces);var isBinnedTrace=clickedPtInfo.pointNumbers.length>0;// Note: potentially costly operation isPointOrBinSelected is\n// called as late as possible through the use of an assignment\n// in an if condition.\nif(isBinnedTrace?isOnlyThisBinSelected(searchTraces,clickedPtInfo):isOnlyOnePointSelected(searchTraces)&&(pointOrBinSelected=isPointOrBinSelected(clickedPtInfo))){if(polygonOutlines)polygonOutlines.remove();for(i=0;i<searchTraces.length;i++){searchInfo=searchTraces[i];searchInfo._module.selectPoints(searchInfo,false);}updateSelectedState(gd,searchTraces);clearSelectionsCache(dragOptions);if(sendEvents){gd.emit('plotly_deselect',null);}}else{subtract=evt.shiftKey&&(pointOrBinSelected!==undefined?pointOrBinSelected:isPointOrBinSelected(clickedPtInfo));currentSelectionDef=newPointSelectionDef(clickedPtInfo.pointNumber,clickedPtInfo.searchInfo,subtract);var allSelectionDefs=dragOptions.selectionDefs.concat([currentSelectionDef]);selectionTester=multiTester(allSelectionDefs);for(i=0;i<searchTraces.length;i++){traceSelection=searchTraces[i]._module.selectPoints(searchTraces[i],selectionTester);thisTracesSelection=fillSelectionItem(traceSelection,searchTraces[i]);if(selection.length){for(var j=0;j<thisTracesSelection.length;j++){selection.push(thisTracesSelection[j]);}}else selection=thisTracesSelection;}eventData={points:selection};updateSelectedState(gd,searchTraces,eventData);if(currentSelectionDef&&dragOptions){dragOptions.selectionDefs.push(currentSelectionDef);}if(polygonOutlines)drawSelection(dragOptions.mergedPolygons,polygonOutlines);if(sendEvents){gd.emit('plotly_selected',eventData);}}}}/**\n * Constructs a new point selection definition object.\n */function newPointSelectionDef(pointNumber,searchInfo,subtract){return{pointNumber:pointNumber,searchInfo:searchInfo,subtract:subtract};}function isPointSelectionDef(o){return'pointNumber'in o&&'searchInfo'in o;}/*\n * Constructs a new point number tester.\n */function newPointNumTester(pointSelectionDef){return{xmin:0,xmax:0,ymin:0,ymax:0,pts:[],contains:function contains(pt,omitFirstEdge,pointNumber,searchInfo){var idxWantedTrace=pointSelectionDef.searchInfo.cd[0].trace._expandedIndex;var idxActualTrace=searchInfo.cd[0].trace._expandedIndex;return idxActualTrace===idxWantedTrace&&pointNumber===pointSelectionDef.pointNumber;},isRect:false,degenerate:false,subtract:pointSelectionDef.subtract};}/**\n * Wraps multiple selection testers.\n *\n * @param {Array} list - An array of selection testers.\n *\n * @return a selection tester object with a contains function\n * that can be called to evaluate a point against all wrapped\n * selection testers that were passed in list.\n */function multiTester(list){var testers=[];var xmin=isPointSelectionDef(list[0])?0:list[0][0][0];var xmax=xmin;var ymin=isPointSelectionDef(list[0])?0:list[0][0][1];var ymax=ymin;for(var i=0;i<list.length;i++){if(isPointSelectionDef(list[i])){testers.push(newPointNumTester(list[i]));}else{var tester=polygon.tester(list[i]);tester.subtract=list[i].subtract;testers.push(tester);xmin=Math.min(xmin,tester.xmin);xmax=Math.max(xmax,tester.xmax);ymin=Math.min(ymin,tester.ymin);ymax=Math.max(ymax,tester.ymax);}}/**\n     * Tests if the given point is within this tester.\n     *\n     * @param {Array} pt - [0] is the x coordinate, [1] is the y coordinate of the point.\n     * @param {*} arg - An optional parameter to pass down to wrapped testers.\n     * @param {number} pointNumber - The point number of the point within the underlying data array.\n     * @param {number} searchInfo - An object identifying the trace the point is contained in.\n     *\n     * @return {boolean} true if point is considered to be selected, false otherwise.\n     */function contains(pt,arg,pointNumber,searchInfo){var contained=false;for(var i=0;i<testers.length;i++){if(testers[i].contains(pt,arg,pointNumber,searchInfo)){// if contained by subtract tester - exclude the point\ncontained=testers[i].subtract===false;}}return contained;}return{xmin:xmin,xmax:xmax,ymin:ymin,ymax:ymax,pts:[],contains:contains,isRect:false,degenerate:false};}function coerceSelectionsCache(evt,gd,dragOptions){var fullLayout=gd._fullLayout;var plotinfo=dragOptions.plotinfo;var selectingOnSameSubplot=fullLayout._lastSelectedSubplot&&fullLayout._lastSelectedSubplot===plotinfo.id;var hasModifierKey=evt.shiftKey||evt.altKey;if(selectingOnSameSubplot&&hasModifierKey&&plotinfo.selection&&plotinfo.selection.selectionDefs&&!dragOptions.selectionDefs){// take over selection definitions from prev mode, if any\ndragOptions.selectionDefs=plotinfo.selection.selectionDefs;dragOptions.mergedPolygons=plotinfo.selection.mergedPolygons;}else if(!hasModifierKey||!plotinfo.selection){clearSelectionsCache(dragOptions);}// clear selection outline when selecting a different subplot\nif(!selectingOnSameSubplot){clearSelect(gd);fullLayout._lastSelectedSubplot=plotinfo.id;}}function clearSelectionsCache(dragOptions){var plotinfo=dragOptions.plotinfo;plotinfo.selection={};plotinfo.selection.selectionDefs=dragOptions.selectionDefs=[];plotinfo.selection.mergedPolygons=dragOptions.mergedPolygons=[];}function determineSearchTraces(gd,xAxes,yAxes,subplot){var searchTraces=[];var xAxisIds=xAxes.map(getAxId);var yAxisIds=yAxes.map(getAxId);var cd,trace,i;for(i=0;i<gd.calcdata.length;i++){cd=gd.calcdata[i];trace=cd[0].trace;if(trace.visible!==true||!trace._module||!trace._module.selectPoints)continue;if(subplot&&(trace.subplot===subplot||trace.geo===subplot)){searchTraces.push(createSearchInfo(trace._module,cd,xAxes[0],yAxes[0]));}else if(trace.type==='splom'&&// FIXME: make sure we don't have more than single axis for splom\ntrace._xaxes[xAxisIds[0]]&&trace._yaxes[yAxisIds[0]]){var info=createSearchInfo(trace._module,cd,xAxes[0],yAxes[0]);info.scene=gd._fullLayout._splomScenes[trace.uid];searchTraces.push(info);}else if(trace.type==='sankey'){var sankeyInfo=createSearchInfo(trace._module,cd,xAxes[0],yAxes[0]);searchTraces.push(sankeyInfo);}else{if(xAxisIds.indexOf(trace.xaxis)===-1)continue;if(yAxisIds.indexOf(trace.yaxis)===-1)continue;searchTraces.push(createSearchInfo(trace._module,cd,getFromId(gd,trace.xaxis),getFromId(gd,trace.yaxis)));}}return searchTraces;function createSearchInfo(module,calcData,xaxis,yaxis){return{_module:module,cd:calcData,xaxis:xaxis,yaxis:yaxis};}}function drawSelection(polygons,outlines){var paths=[];var i,d;for(i=0;i<polygons.length;i++){var ppts=polygons[i];paths.push(ppts.join('L')+'L'+ppts[0]);}d=polygons.length>0?'M'+paths.join('M')+'Z':'M0,0Z';outlines.attr('d',d);}function isHoverDataSet(hoverData){return hoverData&&Array.isArray(hoverData)&&hoverData[0].hoverOnBox!==true;}function extractClickedPtInfo(hoverData,searchTraces){var hoverDatum=hoverData[0];var pointNumber=-1;var pointNumbers=[];var searchInfo,i;for(i=0;i<searchTraces.length;i++){searchInfo=searchTraces[i];if(hoverDatum.fullData._expandedIndex===searchInfo.cd[0].trace._expandedIndex){// Special case for box (and violin)\nif(hoverDatum.hoverOnBox===true){break;}// Hint: in some traces like histogram, one graphical element\n// doesn't correspond to one particular data point, but to\n// bins of data points. Thus, hoverDatum can have a binNumber\n// property instead of pointNumber.\nif(hoverDatum.pointNumber!==undefined){pointNumber=hoverDatum.pointNumber;}else if(hoverDatum.binNumber!==undefined){pointNumber=hoverDatum.binNumber;pointNumbers=hoverDatum.pointNumbers;}break;}}return{pointNumber:pointNumber,pointNumbers:pointNumbers,searchInfo:searchInfo};}function isPointOrBinSelected(clickedPtInfo){var trace=clickedPtInfo.searchInfo.cd[0].trace;var ptNum=clickedPtInfo.pointNumber;var ptNums=clickedPtInfo.pointNumbers;var ptNumsSet=ptNums.length>0;// When pointsNumbers is set (e.g. histogram's binning),\n// it is assumed that when the first point of\n// a bin is selected, all others are as well\nvar ptNumToTest=ptNumsSet?ptNums[0]:ptNum;// TODO potential performance improvement\n// Primarily we need this function to determine if a click adds\n// or subtracts from a selection.\n// In cases `trace.selectedpoints` is a huge array, indexOf\n// might be slow. One remedy would be to introduce a hash somewhere.\nreturn trace.selectedpoints?trace.selectedpoints.indexOf(ptNumToTest)>-1:false;}function isOnlyThisBinSelected(searchTraces,clickedPtInfo){var tracesWithSelectedPts=[];var searchInfo,trace,isSameTrace,i;for(i=0;i<searchTraces.length;i++){searchInfo=searchTraces[i];if(searchInfo.cd[0].trace.selectedpoints&&searchInfo.cd[0].trace.selectedpoints.length>0){tracesWithSelectedPts.push(searchInfo);}}if(tracesWithSelectedPts.length===1){isSameTrace=tracesWithSelectedPts[0]===clickedPtInfo.searchInfo;if(isSameTrace){trace=clickedPtInfo.searchInfo.cd[0].trace;if(trace.selectedpoints.length===clickedPtInfo.pointNumbers.length){for(i=0;i<clickedPtInfo.pointNumbers.length;i++){if(trace.selectedpoints.indexOf(clickedPtInfo.pointNumbers[i])<0){return false;}}return true;}}}return false;}function isOnlyOnePointSelected(searchTraces){var len=0;var searchInfo,trace,i;for(i=0;i<searchTraces.length;i++){searchInfo=searchTraces[i];trace=searchInfo.cd[0].trace;if(trace.selectedpoints){if(trace.selectedpoints.length>1)return false;len+=trace.selectedpoints.length;if(len>1)return false;}}return len===1;}function updateSelectedState(gd,searchTraces,eventData){var i,searchInfo,cd,trace;// before anything else, update preGUI if necessary\nfor(i=0;i<searchTraces.length;i++){var fullInputTrace=searchTraces[i].cd[0].trace._fullInput;var tracePreGUI=gd._fullLayout._tracePreGUI[fullInputTrace.uid]||{};if(tracePreGUI.selectedpoints===undefined){tracePreGUI.selectedpoints=fullInputTrace._input.selectedpoints||null;}}if(eventData){var pts=eventData.points||[];for(i=0;i<searchTraces.length;i++){trace=searchTraces[i].cd[0].trace;trace._input.selectedpoints=trace._fullInput.selectedpoints=[];if(trace._fullInput!==trace)trace.selectedpoints=[];}for(i=0;i<pts.length;i++){var pt=pts[i];var data=pt.data;var fullData=pt.fullData;if(pt.pointIndices){[].push.apply(data.selectedpoints,pt.pointIndices);if(trace._fullInput!==trace){[].push.apply(fullData.selectedpoints,pt.pointIndices);}}else{data.selectedpoints.push(pt.pointIndex);if(trace._fullInput!==trace){fullData.selectedpoints.push(pt.pointIndex);}}}}else{for(i=0;i<searchTraces.length;i++){trace=searchTraces[i].cd[0].trace;delete trace.selectedpoints;delete trace._input.selectedpoints;if(trace._fullInput!==trace){delete trace._fullInput.selectedpoints;}}}var hasRegl=false;for(i=0;i<searchTraces.length;i++){searchInfo=searchTraces[i];cd=searchInfo.cd;trace=cd[0].trace;if(Registry.traceIs(trace,'regl')){hasRegl=true;}var _module=searchInfo._module;var fn=_module.styleOnSelect||_module.style;if(fn)fn(gd,cd);}if(hasRegl){clearGlCanvases(gd);redrawReglTraces(gd);}}function mergePolygons(list,poly,subtract){var res;if(subtract){res=polybool.difference({regions:list,inverted:false},{regions:[poly],inverted:false});return res.regions;}res=polybool.union({regions:list,inverted:false},{regions:[poly],inverted:false});return res.regions;}function fillSelectionItem(selection,searchInfo){if(Array.isArray(selection)){var cd=searchInfo.cd;var trace=searchInfo.cd[0].trace;for(var i=0;i<selection.length;i++){selection[i]=makeEventData(selection[i],trace,cd);}}return selection;}// until we get around to persistent selections, remove the outline\n// here. The selection itself will be removed when the plot redraws\n// at the end.\nfunction clearSelect(gd){var fullLayout=gd._fullLayout||{};var zoomlayer=fullLayout._zoomlayer;if(zoomlayer){zoomlayer.selectAll('.select-outline').remove();}}module.exports={prepSelect:prepSelect,clearSelect:clearSelect,selectOnClick:selectOnClick};},{\"../../components/color\":43,\"../../components/fx\":82,\"../../components/fx/helpers\":78,\"../../lib\":159,\"../../lib/clear_gl_canvases\":148,\"../../lib/polygon\":171,\"../../lib/throttle\":181,\"../../plot_api/subroutines\":194,\"../../registry\":242,\"./axis_ids\":206,\"./constants\":209,\"polybooljs\":17}],221:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var isNumeric=_dereq_('fast-isnumeric');var Lib=_dereq_('../../lib');var cleanNumber=Lib.cleanNumber;var ms2DateTime=Lib.ms2DateTime;var dateTime2ms=Lib.dateTime2ms;var ensureNumber=Lib.ensureNumber;var isArrayOrTypedArray=Lib.isArrayOrTypedArray;var numConstants=_dereq_('../../constants/numerical');var FP_SAFE=numConstants.FP_SAFE;var BADNUM=numConstants.BADNUM;var LOG_CLIP=numConstants.LOG_CLIP;var constants=_dereq_('./constants');var axisIds=_dereq_('./axis_ids');function fromLog(v){return Math.pow(10,v);}function isValidCategory(v){return v!==null&&v!==undefined;}/**\n * Define the conversion functions for an axis data is used in 5 ways:\n *\n *  d: data, in whatever form it's provided\n *  c: calcdata: turned into numbers, but not linearized\n *  l: linearized - same as c except for log axes (and other nonlinear\n *      mappings later?) this is used when we need to know if it's\n *      *possible* to show some data on this axis, without caring about\n *      the current range\n *  p: pixel value - mapped to the screen with current size and zoom\n *  r: ranges, tick0, and annotation positions match one of the above\n *     but are handled differently for different types:\n *     - linear and date: data format (d)\n *     - category: calcdata format (c), and will stay that way because\n *       the data format has no continuous mapping\n *     - log: linearized (l) format\n *       TODO: in v2.0 we plan to change it to data format. At that point\n *       shapes will work the same way as ranges, tick0, and annotations\n *       so they can use this conversion too.\n *\n * Creates/updates these conversion functions, and a few more utilities\n * like cleanRange, and makeCalcdata\n *\n * also clears the autotick constraints ._minDtick, ._forceTick0\n */module.exports=function setConvert(ax,fullLayout){fullLayout=fullLayout||{};var axId=ax._id||'x';var axLetter=axId.charAt(0);function toLog(v,clip){if(v>0)return Math.log(v)/Math.LN10;else if(v<=0&&clip&&ax.range&&ax.range.length===2){// clip NaN (ie past negative infinity) to LOG_CLIP axis\n// length past the negative edge\nvar r0=ax.range[0];var r1=ax.range[1];return 0.5*(r0+r1-2*LOG_CLIP*Math.abs(r0-r1));}else return BADNUM;}/*\n     * wrapped dateTime2ms that:\n     * - accepts ms numbers for backward compatibility\n     * - inserts a dummy arg so calendar is the 3rd arg (see notes below).\n     * - defaults to ax.calendar\n     */function dt2ms(v,_,calendar){// NOTE: Changed this behavior: previously we took any numeric value\n// to be a ms, even if it was a string that could be a bare year.\n// Now we convert it as a date if at all possible, and only try\n// as (local) ms if that fails.\nvar ms=dateTime2ms(v,calendar||ax.calendar);if(ms===BADNUM){if(isNumeric(v)){v=+v;// keep track of tenths of ms, that `new Date` will drop\n// same logic as in Lib.ms2DateTime\nvar msecTenths=Math.floor(Lib.mod(v+0.05,1)*10);var msRounded=Math.round(v-msecTenths/10);ms=dateTime2ms(new Date(msRounded))+msecTenths/10;}else return BADNUM;}return ms;}// wrapped ms2DateTime to insert default ax.calendar\nfunction ms2dt(v,r,calendar){return ms2DateTime(v,r,calendar||ax.calendar);}function getCategoryName(v){return ax._categories[Math.round(v)];}/*\n     * setCategoryIndex: return the index of category v,\n     * inserting it in the list if it's not already there\n     *\n     * this will enter the categories in the order it\n     * encounters them, ie all the categories from the\n     * first data set, then all the ones from the second\n     * that aren't in the first etc.\n     *\n     * it is assumed that this function is being invoked in the\n     * already sorted category order; otherwise there would be\n     * a disconnect between the array and the index returned\n     */function setCategoryIndex(v){if(isValidCategory(v)){if(ax._categoriesMap===undefined){ax._categoriesMap={};}if(ax._categoriesMap[v]!==undefined){return ax._categoriesMap[v];}else{ax._categories.push(v);var curLength=ax._categories.length-1;ax._categoriesMap[v]=curLength;return curLength;}}return BADNUM;}function setMultiCategoryIndex(arrayIn,len){var arrayOut=new Array(len);for(var i=0;i<len;i++){var v0=(arrayIn[0]||[])[i];var v1=(arrayIn[1]||[])[i];arrayOut[i]=getCategoryIndex([v0,v1]);}return arrayOut;}function getCategoryIndex(v){if(ax._categoriesMap){return ax._categoriesMap[v];}}function getCategoryPosition(v){// d2l/d2c variant that that won't add categories but will also\n// allow numbers to be mapped to the linearized axis positions\nvar index=getCategoryIndex(v);if(index!==undefined)return index;if(isNumeric(v))return+v;}function l2p(v){if(!isNumeric(v))return BADNUM;// include 2 fractional digits on pixel, for PDF zooming etc\nreturn d3.round(ax._b+ax._m*v,2);}function p2l(px){return(px-ax._b)/ax._m;}// conversions among c/l/p are fairly simple - do them together for all axis types\nax.c2l=ax.type==='log'?toLog:ensureNumber;ax.l2c=ax.type==='log'?fromLog:ensureNumber;ax.l2p=l2p;ax.p2l=p2l;ax.c2p=ax.type==='log'?function(v,clip){return l2p(toLog(v,clip));}:l2p;ax.p2c=ax.type==='log'?function(px){return fromLog(p2l(px));}:p2l;/*\n     * now type-specific conversions for **ALL** other combinations\n     * they're all written out, instead of being combinations of each other, for\n     * both clarity and speed.\n     */if(['linear','-'].indexOf(ax.type)!==-1){// all are data vals, but d and r need cleaning\nax.d2r=ax.r2d=ax.d2c=ax.r2c=ax.d2l=ax.r2l=cleanNumber;ax.c2d=ax.c2r=ax.l2d=ax.l2r=ensureNumber;ax.d2p=ax.r2p=function(v){return ax.l2p(cleanNumber(v));};ax.p2d=ax.p2r=p2l;ax.cleanPos=ensureNumber;}else if(ax.type==='log'){// d and c are data vals, r and l are logged (but d and r need cleaning)\nax.d2r=ax.d2l=function(v,clip){return toLog(cleanNumber(v),clip);};ax.r2d=ax.r2c=function(v){return fromLog(cleanNumber(v));};ax.d2c=ax.r2l=cleanNumber;ax.c2d=ax.l2r=ensureNumber;ax.c2r=toLog;ax.l2d=fromLog;ax.d2p=function(v,clip){return ax.l2p(ax.d2r(v,clip));};ax.p2d=function(px){return fromLog(p2l(px));};ax.r2p=function(v){return ax.l2p(cleanNumber(v));};ax.p2r=p2l;ax.cleanPos=ensureNumber;}else if(ax.type==='date'){// r and d are date strings, l and c are ms\n/*\n         * Any of these functions with r and d on either side, calendar is the\n         * **3rd** argument. log has reserved the second argument.\n         *\n         * Unless you need the special behavior of the second arg (ms2DateTime\n         * uses this to limit precision, toLog uses true to clip negatives\n         * to offscreen low rather than undefined), it's safe to pass 0.\n         */ax.d2r=ax.r2d=Lib.identity;ax.d2c=ax.r2c=ax.d2l=ax.r2l=dt2ms;ax.c2d=ax.c2r=ax.l2d=ax.l2r=ms2dt;ax.d2p=ax.r2p=function(v,_,calendar){return ax.l2p(dt2ms(v,0,calendar));};ax.p2d=ax.p2r=function(px,r,calendar){return ms2dt(p2l(px),r,calendar);};ax.cleanPos=function(v){return Lib.cleanDate(v,BADNUM,ax.calendar);};}else if(ax.type==='category'){// d is categories (string)\n// c and l are indices (numbers)\n// r is categories or numbers\nax.d2c=ax.d2l=setCategoryIndex;ax.r2d=ax.c2d=ax.l2d=getCategoryName;ax.d2r=ax.d2l_noadd=getCategoryPosition;ax.r2c=function(v){var index=getCategoryPosition(v);return index!==undefined?index:ax.fraction2r(0.5);};ax.l2r=ax.c2r=ensureNumber;ax.r2l=getCategoryPosition;ax.d2p=function(v){return ax.l2p(ax.r2c(v));};ax.p2d=function(px){return getCategoryName(p2l(px));};ax.r2p=ax.d2p;ax.p2r=p2l;ax.cleanPos=function(v){if(typeof v==='string'&&v!=='')return v;return ensureNumber(v);};}else if(ax.type==='multicategory'){// N.B. multicategory axes don't define d2c and d2l,\n// as 'data-to-calcdata' conversion needs to take into\n// account all data array items as in ax.makeCalcdata.\nax.r2d=ax.c2d=ax.l2d=getCategoryName;ax.d2r=ax.d2l_noadd=getCategoryPosition;ax.r2c=function(v){var index=getCategoryPosition(v);return index!==undefined?index:ax.fraction2r(0.5);};ax.r2c_just_indices=getCategoryIndex;ax.l2r=ax.c2r=ensureNumber;ax.r2l=getCategoryPosition;ax.d2p=function(v){return ax.l2p(ax.r2c(v));};ax.p2d=function(px){return getCategoryName(p2l(px));};ax.r2p=ax.d2p;ax.p2r=p2l;ax.cleanPos=function(v){if(Array.isArray(v)||typeof v==='string'&&v!=='')return v;return ensureNumber(v);};ax.setupMultiCategory=function(fullData){var traceIndices=ax._traceIndices;var i,j;var matchGroups=fullLayout._axisMatchGroups;if(matchGroups&&matchGroups.length&&ax._categories.length===0){for(i=0;i<matchGroups.length;i++){var group=matchGroups[i];if(group[axId]){for(var axId2 in group){if(axId2!==axId){var ax2=fullLayout[axisIds.id2name(axId2)];traceIndices=traceIndices.concat(ax2._traceIndices);}}}}}// [ [cnt, {$cat: index}], for 1,2 ]\nvar seen=[[0,{}],[0,{}]];// [ [arrayIn[0][i], arrayIn[1][i]], for i .. N ]\nvar list=[];for(i=0;i<traceIndices.length;i++){var trace=fullData[traceIndices[i]];if(axLetter in trace){var arrayIn=trace[axLetter];var len=trace._length||Lib.minRowLength(arrayIn);if(isArrayOrTypedArray(arrayIn[0])&&isArrayOrTypedArray(arrayIn[1])){for(j=0;j<len;j++){var v0=arrayIn[0][j];var v1=arrayIn[1][j];if(isValidCategory(v0)&&isValidCategory(v1)){list.push([v0,v1]);if(!(v0 in seen[0][1])){seen[0][1][v0]=seen[0][0]++;}if(!(v1 in seen[1][1])){seen[1][1][v1]=seen[1][0]++;}}}}}}list.sort(function(a,b){var ind0=seen[0][1];var d=ind0[a[0]]-ind0[b[0]];if(d)return d;var ind1=seen[1][1];return ind1[a[1]]-ind1[b[1]];});for(i=0;i<list.length;i++){setCategoryIndex(list[i]);}};}// find the range value at the specified (linear) fraction of the axis\nax.fraction2r=function(v){var rl0=ax.r2l(ax.range[0]);var rl1=ax.r2l(ax.range[1]);return ax.l2r(rl0+v*(rl1-rl0));};// find the fraction of the range at the specified range value\nax.r2fraction=function(v){var rl0=ax.r2l(ax.range[0]);var rl1=ax.r2l(ax.range[1]);return(ax.r2l(v)-rl0)/(rl1-rl0);};/*\n     * cleanRange: make sure range is a couplet of valid & distinct values\n     * keep numbers away from the limits of floating point numbers,\n     * and dates away from the ends of our date system (+/- 9999 years)\n     *\n     * optional param rangeAttr: operate on a different attribute, like\n     * ax._r, rather than ax.range\n     */ax.cleanRange=function(rangeAttr,opts){if(!opts)opts={};if(!rangeAttr)rangeAttr='range';var range=Lib.nestedProperty(ax,rangeAttr).get();var i,dflt;if(ax.type==='date')dflt=Lib.dfltRange(ax.calendar);else if(axLetter==='y')dflt=constants.DFLTRANGEY;else dflt=opts.dfltRange||constants.DFLTRANGEX;// make sure we don't later mutate the defaults\ndflt=dflt.slice();if(!range||range.length!==2){Lib.nestedProperty(ax,rangeAttr).set(dflt);return;}if(ax.type==='date'){// check if milliseconds or js date objects are provided for range\n// and convert to date strings\nrange[0]=Lib.cleanDate(range[0],BADNUM,ax.calendar);range[1]=Lib.cleanDate(range[1],BADNUM,ax.calendar);}for(i=0;i<2;i++){if(ax.type==='date'){if(!Lib.isDateTime(range[i],ax.calendar)){ax[rangeAttr]=dflt;break;}if(ax.r2l(range[0])===ax.r2l(range[1])){// split by +/- 1 second\nvar linCenter=Lib.constrain(ax.r2l(range[0]),Lib.MIN_MS+1000,Lib.MAX_MS-1000);range[0]=ax.l2r(linCenter-1000);range[1]=ax.l2r(linCenter+1000);break;}}else{if(!isNumeric(range[i])){if(isNumeric(range[1-i])){range[i]=range[1-i]*(i?10:0.1);}else{ax[rangeAttr]=dflt;break;}}if(range[i]<-FP_SAFE)range[i]=-FP_SAFE;else if(range[i]>FP_SAFE)range[i]=FP_SAFE;if(range[0]===range[1]){// somewhat arbitrary: split by 1 or 1ppm, whichever is bigger\nvar inc=Math.max(1,Math.abs(range[0]*1e-6));range[0]-=inc;range[1]+=inc;}}}};// set scaling to pixels\nax.setScale=function(usePrivateRange){var gs=fullLayout._size;// make sure we have a domain (pull it in from the axis\n// this one is overlaying if necessary)\nif(ax.overlaying){var ax2=axisIds.getFromId({_fullLayout:fullLayout},ax.overlaying);ax.domain=ax2.domain;}// While transitions are occuring, occurring, we get a double-transform\n// issue if we transform the drawn layer *and* use the new axis range to\n// draw the data. This allows us to construct setConvert using the pre-\n// interaction values of the range:\nvar rangeAttr=usePrivateRange&&ax._r?'_r':'range';var calendar=ax.calendar;ax.cleanRange(rangeAttr);var rl0=ax.r2l(ax[rangeAttr][0],calendar);var rl1=ax.r2l(ax[rangeAttr][1],calendar);if(axLetter==='y'){ax._offset=gs.t+(1-ax.domain[1])*gs.h;ax._length=gs.h*(ax.domain[1]-ax.domain[0]);ax._m=ax._length/(rl0-rl1);ax._b=-ax._m*rl1;}else{ax._offset=gs.l+ax.domain[0]*gs.w;ax._length=gs.w*(ax.domain[1]-ax.domain[0]);ax._m=ax._length/(rl1-rl0);ax._b=-ax._m*rl0;}if(!isFinite(ax._m)||!isFinite(ax._b)||ax._length<0){fullLayout._replotting=false;throw new Error('Something went wrong with axis scaling');}};// makeCalcdata: takes an x or y array and converts it\n// to a position on the axis object \"ax\"\n// inputs:\n//      trace - a data object from gd.data\n//      axLetter - a string, either 'x' or 'y', for which item\n//          to convert (TODO: is this now always the same as\n//          the first letter of ax._id?)\n// in case the expected data isn't there, make a list of\n// integers based on the opposite data\nax.makeCalcdata=function(trace,axLetter){var arrayIn,arrayOut,i,len;var axType=ax.type;var cal=axType==='date'&&trace[axLetter+'calendar'];if(axLetter in trace){arrayIn=trace[axLetter];len=trace._length||Lib.minRowLength(arrayIn);if(Lib.isTypedArray(arrayIn)&&(axType==='linear'||axType==='log')){if(len===arrayIn.length){return arrayIn;}else if(arrayIn.subarray){return arrayIn.subarray(0,len);}}if(axType==='multicategory'){return setMultiCategoryIndex(arrayIn,len);}arrayOut=new Array(len);for(i=0;i<len;i++){arrayOut[i]=ax.d2c(arrayIn[i],0,cal);}}else{var v0=axLetter+'0'in trace?ax.d2c(trace[axLetter+'0'],0,cal):0;var dv=trace['d'+axLetter]?Number(trace['d'+axLetter]):1;// the opposing data, for size if we have x and dx etc\narrayIn=trace[{x:'y',y:'x'}[axLetter]];len=trace._length||arrayIn.length;arrayOut=new Array(len);for(i=0;i<len;i++){arrayOut[i]=v0+i*dv;}}return arrayOut;};ax.isValidRange=function(range){return Array.isArray(range)&&range.length===2&&isNumeric(ax.r2l(range[0]))&&isNumeric(ax.r2l(range[1]));};ax.isPtWithinRange=function(d,calendar){var coord=ax.c2l(d[axLetter],null,calendar);var r0=ax.r2l(ax.range[0]);var r1=ax.r2l(ax.range[1]);if(r0<r1){return r0<=coord&&coord<=r1;}else{// Reversed axis case.\nreturn r1<=coord&&coord<=r0;}};// should skip if not category nor multicategory\nax.clearCalc=function(){var emptyCategories=function emptyCategories(){ax._categories=[];ax._categoriesMap={};};var matchGroups=fullLayout._axisMatchGroups;if(matchGroups&&matchGroups.length){var found=false;for(var i=0;i<matchGroups.length;i++){var group=matchGroups[i];if(group[axId]){found=true;var categories=null;var categoriesMap=null;for(var axId2 in group){var ax2=fullLayout[axisIds.id2name(axId2)];if(ax2._categories){categories=ax2._categories;categoriesMap=ax2._categoriesMap;break;}}if(categories&&categoriesMap){ax._categories=categories;ax._categoriesMap=categoriesMap;}else{emptyCategories();}break;}}if(!found)emptyCategories();}else{emptyCategories();}if(ax._initialCategories){for(var j=0;j<ax._initialCategories.length;j++){setCategoryIndex(ax._initialCategories[j]);}}};// Propagate localization into the axis so that\n// methods in Axes can use it w/o having to pass fullLayout\n// Default (non-d3) number formatting uses separators directly\n// dates and d3-formatted numbers use the d3 locale\n// Fall back on default format for dummy axes that don't care about formatting\nvar locale=fullLayout._d3locale;if(ax.type==='date'){ax._dateFormat=locale?locale.timeFormat.utc:d3.time.format.utc;ax._extraFormat=fullLayout._extraFormat;}// occasionally we need _numFormat to pass through\n// even though it won't be needed by this axis\nax._separators=fullLayout.separators;ax._numFormat=locale?locale.numberFormat:d3.format;// and for bar charts and box plots: reset forced minimum tick spacing\ndelete ax._minDtick;delete ax._forceTick0;};},{\"../../constants/numerical\":140,\"../../lib\":159,\"./axis_ids\":206,\"./constants\":209,\"d3\":8,\"fast-isnumeric\":10}],222:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var layoutAttributes=_dereq_('./layout_attributes');var handleArrayContainerDefaults=_dereq_('../array_container_defaults');module.exports=function handleTickLabelDefaults(containerIn,containerOut,coerce,axType,options){var showAttrDflt=getShowAttrDflt(containerIn);var tickPrefix=coerce('tickprefix');if(tickPrefix)coerce('showtickprefix',showAttrDflt);var tickSuffix=coerce('ticksuffix',options.tickSuffixDflt);if(tickSuffix)coerce('showticksuffix',showAttrDflt);var showTickLabels=coerce('showticklabels');if(showTickLabels){var font=options.font||{};var contColor=containerOut.color;// as with titlefont.color, inherit axis.color only if one was\n// explicitly provided\nvar dfltFontColor=contColor&&contColor!==layoutAttributes.color.dflt?contColor:font.color;Lib.coerceFont(coerce,'tickfont',{family:font.family,size:font.size,color:dfltFontColor});coerce('tickangle');if(axType!=='category'){var tickFormat=coerce('tickformat');var tickformatStops=containerIn.tickformatstops;if(Array.isArray(tickformatStops)&&tickformatStops.length){handleArrayContainerDefaults(containerIn,containerOut,{name:'tickformatstops',inclusionAttr:'enabled',handleItemDefaults:tickformatstopDefaults});}if(!tickFormat&&axType!=='date'){coerce('showexponent',showAttrDflt);coerce('exponentformat');coerce('separatethousands');}}}};/*\n * Attributes 'showexponent', 'showtickprefix' and 'showticksuffix'\n * share values.\n *\n * If only 1 attribute is set,\n * the remaining attributes inherit that value.\n *\n * If 2 attributes are set to the same value,\n * the remaining attribute inherits that value.\n *\n * If 2 attributes are set to different values,\n * the remaining is set to its dflt value.\n *\n */function getShowAttrDflt(containerIn){var showAttrsAll=['showexponent','showtickprefix','showticksuffix'];var showAttrs=showAttrsAll.filter(function(a){return containerIn[a]!==undefined;});var sameVal=function sameVal(a){return containerIn[a]===containerIn[showAttrs[0]];};if(showAttrs.every(sameVal)||showAttrs.length===1){return containerIn[showAttrs[0]];}}function tickformatstopDefaults(valueIn,valueOut){function coerce(attr,dflt){return Lib.coerce(valueIn,valueOut,layoutAttributes.tickformatstops,attr,dflt);}var enabled=coerce('enabled');if(enabled){coerce('dtickrange');coerce('value');}}},{\"../../lib\":159,\"../array_container_defaults\":199,\"./layout_attributes\":215}],223:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var layoutAttributes=_dereq_('./layout_attributes');/**\n * options: inherits outerTicks from axes.handleAxisDefaults\n */module.exports=function handleTickDefaults(containerIn,containerOut,coerce,options){var tickLen=Lib.coerce2(containerIn,containerOut,layoutAttributes,'ticklen');var tickWidth=Lib.coerce2(containerIn,containerOut,layoutAttributes,'tickwidth');var tickColor=Lib.coerce2(containerIn,containerOut,layoutAttributes,'tickcolor',containerOut.color);var showTicks=coerce('ticks',options.outerTicks||tickLen||tickWidth||tickColor?'outside':'');if(!showTicks){delete containerOut.ticklen;delete containerOut.tickwidth;delete containerOut.tickcolor;}};},{\"../../lib\":159,\"./layout_attributes\":215}],224:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var cleanTicks=_dereq_('./clean_ticks');module.exports=function handleTickValueDefaults(containerIn,containerOut,coerce,axType){var tickmode;if(containerIn.tickmode==='array'&&(axType==='log'||axType==='date')){tickmode=containerOut.tickmode='auto';}else{var tickmodeDefault=Array.isArray(containerIn.tickvals)?'array':containerIn.dtick?'linear':'auto';tickmode=coerce('tickmode',tickmodeDefault);}if(tickmode==='auto')coerce('nticks');else if(tickmode==='linear'){// dtick is usually a positive number, but there are some\n// special strings available for log or date axes\n// tick0 also has special logic\nvar dtick=containerOut.dtick=cleanTicks.dtick(containerIn.dtick,axType);containerOut.tick0=cleanTicks.tick0(containerIn.tick0,axType,containerOut.calendar,dtick);}else if(axType!=='multicategory'){var tickvals=coerce('tickvals');if(tickvals===undefined)containerOut.tickmode='auto';else coerce('ticktext');}};},{\"./clean_ticks\":208}],225:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var Registry=_dereq_('../../registry');var Drawing=_dereq_('../../components/drawing');var Axes=_dereq_('./axes');/**\n * transitionAxes\n *\n * transition axes from one set of ranges to another, using a svg\n * transformations, similar to during panning.\n *\n * @param {DOM element | object} gd\n * @param {array} edits : array of 'edits', each item with\n * - plotinfo {object} subplot object\n * - xr0 {array} initial x-range\n * - xr1 {array} end x-range\n * - yr0 {array} initial y-range\n * - yr1 {array} end y-range\n * @param {object} transitionOpts\n * @param {function} makeOnCompleteCallback\n */module.exports=function transitionAxes(gd,edits,transitionOpts,makeOnCompleteCallback){var fullLayout=gd._fullLayout;// special case for redraw:false Plotly.animate that relies on this\n// to update axis-referenced layout components\nif(edits.length===0){Axes.redrawComponents(gd);return;}function unsetSubplotTransform(subplot){var xa=subplot.xaxis;var ya=subplot.yaxis;fullLayout._defs.select('#'+subplot.clipId+'> rect').call(Drawing.setTranslate,0,0).call(Drawing.setScale,1,1);subplot.plot.call(Drawing.setTranslate,xa._offset,ya._offset).call(Drawing.setScale,1,1);var traceGroups=subplot.plot.selectAll('.scatterlayer .trace');// This is specifically directed at scatter traces, applying an inverse\n// scale to individual points to counteract the scale of the trace\n// as a whole:\ntraceGroups.selectAll('.point').call(Drawing.setPointGroupScale,1,1);traceGroups.selectAll('.textpoint').call(Drawing.setTextPointsScale,1,1);traceGroups.call(Drawing.hideOutsideRangePoints,subplot);}function updateSubplot(edit,progress){var plotinfo=edit.plotinfo;var xa=plotinfo.xaxis;var ya=plotinfo.yaxis;var xr0=edit.xr0;var xr1=edit.xr1;var xlen=xa._length;var yr0=edit.yr0;var yr1=edit.yr1;var ylen=ya._length;var editX=!!xr1;var editY=!!yr1;var viewBox=[];if(editX){var dx0=xr0[1]-xr0[0];var dx1=xr1[1]-xr1[0];viewBox[0]=(xr0[0]*(1-progress)+progress*xr1[0]-xr0[0])/(xr0[1]-xr0[0])*xlen;viewBox[2]=xlen*(1-progress+progress*dx1/dx0);xa.range[0]=xr0[0]*(1-progress)+progress*xr1[0];xa.range[1]=xr0[1]*(1-progress)+progress*xr1[1];}else{viewBox[0]=0;viewBox[2]=xlen;}if(editY){var dy0=yr0[1]-yr0[0];var dy1=yr1[1]-yr1[0];viewBox[1]=(yr0[1]*(1-progress)+progress*yr1[1]-yr0[1])/(yr0[0]-yr0[1])*ylen;viewBox[3]=ylen*(1-progress+progress*dy1/dy0);ya.range[0]=yr0[0]*(1-progress)+progress*yr1[0];ya.range[1]=yr0[1]*(1-progress)+progress*yr1[1];}else{viewBox[1]=0;viewBox[3]=ylen;}Axes.drawOne(gd,xa,{skipTitle:true});Axes.drawOne(gd,ya,{skipTitle:true});Axes.redrawComponents(gd,[xa._id,ya._id]);var xScaleFactor=editX?xlen/viewBox[2]:1;var yScaleFactor=editY?ylen/viewBox[3]:1;var clipDx=editX?viewBox[0]:0;var clipDy=editY?viewBox[1]:0;var fracDx=editX?viewBox[0]/viewBox[2]*xlen:0;var fracDy=editY?viewBox[1]/viewBox[3]*ylen:0;var plotDx=xa._offset-fracDx;var plotDy=ya._offset-fracDy;plotinfo.clipRect.call(Drawing.setTranslate,clipDx,clipDy).call(Drawing.setScale,1/xScaleFactor,1/yScaleFactor);plotinfo.plot.call(Drawing.setTranslate,plotDx,plotDy).call(Drawing.setScale,xScaleFactor,yScaleFactor);// apply an inverse scale to individual points to counteract\n// the scale of the trace group.\nDrawing.setPointGroupScale(plotinfo.zoomScalePts,1/xScaleFactor,1/yScaleFactor);Drawing.setTextPointsScale(plotinfo.zoomScaleTxt,1/xScaleFactor,1/yScaleFactor);}var onComplete;if(makeOnCompleteCallback){// This module makes the choice whether or not it notifies Plotly.transition\n// about completion:\nonComplete=makeOnCompleteCallback();}function transitionComplete(){var aobj={};for(var i=0;i<edits.length;i++){var edit=edits[i];if(edit.xr1)aobj[edit.plotinfo.xaxis._name+'.range']=edit.xr1.slice();if(edit.yr1)aobj[edit.plotinfo.yaxis._name+'.range']=edit.yr1.slice();}// Signal that this transition has completed:\nonComplete&&onComplete();return Registry.call('relayout',gd,aobj).then(function(){for(var i=0;i<edits.length;i++){unsetSubplotTransform(edits[i].plotinfo);}});}function transitionInterrupt(){var aobj={};for(var i=0;i<edits.length;i++){var edit=edits[i];if(edit.xr0)aobj[edit.plotinfo.xaxis._name+'.range']=edit.xr0.slice();if(edit.yr0)aobj[edit.plotinfo.yaxis._name+'.range']=edit.yr0.slice();}return Registry.call('relayout',gd,aobj).then(function(){for(var i=0;i<edits.length;i++){unsetSubplotTransform(edits[i].plotinfo);}});}var t1,t2,raf;var easeFn=d3.ease(transitionOpts.easing);gd._transitionData._interruptCallbacks.push(function(){window.cancelAnimationFrame(raf);raf=null;return transitionInterrupt();});function doFrame(){t2=Date.now();var tInterp=Math.min(1,(t2-t1)/transitionOpts.duration);var progress=easeFn(tInterp);for(var i=0;i<edits.length;i++){updateSubplot(edits[i],progress);}if(t2-t1>transitionOpts.duration){transitionComplete();raf=window.cancelAnimationFrame(doFrame);}else{raf=window.requestAnimationFrame(doFrame);}}t1=Date.now();raf=window.requestAnimationFrame(doFrame);return Promise.resolve();};},{\"../../components/drawing\":64,\"../../registry\":242,\"./axes\":203,\"d3\":8}],226:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var traceIs=_dereq_('../../registry').traceIs;var autoType=_dereq_('./axis_autotype');/*\n *  data: the plot data to use in choosing auto type\n *  name: axis object name (ie 'xaxis') if one should be stored\n */module.exports=function handleTypeDefaults(containerIn,containerOut,coerce,options){var axType=coerce('type',(options.splomStash||{}).type);if(axType==='-'){setAutoType(containerOut,options.data);if(containerOut.type==='-'){containerOut.type='linear';}else{// copy autoType back to input axis\n// note that if this object didn't exist\n// in the input layout, we have to put it in\n// this happens in the main supplyDefaults function\ncontainerIn.type=containerOut.type;}}};function setAutoType(ax,data){// new logic: let people specify any type they want,\n// only autotype if type is '-'\nif(ax.type!=='-')return;var id=ax._id;var axLetter=id.charAt(0);// support 3d\nif(id.indexOf('scene')!==-1)id=axLetter;var d0=getFirstNonEmptyTrace(data,id,axLetter);if(!d0)return;// first check for histograms, as the count direction\n// should always default to a linear axis\nif(d0.type==='histogram'&&axLetter==={v:'y',h:'x'}[d0.orientation||'v']){ax.type='linear';return;}var calAttr=axLetter+'calendar';var calendar=d0[calAttr];var opts={noMultiCategory:!traceIs(d0,'cartesian')||traceIs(d0,'noMultiCategory')};var i;// check all boxes on this x axis to see\n// if they're dates, numbers, or categories\nif(isBoxWithoutPositionCoords(d0,axLetter)){var posLetter=getBoxPosLetter(d0);var boxPositions=[];for(i=0;i<data.length;i++){var trace=data[i];if(!traceIs(trace,'box-violin')||(trace[axLetter+'axis']||axLetter)!==id)continue;if(trace[posLetter]!==undefined)boxPositions.push(trace[posLetter][0]);else if(trace.name!==undefined)boxPositions.push(trace.name);else boxPositions.push('text');if(trace[calAttr]!==calendar)calendar=undefined;}ax.type=autoType(boxPositions,calendar,opts);}else if(d0.type==='splom'){var dimensions=d0.dimensions;var diag=d0._diag;for(i=0;i<dimensions.length;i++){var dim=dimensions[i];if(dim.visible&&(diag[i][0]===id||diag[i][1]===id)){ax.type=autoType(dim.values,calendar,opts);break;}}}else{ax.type=autoType(d0[axLetter]||[d0[axLetter+'0']],calendar,opts);}}function getFirstNonEmptyTrace(data,id,axLetter){for(var i=0;i<data.length;i++){var trace=data[i];if(trace.type==='splom'&&trace._length>0&&(trace['_'+axLetter+'axes']||{})[id]){return trace;}if((trace[axLetter+'axis']||axLetter)===id){if(isBoxWithoutPositionCoords(trace,axLetter)){return trace;}else if((trace[axLetter]||[]).length||trace[axLetter+'0']){return trace;}}}}function getBoxPosLetter(trace){return{v:'x',h:'y'}[trace.orientation||'v'];}function isBoxWithoutPositionCoords(trace,axLetter){var posLetter=getBoxPosLetter(trace);var isBox=traceIs(trace,'box-violin');var isCandlestick=traceIs(trace._fullInput||{},'candlestick');return isBox&&!isCandlestick&&axLetter===posLetter&&trace[posLetter]===undefined&&trace[posLetter+'0']===undefined;}},{\"../../registry\":242,\"./axis_autotype\":204}],227:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Registry=_dereq_('../registry');var Lib=_dereq_('../lib');/*\n * Create or update an observer. This function is designed to be\n * idempotent so that it can be called over and over as the component\n * updates, and will attach and detach listeners as needed.\n *\n * @param {optional object} container\n *      An object on which the observer is stored. This is the mechanism\n *      by which it is idempotent. If it already exists, another won't be\n *      added. Each time it's called, the value lookup table is updated.\n * @param {array} commandList\n *      An array of commands, following either `buttons` of `updatemenus`\n *      or `steps` of `sliders`.\n * @param {function} onchange\n *      A listener called when the value is changed. Receives data object\n *      with information about the new state.\n */exports.manageCommandObserver=function(gd,container,commandList,onchange){var ret={};var enabled=true;if(container&&container._commandObserver){ret=container._commandObserver;}if(!ret.cache){ret.cache={};}// Either create or just recompute this:\nret.lookupTable={};var binding=exports.hasSimpleAPICommandBindings(gd,commandList,ret.lookupTable);if(container&&container._commandObserver){if(!binding){// If container exists and there are no longer any bindings,\n// remove existing:\nif(container._commandObserver.remove){container._commandObserver.remove();container._commandObserver=null;return ret;}}else{// If container exists and there *are* bindings, then the lookup\n// table should have been updated and check is already attached,\n// so there's nothing to be done:\nreturn ret;}}// Determine whether there's anything to do for this binding:\nif(binding){// Build the cache:\nbindingValueHasChanged(gd,binding,ret.cache);ret.check=function check(){if(!enabled)return;var update=bindingValueHasChanged(gd,binding,ret.cache);if(update.changed&&onchange){// Disable checks for the duration of this command in order to avoid\n// infinite loops:\nif(ret.lookupTable[update.value]!==undefined){ret.disable();Promise.resolve(onchange({value:update.value,type:binding.type,prop:binding.prop,traces:binding.traces,index:ret.lookupTable[update.value]})).then(ret.enable,ret.enable);}}return update.changed;};var checkEvents=['plotly_relayout','plotly_redraw','plotly_restyle','plotly_update','plotly_animatingframe','plotly_afterplot'];for(var i=0;i<checkEvents.length;i++){gd._internalOn(checkEvents[i],ret.check);}ret.remove=function(){for(var i=0;i<checkEvents.length;i++){gd._removeInternalListener(checkEvents[i],ret.check);}};}else{// TODO: It'd be really neat to actually give a *reason* for this, but at least a warning\n// is a start\nLib.log('Unable to automatically bind plot updates to API command');ret.lookupTable={};ret.remove=function(){};}ret.disable=function disable(){enabled=false;};ret.enable=function enable(){enabled=true;};if(container){container._commandObserver=ret;}return ret;};/*\n * This function checks to see if an array of objects containing\n * method and args properties is compatible with automatic two-way\n * binding. The criteria right now are that\n *\n *   1. multiple traces may be affected\n *   2. only one property may be affected\n *   3. the same property must be affected by all commands\n */exports.hasSimpleAPICommandBindings=function(gd,commandList,bindingsByValue){var i;var n=commandList.length;var refBinding;for(i=0;i<n;i++){var binding;var command=commandList[i];var method=command.method;var args=command.args;if(!Array.isArray(args))args=[];// If any command has no method, refuse to bind:\nif(!method){return false;}var bindings=exports.computeAPICommandBindings(gd,method,args);// Right now, handle one and *only* one property being set:\nif(bindings.length!==1){return false;}if(!refBinding){refBinding=bindings[0];if(Array.isArray(refBinding.traces)){refBinding.traces.sort();}}else{binding=bindings[0];if(binding.type!==refBinding.type){return false;}if(binding.prop!==refBinding.prop){return false;}if(Array.isArray(refBinding.traces)){if(Array.isArray(binding.traces)){binding.traces.sort();for(var j=0;j<refBinding.traces.length;j++){if(refBinding.traces[j]!==binding.traces[j]){return false;}}}else{return false;}}else{if(binding.prop!==refBinding.prop){return false;}}}binding=bindings[0];var value=binding.value;if(Array.isArray(value)){if(value.length===1){value=value[0];}else{return false;}}if(bindingsByValue){bindingsByValue[value]=i;}}return refBinding;};function bindingValueHasChanged(gd,binding,cache){var container,value,obj;var changed=false;if(binding.type==='data'){// If it's data, we need to get a trace. Based on the limited scope\n// of what we cover, we can just take the first trace from the list,\n// or otherwise just the first trace:\ncontainer=gd._fullData[binding.traces!==null?binding.traces[0]:0];}else if(binding.type==='layout'){container=gd._fullLayout;}else{return false;}value=Lib.nestedProperty(container,binding.prop).get();obj=cache[binding.type]=cache[binding.type]||{};if(obj.hasOwnProperty(binding.prop)){if(obj[binding.prop]!==value){changed=true;}}obj[binding.prop]=value;return{changed:changed,value:value};}/*\n * Execute an API command. There's really not much to this; it just provides\n * a common hook so that implementations don't need to be synchronized across\n * multiple components with the ability to invoke API commands.\n *\n * @param {string} method\n *      The name of the plotly command to execute. Must be one of 'animate',\n *      'restyle', 'relayout', 'update'.\n * @param {array} args\n *      A list of arguments passed to the API command\n */exports.executeAPICommand=function(gd,method,args){if(method==='skip')return Promise.resolve();var _method=Registry.apiMethodRegistry[method];var allArgs=[gd];if(!Array.isArray(args))args=[];for(var i=0;i<args.length;i++){allArgs.push(args[i]);}return _method.apply(null,allArgs)[\"catch\"](function(err){Lib.warn('API call to Plotly.'+method+' rejected.',err);return Promise.reject(err);});};exports.computeAPICommandBindings=function(gd,method,args){var bindings;if(!Array.isArray(args))args=[];switch(method){case'restyle':bindings=computeDataBindings(gd,args);break;case'relayout':bindings=computeLayoutBindings(gd,args);break;case'update':bindings=computeDataBindings(gd,[args[0],args[2]]).concat(computeLayoutBindings(gd,[args[1]]));break;case'animate':bindings=computeAnimateBindings(gd,args);break;default:// This is the case where intelligent logic about what affects\n// this command is not implemented. It causes no ill effects.\n// For example, addFrames simply won't bind to a control component.\nbindings=[];}return bindings;};function computeAnimateBindings(gd,args){// We'll assume that the only relevant modification an animation\n// makes that's meaningfully tracked is the frame:\nif(Array.isArray(args[0])&&args[0].length===1&&['string','number'].indexOf(_typeof(args[0][0]))!==-1){return[{type:'layout',prop:'_currentFrame',value:args[0][0].toString()}];}else{return[];}}function computeLayoutBindings(gd,args){var bindings=[];var astr=args[0];var aobj={};if(typeof astr==='string'){aobj[astr]=args[1];}else if(Lib.isPlainObject(astr)){aobj=astr;}else{return bindings;}crawl(aobj,function(path,attrName,attr){bindings.push({type:'layout',prop:path,value:attr});},'',0);return bindings;}function computeDataBindings(gd,args){var traces,astr,val,aobj;var bindings=[];// Logic copied from Plotly.restyle:\nastr=args[0];val=args[1];traces=args[2];aobj={};if(typeof astr==='string'){aobj[astr]=val;}else if(Lib.isPlainObject(astr)){// the 3-arg form\naobj=astr;if(traces===undefined){traces=val;}}else{return bindings;}if(traces===undefined){// Explicitly assign this to null instead of undefined:\ntraces=null;}crawl(aobj,function(path,attrName,attr){var thisTraces;if(Array.isArray(attr)){var nAttr=Math.min(attr.length,gd.data.length);if(traces){nAttr=Math.min(nAttr,traces.length);}thisTraces=[];for(var j=0;j<nAttr;j++){thisTraces[j]=traces?traces[j]:j;}}else{thisTraces=traces?traces.slice(0):null;}// Convert [7] to just 7 when traces is null:\nif(thisTraces===null){if(Array.isArray(attr)){attr=attr[0];}}else if(Array.isArray(thisTraces)){if(!Array.isArray(attr)){var tmp=attr;attr=[];for(var i=0;i<thisTraces.length;i++){attr[i]=tmp;}}attr.length=Math.min(thisTraces.length,attr.length);}bindings.push({type:'data',prop:path,traces:thisTraces,value:attr});},'',0);return bindings;}function crawl(attrs,callback,path,depth){Object.keys(attrs).forEach(function(attrName){var attr=attrs[attrName];if(attrName[0]==='_')return;var thisPath=path+(depth>0?'.':'')+attrName;if(Lib.isPlainObject(attr)){crawl(attr,callback,thisPath,depth+1);}else{// Only execute the callback on leaf nodes:\ncallback(thisPath,attrName,attr);}});}},{\"../lib\":159,\"../registry\":242}],228:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var extendFlat=_dereq_('../lib/extend').extendFlat;/**\n * Make a xy domain attribute group\n *\n * @param {object} opts\n *   @param {string}\n *     opts.name: name to be inserted in the default description\n *   @param {boolean}\n *     opts.trace: set to true for trace containers\n *   @param {string}\n *     opts.editType: editType for all pieces\n *   @param {boolean}\n *     opts.noGridCell: set to true to omit `row` and `column`\n *\n * @param {object} extra\n *   @param {string}\n *     extra.description: extra description. N.B we use\n *     a separate extra container to make it compatible with\n *     the compress_attributes transform.\n *\n * @return {object} attributes object containing {x,y} as specified\n */exports.attributes=function(opts,extra){opts=opts||{};extra=extra||{};var base={valType:'info_array',editType:opts.editType,items:[{valType:'number',min:0,max:1,editType:opts.editType},{valType:'number',min:0,max:1,editType:opts.editType}],dflt:[0,1]};var namePart=opts.name?opts.name+' ':'';var contPart=opts.trace?'trace ':'subplot ';var descPart=extra.description?' '+extra.description:'';var out={x:extendFlat({},base,{}),y:extendFlat({},base,{}),editType:opts.editType};if(!opts.noGridCell){out.row={valType:'integer',min:0,dflt:0,editType:opts.editType};out.column={valType:'integer',min:0,dflt:0,editType:opts.editType};}return out;};exports.defaults=function(containerOut,layout,coerce,dfltDomains){var dfltX=dfltDomains&&dfltDomains.x||[0,1];var dfltY=dfltDomains&&dfltDomains.y||[0,1];var grid=layout.grid;if(grid){var column=coerce('domain.column');if(column!==undefined){if(column<grid.columns)dfltX=grid._domains.x[column];else delete containerOut.domain.column;}var row=coerce('domain.row');if(row!==undefined){if(row<grid.rows)dfltY=grid._domains.y[row];else delete containerOut.domain.row;}}coerce('domain.x',dfltX);coerce('domain.y',dfltY);};},{\"../lib/extend\":153}],229:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';/*\n * make a font attribute group\n *\n * @param {object} opts\n *   @param {string}\n *     opts.description: where & how this font is used\n *   @param {optional bool} arrayOk:\n *     should each part (family, size, color) be arrayOk? default false.\n *   @param {string} editType:\n *     the editType for all pieces of this font\n *   @param {optional string} colorEditType:\n *     a separate editType just for color\n *\n * @return {object} attributes object containing {family, size, color} as specified\n */module.exports=function(opts){var editType=opts.editType;var colorEditType=opts.colorEditType;if(colorEditType===undefined)colorEditType=editType;var attrs={family:{valType:'string',noBlank:true,strict:true,editType:editType},size:{valType:'number',min:1,editType:editType},color:{valType:'color',editType:colorEditType},editType:editType// blank strings so compress_attributes can remove\n// TODO - that's uber hacky... better solution?\n};if(opts.arrayOk){attrs.family.arrayOk=true;attrs.size.arrayOk=true;attrs.color.arrayOk=true;}return attrs;};},{}],230:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports={_isLinkedToArray:'frames_entry',group:{valType:'string'},name:{valType:'string'},traces:{valType:'any'},baseframe:{valType:'string'},data:{valType:'any'},layout:{valType:'any'}};},{}],231:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Registry=_dereq_('../registry');var SUBPLOT_PATTERN=_dereq_('./cartesian/constants').SUBPLOT_PATTERN;/**\n * Get calcdata trace(s) associated with a given subplot\n *\n * @param {array} calcData: as in gd.calcdata\n * @param {string} type: subplot type\n * @param {string} subplotId: subplot id to look for\n *\n * @return {array} array of calcdata traces\n */exports.getSubplotCalcData=function(calcData,type,subplotId){var basePlotModule=Registry.subplotsRegistry[type];if(!basePlotModule)return[];var attr=basePlotModule.attr;var subplotCalcData=[];for(var i=0;i<calcData.length;i++){var calcTrace=calcData[i];var trace=calcTrace[0].trace;if(trace[attr]===subplotId)subplotCalcData.push(calcTrace);}return subplotCalcData;};/**\n * Get calcdata trace(s) that can be plotted with a given module\n * NOTE: this isn't necessarily just exactly matching trace type,\n * if multiple trace types use the same plotting routine, they will be\n * collected here.\n * In order to not plot the same thing multiple times, we return two arrays,\n * the calcdata we *will* plot with this module, and the ones we *won't*\n *\n * @param {array} calcdata: as in gd.calcdata\n * @param {object|string|fn} arg1:\n *  the plotting module, or its name, or its plot method\n *\n * @return {array[array]} [foundCalcdata, remainingCalcdata]\n */exports.getModuleCalcData=function(calcdata,arg1){var moduleCalcData=[];var remainingCalcData=[];var plotMethod;if(typeof arg1==='string'){plotMethod=Registry.getModule(arg1).plot;}else if(typeof arg1==='function'){plotMethod=arg1;}else{plotMethod=arg1.plot;}if(!plotMethod){return[moduleCalcData,calcdata];}for(var i=0;i<calcdata.length;i++){var cd=calcdata[i];var trace=cd[0].trace;// N.B. 'legendonly' traces do not make it past here\nif(trace.visible!==true)continue;// group calcdata trace not by 'module' (as the name of this function\n// would suggest), but by 'module plot method' so that if some traces\n// share the same module plot method (e.g. bar and histogram), we\n// only call it one!\nif(trace._module.plot===plotMethod){moduleCalcData.push(cd);}else{remainingCalcData.push(cd);}}return[moduleCalcData,remainingCalcData];};/**\n * Get the data trace(s) associated with a given subplot.\n *\n * @param {array} data  plotly full data array.\n * @param {string} type subplot type to look for.\n * @param {string} subplotId subplot id to look for.\n *\n * @return {array} list of trace objects.\n *\n */exports.getSubplotData=function getSubplotData(data,type,subplotId){if(!Registry.subplotsRegistry[type])return[];var attr=Registry.subplotsRegistry[type].attr;var subplotData=[];var trace,subplotX,subplotY;if(type==='gl2d'){var spmatch=subplotId.match(SUBPLOT_PATTERN);subplotX='x'+spmatch[1];subplotY='y'+spmatch[2];}for(var i=0;i<data.length;i++){trace=data[i];if(type==='gl2d'&&Registry.traceIs(trace,'gl2d')){if(trace[attr[0]]===subplotX&&trace[attr[1]]===subplotY){subplotData.push(trace);}}else{if(trace[attr]===subplotId)subplotData.push(trace);}}return subplotData;};},{\"../registry\":242,\"./cartesian/constants\":209}],232:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';function xformMatrix(m,v){var out=[0,0,0,0];var i,j;for(i=0;i<4;++i){for(j=0;j<4;++j){out[j]+=m[4*i+j]*v[i];}}return out;}function project(camera,v){var p=xformMatrix(camera.projection,xformMatrix(camera.view,xformMatrix(camera.model,[v[0],v[1],v[2],1])));return p;}module.exports=project;},{}],233:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var fontAttrs=_dereq_('./font_attributes');var animationAttrs=_dereq_('./animation_attributes');var colorAttrs=_dereq_('../components/color/attributes');var colorscaleAttrs=_dereq_('../components/colorscale/layout_attributes');var padAttrs=_dereq_('./pad_attributes');var extendFlat=_dereq_('../lib/extend').extendFlat;var globalFont=fontAttrs({editType:'calc'});globalFont.family.dflt='\"Open Sans\", verdana, arial, sans-serif';globalFont.size.dflt=12;globalFont.color.dflt=colorAttrs.defaultLine;module.exports={font:globalFont,title:{text:{valType:'string',editType:'layoutstyle'},font:fontAttrs({editType:'layoutstyle'}),xref:{valType:'enumerated',dflt:'container',values:['container','paper'],editType:'layoutstyle'},yref:{valType:'enumerated',dflt:'container',values:['container','paper'],editType:'layoutstyle'},x:{valType:'number',min:0,max:1,dflt:0.5,editType:'layoutstyle'},y:{valType:'number',min:0,max:1,dflt:'auto',editType:'layoutstyle'},xanchor:{valType:'enumerated',dflt:'auto',values:['auto','left','center','right'],editType:'layoutstyle'},yanchor:{valType:'enumerated',dflt:'auto',values:['auto','top','middle','bottom'],editType:'layoutstyle'},pad:extendFlat(padAttrs({editType:'layoutstyle'}),{}),editType:'layoutstyle'},autosize:{valType:'boolean',dflt:false,// autosize, width, and height get special editType treatment in _relayout\n// so we can handle noop resizes more efficiently\neditType:'none'},width:{valType:'number',min:10,dflt:700,editType:'plot'},height:{valType:'number',min:10,dflt:450,editType:'plot'},margin:{l:{valType:'number',min:0,dflt:80,editType:'plot'},r:{valType:'number',min:0,dflt:80,editType:'plot'},t:{valType:'number',min:0,dflt:100,editType:'plot'},b:{valType:'number',min:0,dflt:80,editType:'plot'},pad:{valType:'number',min:0,dflt:0,editType:'plot'},autoexpand:{valType:'boolean',dflt:true,editType:'plot'},editType:'plot'},paper_bgcolor:{valType:'color',dflt:colorAttrs.background,editType:'plot'},plot_bgcolor:{// defined here, but set in cartesian.supplyLayoutDefaults\n// because it needs to know if there are (2D) axes or not\nvalType:'color',dflt:colorAttrs.background,editType:'layoutstyle'},separators:{valType:'string',editType:'plot'},hidesources:{valType:'boolean',dflt:false,editType:'plot'},showlegend:{// handled in legend.supplyLayoutDefaults\n// but included here because it's not in the legend object\nvalType:'boolean',editType:'legend'},colorway:{valType:'colorlist',dflt:colorAttrs.defaults,editType:'calc'},colorscale:colorscaleAttrs,datarevision:{valType:'any',editType:'calc'},uirevision:{valType:'any',editType:'none'},editrevision:{valType:'any',editType:'none'},selectionrevision:{valType:'any',editType:'none'},template:{valType:'any',editType:'calc'},modebar:{orientation:{valType:'enumerated',values:['v','h'],dflt:'h',editType:'modebar'},bgcolor:{valType:'color',editType:'modebar'},color:{valType:'color',editType:'modebar'},activecolor:{valType:'color',editType:'modebar'},uirevision:{valType:'any',editType:'none'},editType:'modebar'},meta:{valType:'data_array',editType:'plot'},transition:extendFlat({},animationAttrs.transition,{editType:'none'}),_deprecated:{title:{valType:'string',editType:'layoutstyle'},titlefont:fontAttrs({editType:'layoutstyle'})}};},{\"../components/color/attributes\":42,\"../components/colorscale/layout_attributes\":56,\"../lib/extend\":153,\"./animation_attributes\":198,\"./font_attributes\":229,\"./pad_attributes\":234}],234:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';/**\n * Creates a set of padding attributes.\n *\n * @param {object} opts\n *   @param {string} editType:\n *     the editType for all pieces of this padding definition\n *\n * @return {object} attributes object containing {t, r, b, l} as specified\n */module.exports=function(opts){var editType=opts.editType;return{t:{valType:'number',dflt:0,editType:editType},r:{valType:'number',dflt:0,editType:editType},b:{valType:'number',dflt:0,editType:editType},l:{valType:'number',dflt:0,editType:editType},editType:editType};};},{}],235:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var isNumeric=_dereq_('fast-isnumeric');var Registry=_dereq_('../registry');var PlotSchema=_dereq_('../plot_api/plot_schema');var Template=_dereq_('../plot_api/plot_template');var Lib=_dereq_('../lib');var Color=_dereq_('../components/color');var BADNUM=_dereq_('../constants/numerical').BADNUM;var axisIDs=_dereq_('./cartesian/axis_ids');var animationAttrs=_dereq_('./animation_attributes');var frameAttrs=_dereq_('./frame_attributes');var relinkPrivateKeys=Lib.relinkPrivateKeys;var _=Lib._;var plots=module.exports={};// Expose registry methods on Plots for backward-compatibility\nLib.extendFlat(plots,Registry);plots.attributes=_dereq_('./attributes');plots.attributes.type.values=plots.allTypes;plots.fontAttrs=_dereq_('./font_attributes');plots.layoutAttributes=_dereq_('./layout_attributes');// TODO make this a plot attribute?\nplots.fontWeight='normal';var transformsRegistry=plots.transformsRegistry;var commandModule=_dereq_('./command');plots.executeAPICommand=commandModule.executeAPICommand;plots.computeAPICommandBindings=commandModule.computeAPICommandBindings;plots.manageCommandObserver=commandModule.manageCommandObserver;plots.hasSimpleAPICommandBindings=commandModule.hasSimpleAPICommandBindings;// in some cases the browser doesn't seem to know how big\n// the text is at first, so it needs to draw it,\n// then wait a little, then draw it again\nplots.redrawText=function(gd){gd=Lib.getGraphDiv(gd);// do not work if polar is present\nif(gd.data&&gd.data[0]&&gd.data[0].r)return;return new Promise(function(resolve){setTimeout(function(){Registry.getComponentMethod('annotations','draw')(gd);Registry.getComponentMethod('legend','draw')(gd);(gd.calcdata||[]).forEach(function(d){if(d[0]&&d[0].t&&d[0].t.cb)d[0].t.cb();});resolve(plots.previousPromises(gd));},300);});};// resize plot about the container size\nplots.resize=function(gd){gd=Lib.getGraphDiv(gd);return new Promise(function(resolve,reject){function isHidden(gd){var display=window.getComputedStyle(gd).display;return!display||display==='none';}if(!gd||isHidden(gd)){reject(new Error('Resize must be passed a displayed plot div element.'));}if(gd._redrawTimer)clearTimeout(gd._redrawTimer);gd._redrawTimer=setTimeout(function(){// return if there is nothing to resize or is hidden\nif(!gd.layout||gd.layout.width&&gd.layout.height||isHidden(gd)){resolve(gd);return;}delete gd.layout.width;delete gd.layout.height;// autosizing doesn't count as a change that needs saving\nvar oldchanged=gd.changed;// nor should it be included in the undo queue\ngd.autoplay=true;Registry.call('relayout',gd,{autosize:true}).then(function(){gd.changed=oldchanged;resolve(gd);});},100);});};// for use in Lib.syncOrAsync, check if there are any\n// pending promises in this plot and wait for them\nplots.previousPromises=function(gd){if((gd._promises||[]).length){return Promise.all(gd._promises).then(function(){gd._promises=[];});}};/**\n * Adds the 'Edit chart' link.\n * Note that now Plotly.plot() calls this so it can regenerate whenever it replots\n *\n * Add source links to your graph inside the 'showSources' config argument.\n */plots.addLinks=function(gd){// Do not do anything if showLink and showSources are not set to true in config\nif(!gd._context.showLink&&!gd._context.showSources)return;var fullLayout=gd._fullLayout;var linkContainer=Lib.ensureSingle(fullLayout._paper,'text','js-plot-link-container',function(s){s.style({'font-family':'\"Open Sans\", Arial, sans-serif','font-size':'12px','fill':Color.defaultLine,'pointer-events':'all'}).each(function(){var links=d3.select(this);links.append('tspan').classed('js-link-to-tool',true);links.append('tspan').classed('js-link-spacer',true);links.append('tspan').classed('js-sourcelinks',true);});});// The text node inside svg\nvar text=linkContainer.node();var attrs={y:fullLayout._paper.attr('height')-9};// If text's width is bigger than the layout\n// Check that text is a child node or document.body\n// because otherwise IE/Edge might throw an exception\n// when calling getComputedTextLength().\n// Apparently offsetParent is null for invisibles.\nif(document.body.contains(text)&&text.getComputedTextLength()>=fullLayout.width-20){// Align the text at the left\nattrs['text-anchor']='start';attrs.x=5;}else{// Align the text at the right\nattrs['text-anchor']='end';attrs.x=fullLayout._paper.attr('width')-7;}linkContainer.attr(attrs);var toolspan=linkContainer.select('.js-link-to-tool');var spacespan=linkContainer.select('.js-link-spacer');var sourcespan=linkContainer.select('.js-sourcelinks');if(gd._context.showSources)gd._context.showSources(gd);// 'view in plotly' link for embedded plots\nif(gd._context.showLink)positionPlayWithData(gd,toolspan);// separator if we have both sources and tool link\nspacespan.text(toolspan.text()&&sourcespan.text()?' - ':'');};// note that now this function is only adding the brand in\n// iframes and 3rd-party apps\nfunction positionPlayWithData(gd,container){container.text('');var link=container.append('a').attr({'xlink:xlink:href':'#','class':'link--impt link--embedview','font-weight':'bold'}).text(gd._context.linkText+' '+String.fromCharCode(187));if(gd._context.sendData){link.on('click',function(){plots.sendDataToCloud(gd);});}else{var path=window.location.pathname.split('/');var query=window.location.search;link.attr({'xlink:xlink:show':'new','xlink:xlink:href':'/'+path[2].split('.')[0]+'/'+path[1]+query});}}plots.sendDataToCloud=function(gd){gd.emit('plotly_beforeexport');var baseUrl=(window.PLOTLYENV||{}).BASE_URL||gd._context.plotlyServerURL;var hiddenformDiv=d3.select(gd).append('div').attr('id','hiddenform').style('display','none');var hiddenform=hiddenformDiv.append('form').attr({action:baseUrl+'/external',method:'post',target:'_blank'});var hiddenformInput=hiddenform.append('input').attr({type:'text',name:'data'});hiddenformInput.node().value=plots.graphJson(gd,false,'keepdata');hiddenform.node().submit();hiddenformDiv.remove();gd.emit('plotly_afterexport');return false;};var d3FormatKeys=['days','shortDays','months','shortMonths','periods','dateTime','date','time','decimal','thousands','grouping','currency'];var extraFormatKeys=['year','month','dayMonth','dayMonthYear'];/*\n * Fill in default values\n * @param {DOM element} gd\n * @param {object} opts\n * @param {boolean} opts.skipUpdateCalc: normally if the existing gd.calcdata looks\n *   compatible with the new gd._fullData we finish by linking the new _fullData traces\n *   to the old gd.calcdata, so it's correctly set if we're not going to recalc. But also,\n *   if there are calcTransforms on the trace, we first remap data arrays from the old full\n *   trace into the new one. Use skipUpdateCalc to defer this (needed by Plotly.react)\n *\n * gd.data, gd.layout:\n *   are precisely what the user specified (except as modified by cleanData/cleanLayout),\n *   these fields shouldn't be modified (except for filling in some auto values)\n *   nor used directly after the supply defaults step.\n *\n * gd._fullData, gd._fullLayout:\n *   are complete descriptions of how to draw the plot,\n *   use these fields in all required computations.\n *\n * gd._fullLayout._modules\n *   is a list of all the trace modules required to draw the plot.\n *\n * gd._fullLayout._visibleModules\n *   subset of _modules, a list of modules corresponding to visible:true traces.\n *\n * gd._fullLayout._basePlotModules\n *   is a list of all the plot modules required to draw the plot.\n *\n * gd._fullLayout._transformModules\n *   is a list of all the transform modules invoked.\n *\n */plots.supplyDefaults=function(gd,opts){var skipUpdateCalc=opts&&opts.skipUpdateCalc;var oldFullLayout=gd._fullLayout||{};if(oldFullLayout._skipDefaults){delete oldFullLayout._skipDefaults;return;}var newFullLayout=gd._fullLayout={};var newLayout=gd.layout||{};var oldFullData=gd._fullData||[];var newFullData=gd._fullData=[];var newData=gd.data||[];var oldCalcdata=gd.calcdata||[];var context=gd._context||{};var i;// Create all the storage space for frames, but only if doesn't already exist\nif(!gd._transitionData)plots.createTransitionData(gd);// So we only need to do this once (and since we have gd here)\n// get the translated placeholder titles.\n// These ones get used as default values so need to be known at supplyDefaults\n// others keep their blank defaults but render the placeholder as desired later\n// TODO: make these work the same way, only inserting the placeholder text at draw time?\n// The challenge is that this has slightly different behavior right now in editable mode:\n// using the placeholder as default makes this text permanently (but lightly) visible,\n// but explicit '' for these titles gives you a placeholder that's hidden until you mouse\n// over it - so you're not distracted by it if you really don't want a title, but if you do\n// and you're new to plotly you may not be able to find it.\n// When editable=false the two behave the same, no title is drawn.\nnewFullLayout._dfltTitle={plot:_(gd,'Click to enter Plot title'),x:_(gd,'Click to enter X axis title'),y:_(gd,'Click to enter Y axis title'),colorbar:_(gd,'Click to enter Colorscale title'),annotation:_(gd,'new text')};newFullLayout._traceWord=_(gd,'trace');var formatObj=getFormatObj(gd,d3FormatKeys);// stash the token from context so mapbox subplots can use it as default\nnewFullLayout._mapboxAccessToken=context.mapboxAccessToken;// first fill in what we can of layout without looking at data\n// because fullData needs a few things from layout\nif(oldFullLayout._initialAutoSizeIsDone){// coerce the updated layout while preserving width and height\nvar oldWidth=oldFullLayout.width;var oldHeight=oldFullLayout.height;plots.supplyLayoutGlobalDefaults(newLayout,newFullLayout,formatObj);if(!newLayout.width)newFullLayout.width=oldWidth;if(!newLayout.height)newFullLayout.height=oldHeight;plots.sanitizeMargins(newFullLayout);}else{// coerce the updated layout and autosize if needed\nplots.supplyLayoutGlobalDefaults(newLayout,newFullLayout,formatObj);var missingWidthOrHeight=!newLayout.width||!newLayout.height;var autosize=newFullLayout.autosize;var autosizable=context.autosizable;var initialAutoSize=missingWidthOrHeight&&(autosize||autosizable);if(initialAutoSize)plots.plotAutoSize(gd,newLayout,newFullLayout);else if(missingWidthOrHeight)plots.sanitizeMargins(newFullLayout);// for backwards-compatibility with Plotly v1.x.x\nif(!autosize&&missingWidthOrHeight){newLayout.width=newFullLayout.width;newLayout.height=newFullLayout.height;}}newFullLayout._d3locale=getFormatter(formatObj,newFullLayout.separators);newFullLayout._extraFormat=getFormatObj(gd,extraFormatKeys);newFullLayout._initialAutoSizeIsDone=true;// keep track of how many traces are inputted\nnewFullLayout._dataLength=newData.length;// clear the lists of trace and baseplot modules, and subplots\nnewFullLayout._modules=[];newFullLayout._visibleModules=[];newFullLayout._basePlotModules=[];var subplots=newFullLayout._subplots=emptySubplotLists();// initialize axis and subplot hash objects for splom-generated grids\nvar splomAxes=newFullLayout._splomAxes={x:{},y:{}};var splomSubplots=newFullLayout._splomSubplots={};// initialize splom grid defaults\nnewFullLayout._splomGridDflt={};// for stacked area traces to share config across traces\nnewFullLayout._scatterStackOpts={};// for the first scatter trace on each subplot (so it knows tonext->tozero)\nnewFullLayout._firstScatter={};// for grouped bar/box/violin trace to share config across traces\nnewFullLayout._alignmentOpts={};// for traces to request a default rangeslider on their x axes\n// eg set `_requestRangeslider.x2 = true` for xaxis2\nnewFullLayout._requestRangeslider={};// pull uids from old data to use as new defaults\nnewFullLayout._traceUids=getTraceUids(oldFullData,newData);// then do the data\nnewFullLayout._globalTransforms=(gd._context||{}).globalTransforms;plots.supplyDataDefaults(newData,newFullData,newLayout,newFullLayout);// redo grid size defaults with info about splom x/y axes,\n// and fill in generated cartesian axes and subplots\nvar splomXa=Object.keys(splomAxes.x);var splomYa=Object.keys(splomAxes.y);if(splomXa.length>1&&splomYa.length>1){Registry.getComponentMethod('grid','sizeDefaults')(newLayout,newFullLayout);for(i=0;i<splomXa.length;i++){Lib.pushUnique(subplots.xaxis,splomXa[i]);}for(i=0;i<splomYa.length;i++){Lib.pushUnique(subplots.yaxis,splomYa[i]);}for(var k in splomSubplots){Lib.pushUnique(subplots.cartesian,k);}}// attach helper method to check whether a plot type is present on graph\nnewFullLayout._has=plots._hasPlotType.bind(newFullLayout);if(oldFullData.length===newFullData.length){for(i=0;i<newFullData.length;i++){relinkPrivateKeys(newFullData[i],oldFullData[i]);}}// finally, fill in the pieces of layout that may need to look at data\nplots.supplyLayoutModuleDefaults(newLayout,newFullLayout,newFullData,gd._transitionData);// Special cases that introduce interactions between traces.\n// This is after relinkPrivateKeys so we can use those in crossTraceDefaults\n// and after layout module defaults, so we can use eg barmode\nvar _modules=newFullLayout._visibleModules;var crossTraceDefaultsFuncs=[];for(i=0;i<_modules.length;i++){var funci=_modules[i].crossTraceDefaults;// some trace types share crossTraceDefaults (ie histogram2d, histogram2dcontour)\nif(funci)Lib.pushUnique(crossTraceDefaultsFuncs,funci);}for(i=0;i<crossTraceDefaultsFuncs.length;i++){crossTraceDefaultsFuncs[i](newFullData,newFullLayout);}Registry.getComponentMethod('colorscale','crossTraceDefaults')(newFullData,newFullLayout);// turn on flag to optimize large splom-only graphs\n// mostly by omitting SVG layers during Cartesian.drawFramework\nnewFullLayout._hasOnlyLargeSploms=newFullLayout._basePlotModules.length===1&&newFullLayout._basePlotModules[0].name==='splom'&&splomXa.length>15&&splomYa.length>15&&newFullLayout.shapes.length===0&&newFullLayout.images.length===0;// TODO remove in v2.0.0\n// add has-plot-type refs to fullLayout for backward compatibility\nnewFullLayout._hasCartesian=newFullLayout._has('cartesian');newFullLayout._hasGeo=newFullLayout._has('geo');newFullLayout._hasGL3D=newFullLayout._has('gl3d');newFullLayout._hasGL2D=newFullLayout._has('gl2d');newFullLayout._hasTernary=newFullLayout._has('ternary');newFullLayout._hasPie=newFullLayout._has('pie');// relink / initialize subplot axis objects\nplots.linkSubplots(newFullData,newFullLayout,oldFullData,oldFullLayout);// clean subplots and other artifacts from previous plot calls\nplots.cleanPlot(newFullData,newFullLayout,oldFullData,oldFullLayout);// clear selection outline until we implement persistent selection,\n// don't clear them though when drag handlers (e.g. listening to\n// `plotly_selecting`) update the graph.\n// we should try to come up with a better solution when implementing\n// https://github.com/plotly/plotly.js/issues/1851\nif(oldFullLayout._zoomlayer&&!gd._dragging){oldFullLayout._zoomlayer.selectAll('.select-outline').remove();}// relink functions and _ attributes to promote consistency between plots\nrelinkPrivateKeys(newFullLayout,oldFullLayout);// For persisting GUI-driven changes in layout\n// _preGUI and _tracePreGUI were already copied over in relinkPrivateKeys\nif(!newFullLayout._preGUI)newFullLayout._preGUI={};// track trace GUI changes by uid rather than by trace index\nif(!newFullLayout._tracePreGUI)newFullLayout._tracePreGUI={};var tracePreGUI=newFullLayout._tracePreGUI;var uids={};var uid;for(uid in tracePreGUI){uids[uid]='old';}for(i=0;i<newFullData.length;i++){uid=newFullData[i]._fullInput.uid;if(!uids[uid])tracePreGUI[uid]={};uids[uid]='new';}for(uid in uids){if(uids[uid]==='old')delete tracePreGUI[uid];}// set up containers for margin calculations\ninitMargins(newFullLayout);// collect and do some initial calculations for rangesliders\nRegistry.getComponentMethod('rangeslider','makeData')(newFullLayout);// update object references in calcdata\nif(!skipUpdateCalc&&oldCalcdata.length===newFullData.length){plots.supplyDefaultsUpdateCalc(oldCalcdata,newFullData);}};plots.supplyDefaultsUpdateCalc=function(oldCalcdata,newFullData){for(var i=0;i<newFullData.length;i++){var newTrace=newFullData[i];var cd0=(oldCalcdata[i]||[])[0];if(cd0&&cd0.trace){var oldTrace=cd0.trace;if(oldTrace._hasCalcTransform){var arrayAttrs=oldTrace._arrayAttrs;var j,astr,oldArrayVal;for(j=0;j<arrayAttrs.length;j++){astr=arrayAttrs[j];oldArrayVal=Lib.nestedProperty(oldTrace,astr).get().slice();Lib.nestedProperty(newTrace,astr).set(oldArrayVal);}}cd0.trace=newTrace;}}};/**\n * Create a list of uid strings satisfying (in this order of importance):\n * 1. all unique, all strings\n * 2. matches input uids if provided\n * 3. matches previous data uids\n */function getTraceUids(oldFullData,newData){var len=newData.length;var oldFullInput=[];var i,prevFullInput;for(i=0;i<oldFullData.length;i++){var thisFullInput=oldFullData[i]._fullInput;if(thisFullInput!==prevFullInput)oldFullInput.push(thisFullInput);prevFullInput=thisFullInput;}var oldLen=oldFullInput.length;var out=new Array(len);var seenUids={};function setUid(uid,i){out[i]=uid;seenUids[uid]=1;}function tryUid(uid,i){if(uid&&typeof uid==='string'&&!seenUids[uid]){setUid(uid,i);return true;}}for(i=0;i<len;i++){var newUid=newData[i].uid;if(typeof newUid==='number')newUid=String(newUid);if(tryUid(newUid,i))continue;if(i<oldLen&&tryUid(oldFullInput[i].uid,i))continue;setUid(Lib.randstr(seenUids),i);}return out;}/**\n * Make a container for collecting subplots we need to display.\n *\n * Finds all subplot types we need to enumerate once and caches it,\n * but makes a new output object each time.\n * Single-trace subplots (which have no `id`) such as pie, table, etc\n * do not need to be collected because we just draw all visible traces.\n */function emptySubplotLists(){var collectableSubplotTypes=Registry.collectableSubplotTypes;var out={};var i,j;if(!collectableSubplotTypes){collectableSubplotTypes=[];var subplotsRegistry=Registry.subplotsRegistry;for(var subplotType in subplotsRegistry){var subplotModule=subplotsRegistry[subplotType];var subplotAttr=subplotModule.attr;if(subplotAttr){collectableSubplotTypes.push(subplotType);// special case, currently just for cartesian:\n// we need to enumerate axes, not just subplots\nif(Array.isArray(subplotAttr)){for(j=0;j<subplotAttr.length;j++){Lib.pushUnique(collectableSubplotTypes,subplotAttr[j]);}}}}}for(i=0;i<collectableSubplotTypes.length;i++){out[collectableSubplotTypes[i]]=[];}return out;}/**\n * getFormatObj: use _context to get the format object from locale.\n * Used to get d3.locale argument object and extraFormat argument object\n *\n * Regarding d3.locale argument :\n * decimal and thousands can be overridden later by layout.separators\n * grouping and currency are not presently used by our automatic number\n * formatting system but can be used by custom formats.\n *\n * @returns {object} d3.locale format object\n */function getFormatObj(gd,formatKeys){var locale=gd._context.locale;if(!locale)locale==='en-US';var formatDone=false;var formatObj={};function includeFormat(newFormat){var formatFinished=true;for(var i=0;i<formatKeys.length;i++){var formatKey=formatKeys[i];if(!formatObj[formatKey]){if(newFormat[formatKey]){formatObj[formatKey]=newFormat[formatKey];}else formatFinished=false;}}if(formatFinished)formatDone=true;}// same as localize, look for format parts in each format spec in the chain\nfor(var i=0;i<2;i++){var locales=gd._context.locales;for(var j=0;j<2;j++){var formatj=(locales[locale]||{}).format;if(formatj){includeFormat(formatj);if(formatDone)break;}locales=Registry.localeRegistry;}var baseLocale=locale.split('-')[0];if(formatDone||baseLocale===locale)break;locale=baseLocale;}// lastly pick out defaults from english (non-US, as DMY is so much more common)\nif(!formatDone)includeFormat(Registry.localeRegistry.en.format);return formatObj;}/**\n * getFormatter: combine the final separators with the locale formatting object\n * we pulled earlier to generate number and time formatters\n * TODO: remove separators in v2, only use locale, so we don't need this step?\n *\n * @param {object} formatObj: d3.locale format object\n * @param {string} separators: length-2 string to override decimal and thousands\n *   separators in number formatting\n *\n * @returns {object} {numberFormat, timeFormat} d3 formatter factory functions\n *   for numbers and time\n */function getFormatter(formatObj,separators){formatObj.decimal=separators.charAt(0);formatObj.thousands=separators.charAt(1);return d3.locale(formatObj);}// Create storage for all of the data related to frames and transitions:\nplots.createTransitionData=function(gd){// Set up the default keyframe if it doesn't exist:\nif(!gd._transitionData){gd._transitionData={};}if(!gd._transitionData._frames){gd._transitionData._frames=[];}if(!gd._transitionData._frameHash){gd._transitionData._frameHash={};}if(!gd._transitionData._counter){gd._transitionData._counter=0;}if(!gd._transitionData._interruptCallbacks){gd._transitionData._interruptCallbacks=[];}};// helper function to be bound to fullLayout to check\n// whether a certain plot type is present on plot\n// or trace has a category\nplots._hasPlotType=function(category){var i;// check base plot modules\nvar basePlotModules=this._basePlotModules||[];for(i=0;i<basePlotModules.length;i++){if(basePlotModules[i].name===category)return true;}// check trace modules (including non-visible:true)\nvar modules=this._modules||[];for(i=0;i<modules.length;i++){var name=modules[i].name;if(name===category)return true;// N.B. this is modules[i] along with 'categories' as a hash object\nvar _module=Registry.modules[name];if(_module&&_module.categories[category])return true;}return false;};plots.cleanPlot=function(newFullData,newFullLayout,oldFullData,oldFullLayout){var i,j;var basePlotModules=oldFullLayout._basePlotModules||[];for(i=0;i<basePlotModules.length;i++){var _module=basePlotModules[i];if(_module.clean){_module.clean(newFullData,newFullLayout,oldFullData,oldFullLayout);}}var hadGl=oldFullLayout._has&&oldFullLayout._has('gl');var hasGl=newFullLayout._has&&newFullLayout._has('gl');if(hadGl&&!hasGl){if(oldFullLayout._glcontainer!==undefined){oldFullLayout._glcontainer.selectAll('.gl-canvas').remove();oldFullLayout._glcontainer.selectAll('.no-webgl').remove();oldFullLayout._glcanvas=null;}}var hasInfoLayer=!!oldFullLayout._infolayer;oldLoop:for(i=0;i<oldFullData.length;i++){var oldTrace=oldFullData[i];var oldUid=oldTrace.uid;for(j=0;j<newFullData.length;j++){var newTrace=newFullData[j];if(oldUid===newTrace.uid)continue oldLoop;}// clean old colorbars\nif(hasInfoLayer){oldFullLayout._infolayer.select('.cb'+oldUid).remove();}}};plots.linkSubplots=function(newFullData,newFullLayout,oldFullData,oldFullLayout){var i,j;var oldSubplots=oldFullLayout._plots||{};var newSubplots=newFullLayout._plots={};var newSubplotList=newFullLayout._subplots;var mockGd={_fullData:newFullData,_fullLayout:newFullLayout};var ids=newSubplotList.cartesian.concat(newSubplotList.gl2d||[]);for(i=0;i<ids.length;i++){var id=ids[i];var oldSubplot=oldSubplots[id];var xaxis=axisIDs.getFromId(mockGd,id,'x');var yaxis=axisIDs.getFromId(mockGd,id,'y');var plotinfo;// link or create subplot object\nif(oldSubplot){plotinfo=newSubplots[id]=oldSubplot;}else{plotinfo=newSubplots[id]={};plotinfo.id=id;}// add these axis ids to each others' subplot lists\nxaxis._counterAxes.push(yaxis._id);yaxis._counterAxes.push(xaxis._id);xaxis._subplotsWith.push(id);yaxis._subplotsWith.push(id);// update x and y axis layout object refs\nplotinfo.xaxis=xaxis;plotinfo.yaxis=yaxis;// By default, we clip at the subplot level,\n// but if one trace on a given subplot has *cliponaxis* set to false,\n// we need to clip at the trace module layer level;\n// find this out here, once of for all.\nplotinfo._hasClipOnAxisFalse=false;for(j=0;j<newFullData.length;j++){var trace=newFullData[j];if(trace.xaxis===plotinfo.xaxis._id&&trace.yaxis===plotinfo.yaxis._id&&trace.cliponaxis===false){plotinfo._hasClipOnAxisFalse=true;break;}}}// while we're at it, link overlaying axes to their main axes and\n// anchored axes to the axes they're anchored to\nvar axList=axisIDs.list(mockGd,null,true);var ax;for(i=0;i<axList.length;i++){ax=axList[i];var mainAx=null;if(ax.overlaying){mainAx=axisIDs.getFromId(mockGd,ax.overlaying);// you cannot overlay an axis that's already overlaying another\nif(mainAx&&mainAx.overlaying){ax.overlaying=false;mainAx=null;}}ax._mainAxis=mainAx||ax;/*\n         * For now force overlays to overlay completely... so they\n         * can drag together correctly and share backgrounds.\n         * Later perhaps we make separate axis domain and\n         * tick/line domain or something, so they can still share\n         * the (possibly larger) dragger and background but don't\n         * have to both be drawn over that whole domain\n         */if(mainAx)ax.domain=mainAx.domain.slice();ax._anchorAxis=ax.anchor==='free'?null:axisIDs.getFromId(mockGd,ax.anchor);}// finally, we can find the main subplot for each axis\n// (on which the ticks & labels are drawn)\nfor(i=0;i<axList.length;i++){ax=axList[i];ax._counterAxes.sort(axisIDs.idSort);ax._subplotsWith.sort(Lib.subplotSort);ax._mainSubplot=findMainSubplot(ax,newFullLayout);}};function findMainSubplot(ax,fullLayout){var mockGd={_fullLayout:fullLayout};var isX=ax._id.charAt(0)==='x';var anchorAx=ax._mainAxis._anchorAxis;var mainSubplotID='';var nextBestMainSubplotID='';var anchorID='';// First try the main ID with the anchor\nif(anchorAx){anchorID=anchorAx._mainAxis._id;mainSubplotID=isX?ax._id+anchorID:anchorID+ax._id;}// Then look for a subplot with the counteraxis overlaying the anchor\n// If that fails just use the first subplot including this axis\nif(!mainSubplotID||!fullLayout._plots[mainSubplotID]){mainSubplotID='';var counterIDs=ax._counterAxes;for(var j=0;j<counterIDs.length;j++){var counterPart=counterIDs[j];var id=isX?ax._id+counterPart:counterPart+ax._id;if(!nextBestMainSubplotID)nextBestMainSubplotID=id;var counterAx=axisIDs.getFromId(mockGd,counterPart);if(anchorID&&counterAx.overlaying===anchorID){mainSubplotID=id;break;}}}return mainSubplotID||nextBestMainSubplotID;}// This function clears any trace attributes with valType: color and\n// no set dflt filed in the plot schema. This is needed because groupby (which\n// is the only transform for which this currently applies) supplies parent\n// trace defaults, then expanded trace defaults. The result is that `null`\n// colors are default-supplied and inherited as a color instead of a null.\n// The result is that expanded trace default colors have no effect, with\n// the final result that groups are indistinguishable. This function clears\n// those colors so that individual groupby groups get unique colors.\nplots.clearExpandedTraceDefaultColors=function(trace){var colorAttrs,path,i;// This uses weird closure state in order to satisfy the linter rule\n// that we can't create functions in a loop.\nfunction locateColorAttrs(attr,attrName,attrs,level){path[level]=attrName;path.length=level+1;if(attr.valType==='color'&&attr.dflt===undefined){colorAttrs.push(path.join('.'));}}path=[];// Get the cached colorAttrs:\ncolorAttrs=trace._module._colorAttrs;// Or else compute and cache the colorAttrs on the module:\nif(!colorAttrs){trace._module._colorAttrs=colorAttrs=[];PlotSchema.crawl(trace._module.attributes,locateColorAttrs);}for(i=0;i<colorAttrs.length;i++){var origprop=Lib.nestedProperty(trace,'_input.'+colorAttrs[i]);if(!origprop.get()){Lib.nestedProperty(trace,colorAttrs[i]).set(null);}}};plots.supplyDataDefaults=function(dataIn,dataOut,layout,fullLayout){var modules=fullLayout._modules;var visibleModules=fullLayout._visibleModules;var basePlotModules=fullLayout._basePlotModules;var cnt=0;var colorCnt=0;var i,fullTrace,trace;fullLayout._transformModules=[];function pushModule(fullTrace){dataOut.push(fullTrace);var _module=fullTrace._module;if(!_module)return;Lib.pushUnique(modules,_module);if(fullTrace.visible===true)Lib.pushUnique(visibleModules,_module);Lib.pushUnique(basePlotModules,fullTrace._module.basePlotModule);cnt++;// TODO: do we really want color not to increment for explicitly invisible traces?\n// This logic is weird, but matches previous behavior: traces that you explicitly\n// set to visible:false do not increment the color, but traces WE determine to be\n// empty or invalid (and thus set to visible:false) DO increment color.\n// I kind of think we should just let all traces increment color, visible or not.\n// see mock: axes-autotype-empty vs. a test of restyling visible: false that\n// I can't find right now...\nif(fullTrace._input.visible!==false)colorCnt++;}var carpetIndex={};var carpetDependents=[];var dataTemplate=(layout.template||{}).data||{};var templater=Template.traceTemplater(dataTemplate);for(i=0;i<dataIn.length;i++){trace=dataIn[i];// reuse uid we may have pulled out of oldFullData\n// Note: templater supplies trace type\nfullTrace=templater.newTrace(trace);fullTrace.uid=fullLayout._traceUids[i];plots.supplyTraceDefaults(trace,fullTrace,colorCnt,fullLayout,i);fullTrace.index=i;fullTrace._input=trace;fullTrace._expandedIndex=cnt;if(fullTrace.transforms&&fullTrace.transforms.length){var sdInvisible=trace.visible!==false&&fullTrace.visible===false;var expandedTraces=applyTransforms(fullTrace,dataOut,layout,fullLayout);for(var j=0;j<expandedTraces.length;j++){var expandedTrace=expandedTraces[j];// No further templating during transforms.\nvar fullExpandedTrace={_template:fullTrace._template,type:fullTrace.type,// set uid using parent uid and expanded index\n// to promote consistency between update calls\nuid:fullTrace.uid+j};// If the first supplyDefaults created `visible: false`,\n// clear it before running supplyDefaults a second time,\n// because sometimes there are items we still want to coerce\n// inside trace modules before determining that the trace is\n// again `visible: false`, for example partial visibilities\n// in `splom` traces.\nif(sdInvisible&&expandedTrace.visible===false){delete expandedTrace.visible;}plots.supplyTraceDefaults(expandedTrace,fullExpandedTrace,cnt,fullLayout,i);// relink private (i.e. underscore) keys expanded trace to full expanded trace so\n// that transform supply-default methods can set _ keys for future use.\nrelinkPrivateKeys(fullExpandedTrace,expandedTrace);// add info about parent data trace\nfullExpandedTrace.index=i;fullExpandedTrace._input=trace;fullExpandedTrace._fullInput=fullTrace;// add info about the expanded data\nfullExpandedTrace._expandedIndex=cnt;fullExpandedTrace._expandedInput=expandedTrace;pushModule(fullExpandedTrace);}}else{// add identify refs for consistency with transformed traces\nfullTrace._fullInput=fullTrace;fullTrace._expandedInput=fullTrace;pushModule(fullTrace);}if(Registry.traceIs(fullTrace,'carpetAxis')){carpetIndex[fullTrace.carpet]=fullTrace;}if(Registry.traceIs(fullTrace,'carpetDependent')){carpetDependents.push(i);}}for(i=0;i<carpetDependents.length;i++){fullTrace=dataOut[carpetDependents[i]];if(!fullTrace.visible)continue;var carpetAxis=carpetIndex[fullTrace.carpet];fullTrace._carpet=carpetAxis;if(!carpetAxis||!carpetAxis.visible){fullTrace.visible=false;continue;}fullTrace.xaxis=carpetAxis.xaxis;fullTrace.yaxis=carpetAxis.yaxis;}};plots.supplyAnimationDefaults=function(opts){opts=opts||{};var i;var optsOut={};function coerce(attr,dflt){return Lib.coerce(opts||{},optsOut,animationAttrs,attr,dflt);}coerce('mode');coerce('direction');coerce('fromcurrent');if(Array.isArray(opts.frame)){optsOut.frame=[];for(i=0;i<opts.frame.length;i++){optsOut.frame[i]=plots.supplyAnimationFrameDefaults(opts.frame[i]||{});}}else{optsOut.frame=plots.supplyAnimationFrameDefaults(opts.frame||{});}if(Array.isArray(opts.transition)){optsOut.transition=[];for(i=0;i<opts.transition.length;i++){optsOut.transition[i]=plots.supplyAnimationTransitionDefaults(opts.transition[i]||{});}}else{optsOut.transition=plots.supplyAnimationTransitionDefaults(opts.transition||{});}return optsOut;};plots.supplyAnimationFrameDefaults=function(opts){var optsOut={};function coerce(attr,dflt){return Lib.coerce(opts||{},optsOut,animationAttrs.frame,attr,dflt);}coerce('duration');coerce('redraw');return optsOut;};plots.supplyAnimationTransitionDefaults=function(opts){var optsOut={};function coerce(attr,dflt){return Lib.coerce(opts||{},optsOut,animationAttrs.transition,attr,dflt);}coerce('duration');coerce('easing');return optsOut;};plots.supplyFrameDefaults=function(frameIn){var frameOut={};function coerce(attr,dflt){return Lib.coerce(frameIn,frameOut,frameAttrs,attr,dflt);}coerce('group');coerce('name');coerce('traces');coerce('baseframe');coerce('data');coerce('layout');return frameOut;};plots.supplyTraceDefaults=function(traceIn,traceOut,colorIndex,layout,traceInIndex){var colorway=layout.colorway||Color.defaults;var defaultColor=colorway[colorIndex%colorway.length];var i;function coerce(attr,dflt){return Lib.coerce(traceIn,traceOut,plots.attributes,attr,dflt);}var visible=coerce('visible');coerce('type');coerce('name',layout._traceWord+' '+traceInIndex);coerce('uirevision',layout.uirevision);// we want even invisible traces to make their would-be subplots visible\n// so coerce the subplot id(s) now no matter what\nvar _module=plots.getModule(traceOut);traceOut._module=_module;if(_module){var basePlotModule=_module.basePlotModule;var subplotAttr=basePlotModule.attr;var subplotAttrs=basePlotModule.attributes;if(subplotAttr&&subplotAttrs){var subplots=layout._subplots;var subplotId='';// TODO - currently if we draw an empty gl2d subplot, it draws\n// nothing then gets stuck and you can't get it back without newPlot\n// sort this out in the regl refactor? but for now just drop empty gl2d subplots\nif(basePlotModule.name!=='gl2d'||visible){if(Array.isArray(subplotAttr)){for(i=0;i<subplotAttr.length;i++){var attri=subplotAttr[i];var vali=Lib.coerce(traceIn,traceOut,subplotAttrs,attri);if(subplots[attri])Lib.pushUnique(subplots[attri],vali);subplotId+=vali;}}else{subplotId=Lib.coerce(traceIn,traceOut,subplotAttrs,subplotAttr);}if(subplots[basePlotModule.name]){Lib.pushUnique(subplots[basePlotModule.name],subplotId);}}}}if(visible){coerce('customdata');coerce('ids');if(Registry.traceIs(traceOut,'showLegend')){traceOut._dfltShowLegend=true;coerce('showlegend');coerce('legendgroup');}else{traceOut._dfltShowLegend=false;}if(_module){_module.supplyDefaults(traceIn,traceOut,defaultColor,layout);}if(!Registry.traceIs(traceOut,'noOpacity')){coerce('opacity');}if(Registry.traceIs(traceOut,'notLegendIsolatable')){// This clears out the legendonly state for traces like carpet that\n// cannot be isolated in the legend\ntraceOut.visible=!!traceOut.visible;}if(!Registry.traceIs(traceOut,'noHover')){if(!traceOut.hovertemplate)Lib.coerceHoverinfo(traceIn,traceOut,layout);// parcats support hover, but not hoverlabel stylings (yet)\nif(traceOut.type!=='parcats'){Registry.getComponentMethod('fx','supplyDefaults')(traceIn,traceOut,defaultColor,layout);}}if(_module&&_module.selectPoints){coerce('selectedpoints');}plots.supplyTransformDefaults(traceIn,traceOut,layout);}return traceOut;};/**\n * hasMakesDataTransform: does this trace have a transform that makes its own\n * data, either by grabbing it from somewhere else or by creating it from input\n * parameters? If so, we should still keep going with supplyDefaults\n * even if the trace is invisible, which may just be because it has no data yet.\n */function hasMakesDataTransform(trace){var transforms=trace.transforms;if(Array.isArray(transforms)&&transforms.length){for(var i=0;i<transforms.length;i++){var ti=transforms[i];var _module=ti._module||transformsRegistry[ti.type];if(_module&&_module.makesData)return true;}}return false;}plots.hasMakesDataTransform=hasMakesDataTransform;plots.supplyTransformDefaults=function(traceIn,traceOut,layout){// For now we only allow transforms on 1D traces, ie those that specify a _length.\n// If we were to implement 2D transforms, we'd need to have each transform\n// describe its own applicability and disable itself when it doesn't apply.\n// Also allow transforms that make their own data, but not in globalTransforms\nif(!(traceOut._length||hasMakesDataTransform(traceIn)))return;var globalTransforms=layout._globalTransforms||[];var transformModules=layout._transformModules||[];if(!Array.isArray(traceIn.transforms)&&globalTransforms.length===0)return;var containerIn=traceIn.transforms||[];var transformList=globalTransforms.concat(containerIn);var containerOut=traceOut.transforms=[];for(var i=0;i<transformList.length;i++){var transformIn=transformList[i];var type=transformIn.type;var _module=transformsRegistry[type];var transformOut;/*\n         * Supply defaults may run twice. First pass runs all supply defaults steps\n         * and adds the _module to any output transforms.\n         * If transforms exist another pass is run so that any generated traces also\n         * go through supply defaults. This has the effect of rerunning\n         * supplyTransformDefaults. If the transform does not have a `transform`\n         * function it could not have generated any new traces and the second stage\n         * is unnecessary. We detect this case with the following variables.\n         */var isFirstStage=!(transformIn._module&&transformIn._module===_module);var doLaterStages=_module&&typeof _module.transform==='function';if(!_module)Lib.warn('Unrecognized transform type '+type+'.');if(_module&&_module.supplyDefaults&&(isFirstStage||doLaterStages)){transformOut=_module.supplyDefaults(transformIn,traceOut,layout,traceIn);transformOut.type=type;transformOut._module=_module;Lib.pushUnique(transformModules,_module);}else{transformOut=Lib.extendFlat({},transformIn);}containerOut.push(transformOut);}};function applyTransforms(fullTrace,fullData,layout,fullLayout){var container=fullTrace.transforms;var dataOut=[fullTrace];for(var i=0;i<container.length;i++){var transform=container[i];var _module=transformsRegistry[transform.type];if(_module&&_module.transform){dataOut=_module.transform(dataOut,{transform:transform,fullTrace:fullTrace,fullData:fullData,layout:layout,fullLayout:fullLayout,transformIndex:i});}}return dataOut;}plots.supplyLayoutGlobalDefaults=function(layoutIn,layoutOut,formatObj){function coerce(attr,dflt){return Lib.coerce(layoutIn,layoutOut,plots.layoutAttributes,attr,dflt);}var template=layoutIn.template;if(Lib.isPlainObject(template)){layoutOut.template=template;layoutOut._template=template.layout;layoutOut._dataTemplate=template.data;}var globalFont=Lib.coerceFont(coerce,'font');coerce('title.text',layoutOut._dfltTitle.plot);Lib.coerceFont(coerce,'title.font',{family:globalFont.family,size:Math.round(globalFont.size*1.4),color:globalFont.color});coerce('title.xref');coerce('title.yref');coerce('title.x');coerce('title.y');coerce('title.xanchor');coerce('title.yanchor');coerce('title.pad.t');coerce('title.pad.r');coerce('title.pad.b');coerce('title.pad.l');// Make sure that autosize is defaulted to *true*\n// on layouts with no set width and height for backward compatibly,\n// in particular https://plot.ly/javascript/responsive-fluid-layout/\n//\n// Before https://github.com/plotly/plotly.js/pull/635 ,\n// layouts with no set width and height were set temporary set to 'initial'\n// to pass through the autosize routine\n//\n// This behavior is subject to change in v2.\ncoerce('autosize',!(layoutIn.width&&layoutIn.height));coerce('width');coerce('height');coerce('margin.l');coerce('margin.r');coerce('margin.t');coerce('margin.b');coerce('margin.pad');coerce('margin.autoexpand');if(layoutIn.width&&layoutIn.height)plots.sanitizeMargins(layoutOut);Registry.getComponentMethod('grid','sizeDefaults')(layoutIn,layoutOut);coerce('paper_bgcolor');coerce('separators',formatObj.decimal+formatObj.thousands);coerce('hidesources');coerce('colorway');coerce('datarevision');var uirevision=coerce('uirevision');coerce('editrevision',uirevision);coerce('selectionrevision',uirevision);coerce('modebar.orientation');coerce('modebar.bgcolor',Color.addOpacity(layoutOut.paper_bgcolor,0.5));var modebarDefaultColor=Color.contrast(Color.rgb(layoutOut.modebar.bgcolor));coerce('modebar.color',Color.addOpacity(modebarDefaultColor,0.3));coerce('modebar.activecolor',Color.addOpacity(modebarDefaultColor,0.7));coerce('modebar.uirevision',uirevision);coerce('meta');// do not include defaults in fullLayout when users do not set transition\nif(Lib.isPlainObject(layoutIn.transition)){coerce('transition.duration');coerce('transition.easing');coerce('transition.ordering');}Registry.getComponentMethod('calendars','handleDefaults')(layoutIn,layoutOut,'calendar');Registry.getComponentMethod('fx','supplyLayoutGlobalDefaults')(layoutIn,layoutOut,coerce);};plots.plotAutoSize=function plotAutoSize(gd,layout,fullLayout){var context=gd._context||{};var frameMargins=context.frameMargins;var newWidth;var newHeight;var isPlotDiv=Lib.isPlotDiv(gd);if(isPlotDiv)gd.emit('plotly_autosize');// embedded in an iframe - just take the full iframe size\n// if we get to this point, with no aspect ratio restrictions\nif(context.fillFrame){newWidth=window.innerWidth;newHeight=window.innerHeight;// somehow we get a few extra px height sometimes...\n// just hide it\ndocument.body.style.overflow='hidden';}else{// plotly.js - let the developers do what they want, either\n// provide height and width for the container div,\n// specify size in layout, or take the defaults,\n// but don't enforce any ratio restrictions\nvar computedStyle=isPlotDiv?window.getComputedStyle(gd):{};newWidth=parseFloat(computedStyle.width)||parseFloat(computedStyle.maxWidth)||fullLayout.width;newHeight=parseFloat(computedStyle.height)||parseFloat(computedStyle.maxHeight)||fullLayout.height;if(isNumeric(frameMargins)&&frameMargins>0){var factor=1-2*frameMargins;newWidth=Math.round(factor*newWidth);newHeight=Math.round(factor*newHeight);}}var minWidth=plots.layoutAttributes.width.min;var minHeight=plots.layoutAttributes.height.min;if(newWidth<minWidth)newWidth=minWidth;if(newHeight<minHeight)newHeight=minHeight;var widthHasChanged=!layout.width&&Math.abs(fullLayout.width-newWidth)>1;var heightHasChanged=!layout.height&&Math.abs(fullLayout.height-newHeight)>1;if(heightHasChanged||widthHasChanged){if(widthHasChanged)fullLayout.width=newWidth;if(heightHasChanged)fullLayout.height=newHeight;}// cache initial autosize value, used in relayout when\n// width or height values are set to null\nif(!gd._initialAutoSize){gd._initialAutoSize={width:newWidth,height:newHeight};}plots.sanitizeMargins(fullLayout);};plots.supplyLayoutModuleDefaults=function(layoutIn,layoutOut,fullData,transitionData){var componentsRegistry=Registry.componentsRegistry;var basePlotModules=layoutOut._basePlotModules;var component,i,_module;var Cartesian=Registry.subplotsRegistry.cartesian;// check if any components need to add more base plot modules\n// that weren't captured by traces\nfor(component in componentsRegistry){_module=componentsRegistry[component];if(_module.includeBasePlot){_module.includeBasePlot(layoutIn,layoutOut);}}// make sure we *at least* have some cartesian axes\nif(!basePlotModules.length){basePlotModules.push(Cartesian);}// ensure all cartesian axes have at least one subplot\nif(layoutOut._has('cartesian')){Registry.getComponentMethod('grid','contentDefaults')(layoutIn,layoutOut);Cartesian.finalizeSubplots(layoutIn,layoutOut);}// sort subplot lists\nfor(var subplotType in layoutOut._subplots){layoutOut._subplots[subplotType].sort(Lib.subplotSort);}// base plot module layout defaults\nfor(i=0;i<basePlotModules.length;i++){_module=basePlotModules[i];// e.g. pie does not have a layout-defaults step\nif(_module.supplyLayoutDefaults){_module.supplyLayoutDefaults(layoutIn,layoutOut,fullData);}}// trace module layout defaults\n// use _modules rather than _visibleModules so that even\n// legendonly traces can include settings - eg barmode, which affects\n// legend.traceorder default value.\nvar modules=layoutOut._modules;for(i=0;i<modules.length;i++){_module=modules[i];if(_module.supplyLayoutDefaults){_module.supplyLayoutDefaults(layoutIn,layoutOut,fullData);}}// transform module layout defaults\nvar transformModules=layoutOut._transformModules;for(i=0;i<transformModules.length;i++){_module=transformModules[i];if(_module.supplyLayoutDefaults){_module.supplyLayoutDefaults(layoutIn,layoutOut,fullData,transitionData);}}for(component in componentsRegistry){_module=componentsRegistry[component];if(_module.supplyLayoutDefaults){_module.supplyLayoutDefaults(layoutIn,layoutOut,fullData);}}};// Remove all plotly attributes from a div so it can be replotted fresh\n// TODO: these really need to be encapsulated into a much smaller set...\nplots.purge=function(gd){// note: we DO NOT remove _context because it doesn't change when we insert\n// a new plot, and may have been set outside of our scope.\nvar fullLayout=gd._fullLayout||{};if(fullLayout._glcontainer!==undefined){fullLayout._glcontainer.selectAll('.gl-canvas').remove();fullLayout._glcontainer.remove();fullLayout._glcanvas=null;}if(fullLayout._geocontainer!==undefined)fullLayout._geocontainer.remove();// remove modebar\nif(fullLayout._modeBar)fullLayout._modeBar.destroy();if(gd._transitionData){// Ensure any dangling callbacks are simply dropped if the plot is purged.\n// This is more or less only actually important for testing.\nif(gd._transitionData._interruptCallbacks){gd._transitionData._interruptCallbacks.length=0;}if(gd._transitionData._animationRaf){window.cancelAnimationFrame(gd._transitionData._animationRaf);}}// remove any planned throttles\nLib.clearThrottle();// remove responsive handler\nLib.clearResponsive(gd);// data and layout\ndelete gd.data;delete gd.layout;delete gd._fullData;delete gd._fullLayout;delete gd.calcdata;delete gd.framework;delete gd.empty;delete gd.fid;delete gd.undoqueue;// action queue\ndelete gd.undonum;delete gd.autoplay;// are we doing an action that doesn't go in undo queue?\ndelete gd.changed;// these get recreated on Plotly.plot anyway, but just to be safe\n// (and to have a record of them...)\ndelete gd._promises;delete gd._redrawTimer;delete gd._hmlumcount;delete gd._hmpixcount;delete gd._transitionData;delete gd._transitioning;delete gd._initialAutoSize;delete gd._transitioningWithDuration;// created during certain events, that *should* clean them up\n// themselves, but may not if there was an error\ndelete gd._dragging;delete gd._dragged;delete gd._dragdata;delete gd._hoverdata;delete gd._snapshotInProgress;delete gd._editing;delete gd._mouseDownTime;delete gd._legendMouseDownTime;// remove all event listeners\nif(gd.removeAllListeners)gd.removeAllListeners();};plots.style=function(gd){var _modules=gd._fullLayout._visibleModules;var styleModules=[];var i;// some trace modules reuse the same style method,\n// make sure to not unnecessary call them multiple times.\nfor(i=0;i<_modules.length;i++){var _module=_modules[i];if(_module.style){Lib.pushUnique(styleModules,_module.style);}}for(i=0;i<styleModules.length;i++){styleModules[i](gd);}};plots.sanitizeMargins=function(fullLayout){// polar doesn't do margins...\nif(!fullLayout||!fullLayout.margin)return;var width=fullLayout.width;var height=fullLayout.height;var margin=fullLayout.margin;var plotWidth=width-(margin.l+margin.r);var plotHeight=height-(margin.t+margin.b);var correction;// if margin.l + margin.r = 0 then plotWidth > 0\n// as width >= 10 by supplyDefaults\n// similarly for margin.t + margin.b\nif(plotWidth<0){correction=(width-1)/(margin.l+margin.r);margin.l=Math.floor(correction*margin.l);margin.r=Math.floor(correction*margin.r);}if(plotHeight<0){correction=(height-1)/(margin.t+margin.b);margin.t=Math.floor(correction*margin.t);margin.b=Math.floor(correction*margin.b);}};plots.clearAutoMarginIds=function(gd){gd._fullLayout._pushmarginIds={};};plots.allowAutoMargin=function(gd,id){gd._fullLayout._pushmarginIds[id]=1;};function initMargins(fullLayout){var margin=fullLayout.margin;if(!fullLayout._size){var gs=fullLayout._size={l:Math.round(margin.l),r:Math.round(margin.r),t:Math.round(margin.t),b:Math.round(margin.b),p:Math.round(margin.pad)};gs.w=Math.round(fullLayout.width)-gs.l-gs.r;gs.h=Math.round(fullLayout.height)-gs.t-gs.b;}if(!fullLayout._pushmargin)fullLayout._pushmargin={};if(!fullLayout._pushmarginIds)fullLayout._pushmarginIds={};}/**\n * autoMargin: called by components that may need to expand the margins to\n * be rendered on-plot.\n *\n * @param {DOM element} gd\n * @param {string} id - an identifier unique (within this plot) to this object,\n *     so we can remove a previous margin expansion from the same object.\n * @param {object} o - the margin requirements of this object, or omit to delete\n *     this entry (like if it's hidden). Keys are:\n *     x, y: plot fraction of the anchor point.\n *     xl, xr, yt, yb: if the object has an extent defined in plot fraction,\n *         you can specify both edges as plot fractions in each dimension\n *     l, r, t, b: the pixels to pad past the plot fraction x[l|r] and y[t|b]\n *     pad: extra pixels to add in all directions, default 12 (why?)\n */plots.autoMargin=function(gd,id,o){var fullLayout=gd._fullLayout;var pushMargin=fullLayout._pushmargin;var pushMarginIds=fullLayout._pushmarginIds;if(fullLayout.margin.autoexpand!==false){if(!o){delete pushMargin[id];delete pushMarginIds[id];}else{var pad=o.pad;if(pad===undefined){var margin=fullLayout.margin;// if no explicit pad is given, use 12px unless there's a\n// specified margin that's smaller than that\npad=Math.min(12,margin.l,margin.r,margin.t,margin.b);}// if the item is too big, just give it enough automargin to\n// make sure you can still grab it and bring it back\nif(o.l+o.r>fullLayout.width*0.5)o.l=o.r=0;if(o.b+o.t>fullLayout.height*0.5)o.b=o.t=0;var xl=o.xl!==undefined?o.xl:o.x;var xr=o.xr!==undefined?o.xr:o.x;var yt=o.yt!==undefined?o.yt:o.y;var yb=o.yb!==undefined?o.yb:o.y;pushMargin[id]={l:{val:xl,size:o.l+pad},r:{val:xr,size:o.r+pad},b:{val:yb,size:o.b+pad},t:{val:yt,size:o.t+pad}};pushMarginIds[id]=1;}if(!fullLayout._replotting)plots.doAutoMargin(gd);}};plots.doAutoMargin=function(gd){var fullLayout=gd._fullLayout;if(!fullLayout._size)fullLayout._size={};initMargins(fullLayout);var gs=fullLayout._size;var oldmargins=JSON.stringify(gs);var margin=fullLayout.margin;// adjust margins for outside components\n// fullLayout.margin is the requested margin,\n// fullLayout._size has margins and plotsize after adjustment\nvar ml=margin.l;var mr=margin.r;var mt=margin.t;var mb=margin.b;var width=fullLayout.width;var height=fullLayout.height;var pushMargin=fullLayout._pushmargin;var pushMarginIds=fullLayout._pushmarginIds;if(fullLayout.margin.autoexpand!==false){for(var k in pushMargin){if(!pushMarginIds[k])delete pushMargin[k];}// fill in the requested margins\npushMargin.base={l:{val:0,size:ml},r:{val:1,size:mr},t:{val:1,size:mt},b:{val:0,size:mb}};// now cycle through all the combinations of l and r\n// (and t and b) to find the required margins\nfor(var k1 in pushMargin){var pushleft=pushMargin[k1].l||{};var pushbottom=pushMargin[k1].b||{};var fl=pushleft.val;var pl=pushleft.size;var fb=pushbottom.val;var pb=pushbottom.size;for(var k2 in pushMargin){if(isNumeric(pl)&&pushMargin[k2].r){var fr=pushMargin[k2].r.val;var pr=pushMargin[k2].r.size;if(fr>fl){var newL=(pl*fr+(pr-width)*fl)/(fr-fl);var newR=(pr*(1-fl)+(pl-width)*(1-fr))/(fr-fl);if(newL>=0&&newR>=0&&width-(newL+newR)>0&&newL+newR>ml+mr){ml=newL;mr=newR;}}}if(isNumeric(pb)&&pushMargin[k2].t){var ft=pushMargin[k2].t.val;var pt=pushMargin[k2].t.size;if(ft>fb){var newB=(pb*ft+(pt-height)*fb)/(ft-fb);var newT=(pt*(1-fb)+(pb-height)*(1-ft))/(ft-fb);if(newB>=0&&newT>=0&&height-(newT+newB)>0&&newB+newT>mb+mt){mb=newB;mt=newT;}}}}}}gs.l=Math.round(ml);gs.r=Math.round(mr);gs.t=Math.round(mt);gs.b=Math.round(mb);gs.p=Math.round(margin.pad);gs.w=Math.round(width)-gs.l-gs.r;gs.h=Math.round(height)-gs.t-gs.b;// if things changed and we're not already redrawing, trigger a redraw\nif(!fullLayout._replotting&&oldmargins!=='{}'&&oldmargins!==JSON.stringify(fullLayout._size)){if('_redrawFromAutoMarginCount'in fullLayout){fullLayout._redrawFromAutoMarginCount++;}else{fullLayout._redrawFromAutoMarginCount=1;}return Registry.call('plot',gd);}};/**\n * JSONify the graph data and layout\n *\n * This function needs to recurse because some src can be inside\n * sub-objects.\n *\n * It also strips out functions and private (starts with _) elements.\n * Therefore, we can add temporary things to data and layout that don't\n * get saved.\n *\n * @param gd The graphDiv\n * @param {Boolean} dataonly If true, don't return layout.\n * @param {'keepref'|'keepdata'|'keepall'} [mode='keepref'] Filter what's kept\n *      keepref: remove data for which there's a src present\n *          eg if there's xsrc present (and xsrc is well-formed,\n *          ie has : and some chars before it), strip out x\n *      keepdata: remove all src tags, don't remove the data itself\n *      keepall: keep data and src\n * @param {String} output If you specify 'object', the result will not be stringified\n * @param {Boolean} useDefaults If truthy, use _fullLayout and _fullData\n * @returns {Object|String}\n */plots.graphJson=function(gd,dataonly,mode,output,useDefaults){// if the defaults aren't supplied yet, we need to do that...\nif(useDefaults&&dataonly&&!gd._fullData||useDefaults&&!dataonly&&!gd._fullLayout){plots.supplyDefaults(gd);}var data=useDefaults?gd._fullData:gd.data;var layout=useDefaults?gd._fullLayout:gd.layout;var frames=(gd._transitionData||{})._frames;function stripObj(d){if(typeof d==='function'){return null;}if(Lib.isPlainObject(d)){var o={};var v,src;for(v in d){// remove private elements and functions\n// _ is for private, [ is a mistake ie [object Object]\nif(typeof d[v]==='function'||['_','['].indexOf(v.charAt(0))!==-1){continue;}// look for src/data matches and remove the appropriate one\nif(mode==='keepdata'){// keepdata: remove all ...src tags\nif(v.substr(v.length-3)==='src'){continue;}}else if(mode==='keepstream'){// keep sourced data if it's being streamed.\n// similar to keepref, but if the 'stream' object exists\n// in a trace, we will keep the data array.\nsrc=d[v+'src'];if(typeof src==='string'&&src.indexOf(':')>0){if(!Lib.isPlainObject(d.stream)){continue;}}}else if(mode!=='keepall'){// keepref: remove sourced data but only\n// if the source tag is well-formed\nsrc=d[v+'src'];if(typeof src==='string'&&src.indexOf(':')>0){continue;}}// OK, we're including this... recurse into it\no[v]=stripObj(d[v]);}return o;}if(Array.isArray(d)){return d.map(stripObj);}if(Lib.isTypedArray(d)){return Lib.simpleMap(d,Lib.identity);}// convert native dates to date strings...\n// mostly for external users exporting to plotly\nif(Lib.isJSDate(d))return Lib.ms2DateTimeLocal(+d);return d;}var obj={data:(data||[]).map(function(v){var d=stripObj(v);// fit has some little arrays in it that don't contain data,\n// just fit params and meta\nif(dataonly){delete d.fit;}return d;})};if(!dataonly){obj.layout=stripObj(layout);}if(gd.framework&&gd.framework.isPolar)obj=gd.framework.getConfig();if(frames)obj.frames=stripObj(frames);return output==='object'?obj:JSON.stringify(obj);};/**\n * Modify a keyframe using a list of operations:\n *\n * @param {array of objects} operations\n *      Sequence of operations to be performed on the keyframes\n */plots.modifyFrames=function(gd,operations){var i,op,frame;var _frames=gd._transitionData._frames;var _frameHash=gd._transitionData._frameHash;for(i=0;i<operations.length;i++){op=operations[i];switch(op.type){// No reason this couldn't exist, but is currently unused/untested:\n/* case 'rename':\n                frame = _frames[op.index];\n                delete _frameHash[frame.name];\n                _frameHash[op.name] = frame;\n                frame.name = op.name;\n                break;*/case'replace':frame=op.value;var oldName=(_frames[op.index]||{}).name;var newName=frame.name;_frames[op.index]=_frameHash[newName]=frame;if(newName!==oldName){// If name has changed in addition to replacement, then update\n// the lookup table:\ndelete _frameHash[oldName];_frameHash[newName]=frame;}break;case'insert':frame=op.value;_frameHash[frame.name]=frame;_frames.splice(op.index,0,frame);break;case'delete':frame=_frames[op.index];delete _frameHash[frame.name];_frames.splice(op.index,1);break;}}return Promise.resolve();};/*\n * Compute a keyframe. Merge a keyframe into its base frame(s) and\n * expand properties.\n *\n * @param {object} frameLookup\n *      An object containing frames keyed by name (i.e. gd._transitionData._frameHash)\n * @param {string} frame\n *      The name of the keyframe to be computed\n *\n * Returns: a new object with the merged content\n */plots.computeFrame=function(gd,frameName){var frameLookup=gd._transitionData._frameHash;var i,traceIndices,traceIndex,destIndex;// Null or undefined will fail on .toString(). We'll allow numbers since we\n// make it clear frames must be given string names, but we'll allow numbers\n// here since they're otherwise fine for looking up frames as long as they're\n// properly cast to strings. We really just want to ensure here that this\n// 1) doesn't fail, and\n// 2) doens't give an incorrect answer (which String(frameName) would)\nif(!frameName){throw new Error('computeFrame must be given a string frame name');}var framePtr=frameLookup[frameName.toString()];// Return false if the name is invalid:\nif(!framePtr){return false;}var frameStack=[framePtr];var frameNameStack=[framePtr.name];// Follow frame pointers:\nwhile(framePtr.baseframe&&(framePtr=frameLookup[framePtr.baseframe.toString()])){// Avoid infinite loops:\nif(frameNameStack.indexOf(framePtr.name)!==-1)break;frameStack.push(framePtr);frameNameStack.push(framePtr.name);}// A new object for the merged result:\nvar result={};// Merge, starting with the last and ending with the desired frame:\nwhile(framePtr=frameStack.pop()){if(framePtr.layout){result.layout=plots.extendLayout(result.layout,framePtr.layout);}if(framePtr.data){if(!result.data){result.data=[];}traceIndices=framePtr.traces;if(!traceIndices){// If not defined, assume serial order starting at zero\ntraceIndices=[];for(i=0;i<framePtr.data.length;i++){traceIndices[i]=i;}}if(!result.traces){result.traces=[];}for(i=0;i<framePtr.data.length;i++){// Loop through this frames data, find out where it should go,\n// and merge it!\ntraceIndex=traceIndices[i];if(traceIndex===undefined||traceIndex===null){continue;}destIndex=result.traces.indexOf(traceIndex);if(destIndex===-1){destIndex=result.data.length;result.traces[destIndex]=traceIndex;}result.data[destIndex]=plots.extendTrace(result.data[destIndex],framePtr.data[i]);}}}return result;};/*\n * Recompute the lookup table that maps frame name -> frame object. addFrames/\n * deleteFrames already manages this data one at a time, so the only time this\n * is necessary is if you poke around manually in `gd._transitionData._frames`\n * and create and haven't updated the lookup table.\n */plots.recomputeFrameHash=function(gd){var hash=gd._transitionData._frameHash={};var frames=gd._transitionData._frames;for(var i=0;i<frames.length;i++){var frame=frames[i];if(frame&&frame.name){hash[frame.name]=frame;}}};/**\n * Extend an object, treating container arrays very differently by extracting\n * their contents and merging them separately.\n *\n * This exists so that we can extendDeepNoArrays and avoid stepping into data\n * arrays without knowledge of the plot schema, but so that we may also manually\n * recurse into known container arrays, such as transforms.\n *\n * See extendTrace and extendLayout below for usage.\n */plots.extendObjectWithContainers=function(dest,src,containerPaths){var containerProp,containerVal,i,j,srcProp,destProp,srcContainer,destContainer;var copy=Lib.extendDeepNoArrays({},src||{});var expandedObj=Lib.expandObjectPaths(copy);var containerObj={};// Step through and extract any container properties. Otherwise extendDeepNoArrays\n// will clobber any existing properties with an empty array and then supplyDefaults\n// will reset everything to defaults.\nif(containerPaths&&containerPaths.length){for(i=0;i<containerPaths.length;i++){containerProp=Lib.nestedProperty(expandedObj,containerPaths[i]);containerVal=containerProp.get();if(containerVal===undefined){Lib.nestedProperty(containerObj,containerPaths[i]).set(null);}else{containerProp.set(null);Lib.nestedProperty(containerObj,containerPaths[i]).set(containerVal);}}}dest=Lib.extendDeepNoArrays(dest||{},expandedObj);if(containerPaths&&containerPaths.length){for(i=0;i<containerPaths.length;i++){srcProp=Lib.nestedProperty(containerObj,containerPaths[i]);srcContainer=srcProp.get();if(!srcContainer)continue;destProp=Lib.nestedProperty(dest,containerPaths[i]);destContainer=destProp.get();if(!Array.isArray(destContainer)){destContainer=[];destProp.set(destContainer);}for(j=0;j<srcContainer.length;j++){var srcObj=srcContainer[j];if(srcObj===null)destContainer[j]=null;else{destContainer[j]=plots.extendObjectWithContainers(destContainer[j],srcObj);}}destProp.set(destContainer);}}return dest;};plots.dataArrayContainers=['transforms','dimensions'];plots.layoutArrayContainers=Registry.layoutArrayContainers;/*\n * Extend a trace definition. This method:\n *\n *  1. directly transfers any array references\n *  2. manually recurses into container arrays like transforms\n *\n * The result is the original object reference with the new contents merged in.\n */plots.extendTrace=function(destTrace,srcTrace){return plots.extendObjectWithContainers(destTrace,srcTrace,plots.dataArrayContainers);};/*\n * Extend a layout definition. This method:\n *\n *  1. directly transfers any array references (not critically important for\n *     layout since there aren't really data arrays)\n *  2. manually recurses into container arrays like annotations\n *\n * The result is the original object reference with the new contents merged in.\n */plots.extendLayout=function(destLayout,srcLayout){return plots.extendObjectWithContainers(destLayout,srcLayout,plots.layoutArrayContainers);};/**\n * Transition to a set of new data and layout properties from Plotly.animate\n *\n * @param {DOM element} gd\n * @param {Object[]} data\n *      an array of data objects following the normal Plotly data definition format\n * @param {Object} layout\n *      a layout object, following normal Plotly layout format\n * @param {Number[]} traces\n *      indices of the corresponding traces specified in `data`\n * @param {Object} frameOpts\n *      options for the frame (i.e. whether to redraw post-transition)\n * @param {Object} transitionOpts\n *      options for the transition\n */plots.transition=function(gd,data,layout,traces,frameOpts,transitionOpts){var opts={redraw:frameOpts.redraw};var transitionedTraces=[];var axEdits=[];opts.prepareFn=function(){var dataLength=Array.isArray(data)?data.length:0;var traceIndices=traces.slice(0,dataLength);for(var i=0;i<traceIndices.length;i++){var traceIdx=traceIndices[i];var trace=gd._fullData[traceIdx];var module=trace._module;// There's nothing to do if this module is not defined:\nif(!module)continue;// Don't register the trace as transitioned if it doesn't know what to do.\n// If it *is* registered, it will receive a callback that it's responsible\n// for calling in order to register the transition as having completed.\nif(module.animatable){transitionedTraces.push(traceIdx);}gd.data[traceIndices[i]]=plots.extendTrace(gd.data[traceIndices[i]],data[i]);}// Follow the same procedure. Clone it so we don't mangle the input, then\n// expand any object paths so we can merge deep into gd.layout:\nvar layoutUpdate=Lib.expandObjectPaths(Lib.extendDeepNoArrays({},layout));// Before merging though, we need to modify the incoming layout. We only\n// know how to *transition* layout ranges, so it's imperative that a new\n// range not be sent to the layout before the transition has started. So\n// we must remove the things we can transition:\nvar axisAttrRe=/^[xy]axis[0-9]*$/;for(var attr in layoutUpdate){if(!axisAttrRe.test(attr))continue;delete layoutUpdate[attr].range;}plots.extendLayout(gd.layout,layoutUpdate);// Supply defaults after applying the incoming properties. Note that any attempt\n// to simplify this step and reduce the amount of work resulted in the reconstruction\n// of essentially the whole supplyDefaults step, so that it seems sensible to just use\n// supplyDefaults even though it's heavier than would otherwise be desired for\n// transitions:\n// first delete calcdata so supplyDefaults knows a calc step is coming\ndelete gd.calcdata;plots.supplyDefaults(gd);plots.doCalcdata(gd);var newLayout=Lib.expandObjectPaths(layout);if(newLayout){var subplots=gd._fullLayout._plots;for(var k in subplots){var plotinfo=subplots[k];var xa=plotinfo.xaxis;var ya=plotinfo.yaxis;var xr0=xa.range.slice();var yr0=ya.range.slice();var xr1;if(Array.isArray(newLayout[xa._name+'.range'])){xr1=newLayout[xa._name+'.range'].slice();}else if(Array.isArray((newLayout[xa._name]||{}).range)){xr1=newLayout[xa._name].range.slice();}var yr1;if(Array.isArray(newLayout[ya._name+'.range'])){yr1=newLayout[ya._name+'.range'].slice();}else if(Array.isArray((newLayout[ya._name]||{}).range)){yr1=newLayout[ya._name].range.slice();}var editX;if(xr0&&xr1&&(xr0[0]!==xr1[0]||xr0[1]!==xr1[1])){editX={xr0:xr0,xr1:xr1};}var editY;if(yr0&&yr1&&(yr0[0]!==yr1[0]||yr0[1]!==yr1[1])){editY={yr0:yr0,yr1:yr1};}if(editX||editY){axEdits.push(Lib.extendFlat({plotinfo:plotinfo},editX,editY));}}}return Promise.resolve();};opts.runFn=function(makeCallback){var traceTransitionOpts;var basePlotModules=gd._fullLayout._basePlotModules;var hasAxisTransition=axEdits.length;var i;if(layout){for(i=0;i<basePlotModules.length;i++){if(basePlotModules[i].transitionAxes){basePlotModules[i].transitionAxes(gd,axEdits,transitionOpts,makeCallback);}}}// Here handle the exception that we refuse to animate scales and axes at the same\n// time. In other words, if there's an axis transition, then set the data transition\n// to instantaneous.\nif(hasAxisTransition){traceTransitionOpts=Lib.extendFlat({},transitionOpts);traceTransitionOpts.duration=0;// This means do not transition traces,\n// this happens on layout-only (e.g. axis range) animations\ntransitionedTraces=null;}else{traceTransitionOpts=transitionOpts;}for(i=0;i<basePlotModules.length;i++){// Note that we pass a callback to *create* the callback that must be invoked on completion.\n// This is since not all traces know about transitions, so it greatly simplifies matters if\n// the trace is responsible for creating a callback, if needed, and then executing it when\n// the time is right.\nbasePlotModules[i].plot(gd,transitionedTraces,traceTransitionOpts,makeCallback);}};return _transition(gd,transitionOpts,opts);};/**\n * Transition to a set of new data and layout properties from Plotly.react\n *\n * @param {DOM element} gd\n * @param {object} restyleFlags\n * - anim {'all'|'some'}\n * @param {object} relayoutFlags\n * - anim {'all'|'some'}\n * @param {object} oldFullLayout : old (pre Plotly.react) fullLayout\n */plots.transitionFromReact=function(gd,restyleFlags,relayoutFlags,oldFullLayout){var fullLayout=gd._fullLayout;var transitionOpts=fullLayout.transition;var opts={};var axEdits=[];opts.prepareFn=function(){var subplots=fullLayout._plots;// no need to redraw at end of transition,\n// if all changes are animatable\nopts.redraw=false;if(restyleFlags.anim==='some')opts.redraw=true;if(relayoutFlags.anim==='some')opts.redraw=true;for(var k in subplots){var plotinfo=subplots[k];var xa=plotinfo.xaxis;var ya=plotinfo.yaxis;var xr0=oldFullLayout[xa._name].range.slice();var yr0=oldFullLayout[ya._name].range.slice();var xr1=xa.range.slice();var yr1=ya.range.slice();xa.setScale();ya.setScale();var editX;if(xr0[0]!==xr1[0]||xr0[1]!==xr1[1]){editX={xr0:xr0,xr1:xr1};}var editY;if(yr0[0]!==yr1[0]||yr0[1]!==yr1[1]){editY={yr0:yr0,yr1:yr1};}if(editX||editY){axEdits.push(Lib.extendFlat({plotinfo:plotinfo},editX,editY));}}return Promise.resolve();};opts.runFn=function(makeCallback){var fullData=gd._fullData;var fullLayout=gd._fullLayout;var basePlotModules=fullLayout._basePlotModules;var axisTransitionOpts;var traceTransitionOpts;var transitionedTraces;var allTraceIndices=[];for(var i=0;i<fullData.length;i++){allTraceIndices.push(i);}function transitionAxes(){for(var j=0;j<basePlotModules.length;j++){if(basePlotModules[j].transitionAxes){basePlotModules[j].transitionAxes(gd,axEdits,axisTransitionOpts,makeCallback);}}}function transitionTraces(){for(var j=0;j<basePlotModules.length;j++){basePlotModules[j].plot(gd,transitionedTraces,traceTransitionOpts,makeCallback);}}if(axEdits.length&&restyleFlags.anim){if(transitionOpts.ordering==='traces first'){axisTransitionOpts=Lib.extendFlat({},transitionOpts,{duration:0});transitionedTraces=allTraceIndices;traceTransitionOpts=transitionOpts;transitionTraces();setTimeout(transitionAxes,transitionOpts.duration);}else{axisTransitionOpts=transitionOpts;transitionedTraces=null;traceTransitionOpts=Lib.extendFlat({},transitionOpts,{duration:0});transitionAxes();transitionTraces();}}else if(axEdits.length){axisTransitionOpts=transitionOpts;transitionAxes();}else if(restyleFlags.anim){transitionedTraces=allTraceIndices;traceTransitionOpts=transitionOpts;transitionTraces();}};return _transition(gd,transitionOpts,opts);};/**\n * trace/layout transition wrapper that works\n * for transitions initiated by Plotly.animate and Plotly.react.\n *\n * @param {DOM element} gd\n * @param {object} transitionOpts\n * @param {object} opts\n * - redraw {boolean}\n * - prepareFn {function} *should return a Promise*\n * - runFn {function} ran inside executeTransitions\n */function _transition(gd,transitionOpts,opts){var aborted=false;function executeCallbacks(list){var p=Promise.resolve();if(!list)return p;while(list.length){p=p.then(list.shift());}return p;}function flushCallbacks(list){if(!list)return;while(list.length){list.shift();}}function executeTransitions(){gd.emit('plotly_transitioning',[]);return new Promise(function(resolve){// This flag is used to disabled things like autorange:\ngd._transitioning=true;// When instantaneous updates are coming through quickly, it's too much to simply disable\n// all interaction, so store this flag so we can disambiguate whether mouse interactions\n// should be fully disabled or not:\nif(transitionOpts.duration>0){gd._transitioningWithDuration=true;}// If another transition is triggered, this callback will be executed simply because it's\n// in the interruptCallbacks queue. If this transition completes, it will instead flush\n// that queue and forget about this callback.\ngd._transitionData._interruptCallbacks.push(function(){aborted=true;});if(opts.redraw){gd._transitionData._interruptCallbacks.push(function(){return Registry.call('redraw',gd);});}// Emit this and make sure it happens last:\ngd._transitionData._interruptCallbacks.push(function(){gd.emit('plotly_transitioninterrupted',[]);});// Construct callbacks that are executed on transition end. This ensures the d3 transitions\n// are *complete* before anything else is done.\nvar numCallbacks=0;var numCompleted=0;function makeCallback(){numCallbacks++;return function(){numCompleted++;// When all are complete, perform a redraw:\nif(!aborted&&numCompleted===numCallbacks){completeTransition(resolve);}};}opts.runFn(makeCallback);// If nothing else creates a callback, then this will trigger the completion in the next tick:\nsetTimeout(makeCallback());});}function completeTransition(callback){// This a simple workaround for tests which purge the graph before animations\n// have completed. That's not a very common case, so this is the simplest\n// fix.\nif(!gd._transitionData)return;flushCallbacks(gd._transitionData._interruptCallbacks);return Promise.resolve().then(function(){if(opts.redraw){return Registry.call('redraw',gd);}}).then(function(){// Set transitioning false again once the redraw has occurred. This is used, for example,\n// to prevent the trailing redraw from autoranging:\ngd._transitioning=false;gd._transitioningWithDuration=false;gd.emit('plotly_transitioned',[]);}).then(callback);}function interruptPreviousTransitions(){// Fail-safe against purged plot:\nif(!gd._transitionData)return;// If a transition is interrupted, set this to false. At the moment, the only thing that would\n// interrupt a transition is another transition, so that it will momentarily be set to true\n// again, but this determines whether autorange or dragbox work, so it's for the sake of\n// cleanliness:\ngd._transitioning=false;return executeCallbacks(gd._transitionData._interruptCallbacks);}var seq=[plots.previousPromises,interruptPreviousTransitions,opts.prepareFn,plots.rehover,executeTransitions];var transitionStarting=Lib.syncOrAsync(seq,gd);if(!transitionStarting||!transitionStarting.then){transitionStarting=Promise.resolve();}return transitionStarting.then(function(){return gd;});}plots.doCalcdata=function(gd,traces){var axList=axisIDs.list(gd);var fullData=gd._fullData;var fullLayout=gd._fullLayout;var trace,_module,i,j;// XXX: Is this correct? Needs a closer look so that *some* traces can be recomputed without\n// *all* needing doCalcdata:\nvar calcdata=new Array(fullData.length);var oldCalcdata=(gd.calcdata||[]).slice(0);gd.calcdata=calcdata;// extra helper variables\n// how many box/violins plots do we have (in case they're grouped)\nfullLayout._numBoxes=0;fullLayout._numViolins=0;// initialize violin per-scale-group stats container\nfullLayout._violinScaleGroupStats={};// for calculating avg luminosity of heatmaps\ngd._hmpixcount=0;gd._hmlumcount=0;// for sharing colors across pies / sunbursts (and for legend)\nfullLayout._piecolormap={};fullLayout._sunburstcolormap={};// If traces were specified and this trace was not included,\n// then transfer it over from the old calcdata:\nfor(i=0;i<fullData.length;i++){if(Array.isArray(traces)&&traces.indexOf(i)===-1){calcdata[i]=oldCalcdata[i];continue;}}for(i=0;i<fullData.length;i++){trace=fullData[i];trace._arrayAttrs=PlotSchema.findArrayAttributes(trace);// keep track of trace extremes (for autorange) in here\ntrace._extremes={};}// add polar axes to axis list\nvar polarIds=fullLayout._subplots.polar||[];for(i=0;i<polarIds.length;i++){axList.push(fullLayout[polarIds[i]].radialaxis,fullLayout[polarIds[i]].angularaxis);}setupAxisCategories(axList,fullData);var hasCalcTransform=false;// transform loop\nfor(i=0;i<fullData.length;i++){trace=fullData[i];if(trace.visible===true&&trace.transforms){_module=trace._module;// we need one round of trace module calc before\n// the calc transform to 'fill in' the categories list\n// used for example in the data-to-coordinate method\nif(_module&&_module.calc){var cdi=_module.calc(gd,trace);// must clear scene 'batches', so that 2nd\n// _module.calc call starts from scratch\nif(cdi[0]&&cdi[0].t&&cdi[0].t._scene){delete cdi[0].t._scene.dirty;}}for(j=0;j<trace.transforms.length;j++){var transform=trace.transforms[j];_module=transformsRegistry[transform.type];if(_module&&_module.calcTransform){trace._hasCalcTransform=true;hasCalcTransform=true;_module.calcTransform(gd,trace,transform);}}}}// clear stuff that should recomputed in 'regular' loop\nif(hasCalcTransform)setupAxisCategories(axList,fullData);function calci(i,isContainer){trace=fullData[i];_module=trace._module;if(!!_module.isContainer!==isContainer)return;var cd=[];if(trace.visible===true){// clear existing ref in case it got relinked\ndelete trace._indexToPoints;// keep ref of index-to-points map object of the *last* enabled transform,\n// this index-to-points map object is required to determine the calcdata indices\n// that correspond to input indices (e.g. from 'selectedpoints')\nvar transforms=trace.transforms||[];for(j=transforms.length-1;j>=0;j--){if(transforms[j].enabled){trace._indexToPoints=transforms[j]._indexToPoints;break;}}if(_module&&_module.calc){cd=_module.calc(gd,trace);}}// Make sure there is a first point.\n//\n// This ensures there is a calcdata item for every trace,\n// even if cartesian logic doesn't handle it (for things like legends).\nif(!Array.isArray(cd)||!cd[0]){cd=[{x:BADNUM,y:BADNUM}];}// add the trace-wide properties to the first point,\n// per point properties to every point\n// t is the holder for trace-wide properties\nif(!cd[0].t)cd[0].t={};cd[0].trace=trace;calcdata[i]=cd;}// 'regular' loop - make sure container traces (eg carpet) calc before\n// contained traces (eg contourcarpet)\nfor(i=0;i<fullData.length;i++){calci(i,true);}for(i=0;i<fullData.length;i++){calci(i,false);}doCrossTraceCalc(gd);Registry.getComponentMethod('fx','calc')(gd);Registry.getComponentMethod('errorbars','calc')(gd);};function setupAxisCategories(axList,fullData){for(var i=0;i<axList.length;i++){var ax=axList[i];ax.clearCalc();if(ax.type==='multicategory'){ax.setupMultiCategory(fullData);}}}function doCrossTraceCalc(gd){var fullLayout=gd._fullLayout;var modules=fullLayout._visibleModules;var hash={};var i,j,k;// position and range calculations for traces that\n// depend on each other ie bars (stacked or grouped)\n// and boxes (grouped) push each other out of the way\nfor(j=0;j<modules.length;j++){var _module=modules[j];var fn=_module.crossTraceCalc;if(fn){var spType=_module.basePlotModule.name;if(hash[spType]){Lib.pushUnique(hash[spType],fn);}else{hash[spType]=[fn];}}}for(k in hash){var methods=hash[k];var subplots=fullLayout._subplots[k];if(Array.isArray(subplots)){for(i=0;i<subplots.length;i++){var sp=subplots[i];var spInfo=k==='cartesian'?fullLayout._plots[sp]:fullLayout[sp];for(j=0;j<methods.length;j++){methods[j](gd,spInfo,sp);}}}else{for(j=0;j<methods.length;j++){methods[j](gd);}}}}plots.rehover=function(gd){if(gd._fullLayout._rehover){gd._fullLayout._rehover();}};plots.redrag=function(gd){if(gd._fullLayout._redrag){gd._fullLayout._redrag();}};plots.generalUpdatePerTraceModule=function(gd,subplot,subplotCalcData,subplotLayout){var traceHashOld=subplot.traceHash;var traceHash={};var i;// build up moduleName -> calcData hash\nfor(i=0;i<subplotCalcData.length;i++){var calcTraces=subplotCalcData[i];var trace=calcTraces[0].trace;// skip over visible === false traces\n// as they don't have `_module` ref\nif(trace.visible){traceHash[trace.type]=traceHash[trace.type]||[];traceHash[trace.type].push(calcTraces);}}// when a trace gets deleted, make sure that its module's\n// plot method is called so that it is properly\n// removed from the DOM.\nfor(var moduleNameOld in traceHashOld){if(!traceHash[moduleNameOld]){var fakeCalcTrace=traceHashOld[moduleNameOld][0];var fakeTrace=fakeCalcTrace[0].trace;fakeTrace.visible=false;traceHash[moduleNameOld]=[fakeCalcTrace];}}// call module plot method\nfor(var moduleName in traceHash){var moduleCalcData=traceHash[moduleName];var _module=moduleCalcData[0][0].trace._module;_module.plot(gd,subplot,Lib.filterVisible(moduleCalcData),subplotLayout);}// update moduleName -> calcData hash\nsubplot.traceHash=traceHash;};},{\"../components/color\":43,\"../constants/numerical\":140,\"../lib\":159,\"../plot_api/plot_schema\":192,\"../plot_api/plot_template\":193,\"../registry\":242,\"./animation_attributes\":198,\"./attributes\":200,\"./cartesian/axis_ids\":206,\"./command\":227,\"./font_attributes\":229,\"./frame_attributes\":230,\"./layout_attributes\":233,\"d3\":8,\"fast-isnumeric\":10}],236:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var scatterAttrs=_dereq_('../../../traces/scatter/attributes');var scatterMarkerAttrs=scatterAttrs.marker;var extendFlat=_dereq_('../../../lib/extend').extendFlat;var deprecationWarning=['Area traces are deprecated!','Please switch to the *barpolar* trace type.'].join(' ');module.exports={r:extendFlat({},scatterAttrs.r,{}),t:extendFlat({},scatterAttrs.t,{}),marker:{color:extendFlat({},scatterMarkerAttrs.color,{}),size:extendFlat({},scatterMarkerAttrs.size,{}),symbol:extendFlat({},scatterMarkerAttrs.symbol,{}),opacity:extendFlat({},scatterMarkerAttrs.opacity,{}),editType:'calc'}};},{\"../../../lib/extend\":153,\"../../../traces/scatter/attributes\":280}],237:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var axesAttrs=_dereq_('../../cartesian/layout_attributes');var extendFlat=_dereq_('../../../lib/extend').extendFlat;var overrideAll=_dereq_('../../../plot_api/edit_types').overrideAll;var deprecationWarning=['Legacy polar charts are deprecated!','Please switch to *polar* subplots.'].join(' ');var domainAttr=extendFlat({},axesAttrs.domain,{});function mergeAttrs(axisName,nonCommonAttrs){var commonAttrs={showline:{valType:'boolean'},showticklabels:{valType:'boolean'},tickorientation:{valType:'enumerated',values:['horizontal','vertical']},ticklen:{valType:'number',min:0},tickcolor:{valType:'color'},ticksuffix:{valType:'string'},endpadding:{valType:'number',description:deprecationWarning},visible:{valType:'boolean'}};return extendFlat({},nonCommonAttrs,commonAttrs);}module.exports=overrideAll({radialaxis:mergeAttrs('radial',{range:{valType:'info_array',items:[{valType:'number'},{valType:'number'}]},domain:domainAttr,orientation:{valType:'number'}}),angularaxis:mergeAttrs('angular',{range:{valType:'info_array',items:[{valType:'number',dflt:0},{valType:'number',dflt:360}]},domain:domainAttr}),// attributes that appear at layout root\nlayout:{direction:{valType:'enumerated',values:['clockwise','counterclockwise']},orientation:{valType:'angle'}}},'plot','nested');},{\"../../../lib/extend\":153,\"../../../plot_api/edit_types\":186,\"../../cartesian/layout_attributes\":215}],238:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Polar=module.exports=_dereq_('./micropolar');Polar.manager=_dereq_('./micropolar_manager');},{\"./micropolar\":239,\"./micropolar_manager\":240}],239:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/var d3=_dereq_('d3');var Lib=_dereq_('../../../lib');var extendDeepAll=Lib.extendDeepAll;var MID_SHIFT=_dereq_('../../../constants/alignment').MID_SHIFT;var =module.exports={version:'0.2.2'};.Axis=function module(){var config={data:[],layout:{}},inputConfig={},liveConfig={};var svg,container,dispatch=d3.dispatch('hover'),radialScale,angularScale;var exports={};function render(_container){container=_container||container;var data=config.data;var axisConfig=config.layout;if(typeof container=='string'||container.nodeName)container=d3.select(container);container.datum(data).each(function(_data,_index){var dataOriginal=_data.slice();liveConfig={data:.util.cloneJson(dataOriginal),layout:.util.cloneJson(axisConfig)};var colorIndex=0;dataOriginal.forEach(function(d,i){if(!d.color){d.color=axisConfig.defaultColorRange[colorIndex];colorIndex=(colorIndex+1)%axisConfig.defaultColorRange.length;}if(!d.strokeColor){d.strokeColor=d.geometry==='LinePlot'?d.color:d3.rgb(d.color).darker().toString();}liveConfig.data[i].color=d.color;liveConfig.data[i].strokeColor=d.strokeColor;liveConfig.data[i].strokeDash=d.strokeDash;liveConfig.data[i].strokeSize=d.strokeSize;});var data=dataOriginal.filter(function(d,i){var visible=d.visible;return typeof visible==='undefined'||visible===true;});var isStacked=false;var dataWithGroupId=data.map(function(d,i){isStacked=isStacked||typeof d.groupId!=='undefined';return d;});if(isStacked){var grouped=d3.nest().key(function(d,i){return typeof d.groupId!='undefined'?d.groupId:'unstacked';}).entries(dataWithGroupId);var dataYStack=[];var stacked=grouped.map(function(d,i){if(d.key==='unstacked')return d.values;else{var prevArray=d.values[0].r.map(function(d,i){return 0;});d.values.forEach(function(d,i,a){d.yStack=[prevArray];dataYStack.push(prevArray);prevArray=.util.sumArrays(d.r,prevArray);});return d.values;}});data=d3.merge(stacked);}data.forEach(function(d,i){d.t=Array.isArray(d.t[0])?d.t:[d.t];d.r=Array.isArray(d.r[0])?d.r:[d.r];});var radius=Math.min(axisConfig.width-axisConfig.margin.left-axisConfig.margin.right,axisConfig.height-axisConfig.margin.top-axisConfig.margin.bottom)/2;radius=Math.max(10,radius);var chartCenter=[axisConfig.margin.left+radius,axisConfig.margin.top+radius];var extent;if(isStacked){var highestStackedValue=d3.max(.util.sumArrays(.util.arrayLast(data).r[0],.util.arrayLast(dataYStack)));extent=[0,highestStackedValue];}else extent=d3.extent(.util.flattenArray(data.map(function(d,i){return d.r;})));if(axisConfig.radialAxis.domain!=.DATAEXTENT)extent[0]=0;radialScale=d3.scale.linear().domain(axisConfig.radialAxis.domain!=.DATAEXTENT&&axisConfig.radialAxis.domain?axisConfig.radialAxis.domain:extent).range([0,radius]);liveConfig.layout.radialAxis.domain=radialScale.domain();var angularDataMerged=.util.flattenArray(data.map(function(d,i){return d.t;}));var isOrdinal=typeof angularDataMerged[0]==='string';var ticks;if(isOrdinal){angularDataMerged=.util.deduplicate(angularDataMerged);ticks=angularDataMerged.slice();angularDataMerged=d3.range(angularDataMerged.length);data=data.map(function(d,i){var result=d;d.t=[angularDataMerged];if(isStacked)result.yStack=d.yStack;return result;});}var hasOnlyLineOrDotPlot=data.filter(function(d,i){return d.geometry==='LinePlot'||d.geometry==='DotPlot';}).length===data.length;var needsEndSpacing=axisConfig.needsEndSpacing===null?isOrdinal||!hasOnlyLineOrDotPlot:axisConfig.needsEndSpacing;var useProvidedDomain=axisConfig.angularAxis.domain&&axisConfig.angularAxis.domain!=.DATAEXTENT&&!isOrdinal&&axisConfig.angularAxis.domain[0]>=0;var angularDomain=useProvidedDomain?axisConfig.angularAxis.domain:d3.extent(angularDataMerged);var angularDomainStep=Math.abs(angularDataMerged[1]-angularDataMerged[0]);if(hasOnlyLineOrDotPlot&&!isOrdinal)angularDomainStep=0;var angularDomainWithPadding=angularDomain.slice();if(needsEndSpacing&&isOrdinal)angularDomainWithPadding[1]+=angularDomainStep;var tickCount=axisConfig.angularAxis.ticksCount||4;if(tickCount>8)tickCount=tickCount/(tickCount/8)+tickCount%8;if(axisConfig.angularAxis.ticksStep){tickCount=(angularDomainWithPadding[1]-angularDomainWithPadding[0])/tickCount;}var angularTicksStep=axisConfig.angularAxis.ticksStep||(angularDomainWithPadding[1]-angularDomainWithPadding[0])/(tickCount*(axisConfig.minorTicks+1));if(ticks)angularTicksStep=Math.max(Math.round(angularTicksStep),1);if(!angularDomainWithPadding[2])angularDomainWithPadding[2]=angularTicksStep;var angularAxisRange=d3.range.apply(this,angularDomainWithPadding);angularAxisRange=angularAxisRange.map(function(d,i){return parseFloat(d.toPrecision(12));});angularScale=d3.scale.linear().domain(angularDomainWithPadding.slice(0,2)).range(axisConfig.direction==='clockwise'?[0,360]:[360,0]);liveConfig.layout.angularAxis.domain=angularScale.domain();liveConfig.layout.angularAxis.endPadding=needsEndSpacing?angularDomainStep:0;svg=d3.select(this).select('svg.chart-root');if(typeof svg==='undefined'||svg.empty()){var skeleton=\"<svg xmlns='http://www.w3.org/2000/svg' class='chart-root'>' + '<g class='outer-group'>' + '<g class='chart-group'>' + '<circle class='background-circle'></circle>' + '<g class='geometry-group'></g>' + '<g class='radial axis-group'>' + '<circle class='outside-circle'></circle>' + '</g>' + '<g class='angular axis-group'></g>' + '<g class='guides-group'><line></line><circle r='0'></circle></g>' + '</g>' + '<g class='legend-group'></g>' + '<g class='tooltips-group'></g>' + '<g class='title-group'><text></text></g>' + '</g>' + '</svg>\";var doc=new DOMParser().parseFromString(skeleton,'application/xml');var newSvg=this.appendChild(this.ownerDocument.importNode(doc.documentElement,true));svg=d3.select(newSvg);}svg.select('.guides-group').style({'pointer-events':'none'});svg.select('.angular.axis-group').style({'pointer-events':'none'});svg.select('.radial.axis-group').style({'pointer-events':'none'});var chartGroup=svg.select('.chart-group');var lineStyle={fill:'none',stroke:axisConfig.tickColor};var fontStyle={'font-size':axisConfig.font.size,'font-family':axisConfig.font.family,fill:axisConfig.font.color,'text-shadow':['-1px 0px','1px -1px','-1px 1px','1px 1px'].map(function(d,i){return' '+d+' 0 '+axisConfig.font.outlineColor;}).join(',')};var legendContainer;if(axisConfig.showLegend){legendContainer=svg.select('.legend-group').attr({transform:'translate('+[radius,axisConfig.margin.top]+')'}).style({display:'block'});var elements=data.map(function(d,i){var datumClone=.util.cloneJson(d);datumClone.symbol=d.geometry==='DotPlot'?d.dotType||'circle':d.geometry!='LinePlot'?'square':'line';datumClone.visibleInLegend=typeof d.visibleInLegend==='undefined'||d.visibleInLegend;datumClone.color=d.geometry==='LinePlot'?d.strokeColor:d.color;return datumClone;});.Legend().config({data:data.map(function(d,i){return d.name||'Element'+i;}),legendConfig:extendDeepAll({},.Legend.defaultConfig().legendConfig,{container:legendContainer,elements:elements,reverseOrder:axisConfig.legend.reverseOrder})})();var legendBBox=legendContainer.node().getBBox();radius=Math.min(axisConfig.width-legendBBox.width-axisConfig.margin.left-axisConfig.margin.right,axisConfig.height-axisConfig.margin.top-axisConfig.margin.bottom)/2;radius=Math.max(10,radius);chartCenter=[axisConfig.margin.left+radius,axisConfig.margin.top+radius];radialScale.range([0,radius]);liveConfig.layout.radialAxis.domain=radialScale.domain();legendContainer.attr('transform','translate('+[chartCenter[0]+radius,chartCenter[1]-radius]+')');}else{legendContainer=svg.select('.legend-group').style({display:'none'});}svg.attr({width:axisConfig.width,height:axisConfig.height}).style({opacity:axisConfig.opacity});chartGroup.attr('transform','translate('+chartCenter+')').style({cursor:'crosshair'});var centeringOffset=[(axisConfig.width-(axisConfig.margin.left+axisConfig.margin.right+radius*2+(legendBBox?legendBBox.width:0)))/2,(axisConfig.height-(axisConfig.margin.top+axisConfig.margin.bottom+radius*2))/2];centeringOffset[0]=Math.max(0,centeringOffset[0]);centeringOffset[1]=Math.max(0,centeringOffset[1]);svg.select('.outer-group').attr('transform','translate('+centeringOffset+')');if(axisConfig.title&&axisConfig.title.text){var title=svg.select('g.title-group text').style(fontStyle).text(axisConfig.title.text);var titleBBox=title.node().getBBox();title.attr({x:chartCenter[0]-titleBBox.width/2,y:chartCenter[1]-radius-20});}var radialAxis=svg.select('.radial.axis-group');if(axisConfig.radialAxis.gridLinesVisible){var gridCircles=radialAxis.selectAll('circle.grid-circle').data(radialScale.ticks(5));gridCircles.enter().append('circle').attr({'class':'grid-circle'}).style(lineStyle);gridCircles.attr('r',radialScale);gridCircles.exit().remove();}radialAxis.select('circle.outside-circle').attr({r:radius}).style(lineStyle);var backgroundCircle=svg.select('circle.background-circle').attr({r:radius}).style({fill:axisConfig.backgroundColor,stroke:axisConfig.stroke});function currentAngle(d,i){return angularScale(d)%360+axisConfig.orientation;}if(axisConfig.radialAxis.visible){var axis=d3.svg.axis().scale(radialScale).ticks(5).tickSize(5);radialAxis.call(axis).attr({transform:'rotate('+axisConfig.radialAxis.orientation+')'});radialAxis.selectAll('.domain').style(lineStyle);radialAxis.selectAll('g>text').text(function(d,i){return this.textContent+axisConfig.radialAxis.ticksSuffix;}).style(fontStyle).style({'text-anchor':'start'}).attr({x:0,y:0,dx:0,dy:0,transform:function transform(d,i){if(axisConfig.radialAxis.tickOrientation==='horizontal'){return'rotate('+-axisConfig.radialAxis.orientation+') translate('+[0,fontStyle['font-size']]+')';}else return'translate('+[0,fontStyle['font-size']]+')';}});radialAxis.selectAll('g>line').style({stroke:'black'});}var angularAxis=svg.select('.angular.axis-group').selectAll('g.angular-tick').data(angularAxisRange);var angularAxisEnter=angularAxis.enter().append('g').classed('angular-tick',true);angularAxis.attr({transform:function transform(d,i){return'rotate('+currentAngle(d,i)+')';}}).style({display:axisConfig.angularAxis.visible?'block':'none'});angularAxis.exit().remove();angularAxisEnter.append('line').classed('grid-line',true).classed('major',function(d,i){return i%(axisConfig.minorTicks+1)==0;}).classed('minor',function(d,i){return!(i%(axisConfig.minorTicks+1)==0);}).style(lineStyle);angularAxisEnter.selectAll('.minor').style({stroke:axisConfig.minorTickColor});angularAxis.select('line.grid-line').attr({x1:axisConfig.tickLength?radius-axisConfig.tickLength:0,x2:radius}).style({display:axisConfig.angularAxis.gridLinesVisible?'block':'none'});angularAxisEnter.append('text').classed('axis-text',true).style(fontStyle);var ticksText=angularAxis.select('text.axis-text').attr({x:radius+axisConfig.labelOffset,dy:MID_SHIFT+'em',transform:function transform(d,i){var angle=currentAngle(d,i);var rad=radius+axisConfig.labelOffset;var orient=axisConfig.angularAxis.tickOrientation;if(orient=='horizontal')return'rotate('+-angle+' '+rad+' 0)';else if(orient=='radial')return angle<270&&angle>90?'rotate(180 '+rad+' 0)':null;else return'rotate('+(angle<=180&&angle>0?-90:90)+' '+rad+' 0)';}}).style({'text-anchor':'middle',display:axisConfig.angularAxis.labelsVisible?'block':'none'}).text(function(d,i){if(i%(axisConfig.minorTicks+1)!=0)return'';if(ticks){return ticks[d]+axisConfig.angularAxis.ticksSuffix;}else return d+axisConfig.angularAxis.ticksSuffix;}).style(fontStyle);if(axisConfig.angularAxis.rewriteTicks)ticksText.text(function(d,i){if(i%(axisConfig.minorTicks+1)!=0)return'';return axisConfig.angularAxis.rewriteTicks(this.textContent,i);});var rightmostTickEndX=d3.max(chartGroup.selectAll('.angular-tick text')[0].map(function(d,i){return d.getCTM().e+d.getBBox().width;}));legendContainer.attr({transform:'translate('+[radius+rightmostTickEndX,axisConfig.margin.top]+')'});var hasGeometry=svg.select('g.geometry-group').selectAll('g').size()>0;var geometryContainer=svg.select('g.geometry-group').selectAll('g.geometry').data(data);geometryContainer.enter().append('g').attr({'class':function _class(d,i){return'geometry geometry'+i;}});geometryContainer.exit().remove();if(data[0]||hasGeometry){var geometryConfigs=[];data.forEach(function(d,i){var geometryConfig={};geometryConfig.radialScale=radialScale;geometryConfig.angularScale=angularScale;geometryConfig.container=geometryContainer.filter(function(dB,iB){return iB==i;});geometryConfig.geometry=d.geometry;geometryConfig.orientation=axisConfig.orientation;geometryConfig.direction=axisConfig.direction;geometryConfig.index=i;geometryConfigs.push({data:d,geometryConfig:geometryConfig});});var geometryConfigsGrouped=d3.nest().key(function(d,i){return typeof d.data.groupId!='undefined'||'unstacked';}).entries(geometryConfigs);var geometryConfigsGrouped2=[];geometryConfigsGrouped.forEach(function(d,i){if(d.key==='unstacked')geometryConfigsGrouped2=geometryConfigsGrouped2.concat(d.values.map(function(d,i){return[d];}));else geometryConfigsGrouped2.push(d.values);});geometryConfigsGrouped2.forEach(function(d,i){var geometry;if(Array.isArray(d))geometry=d[0].geometryConfig.geometry;else geometry=d.geometryConfig.geometry;var finalGeometryConfig=d.map(function(dB,iB){return extendDeepAll([geometry].defaultConfig(),dB);});[geometry]().config(finalGeometryConfig)();});}var guides=svg.select('.guides-group');var tooltipContainer=svg.select('.tooltips-group');var angularTooltip=.tooltipPanel().config({container:tooltipContainer,fontSize:8})();var radialTooltip=.tooltipPanel().config({container:tooltipContainer,fontSize:8})();var geometryTooltip=.tooltipPanel().config({container:tooltipContainer,hasTick:true})();var angularValue,radialValue;if(!isOrdinal){var angularGuideLine=guides.select('line').attr({x1:0,y1:0,y2:0}).style({stroke:'grey','pointer-events':'none'});chartGroup.on('mousemove.angular-guide',function(d,i){var mouseAngle=.util.getMousePos(backgroundCircle).angle;angularGuideLine.attr({x2:-radius,transform:'rotate('+mouseAngle+')'}).style({opacity:.5});var angleWithOriginOffset=(mouseAngle+180+360-axisConfig.orientation)%360;angularValue=angularScale.invert(angleWithOriginOffset);var pos=.util.convertToCartesian(radius+12,mouseAngle+180);angularTooltip.text(.util.round(angularValue)).move([pos[0]+chartCenter[0],pos[1]+chartCenter[1]]);}).on('mouseout.angular-guide',function(d,i){guides.select('line').style({opacity:0});});}var angularGuideCircle=guides.select('circle').style({stroke:'grey',fill:'none'});chartGroup.on('mousemove.radial-guide',function(d,i){var r=.util.getMousePos(backgroundCircle).radius;angularGuideCircle.attr({r:r}).style({opacity:.5});radialValue=radialScale.invert(.util.getMousePos(backgroundCircle).radius);var pos=.util.convertToCartesian(r,axisConfig.radialAxis.orientation);radialTooltip.text(.util.round(radialValue)).move([pos[0]+chartCenter[0],pos[1]+chartCenter[1]]);}).on('mouseout.radial-guide',function(d,i){angularGuideCircle.style({opacity:0});geometryTooltip.hide();angularTooltip.hide();radialTooltip.hide();});svg.selectAll('.geometry-group .mark').on('mouseover.tooltip',function(d,i){var el=d3.select(this);var color=this.style.fill;var newColor='black';var opacity=this.style.opacity||1;el.attr({'data-opacity':opacity});if(color&&color!=='none'){el.attr({'data-fill':color});newColor=d3.hsl(color).darker().toString();el.style({fill:newColor,opacity:1});var textData={t:.util.round(d[0]),r:.util.round(d[1])};if(isOrdinal)textData.t=ticks[d[0]];var text='t: '+textData.t+', r: '+textData.r;var bbox=this.getBoundingClientRect();var svgBBox=svg.node().getBoundingClientRect();var pos=[bbox.left+bbox.width/2-centeringOffset[0]-svgBBox.left,bbox.top+bbox.height/2-centeringOffset[1]-svgBBox.top];geometryTooltip.config({color:newColor}).text(text);geometryTooltip.move(pos);}else{color=this.style.stroke||'black';el.attr({'data-stroke':color});newColor=d3.hsl(color).darker().toString();el.style({stroke:newColor,opacity:1});}}).on('mousemove.tooltip',function(d,i){if(d3.event.which!=0)return false;if(d3.select(this).attr('data-fill'))geometryTooltip.show();}).on('mouseout.tooltip',function(d,i){geometryTooltip.hide();var el=d3.select(this);var fillColor=el.attr('data-fill');if(fillColor)el.style({fill:fillColor,opacity:el.attr('data-opacity')});else el.style({stroke:el.attr('data-stroke'),opacity:el.attr('data-opacity')});});});return exports;}exports.render=function(_container){render(_container);return this;};exports.config=function(_x){if(!arguments.length)return config;var xClone=.util.cloneJson(_x);xClone.data.forEach(function(d,i){if(!config.data[i])config.data[i]={};extendDeepAll(config.data[i],.Axis.defaultConfig().data[0]);extendDeepAll(config.data[i],d);});extendDeepAll(config.layout,.Axis.defaultConfig().layout);extendDeepAll(config.layout,xClone.layout);return this;};exports.getLiveConfig=function(){return liveConfig;};exports.getinputConfig=function(){return inputConfig;};exports.radialScale=function(_x){return radialScale;};exports.angularScale=function(_x){return angularScale;};exports.svg=function(){return svg;};d3.rebind(exports,dispatch,'on');return exports;};.Axis.defaultConfig=function(d,i){var config={data:[{t:[1,2,3,4],r:[10,11,12,13],name:'Line1',geometry:'LinePlot',color:null,strokeDash:'solid',strokeColor:null,strokeSize:'1',visibleInLegend:true,opacity:1}],layout:{defaultColorRange:d3.scale.category10().range(),title:null,height:450,width:500,margin:{top:40,right:40,bottom:40,left:40},font:{size:12,color:'gray',outlineColor:'white',family:'Tahoma, sans-serif'},direction:'clockwise',orientation:0,labelOffset:10,radialAxis:{domain:null,orientation:-45,ticksSuffix:'',visible:true,gridLinesVisible:true,tickOrientation:'horizontal',rewriteTicks:null},angularAxis:{domain:[0,360],ticksSuffix:'',visible:true,gridLinesVisible:true,labelsVisible:true,tickOrientation:'horizontal',rewriteTicks:null,ticksCount:null,ticksStep:null},minorTicks:0,tickLength:null,tickColor:'silver',minorTickColor:'#eee',backgroundColor:'none',needsEndSpacing:null,showLegend:true,legend:{reverseOrder:false},opacity:1}};return config;};.util={};.DATAEXTENT='dataExtent';.AREA='AreaChart';.LINE='LinePlot';.DOT='DotPlot';.BAR='BarChart';.util._override=function(_objA,_objB){for(var x in _objA){if(x in _objB)_objB[x]=_objA[x];}};.util._extend=function(_objA,_objB){for(var x in _objA){_objB[x]=_objA[x];}};.util._rndSnd=function(){return Math.random()*2-1+(Math.random()*2-1)+(Math.random()*2-1);};.util.dataFromEquation2=function(_equation,_step){var step=_step||6;var data=d3.range(0,360+step,step).map(function(deg,index){var theta=deg*Math.PI/180;var radius=_equation(theta);return[deg,radius];});return data;};.util.dataFromEquation=function(_equation,_step,_name){var step=_step||6;var t=[],r=[];d3.range(0,360+step,step).forEach(function(deg,index){var theta=deg*Math.PI/180;var radius=_equation(theta);t.push(deg);r.push(radius);});var result={t:t,r:r};if(_name)result.name=_name;return result;};.util.ensureArray=function(_val,_count){if(typeof _val==='undefined')return null;var arr=[].concat(_val);return d3.range(_count).map(function(d,i){return arr[i]||arr[0];});};.util.fillArrays=function(_obj,_valueNames,_count){_valueNames.forEach(function(d,i){_obj[d]=.util.ensureArray(_obj[d],_count);});return _obj;};.util.cloneJson=function(json){return JSON.parse(JSON.stringify(json));};.util.validateKeys=function(obj,keys){if(typeof keys==='string')keys=keys.split('.');var next=keys.shift();return obj[next]&&(!keys.length||objHasKeys(obj[next],keys));};.util.sumArrays=function(a,b){return d3.zip(a,b).map(function(d,i){return d3.sum(d);});};.util.arrayLast=function(a){return a[a.length-1];};.util.arrayEqual=function(a,b){var i=Math.max(a.length,b.length,1);while(i-->=0&&a[i]===b[i]){;}return i===-2;};.util.flattenArray=function(arr){var r=[];while(!.util.arrayEqual(r,arr)){r=arr;arr=[].concat.apply([],arr);}return arr;};.util.deduplicate=function(arr){return arr.filter(function(v,i,a){return a.indexOf(v)==i;});};.util.convertToCartesian=function(radius,theta){var thetaRadians=theta*Math.PI/180;var x=radius*Math.cos(thetaRadians);var y=radius*Math.sin(thetaRadians);return[x,y];};.util.round=function(_value,_digits){var digits=_digits||2;var mult=Math.pow(10,digits);return Math.round(_value*mult)/mult;};.util.getMousePos=function(_referenceElement){var mousePos=d3.mouse(_referenceElement.node());var mouseX=mousePos[0];var mouseY=mousePos[1];var mouse={};mouse.x=mouseX;mouse.y=mouseY;mouse.pos=mousePos;mouse.angle=(Math.atan2(mouseY,mouseX)+Math.PI)*180/Math.PI;mouse.radius=Math.sqrt(mouseX*mouseX+mouseY*mouseY);return mouse;};.util.duplicatesCount=function(arr){var uniques={},val;var dups={};for(var i=0,len=arr.length;i<len;i++){val=arr[i];if(val in uniques){uniques[val]++;dups[val]=uniques[val];}else{uniques[val]=1;}}return dups;};.util.duplicates=function(arr){return Object.keys(.util.duplicatesCount(arr));};.util.translator=function(obj,sourceBranch,targetBranch,reverse){if(reverse){var targetBranchCopy=targetBranch.slice();targetBranch=sourceBranch;sourceBranch=targetBranchCopy;}var value=sourceBranch.reduce(function(previousValue,currentValue){if(typeof previousValue!='undefined')return previousValue[currentValue];},obj);if(typeof value==='undefined')return;sourceBranch.reduce(function(previousValue,currentValue,index){if(typeof previousValue=='undefined')return;if(index===sourceBranch.length-1)delete previousValue[currentValue];return previousValue[currentValue];},obj);targetBranch.reduce(function(previousValue,currentValue,index){if(typeof previousValue[currentValue]==='undefined')previousValue[currentValue]={};if(index===targetBranch.length-1)previousValue[currentValue]=value;return previousValue[currentValue];},obj);};.PolyChart=function module(){var config=[.PolyChart.defaultConfig()];var dispatch=d3.dispatch('hover');var dashArray={solid:'none',dash:[5,2],dot:[2,5]};var colorScale;function exports(){var geometryConfig=config[0].geometryConfig;var container=geometryConfig.container;if(typeof container=='string')container=d3.select(container);container.datum(config).each(function(_config,_index){var isStack=!!_config[0].data.yStack;var data=_config.map(function(d,i){if(isStack)return d3.zip(d.data.t[0],d.data.r[0],d.data.yStack[0]);else return d3.zip(d.data.t[0],d.data.r[0]);});var angularScale=geometryConfig.angularScale;var domainMin=geometryConfig.radialScale.domain()[0];var generator={};generator.bar=function(d,i,pI){var dataConfig=_config[pI].data;var h=geometryConfig.radialScale(d[1])-geometryConfig.radialScale(0);var stackTop=geometryConfig.radialScale(d[2]||0);var w=dataConfig.barWidth;d3.select(this).attr({'class':'mark bar',d:'M'+[[h+stackTop,-w/2],[h+stackTop,w/2],[stackTop,w/2],[stackTop,-w/2]].join('L')+'Z',transform:function transform(d,i){return'rotate('+(geometryConfig.orientation+angularScale(d[0]))+')';}});};generator.dot=function(d,i,pI){var stackedData=d[2]?[d[0],d[1]+d[2]]:d;var symbol=d3.svg.symbol().size(_config[pI].data.dotSize).type(_config[pI].data.dotType)(d,i);d3.select(this).attr({'class':'mark dot',d:symbol,transform:function transform(d,i){var coord=convertToCartesian(getPolarCoordinates(stackedData));return'translate('+[coord.x,coord.y]+')';}});};var line=d3.svg.line.radial().interpolate(_config[0].data.lineInterpolation).radius(function(d){return geometryConfig.radialScale(d[1]);}).angle(function(d){return geometryConfig.angularScale(d[0])*Math.PI/180;});generator.line=function(d,i,pI){var lineData=d[2]?data[pI].map(function(d,i){return[d[0],d[1]+d[2]];}):data[pI];d3.select(this).each(generator['dot']).style({opacity:function opacity(dB,iB){return+_config[pI].data.dotVisible;},fill:markStyle.stroke(d,i,pI)}).attr({'class':'mark dot'});if(i>0)return;var lineSelection=d3.select(this.parentNode).selectAll('path.line').data([0]);lineSelection.enter().insert('path');lineSelection.attr({'class':'line',d:line(lineData),transform:function transform(dB,iB){return'rotate('+(geometryConfig.orientation+90)+')';},'pointer-events':'none'}).style({fill:function fill(dB,iB){return markStyle.fill(d,i,pI);},'fill-opacity':0,stroke:function stroke(dB,iB){return markStyle.stroke(d,i,pI);},'stroke-width':function strokeWidth(dB,iB){return markStyle['stroke-width'](d,i,pI);},'stroke-dasharray':function strokeDasharray(dB,iB){return markStyle['stroke-dasharray'](d,i,pI);},opacity:function opacity(dB,iB){return markStyle.opacity(d,i,pI);},display:function display(dB,iB){return markStyle.display(d,i,pI);}});};var angularRange=geometryConfig.angularScale.range();var triangleAngle=Math.abs(angularRange[1]-angularRange[0])/data[0].length*Math.PI/180;var arc=d3.svg.arc().startAngle(function(d){return-triangleAngle/2;}).endAngle(function(d){return triangleAngle/2;}).innerRadius(function(d){return geometryConfig.radialScale(domainMin+(d[2]||0));}).outerRadius(function(d){return geometryConfig.radialScale(domainMin+(d[2]||0))+geometryConfig.radialScale(d[1]);});generator.arc=function(d,i,pI){d3.select(this).attr({'class':'mark arc',d:arc,transform:function transform(d,i){return'rotate('+(geometryConfig.orientation+angularScale(d[0])+90)+')';}});};var markStyle={fill:function fill(d,i,pI){return _config[pI].data.color;},stroke:function stroke(d,i,pI){return _config[pI].data.strokeColor;},'stroke-width':function strokeWidth(d,i,pI){return _config[pI].data.strokeSize+'px';},'stroke-dasharray':function strokeDasharray(d,i,pI){return dashArray[_config[pI].data.strokeDash];},opacity:function opacity(d,i,pI){return _config[pI].data.opacity;},display:function display(d,i,pI){return typeof _config[pI].data.visible==='undefined'||_config[pI].data.visible?'block':'none';}};var geometryLayer=d3.select(this).selectAll('g.layer').data(data);geometryLayer.enter().append('g').attr({'class':'layer'});var geometry=geometryLayer.selectAll('path.mark').data(function(d,i){return d;});geometry.enter().append('path').attr({'class':'mark'});geometry.style(markStyle).each(generator[geometryConfig.geometryType]);geometry.exit().remove();geometryLayer.exit().remove();function getPolarCoordinates(d,i){var r=geometryConfig.radialScale(d[1]);var t=(geometryConfig.angularScale(d[0])+geometryConfig.orientation)*Math.PI/180;return{r:r,t:t};}function convertToCartesian(polarCoordinates){var x=polarCoordinates.r*Math.cos(polarCoordinates.t);var y=polarCoordinates.r*Math.sin(polarCoordinates.t);return{x:x,y:y};}});}exports.config=function(_x){if(!arguments.length)return config;_x.forEach(function(d,i){if(!config[i])config[i]={};extendDeepAll(config[i],.PolyChart.defaultConfig());extendDeepAll(config[i],d);});return this;};exports.getColorScale=function(){return colorScale;};d3.rebind(exports,dispatch,'on');return exports;};.PolyChart.defaultConfig=function(){var config={data:{name:'geom1',t:[[1,2,3,4]],r:[[1,2,3,4]],dotType:'circle',dotSize:64,dotVisible:false,barWidth:20,color:'#ffa500',strokeSize:1,strokeColor:'silver',strokeDash:'solid',opacity:1,index:0,visible:true,visibleInLegend:true},geometryConfig:{geometry:'LinePlot',geometryType:'arc',direction:'clockwise',orientation:0,container:'body',radialScale:null,angularScale:null,colorScale:d3.scale.category20()}};return config;};.BarChart=function module(){return .PolyChart();};.BarChart.defaultConfig=function(){var config={geometryConfig:{geometryType:'bar'}};return config;};.AreaChart=function module(){return .PolyChart();};.AreaChart.defaultConfig=function(){var config={geometryConfig:{geometryType:'arc'}};return config;};.DotPlot=function module(){return .PolyChart();};.DotPlot.defaultConfig=function(){var config={geometryConfig:{geometryType:'dot',dotType:'circle'}};return config;};.LinePlot=function module(){return .PolyChart();};.LinePlot.defaultConfig=function(){var config={geometryConfig:{geometryType:'line'}};return config;};.Legend=function module(){var config=.Legend.defaultConfig();var dispatch=d3.dispatch('hover');function exports(){var legendConfig=config.legendConfig;var flattenData=config.data.map(function(d,i){return[].concat(d).map(function(dB,iB){var element=extendDeepAll({},legendConfig.elements[i]);element.name=dB;element.color=[].concat(legendConfig.elements[i].color)[iB];return element;});});var data=d3.merge(flattenData);data=data.filter(function(d,i){return legendConfig.elements[i]&&(legendConfig.elements[i].visibleInLegend||typeof legendConfig.elements[i].visibleInLegend==='undefined');});if(legendConfig.reverseOrder)data=data.reverse();var container=legendConfig.container;if(typeof container=='string'||container.nodeName)container=d3.select(container);var colors=data.map(function(d,i){return d.color;});var lineHeight=legendConfig.fontSize;var isContinuous=legendConfig.isContinuous==null?typeof data[0]==='number':legendConfig.isContinuous;var height=isContinuous?legendConfig.height:lineHeight*data.length;var legendContainerGroup=container.classed('legend-group',true);var svg=legendContainerGroup.selectAll('svg').data([0]);var svgEnter=svg.enter().append('svg').attr({width:300,height:height+lineHeight,xmlns:'http://www.w3.org/2000/svg','xmlns:xlink':'http://www.w3.org/1999/xlink',version:'1.1'});svgEnter.append('g').classed('legend-axis',true);svgEnter.append('g').classed('legend-marks',true);var dataNumbered=d3.range(data.length);var colorScale=d3.scale[isContinuous?'linear':'ordinal']().domain(dataNumbered).range(colors);var dataScale=d3.scale[isContinuous?'linear':'ordinal']().domain(dataNumbered)[isContinuous?'range':'rangePoints']([0,height]);var shapeGenerator=function shapeGenerator(_type,_size){var squareSize=_size*3;if(_type==='line'){return'M'+[[-_size/2,-_size/12],[_size/2,-_size/12],[_size/2,_size/12],[-_size/2,_size/12]]+'Z';}else if(d3.svg.symbolTypes.indexOf(_type)!=-1)return d3.svg.symbol().type(_type).size(squareSize)();else return d3.svg.symbol().type('square').size(squareSize)();};if(isContinuous){var gradient=svg.select('.legend-marks').append('defs').append('linearGradient').attr({id:'grad1',x1:'0%',y1:'0%',x2:'0%',y2:'100%'}).selectAll('stop').data(colors);gradient.enter().append('stop');gradient.attr({offset:function offset(d,i){return i/(colors.length-1)*100+'%';}}).style({'stop-color':function stopColor(d,i){return d;}});svg.append('rect').classed('legend-mark',true).attr({height:legendConfig.height,width:legendConfig.colorBandWidth,fill:'url(#grad1)'});}else{var legendElement=svg.select('.legend-marks').selectAll('path.legend-mark').data(data);legendElement.enter().append('path').classed('legend-mark',true);legendElement.attr({transform:function transform(d,i){return'translate('+[lineHeight/2,dataScale(i)+lineHeight/2]+')';},d:function d(_d2,i){var symbolType=_d2.symbol;return shapeGenerator(symbolType,lineHeight);},fill:function fill(d,i){return colorScale(i);}});legendElement.exit().remove();}var legendAxis=d3.svg.axis().scale(dataScale).orient('right');var axis=svg.select('g.legend-axis').attr({transform:'translate('+[isContinuous?legendConfig.colorBandWidth:lineHeight,lineHeight/2]+')'}).call(legendAxis);axis.selectAll('.domain').style({fill:'none',stroke:'none'});axis.selectAll('line').style({fill:'none',stroke:isContinuous?legendConfig.textColor:'none'});axis.selectAll('text').style({fill:legendConfig.textColor,'font-size':legendConfig.fontSize}).text(function(d,i){return data[i].name;});return exports;}exports.config=function(_x){if(!arguments.length)return config;extendDeepAll(config,_x);return this;};d3.rebind(exports,dispatch,'on');return exports;};.Legend.defaultConfig=function(d,i){var config={data:['a','b','c'],legendConfig:{elements:[{symbol:'line',color:'red'},{symbol:'square',color:'yellow'},{symbol:'diamond',color:'limegreen'}],height:150,colorBandWidth:30,fontSize:12,container:'body',isContinuous:null,textColor:'grey',reverseOrder:false}};return config;};.tooltipPanel=function(){var tooltipEl,tooltipTextEl,backgroundEl;var config={container:null,hasTick:false,fontSize:12,color:'white',padding:5};var id='tooltip-'+.tooltipPanel.uid++;var tickSize=10;var exports=function exports(){tooltipEl=config.container.selectAll('g.'+id).data([0]);var tooltipEnter=tooltipEl.enter().append('g').classed(id,true).style({'pointer-events':'none',display:'none'});backgroundEl=tooltipEnter.append('path').style({fill:'white','fill-opacity':.9}).attr({d:'M0 0'});tooltipTextEl=tooltipEnter.append('text').attr({dx:config.padding+tickSize,dy:+config.fontSize*.3});return exports;};exports.text=function(_text){var l=d3.hsl(config.color).l;var strokeColor=l>=.5?'#aaa':'white';var fillColor=l>=.5?'black':'white';var text=_text||'';tooltipTextEl.style({fill:fillColor,'font-size':config.fontSize+'px'}).text(text);var padding=config.padding;var bbox=tooltipTextEl.node().getBBox();var boxStyle={fill:config.color,stroke:strokeColor,'stroke-width':'2px'};var backGroundW=bbox.width+padding*2+tickSize;var backGroundH=bbox.height+padding*2;backgroundEl.attr({d:'M'+[[tickSize,-backGroundH/2],[tickSize,-backGroundH/4],[config.hasTick?0:tickSize,0],[tickSize,backGroundH/4],[tickSize,backGroundH/2],[backGroundW,backGroundH/2],[backGroundW,-backGroundH/2]].join('L')+'Z'}).style(boxStyle);tooltipEl.attr({transform:'translate('+[tickSize,-backGroundH/2+padding*2]+')'});tooltipEl.style({display:'block'});return exports;};exports.move=function(_pos){if(!tooltipEl)return;tooltipEl.attr({transform:'translate('+[_pos[0],_pos[1]]+')'}).style({display:'block'});return exports;};exports.hide=function(){if(!tooltipEl)return;tooltipEl.style({display:'none'});return exports;};exports.show=function(){if(!tooltipEl)return;tooltipEl.style({display:'block'});return exports;};exports.config=function(_x){extendDeepAll(config,_x);return exports;};return exports;};.tooltipPanel.uid=1;.adapter={};.adapter.plotly=function module(){var exports={};exports.convert=function(_inputConfig,reverse){var outputConfig={};if(_inputConfig.data){outputConfig.data=_inputConfig.data.map(function(d,i){var r=extendDeepAll({},d);var toTranslate=[[r,['marker','color'],['color']],[r,['marker','opacity'],['opacity']],[r,['marker','line','color'],['strokeColor']],[r,['marker','line','dash'],['strokeDash']],[r,['marker','line','width'],['strokeSize']],[r,['marker','symbol'],['dotType']],[r,['marker','size'],['dotSize']],[r,['marker','barWidth'],['barWidth']],[r,['line','interpolation'],['lineInterpolation']],[r,['showlegend'],['visibleInLegend']]];toTranslate.forEach(function(d,i){.util.translator.apply(null,d.concat(reverse));});if(!reverse)delete r.marker;if(reverse)delete r.groupId;if(!reverse){if(r.type==='scatter'){if(r.mode==='lines')r.geometry='LinePlot';else if(r.mode==='markers')r.geometry='DotPlot';else if(r.mode==='lines+markers'){r.geometry='LinePlot';r.dotVisible=true;}}else if(r.type==='area')r.geometry='AreaChart';else if(r.type==='bar')r.geometry='BarChart';delete r.mode;delete r.type;}else{if(r.geometry==='LinePlot'){r.type='scatter';if(r.dotVisible===true){delete r.dotVisible;r.mode='lines+markers';}else r.mode='lines';}else if(r.geometry==='DotPlot'){r.type='scatter';r.mode='markers';}else if(r.geometry==='AreaChart')r.type='area';else if(r.geometry==='BarChart')r.type='bar';delete r.geometry;}return r;});if(!reverse&&_inputConfig.layout&&_inputConfig.layout.barmode==='stack'){var duplicates=.util.duplicates(outputConfig.data.map(function(d,i){return d.geometry;}));outputConfig.data.forEach(function(d,i){var idx=duplicates.indexOf(d.geometry);if(idx!=-1)outputConfig.data[i].groupId=idx;});}}if(_inputConfig.layout){var r=extendDeepAll({},_inputConfig.layout);var toTranslate=[[r,['plot_bgcolor'],['backgroundColor']],[r,['showlegend'],['showLegend']],[r,['radialaxis'],['radialAxis']],[r,['angularaxis'],['angularAxis']],[r.angularaxis,['showline'],['gridLinesVisible']],[r.angularaxis,['showticklabels'],['labelsVisible']],[r.angularaxis,['nticks'],['ticksCount']],[r.angularaxis,['tickorientation'],['tickOrientation']],[r.angularaxis,['ticksuffix'],['ticksSuffix']],[r.angularaxis,['range'],['domain']],[r.angularaxis,['endpadding'],['endPadding']],[r.radialaxis,['showline'],['gridLinesVisible']],[r.radialaxis,['tickorientation'],['tickOrientation']],[r.radialaxis,['ticksuffix'],['ticksSuffix']],[r.radialaxis,['range'],['domain']],[r.angularAxis,['showline'],['gridLinesVisible']],[r.angularAxis,['showticklabels'],['labelsVisible']],[r.angularAxis,['nticks'],['ticksCount']],[r.angularAxis,['tickorientation'],['tickOrientation']],[r.angularAxis,['ticksuffix'],['ticksSuffix']],[r.angularAxis,['range'],['domain']],[r.angularAxis,['endpadding'],['endPadding']],[r.radialAxis,['showline'],['gridLinesVisible']],[r.radialAxis,['tickorientation'],['tickOrientation']],[r.radialAxis,['ticksuffix'],['ticksSuffix']],[r.radialAxis,['range'],['domain']],[r.font,['outlinecolor'],['outlineColor']],[r.legend,['traceorder'],['reverseOrder']],[r,['labeloffset'],['labelOffset']],[r,['defaultcolorrange'],['defaultColorRange']]];toTranslate.forEach(function(d,i){.util.translator.apply(null,d.concat(reverse));});if(!reverse){if(r.angularAxis&&typeof r.angularAxis.ticklen!=='undefined')r.tickLength=r.angularAxis.ticklen;if(r.angularAxis&&typeof r.angularAxis.tickcolor!=='undefined')r.tickColor=r.angularAxis.tickcolor;}else{if(typeof r.tickLength!=='undefined'){r.angularaxis.ticklen=r.tickLength;delete r.tickLength;}if(r.tickColor){r.angularaxis.tickcolor=r.tickColor;delete r.tickColor;}}if(r.legend&&typeof r.legend.reverseOrder!='boolean'){r.legend.reverseOrder=r.legend.reverseOrder!='normal';}if(r.legend&&typeof r.legend.traceorder=='boolean'){r.legend.traceorder=r.legend.traceorder?'reversed':'normal';delete r.legend.reverseOrder;}if(r.margin&&typeof r.margin.t!='undefined'){var source=['t','r','b','l','pad'];var target=['top','right','bottom','left','pad'];var margin={};d3.entries(r.margin).forEach(function(dB,iB){margin[target[source.indexOf(dB.key)]]=dB.value;});r.margin=margin;}if(reverse){delete r.needsEndSpacing;delete r.minorTickColor;delete r.minorTicks;delete r.angularaxis.ticksCount;delete r.angularaxis.ticksCount;delete r.angularaxis.ticksStep;delete r.angularaxis.rewriteTicks;delete r.angularaxis.nticks;delete r.radialaxis.ticksCount;delete r.radialaxis.ticksCount;delete r.radialaxis.ticksStep;delete r.radialaxis.rewriteTicks;delete r.radialaxis.nticks;}outputConfig.layout=r;}return outputConfig;};return exports;};},{\"../../../constants/alignment\":138,\"../../../lib\":159,\"d3\":8}],240:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/ /* eslint-disable new-cap */'use strict';var d3=_dereq_('d3');var Lib=_dereq_('../../../lib');var Color=_dereq_('../../../components/color');var micropolar=_dereq_('./micropolar');var UndoManager=_dereq_('./undo_manager');var extendDeepAll=Lib.extendDeepAll;var manager=module.exports={};manager.framework=function(_gd){var config,previousConfigClone,plot,convertedInput,container;var undoManager=new UndoManager();function exports(_inputConfig,_container){if(_container)container=_container;d3.select(d3.select(container).node().parentNode).selectAll('.svg-container>*:not(.chart-root)').remove();config=!config?_inputConfig:extendDeepAll(config,_inputConfig);if(!plot)plot=micropolar.Axis();convertedInput=micropolar.adapter.plotly().convert(config);plot.config(convertedInput).render(container);_gd.data=config.data;_gd.layout=config.layout;manager.fillLayout(_gd);return config;}exports.isPolar=true;exports.svg=function(){return plot.svg();};exports.getConfig=function(){return config;};exports.getLiveConfig=function(){return micropolar.adapter.plotly().convert(plot.getLiveConfig(),true);};exports.getLiveScales=function(){return{t:plot.angularScale(),r:plot.radialScale()};};exports.setUndoPoint=function(){var that=this;var configClone=micropolar.util.cloneJson(config);(function(_configClone,_previousConfigClone){undoManager.add({undo:function undo(){if(_previousConfigClone)that(_previousConfigClone);},redo:function redo(){that(_configClone);}});})(configClone,previousConfigClone);previousConfigClone=micropolar.util.cloneJson(configClone);};exports.undo=function(){undoManager.undo();};exports.redo=function(){undoManager.redo();};return exports;};manager.fillLayout=function(_gd){var container=d3.select(_gd).selectAll('.plot-container');var paperDiv=container.selectAll('.svg-container');var paper=_gd.framework&&_gd.framework.svg&&_gd.framework.svg();var dflts={width:800,height:600,paper_bgcolor:Color.background,_container:container,_paperdiv:paperDiv,_paper:paper};_gd._fullLayout=extendDeepAll(dflts,_gd.layout);};},{\"../../../components/color\":43,\"../../../lib\":159,\"./micropolar\":239,\"./undo_manager\":241,\"d3\":8}],241:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';// Modified from https://github.com/ArthurClemens/Javascript-Undo-Manager\n// Copyright (c) 2010-2013 Arthur Clemens, arthur@visiblearea.com\nmodule.exports=function UndoManager(){var undoCommands=[];var index=-1;var isExecuting=false;var callback;function execute(command,action){if(!command)return this;isExecuting=true;command[action]();isExecuting=false;return this;}return{add:function add(command){if(isExecuting)return this;undoCommands.splice(index+1,undoCommands.length-index);undoCommands.push(command);index=undoCommands.length-1;return this;},setCallback:function setCallback(callbackFunc){callback=callbackFunc;},undo:function undo(){var command=undoCommands[index];if(!command)return this;execute(command,'undo');index-=1;if(callback)callback(command.undo);return this;},redo:function redo(){var command=undoCommands[index+1];if(!command)return this;execute(command,'redo');index+=1;if(callback)callback(command.redo);return this;},clear:function clear(){undoCommands=[];index=-1;},hasUndo:function hasUndo(){return index!==-1;},hasRedo:function hasRedo(){return index<undoCommands.length-1;},getCommands:function getCommands(){return undoCommands;},getPreviousCommand:function getPreviousCommand(){return undoCommands[index-1];},getIndex:function getIndex(){return index;}};};},{}],242:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Loggers=_dereq_('./lib/loggers');var noop=_dereq_('./lib/noop');var pushUnique=_dereq_('./lib/push_unique');var isPlainObject=_dereq_('./lib/is_plain_object');var ExtendModule=_dereq_('./lib/extend');var basePlotAttributes=_dereq_('./plots/attributes');var baseLayoutAttributes=_dereq_('./plots/layout_attributes');var extendFlat=ExtendModule.extendFlat;var extendDeepAll=ExtendModule.extendDeepAll;exports.modules={};exports.allCategories={};exports.allTypes=[];exports.subplotsRegistry={};exports.transformsRegistry={};exports.componentsRegistry={};exports.layoutArrayContainers=[];exports.layoutArrayRegexes=[];exports.traceLayoutAttributes={};exports.localeRegistry={};exports.apiMethodRegistry={};exports.collectableSubplotTypes=null;/**\n * Top-level register routine, exported as Plotly.register\n *\n * @param {object array or array of objects} _modules :\n *  module object or list of module object to register.\n *\n *  A valid `moduleType: 'trace'` module has fields:\n *  - name {string} : the trace type\n *  - categories {array} : categories associated with this trace type,\n *                         tested with Register.traceIs()\n *  - meta {object} : meta info (mostly for plot-schema)\n *\n *  A valid `moduleType: 'locale'` module has fields:\n *  - name {string} : the locale name. Should be a 2-digit language string ('en', 'de')\n *                    optionally with a country/region code ('en-GB', 'de-CH'). If a country\n *                    code is used but the base language locale has not yet been supplied,\n *                    we will use this locale for the base as well.\n *  - dictionary {object} : the dictionary mapping input strings to localized strings\n *                          generally the keys should be the literal input strings, but\n *                          if default translations are provided you can use any string as a key.\n *  - format {object} : a `d3.locale` format specifier for this locale\n *                      any omitted keys we'll fall back on en-US.\n *\n *  A valid `moduleType: 'transform'` module has fields:\n *  - name {string} : transform name\n *  - transform {function} : default-level transform function\n *  - calcTransform {function} : calc-level transform function\n *  - attributes {object} : transform attributes declarations\n *  - supplyDefaults {function} : attributes default-supply function\n *\n *  A valid `moduleType: 'component'` module has fields:\n *  - name {string} : the component name, used it with Register.getComponentMethod()\n *                    to employ component method.\n *\n *  A valid `moduleType: 'apiMethod'` module has fields:\n *  - name {string} : the api method name.\n *  - fn {function} : the api method called with Register.call();\n *\n */exports.register=function register(_modules){exports.collectableSubplotTypes=null;if(!_modules){throw new Error('No argument passed to Plotly.register.');}else if(_modules&&!Array.isArray(_modules)){_modules=[_modules];}for(var i=0;i<_modules.length;i++){var newModule=_modules[i];if(!newModule){throw new Error('Invalid module was attempted to be registered!');}switch(newModule.moduleType){case'trace':registerTraceModule(newModule);break;case'transform':registerTransformModule(newModule);break;case'component':registerComponentModule(newModule);break;case'locale':registerLocale(newModule);break;case'apiMethod':var name=newModule.name;exports.apiMethodRegistry[name]=newModule.fn;break;default:throw new Error('Invalid module was attempted to be registered!');}}};/**\n * Get registered module using trace object or trace type\n *\n * @param {object||string} trace\n *  trace object with prop 'type' or trace type as a string\n * @return {object}\n *  module object corresponding to trace type\n */exports.getModule=function(trace){var _module=exports.modules[getTraceType(trace)];if(!_module)return false;return _module._module;};/**\n * Determine if this trace type is in a given category\n *\n * @param {object||string} traceType\n *  a trace (object) or trace type (string)\n * @param {string} category\n *  category in question\n * @return {boolean}\n */exports.traceIs=function(traceType,category){traceType=getTraceType(traceType);// old plot.ly workspace hack, nothing to see here\nif(traceType==='various')return false;var _module=exports.modules[traceType];if(!_module){if(traceType&&traceType!=='area'){Loggers.log('Unrecognized trace type '+traceType+'.');}_module=exports.modules[basePlotAttributes.type.dflt];}return!!_module.categories[category];};/**\n * Determine if this trace has a transform of the given type and return\n * array of matching indices.\n *\n * @param {object} data\n *  a trace object (member of data or fullData)\n * @param {string} type\n *  type of trace to test\n * @return {array}\n *  array of matching indices. If none found, returns []\n */exports.getTransformIndices=function(data,type){var indices=[];var transforms=data.transforms||[];for(var i=0;i<transforms.length;i++){if(transforms[i].type===type){indices.push(i);}}return indices;};/**\n * Determine if this trace has a transform of the given type\n *\n * @param {object} data\n *  a trace object (member of data or fullData)\n * @param {string} type\n *  type of trace to test\n * @return {boolean}\n */exports.hasTransform=function(data,type){var transforms=data.transforms||[];for(var i=0;i<transforms.length;i++){if(transforms[i].type===type){return true;}}return false;};/**\n * Retrieve component module method. Falls back on noop if either the\n * module or the method is missing, so the result can always be safely called\n *\n * @param {string} name\n *  name of component (as declared in component module)\n * @param {string} method\n *  name of component module method\n * @return {function}\n */exports.getComponentMethod=function(name,method){var _module=exports.componentsRegistry[name];if(!_module)return noop;return _module[method]||noop;};/**\n * Call registered api method.\n *\n * @param {string} name : api method name\n * @param {...array} args : arguments passed to api method\n * @return {any} : returns api method output\n */exports.call=function(){var name=arguments[0];var args=[].slice.call(arguments,1);return exports.apiMethodRegistry[name].apply(null,args);};function registerTraceModule(_module){var thisType=_module.name;var categoriesIn=_module.categories;var meta=_module.meta;if(exports.modules[thisType]){Loggers.log('Type '+thisType+' already registered');return;}if(!exports.subplotsRegistry[_module.basePlotModule.name]){registerSubplot(_module.basePlotModule);}var categoryObj={};for(var i=0;i<categoriesIn.length;i++){categoryObj[categoriesIn[i]]=true;exports.allCategories[categoriesIn[i]]=true;}exports.modules[thisType]={_module:_module,categories:categoryObj};if(meta&&Object.keys(meta).length){exports.modules[thisType].meta=meta;}exports.allTypes.push(thisType);for(var componentName in exports.componentsRegistry){mergeComponentAttrsToTrace(componentName,thisType);}/*\n     * Collect all trace layout attributes in one place for easier lookup later\n     * but don't merge them into the base schema as it would confuse the docs\n     * (at least after https://github.com/plotly/documentation/issues/202 gets done!)\n     */if(_module.layoutAttributes){extendFlat(exports.traceLayoutAttributes,_module.layoutAttributes);}}function registerSubplot(_module){var plotType=_module.name;if(exports.subplotsRegistry[plotType]){Loggers.log('Plot type '+plotType+' already registered.');return;}// relayout array handling will look for component module methods with this\n// name and won't find them because this is a subplot module... but that\n// should be fine, it will just fall back on redrawing the plot.\nfindArrayRegexps(_module);// not sure what's best for the 'cartesian' type at this point\nexports.subplotsRegistry[plotType]=_module;for(var componentName in exports.componentsRegistry){mergeComponentAttrsToSubplot(componentName,_module.name);}}function registerComponentModule(_module){if(typeof _module.name!=='string'){throw new Error('Component module *name* must be a string.');}var name=_module.name;exports.componentsRegistry[name]=_module;if(_module.layoutAttributes){if(_module.layoutAttributes._isLinkedToArray){pushUnique(exports.layoutArrayContainers,name);}findArrayRegexps(_module);}for(var traceType in exports.modules){mergeComponentAttrsToTrace(name,traceType);}for(var subplotName in exports.subplotsRegistry){mergeComponentAttrsToSubplot(name,subplotName);}for(var transformType in exports.transformsRegistry){mergeComponentAttrsToTransform(name,transformType);}if(_module.schema&&_module.schema.layout){extendDeepAll(baseLayoutAttributes,_module.schema.layout);}}function registerTransformModule(_module){if(typeof _module.name!=='string'){throw new Error('Transform module *name* must be a string.');}var prefix='Transform module '+_module.name;var hasTransform=typeof _module.transform==='function';var hasCalcTransform=typeof _module.calcTransform==='function';if(!hasTransform&&!hasCalcTransform){throw new Error(prefix+' is missing a *transform* or *calcTransform* method.');}if(hasTransform&&hasCalcTransform){Loggers.log([prefix+' has both a *transform* and *calcTransform* methods.','Please note that all *transform* methods are executed','before all *calcTransform* methods.'].join(' '));}if(!isPlainObject(_module.attributes)){Loggers.log(prefix+' registered without an *attributes* object.');}if(typeof _module.supplyDefaults!=='function'){Loggers.log(prefix+' registered without a *supplyDefaults* method.');}exports.transformsRegistry[_module.name]=_module;for(var componentName in exports.componentsRegistry){mergeComponentAttrsToTransform(componentName,_module.name);}}function registerLocale(_module){var locale=_module.name;var baseLocale=locale.split('-')[0];var newDict=_module.dictionary;var newFormat=_module.format;var hasDict=newDict&&Object.keys(newDict).length;var hasFormat=newFormat&&Object.keys(newFormat).length;var locales=exports.localeRegistry;var localeObj=locales[locale];if(!localeObj)locales[locale]=localeObj={};// Should we use this dict for the base locale?\n// In case we're overwriting a previous dict for this locale, check\n// whether the base matches the full locale dict now. If we're not\n// overwriting, locales[locale] is undefined so this just checks if\n// baseLocale already had a dict or not.\n// Same logic for dateFormats\nif(baseLocale!==locale){var baseLocaleObj=locales[baseLocale];if(!baseLocaleObj)locales[baseLocale]=baseLocaleObj={};if(hasDict&&baseLocaleObj.dictionary===localeObj.dictionary){baseLocaleObj.dictionary=newDict;}if(hasFormat&&baseLocaleObj.format===localeObj.format){baseLocaleObj.format=newFormat;}}if(hasDict)localeObj.dictionary=newDict;if(hasFormat)localeObj.format=newFormat;}function findArrayRegexps(_module){if(_module.layoutAttributes){var arrayAttrRegexps=_module.layoutAttributes._arrayAttrRegexps;if(arrayAttrRegexps){for(var i=0;i<arrayAttrRegexps.length;i++){pushUnique(exports.layoutArrayRegexes,arrayAttrRegexps[i]);}}}}function mergeComponentAttrsToTrace(componentName,traceType){var componentSchema=exports.componentsRegistry[componentName].schema;if(!componentSchema||!componentSchema.traces)return;var traceAttrs=componentSchema.traces[traceType];if(traceAttrs){extendDeepAll(exports.modules[traceType]._module.attributes,traceAttrs);}}function mergeComponentAttrsToTransform(componentName,transformType){var componentSchema=exports.componentsRegistry[componentName].schema;if(!componentSchema||!componentSchema.transforms)return;var transformAttrs=componentSchema.transforms[transformType];if(transformAttrs){extendDeepAll(exports.transformsRegistry[transformType].attributes,transformAttrs);}}function mergeComponentAttrsToSubplot(componentName,subplotName){var componentSchema=exports.componentsRegistry[componentName].schema;if(!componentSchema||!componentSchema.subplots)return;var subplotModule=exports.subplotsRegistry[subplotName];var subplotAttrs=subplotModule.layoutAttributes;var subplotAttr=subplotModule.attr==='subplot'?subplotModule.name:subplotModule.attr;if(Array.isArray(subplotAttr))subplotAttr=subplotAttr[0];var componentLayoutAttrs=componentSchema.subplots[subplotAttr];if(subplotAttrs&&componentLayoutAttrs){extendDeepAll(subplotAttrs,componentLayoutAttrs);}}function getTraceType(traceType){if(_typeof(traceType)==='object')traceType=traceType.type;return traceType;}},{\"./lib/extend\":153,\"./lib/is_plain_object\":160,\"./lib/loggers\":163,\"./lib/noop\":168,\"./lib/push_unique\":172,\"./plots/attributes\":200,\"./plots/layout_attributes\":233}],243:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../lib');var extendFlat=Lib.extendFlat;var extendDeep=Lib.extendDeep;// Put default plotTile layouts here\nfunction cloneLayoutOverride(tileClass){var override;switch(tileClass){case'themes__thumb':override={autosize:true,width:150,height:150,title:{text:''},showlegend:false,margin:{l:5,r:5,t:5,b:5,pad:0},annotations:[]};break;case'thumbnail':override={title:{text:''},hidesources:true,showlegend:false,borderwidth:0,bordercolor:'',margin:{l:1,r:1,t:1,b:1,pad:0},annotations:[]};break;default:override={};}return override;}function keyIsAxis(keyName){var types=['xaxis','yaxis','zaxis'];return types.indexOf(keyName.slice(0,5))>-1;}module.exports=function clonePlot(graphObj,options){// Polar plot compatibility\nif(graphObj.framework&&graphObj.framework.isPolar){graphObj=graphObj.framework.getConfig();}var i;var oldData=graphObj.data;var oldLayout=graphObj.layout;var newData=extendDeep([],oldData);var newLayout=extendDeep({},oldLayout,cloneLayoutOverride(options.tileClass));var context=graphObj._context||{};if(options.width)newLayout.width=options.width;if(options.height)newLayout.height=options.height;if(options.tileClass==='thumbnail'||options.tileClass==='themes__thumb'){// kill annotations\nnewLayout.annotations=[];var keys=Object.keys(newLayout);for(i=0;i<keys.length;i++){if(keyIsAxis(keys[i])){newLayout[keys[i]].title={text:''};}}// kill colorbar and pie labels\nfor(i=0;i<newData.length;i++){var trace=newData[i];trace.showscale=false;if(trace.marker)trace.marker.showscale=false;if(trace.type==='pie')trace.textposition='none';}}if(Array.isArray(options.annotations)){for(i=0;i<options.annotations.length;i++){newLayout.annotations.push(options.annotations[i]);}}// TODO: does this scene modification really belong here?\n// If we still need it, can it move into the gl3d module?\nvar sceneIds=Object.keys(newLayout).filter(function(key){return key.match(/^scene\\d*$/);});if(sceneIds.length){var axesImageOverride={};if(options.tileClass==='thumbnail'){axesImageOverride={title:{text:''},showaxeslabels:false,showticklabels:false,linetickenable:false};}for(i=0;i<sceneIds.length;i++){var scene=newLayout[sceneIds[i]];if(!scene.xaxis){scene.xaxis={};}if(!scene.yaxis){scene.yaxis={};}if(!scene.zaxis){scene.zaxis={};}extendFlat(scene.xaxis,axesImageOverride);extendFlat(scene.yaxis,axesImageOverride);extendFlat(scene.zaxis,axesImageOverride);// TODO what does this do?\nscene._scene=null;}}var gd=document.createElement('div');if(options.tileClass)gd.className=options.tileClass;var plotTile={gd:gd,td:gd,// for external (image server) compatibility\nlayout:newLayout,data:newData,config:{staticPlot:options.staticPlot===undefined?true:options.staticPlot,plotGlPixelRatio:options.plotGlPixelRatio===undefined?2:options.plotGlPixelRatio,displaylogo:options.displaylogo||false,showLink:options.showLink||false,showTips:options.showTips||false,mapboxAccessToken:context.mapboxAccessToken}};if(options.setBackground!=='transparent'){plotTile.config.setBackground=options.setBackground||'opaque';}// attaching the default Layout the gd, so you can grab it later\nplotTile.gd.defaultLayout=cloneLayoutOverride(options.tileClass);return plotTile;};},{\"../lib\":159}],244:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var toImage=_dereq_('../plot_api/to_image');var Lib=_dereq_('../lib');var fileSaver=_dereq_('./filesaver');/** Plotly.downloadImage\n *\n * @param {object | string | HTML div} gd\n *   can either be a data/layout/config object\n *   or an existing graph <div>\n *   or an id to an existing graph <div>\n * @param {object} opts (see ../plot_api/to_image)\n * @return {promise}\n */function downloadImage(gd,opts){var _gd;if(!Lib.isPlainObject(gd))_gd=Lib.getGraphDiv(gd);// check for undefined opts\nopts=opts||{};// default to png\nopts.format=opts.format||'png';return new Promise(function(resolve,reject){if(_gd&&_gd._snapshotInProgress){reject(new Error('Snapshotting already in progress.'));}// see comments within svgtoimg for additional\n//   discussion of problems with IE\n//   can now draw to canvas, but CORS tainted canvas\n//   does not allow toDataURL\n//   svg format will work though\nif(Lib.isIE()&&opts.format!=='svg'){reject(new Error('Sorry IE does not support downloading from canvas. Try {format:\\'svg\\'} instead.'));}if(_gd)_gd._snapshotInProgress=true;var promise=toImage(gd,opts);var filename=opts.filename||gd.fn||'newplot';filename+='.'+opts.format;promise.then(function(result){if(_gd)_gd._snapshotInProgress=false;return fileSaver(result,filename);}).then(function(name){resolve(name);})[\"catch\"](function(err){if(_gd)_gd._snapshotInProgress=false;reject(err);});});}module.exports=downloadImage;},{\"../lib\":159,\"../plot_api/to_image\":196,\"./filesaver\":245}],245:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/ /*\n* substantial portions of this code from FileSaver.js\n* https://github.com/eligrey/FileSaver.js\n* License: https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md\n* FileSaver.js\n* A saveAs() FileSaver implementation.\n* 1.1.20160328\n*\n* By Eli Grey, http://eligrey.com\n* License: MIT\n*   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md\n*/'use strict';var fileSaver=function fileSaver(url,name){var saveLink=document.createElement('a');var canUseSaveLink='download'in saveLink;var isSafari=/Version\\/[\\d\\.]+.*Safari/.test(navigator.userAgent);var promise=new Promise(function(resolve,reject){// IE <10 is explicitly unsupported\nif(typeof navigator!=='undefined'&&/MSIE [1-9]\\./.test(navigator.userAgent)){reject(new Error('IE < 10 unsupported'));}// First try a.download, then web filesystem, then object URLs\nif(isSafari){// Safari doesn't allow downloading of blob urls\ndocument.location.href='data:application/octet-stream'+url.slice(url.search(/[,;]/));resolve(name);}if(!name){name='download';}if(canUseSaveLink){saveLink.href=url;saveLink.download=name;document.body.appendChild(saveLink);saveLink.click();document.body.removeChild(saveLink);resolve(name);}// IE 10+ (native saveAs)\nif(typeof navigator!=='undefined'&&navigator.msSaveBlob){// At this point we are only dealing with a SVG encoded as\n// a data URL (since IE only supports SVG)\nvar encoded=url.split(/^data:image\\/svg\\+xml,/)[1];var svg=decodeURIComponent(encoded);navigator.msSaveBlob(new Blob([svg]),name);resolve(name);}reject(new Error('download error'));});return promise;};module.exports=fileSaver;},{}],246:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';exports.getDelay=function(fullLayout){if(!fullLayout._has)return 0;return fullLayout._has('gl3d')||fullLayout._has('gl2d')||fullLayout._has('mapbox')?500:0;};exports.getRedrawFunc=function(gd){var fullLayout=gd._fullLayout||{};var hasPolar=fullLayout._has&&fullLayout._has('polar');var hasLegacyPolar=!hasPolar&&gd.data&&gd.data[0]&&gd.data[0].r;// do not work for legacy polar\nif(hasLegacyPolar)return;return function(){(gd.calcdata||[]).forEach(function(d){if(d[0]&&d[0].t&&d[0].t.cb)d[0].t.cb();});};};},{}],247:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var helpers=_dereq_('./helpers');var Snapshot={getDelay:helpers.getDelay,getRedrawFunc:helpers.getRedrawFunc,clone:_dereq_('./cloneplot'),toSVG:_dereq_('./tosvg'),svgToImg:_dereq_('./svgtoimg'),toImage:_dereq_('./toimage'),downloadImage:_dereq_('./download')};module.exports=Snapshot;},{\"./cloneplot\":243,\"./download\":244,\"./helpers\":246,\"./svgtoimg\":248,\"./toimage\":249,\"./tosvg\":250}],248:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../lib');var EventEmitter=_dereq_('events').EventEmitter;function svgToImg(opts){var ev=opts.emitter||new EventEmitter();var promise=new Promise(function(resolve,reject){var Image=window.Image;var svg=opts.svg;var format=opts.format||'png';// IE only support svg\nif(Lib.isIE()&&format!=='svg'){var ieSvgError=new Error('Sorry IE does not support downloading from canvas. Try {format:\\'svg\\'} instead.');reject(ieSvgError);// eventually remove the ev\n//  in favor of promises\nif(!opts.promise){return ev.emit('error',ieSvgError);}else{return promise;}}var canvas=opts.canvas;var scale=opts.scale||1;var w0=opts.width||300;var h0=opts.height||150;var w1=scale*w0;var h1=scale*h0;var ctx=canvas.getContext('2d');var img=new Image();// for Safari support, eliminate createObjectURL\n//  this decision could cause problems if content\n//  is not restricted to svg\nvar url='data:image/svg+xml,'+encodeURIComponent(svg);canvas.width=w1;canvas.height=h1;img.onload=function(){var imgData;// don't need to draw to canvas if svg\n//  save some time and also avoid failure on IE\nif(format!=='svg'){ctx.drawImage(img,0,0,w1,h1);}switch(format){case'jpeg':imgData=canvas.toDataURL('image/jpeg');break;case'png':imgData=canvas.toDataURL('image/png');break;case'webp':imgData=canvas.toDataURL('image/webp');break;case'svg':imgData=url;break;default:var errorMsg='Image format is not jpeg, png, svg or webp.';reject(new Error(errorMsg));// eventually remove the ev\n//  in favor of promises\nif(!opts.promise){return ev.emit('error',errorMsg);}}resolve(imgData);// eventually remove the ev\n//  in favor of promises\nif(!opts.promise){ev.emit('success',imgData);}};img.onerror=function(err){reject(err);// eventually remove the ev\n//  in favor of promises\nif(!opts.promise){return ev.emit('error',err);}};img.src=url;});// temporary for backward compatibility\n//  move to only Promise in 2.0.0\n//  and eliminate the EventEmitter\nif(opts.promise){return promise;}return ev;}module.exports=svgToImg;},{\"../lib\":159,\"events\":7}],249:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var EventEmitter=_dereq_('events').EventEmitter;var Registry=_dereq_('../registry');var Lib=_dereq_('../lib');var helpers=_dereq_('./helpers');var clonePlot=_dereq_('./cloneplot');var toSVG=_dereq_('./tosvg');var svgToImg=_dereq_('./svgtoimg');/**\n * @param {object} gd figure Object\n * @param {object} opts option object\n * @param opts.format 'jpeg' | 'png' | 'webp' | 'svg'\n */function toImage(gd,opts){// first clone the GD so we can operate in a clean environment\nvar ev=new EventEmitter();var clone=clonePlot(gd,{format:'png'});var clonedGd=clone.gd;// put the cloned div somewhere off screen before attaching to DOM\nclonedGd.style.position='absolute';clonedGd.style.left='-5000px';document.body.appendChild(clonedGd);function wait(){var delay=helpers.getDelay(clonedGd._fullLayout);setTimeout(function(){var svg=toSVG(clonedGd);var canvas=document.createElement('canvas');canvas.id=Lib.randstr();ev=svgToImg({format:opts.format,width:clonedGd._fullLayout.width,height:clonedGd._fullLayout.height,canvas:canvas,emitter:ev,svg:svg});ev.clean=function(){if(clonedGd)document.body.removeChild(clonedGd);};},delay);}var redrawFunc=helpers.getRedrawFunc(clonedGd);Registry.call('plot',clonedGd,clone.data,clone.layout,clone.config).then(redrawFunc).then(wait)[\"catch\"](function(err){ev.emit('error',err);});return ev;}module.exports=toImage;},{\"../lib\":159,\"../registry\":242,\"./cloneplot\":243,\"./helpers\":246,\"./svgtoimg\":248,\"./tosvg\":250,\"events\":7}],250:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var Lib=_dereq_('../lib');var Drawing=_dereq_('../components/drawing');var Color=_dereq_('../components/color');var xmlnsNamespaces=_dereq_('../constants/xmlns_namespaces');var DOUBLEQUOTE_REGEX=/\"/g;var DUMMY_SUB='TOBESTRIPPED';var DUMMY_REGEX=new RegExp('(\"'+DUMMY_SUB+')|('+DUMMY_SUB+'\")','g');function htmlEntityDecode(s){var hiddenDiv=d3.select('body').append('div').style({display:'none'}).html('');var replaced=s.replace(/(&[^;]*;)/gi,function(d){if(d==='&lt;'){return'&#60;';}// special handling for brackets\nif(d==='&rt;'){return'&#62;';}if(d.indexOf('<')!==-1||d.indexOf('>')!==-1){return'';}return hiddenDiv.html(d).text();// everything else, let the browser decode it to unicode\n});hiddenDiv.remove();return replaced;}function xmlEntityEncode(str){return str.replace(/&(?!\\w+;|\\#[0-9]+;| \\#x[0-9A-F]+;)/g,'&amp;');}module.exports=function toSVG(gd,format,scale){var fullLayout=gd._fullLayout;var svg=fullLayout._paper;var toppaper=fullLayout._toppaper;var width=fullLayout.width;var height=fullLayout.height;var i;// make background color a rect in the svg, then revert after scraping\n// all other alterations have been dealt with by properly preparing the svg\n// in the first place... like setting cursors with css classes so we don't\n// have to remove them, and providing the right namespaces in the svg to\n// begin with\nsvg.insert('rect',':first-child').call(Drawing.setRect,0,0,width,height).call(Color.fill,fullLayout.paper_bgcolor);// subplot-specific to-SVG methods\n// which notably add the contents of the gl-container\n// into the main svg node\nvar basePlotModules=fullLayout._basePlotModules||[];for(i=0;i<basePlotModules.length;i++){var _module=basePlotModules[i];if(_module.toSVG)_module.toSVG(gd);}// add top items above them assumes everything in toppaper is either\n// a group or a defs, and if it's empty (like hoverlayer) we can ignore it.\nif(toppaper){var nodes=toppaper.node().childNodes;// make copy of nodes as childNodes prop gets mutated in loop below\nvar topGroups=Array.prototype.slice.call(nodes);for(i=0;i<topGroups.length;i++){var topGroup=topGroups[i];if(topGroup.childNodes.length)svg.node().appendChild(topGroup);}}// remove draglayer for Adobe Illustrator compatibility\nif(fullLayout._draggers){fullLayout._draggers.remove();}// in case the svg element had an explicit background color, remove this\n// we want the rect to get the color so it's the right size; svg bg will\n// fill whatever container it's displayed in regardless of plot size.\nsvg.node().style.background='';svg.selectAll('text').attr({'data-unformatted':null,'data-math':null}).each(function(){var txt=d3.select(this);// hidden text is pre-formatting mathjax, the browser ignores it\n// but in a static plot it's useless and it can confuse batik\n// we've tried to standardize on display:none but make sure we still\n// catch visibility:hidden if it ever arises\nif(this.style.visibility==='hidden'||this.style.display==='none'){txt.remove();return;}else{// clear other visibility/display values to default\n// to not potentially confuse non-browser SVG implementations\ntxt.style({visibility:null,display:null});}// Font family styles break things because of quotation marks,\n// so we must remove them *after* the SVG DOM has been serialized\n// to a string (browsers convert singles back)\nvar ff=this.style.fontFamily;if(ff&&ff.indexOf('\"')!==-1){txt.style('font-family',ff.replace(DOUBLEQUOTE_REGEX,DUMMY_SUB));}});svg.selectAll('.point, .scatterpts, .legendfill>path, .legendlines>path, .cbfill').each(function(){var pt=d3.select(this);// similar to font family styles above,\n// we must remove \" after the SVG DOM has been serialized\nvar fill=this.style.fill;if(fill&&fill.indexOf('url(')!==-1){pt.style('fill',fill.replace(DOUBLEQUOTE_REGEX,DUMMY_SUB));}var stroke=this.style.stroke;if(stroke&&stroke.indexOf('url(')!==-1){pt.style('stroke',stroke.replace(DOUBLEQUOTE_REGEX,DUMMY_SUB));}});if(format==='pdf'||format==='eps'){// these formats make the extra line MathJax adds around symbols look super thick in some cases\n// it looks better if this is removed entirely.\nsvg.selectAll('#MathJax_SVG_glyphs path').attr('stroke-width',0);}// fix for IE namespacing quirk?\n// http://stackoverflow.com/questions/19610089/unwanted-namespaces-on-svg-markup-when-using-xmlserializer-in-javascript-with-ie\nsvg.node().setAttributeNS(xmlnsNamespaces.xmlns,'xmlns',xmlnsNamespaces.svg);svg.node().setAttributeNS(xmlnsNamespaces.xmlns,'xmlns:xlink',xmlnsNamespaces.xlink);if(format==='svg'&&scale){svg.attr('width',scale*width);svg.attr('height',scale*height);svg.attr('viewBox','0 0 '+width+' '+height);}var s=new window.XMLSerializer().serializeToString(svg.node());s=htmlEntityDecode(s);s=xmlEntityEncode(s);// Fix quotations around font strings and gradient URLs\ns=s.replace(DUMMY_REGEX,'\\'');// IE is very strict, so we will need to clean\n//  svg with the following regex\n//  yes this is messy, but do not know a better way\n// Even with this IE will not work due to tainted canvas\n//  see https://github.com/kangax/fabric.js/issues/1957\n//      http://stackoverflow.com/questions/18112047/canvas-todataurl-working-in-all-browsers-except-ie10\n// Leave here just in case the CORS/tainted IE issue gets resolved\nif(Lib.isIE()){// replace double quote with single quote\ns=s.replace(/\"/gi,'\\'');// url in svg are single quoted\n//   since we changed double to single\n//   we'll need to change these to double-quoted\ns=s.replace(/(\\('#)([^']*)('\\))/gi,'(\\\"#$2\\\")');// font names with spaces will be escaped single-quoted\n//   we'll need to change these to double-quoted\ns=s.replace(/(\\\\')/gi,'\\\"');}return s;};},{\"../components/color\":43,\"../components/drawing\":64,\"../constants/xmlns_namespaces\":141,\"../lib\":159,\"d3\":8}],251:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var mergeArray=_dereq_('../../lib').mergeArray;// arrayOk attributes, merge them into calcdata array\nmodule.exports=function arraysToCalcdata(cd,trace){for(var i=0;i<cd.length;i++){cd[i].i=i;}mergeArray(trace.text,cd,'tx');mergeArray(trace.hovertext,cd,'htx');var marker=trace.marker;if(marker){mergeArray(marker.opacity,cd,'mo');mergeArray(marker.color,cd,'mc');var markerLine=marker.line;if(markerLine){mergeArray(markerLine.color,cd,'mlc');mergeArray(markerLine.width,cd,'mlw');}}};},{\"../../lib\":159}],252:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var scatterAttrs=_dereq_('../scatter/attributes');var hovertemplateAttrs=_dereq_('../../components/fx/hovertemplate_attributes');var colorAttributes=_dereq_('../../components/colorscale/attributes');var colorbarAttrs=_dereq_('../../components/colorbar/attributes');var fontAttrs=_dereq_('../../plots/font_attributes');var constants=_dereq_('./constants.js');var extendFlat=_dereq_('../../lib/extend').extendFlat;var textFontAttrs=fontAttrs({editType:'calc',arrayOk:true,colorEditType:'style'});var scatterMarkerAttrs=scatterAttrs.marker;var scatterMarkerLineAttrs=scatterMarkerAttrs.line;var markerLineWidth=extendFlat({},scatterMarkerLineAttrs.width,{dflt:0});var markerLine=extendFlat({width:markerLineWidth,editType:'calc'},colorAttributes('marker.line'));var marker=extendFlat({line:markerLine,editType:'calc'},colorAttributes('marker'),{colorbar:colorbarAttrs,opacity:{valType:'number',arrayOk:true,dflt:1,min:0,max:1,editType:'style'}});module.exports={x:scatterAttrs.x,x0:scatterAttrs.x0,dx:scatterAttrs.dx,y:scatterAttrs.y,y0:scatterAttrs.y0,dy:scatterAttrs.dy,text:scatterAttrs.text,hovertext:scatterAttrs.hovertext,hovertemplate:hovertemplateAttrs({},{keys:constants.eventDataKeys}),textposition:{valType:'enumerated',values:['inside','outside','auto','none'],dflt:'none',arrayOk:true,editType:'calc'},textfont:extendFlat({},textFontAttrs,{}),insidetextfont:extendFlat({},textFontAttrs,{}),outsidetextfont:extendFlat({},textFontAttrs,{}),constraintext:{valType:'enumerated',values:['inside','outside','both','none'],dflt:'both',editType:'calc'},cliponaxis:extendFlat({},scatterAttrs.cliponaxis,{}),orientation:{valType:'enumerated',values:['v','h'],editType:'calc+clearAxisTypes'},base:{valType:'any',dflt:null,arrayOk:true,editType:'calc'},offset:{valType:'number',dflt:null,arrayOk:true,editType:'calc'},width:{valType:'number',dflt:null,min:0,arrayOk:true,editType:'calc'},marker:marker,offsetgroup:{valType:'string',dflt:'',editType:'calc'},alignmentgroup:{valType:'string',dflt:'',editType:'calc'},selected:{marker:{opacity:scatterAttrs.selected.marker.opacity,color:scatterAttrs.selected.marker.color,editType:'style'},textfont:scatterAttrs.selected.textfont,editType:'style'},unselected:{marker:{opacity:scatterAttrs.unselected.marker.opacity,color:scatterAttrs.unselected.marker.color,editType:'style'},textfont:scatterAttrs.unselected.textfont,editType:'style'},r:scatterAttrs.r,t:scatterAttrs.t,_deprecated:{bardir:{valType:'enumerated',editType:'calc',values:['v','h']}}};},{\"../../components/colorbar/attributes\":44,\"../../components/colorscale/attributes\":50,\"../../components/fx/hovertemplate_attributes\":81,\"../../lib/extend\":153,\"../../plots/font_attributes\":229,\"../scatter/attributes\":280,\"./constants.js\":254}],253:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Axes=_dereq_('../../plots/cartesian/axes');var hasColorscale=_dereq_('../../components/colorscale/helpers').hasColorscale;var colorscaleCalc=_dereq_('../../components/colorscale/calc');var arraysToCalcdata=_dereq_('./arrays_to_calcdata');var calcSelection=_dereq_('../scatter/calc_selection');module.exports=function calc(gd,trace){var xa=Axes.getFromId(gd,trace.xaxis||'x');var ya=Axes.getFromId(gd,trace.yaxis||'y');var size,pos;if(trace.orientation==='h'){size=xa.makeCalcdata(trace,'x');pos=ya.makeCalcdata(trace,'y');}else{size=ya.makeCalcdata(trace,'y');pos=xa.makeCalcdata(trace,'x');}// create the \"calculated data\" to plot\nvar serieslen=Math.min(pos.length,size.length);var cd=new Array(serieslen);// set position and size\nfor(var i=0;i<serieslen;i++){cd[i]={p:pos[i],s:size[i]};if(trace.ids){cd[i].id=String(trace.ids[i]);}}// auto-z and autocolorscale if applicable\nif(hasColorscale(trace,'marker')){colorscaleCalc(gd,trace,{vals:trace.marker.color,containerStr:'marker',cLetter:'c'});}if(hasColorscale(trace,'marker.line')){colorscaleCalc(gd,trace,{vals:trace.marker.line.color,containerStr:'marker.line',cLetter:'c'});}arraysToCalcdata(cd,trace);calcSelection(cd,trace);return cd;};},{\"../../components/colorscale/calc\":51,\"../../components/colorscale/helpers\":54,\"../../plots/cartesian/axes\":203,\"../scatter/calc_selection\":282,\"./arrays_to_calcdata\":251}],254:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports={eventDataKeys:[]};},{}],255:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var isNumeric=_dereq_('fast-isnumeric');var isArrayOrTypedArray=_dereq_('../../lib').isArrayOrTypedArray;var BADNUM=_dereq_('../../constants/numerical').BADNUM;var Registry=_dereq_('../../registry');var Axes=_dereq_('../../plots/cartesian/axes');var getAxisGroup=_dereq_('../../plots/cartesian/axis_ids').getAxisGroup;var Sieve=_dereq_('./sieve.js');/*\n * Bar chart stacking/grouping positioning and autoscaling calculations\n * for each direction separately calculate the ranges and positions\n * note that this handles histograms too\n * now doing this one subplot at a time\n */function crossTraceCalc(gd,plotinfo){var xa=plotinfo.xaxis;var ya=plotinfo.yaxis;var fullTraces=gd._fullData;var calcTraces=gd.calcdata;var calcTracesHorizontal=[];var calcTracesVertical=[];for(var i=0;i<fullTraces.length;i++){var fullTrace=fullTraces[i];if(fullTrace.visible===true&&Registry.traceIs(fullTrace,'bar')&&fullTrace.xaxis===xa._id&&fullTrace.yaxis===ya._id){if(fullTrace.orientation==='h'){calcTracesHorizontal.push(calcTraces[i]);}else{calcTracesVertical.push(calcTraces[i]);}}}setGroupPositions(gd,xa,ya,calcTracesVertical);setGroupPositions(gd,ya,xa,calcTracesHorizontal);}function setGroupPositions(gd,pa,sa,calcTraces){if(!calcTraces.length)return;var barmode=gd._fullLayout.barmode;var excluded;var included;var i,calcTrace,fullTrace;initBase(gd,pa,sa,calcTraces);switch(barmode){case'overlay':setGroupPositionsInOverlayMode(gd,pa,sa,calcTraces);break;case'group':// exclude from the group those traces for which the user set an offset\nexcluded=[];included=[];for(i=0;i<calcTraces.length;i++){calcTrace=calcTraces[i];fullTrace=calcTrace[0].trace;if(fullTrace.offset===undefined)included.push(calcTrace);else excluded.push(calcTrace);}if(included.length){setGroupPositionsInGroupMode(gd,pa,sa,included);}if(excluded.length){setGroupPositionsInOverlayMode(gd,pa,sa,excluded);}break;case'stack':case'relative':// exclude from the stack those traces for which the user set a base\nexcluded=[];included=[];for(i=0;i<calcTraces.length;i++){calcTrace=calcTraces[i];fullTrace=calcTrace[0].trace;if(fullTrace.base===undefined)included.push(calcTrace);else excluded.push(calcTrace);}if(included.length){setGroupPositionsInStackOrRelativeMode(gd,pa,sa,included);}if(excluded.length){setGroupPositionsInOverlayMode(gd,pa,sa,excluded);}break;}collectExtents(calcTraces,pa);}function initBase(gd,pa,sa,calcTraces){var i,j;for(i=0;i<calcTraces.length;i++){var cd=calcTraces[i];var trace=cd[0].trace;var base=trace.base;var b;// not sure if it really makes sense to have dates for bar size data...\n// ideally if we want to make gantt charts or something we'd treat\n// the actual size (trace.x or y) as time delta but base as absolute\n// time. But included here for completeness.\nvar scalendar=trace.orientation==='h'?trace.xcalendar:trace.ycalendar;// 'base' on categorical axes makes no sense\nvar d2c=sa.type==='category'||sa.type==='multicategory'?function(){return null;}:sa.d2c;if(isArrayOrTypedArray(base)){for(j=0;j<Math.min(base.length,cd.length);j++){b=d2c(base[j],0,scalendar);if(isNumeric(b)){cd[j].b=+b;cd[j].hasB=1;}else cd[j].b=0;}for(;j<cd.length;j++){cd[j].b=0;}}else{b=d2c(base,0,scalendar);var hasBase=isNumeric(b);b=hasBase?b:0;for(j=0;j<cd.length;j++){cd[j].b=b;if(hasBase)cd[j].hasB=1;}}}}function setGroupPositionsInOverlayMode(gd,pa,sa,calcTraces){var barnorm=gd._fullLayout.barnorm;// update position axis and set bar offsets and widths\nfor(var i=0;i<calcTraces.length;i++){var calcTrace=calcTraces[i];var sieve=new Sieve([calcTrace],{sepNegVal:false,overlapNoMerge:!barnorm});// set bar offsets and widths, and update position axis\nsetOffsetAndWidth(gd,pa,sieve);// set bar bases and sizes, and update size axis\n//\n// (note that `setGroupPositionsInOverlayMode` handles the case barnorm\n// is defined, because this function is also invoked for traces that\n// can't be grouped or stacked)\nif(barnorm){sieveBars(gd,sa,sieve);normalizeBars(gd,sa,sieve);}else{setBaseAndTop(gd,sa,sieve);}}}function setGroupPositionsInGroupMode(gd,pa,sa,calcTraces){var fullLayout=gd._fullLayout;var barnorm=fullLayout.barnorm;var sieve=new Sieve(calcTraces,{sepNegVal:false,overlapNoMerge:!barnorm});// set bar offsets and widths, and update position axis\nsetOffsetAndWidthInGroupMode(gd,pa,sieve);// relative-stack bars within the same trace that would otherwise\n// be hidden\nunhideBarsWithinTrace(gd,sa,sieve);// set bar bases and sizes, and update size axis\nif(barnorm){sieveBars(gd,sa,sieve);normalizeBars(gd,sa,sieve);}else{setBaseAndTop(gd,sa,sieve);}}function setGroupPositionsInStackOrRelativeMode(gd,pa,sa,calcTraces){var fullLayout=gd._fullLayout;var barmode=fullLayout.barmode;var barnorm=fullLayout.barnorm;var sieve=new Sieve(calcTraces,{sepNegVal:barmode==='relative',overlapNoMerge:!(barnorm||barmode==='stack'||barmode==='relative')});// set bar offsets and widths, and update position axis\nsetOffsetAndWidth(gd,pa,sieve);// set bar bases and sizes, and update size axis\nstackBars(gd,sa,sieve);// flag the outmost bar (for text display purposes)\nfor(var i=0;i<calcTraces.length;i++){var calcTrace=calcTraces[i];for(var j=0;j<calcTrace.length;j++){var bar=calcTrace[j];if(bar.s!==BADNUM){var isOutmostBar=bar.b+bar.s===sieve.get(bar.p,bar.s);if(isOutmostBar)bar._outmost=true;}}}// Note that marking the outmost bars has to be done\n// before `normalizeBars` changes `bar.b` and `bar.s`.\nif(barnorm)normalizeBars(gd,sa,sieve);}function setOffsetAndWidth(gd,pa,sieve){var fullLayout=gd._fullLayout;var bargap=fullLayout.bargap;var bargroupgap=fullLayout.bargroupgap||0;var minDiff=sieve.minDiff;var calcTraces=sieve.traces;// set bar offsets and widths\nvar barGroupWidth=minDiff*(1-bargap);var barWidthPlusGap=barGroupWidth;var barWidth=barWidthPlusGap*(1-bargroupgap);// computer bar group center and bar offset\nvar offsetFromCenter=-barWidth/2;for(var i=0;i<calcTraces.length;i++){var calcTrace=calcTraces[i];var t=calcTrace[0].t;// store bar width and offset for this trace\nt.barwidth=barWidth;t.poffset=offsetFromCenter;t.bargroupwidth=barGroupWidth;t.bardelta=minDiff;}// stack bars that only differ by rounding\nsieve.binWidth=calcTraces[0][0].t.barwidth/100;// if defined, apply trace offset and width\napplyAttributes(sieve);// store the bar center in each calcdata item\nsetBarCenterAndWidth(gd,pa,sieve);// update position axes\nupdatePositionAxis(gd,pa,sieve);}function setOffsetAndWidthInGroupMode(gd,pa,sieve){var fullLayout=gd._fullLayout;var bargap=fullLayout.bargap;var bargroupgap=fullLayout.bargroupgap||0;var positions=sieve.positions;var distinctPositions=sieve.distinctPositions;var minDiff=sieve.minDiff;var calcTraces=sieve.traces;var nTraces=calcTraces.length;// if there aren't any overlapping positions,\n// let them have full width even if mode is group\nvar overlap=positions.length!==distinctPositions.length;var barGroupWidth=minDiff*(1-bargap);var groupId=getAxisGroup(fullLayout,pa._id)+calcTraces[0][0].trace.orientation;var alignmentGroups=fullLayout._alignmentOpts[groupId]||{};for(var i=0;i<nTraces;i++){var calcTrace=calcTraces[i];var trace=calcTrace[0].trace;var alignmentGroupOpts=alignmentGroups[trace.alignmentgroup]||{};var nOffsetGroups=Object.keys(alignmentGroupOpts.offsetGroups||{}).length;var barWidthPlusGap;if(nOffsetGroups){barWidthPlusGap=barGroupWidth/nOffsetGroups;}else{barWidthPlusGap=overlap?barGroupWidth/nTraces:barGroupWidth;}var barWidth=barWidthPlusGap*(1-bargroupgap);var offsetFromCenter;if(nOffsetGroups){offsetFromCenter=((2*trace._offsetIndex+1-nOffsetGroups)*barWidthPlusGap-barWidth)/2;}else{offsetFromCenter=overlap?((2*i+1-nTraces)*barWidthPlusGap-barWidth)/2:-barWidth/2;}var t=calcTrace[0].t;t.barwidth=barWidth;t.poffset=offsetFromCenter;t.bargroupwidth=barGroupWidth;t.bardelta=minDiff;}// stack bars that only differ by rounding\nsieve.binWidth=calcTraces[0][0].t.barwidth/100;// if defined, apply trace width\napplyAttributes(sieve);// store the bar center in each calcdata item\nsetBarCenterAndWidth(gd,pa,sieve);// update position axes\nupdatePositionAxis(gd,pa,sieve,overlap);}function applyAttributes(sieve){var calcTraces=sieve.traces;var i,j;for(i=0;i<calcTraces.length;i++){var calcTrace=calcTraces[i];var calcTrace0=calcTrace[0];var fullTrace=calcTrace0.trace;var t=calcTrace0.t;var offset=fullTrace._offset||fullTrace.offset;var initialPoffset=t.poffset;var newPoffset;if(isArrayOrTypedArray(offset)){// if offset is an array, then clone it into t.poffset.\nnewPoffset=Array.prototype.slice.call(offset,0,calcTrace.length);// guard against non-numeric items\nfor(j=0;j<newPoffset.length;j++){if(!isNumeric(newPoffset[j])){newPoffset[j]=initialPoffset;}}// if the length of the array is too short,\n// then extend it with the initial value of t.poffset\nfor(j=newPoffset.length;j<calcTrace.length;j++){newPoffset.push(initialPoffset);}t.poffset=newPoffset;}else if(offset!==undefined){t.poffset=offset;}var width=fullTrace._width||fullTrace.width;var initialBarwidth=t.barwidth;if(isArrayOrTypedArray(width)){// if width is an array, then clone it into t.barwidth.\nvar newBarwidth=Array.prototype.slice.call(width,0,calcTrace.length);// guard against non-numeric items\nfor(j=0;j<newBarwidth.length;j++){if(!isNumeric(newBarwidth[j]))newBarwidth[j]=initialBarwidth;}// if the length of the array is too short,\n// then extend it with the initial value of t.barwidth\nfor(j=newBarwidth.length;j<calcTrace.length;j++){newBarwidth.push(initialBarwidth);}t.barwidth=newBarwidth;// if user didn't set offset,\n// then correct t.poffset to ensure bars remain centered\nif(offset===undefined){newPoffset=[];for(j=0;j<calcTrace.length;j++){newPoffset.push(initialPoffset+(initialBarwidth-newBarwidth[j])/2);}t.poffset=newPoffset;}}else if(width!==undefined){t.barwidth=width;// if user didn't set offset,\n// then correct t.poffset to ensure bars remain centered\nif(offset===undefined){t.poffset=initialPoffset+(initialBarwidth-width)/2;}}}}function setBarCenterAndWidth(gd,pa,sieve){var calcTraces=sieve.traces;var pLetter=getAxisLetter(pa);for(var i=0;i<calcTraces.length;i++){var calcTrace=calcTraces[i];var t=calcTrace[0].t;var poffset=t.poffset;var poffsetIsArray=Array.isArray(poffset);var barwidth=t.barwidth;var barwidthIsArray=Array.isArray(barwidth);for(var j=0;j<calcTrace.length;j++){var calcBar=calcTrace[j];// store the actual bar width and position, for use by hover\nvar width=calcBar.w=barwidthIsArray?barwidth[j]:barwidth;calcBar[pLetter]=calcBar.p+(poffsetIsArray?poffset[j]:poffset)+width/2;}}}function updatePositionAxis(gd,pa,sieve,allowMinDtick){var calcTraces=sieve.traces;var minDiff=sieve.minDiff;var vpad=minDiff/2;Axes.minDtick(pa,sieve.minDiff,sieve.distinctPositions[0],allowMinDtick);for(var i=0;i<calcTraces.length;i++){var calcTrace=calcTraces[i];var calcTrace0=calcTrace[0];var fullTrace=calcTrace0.trace;var pts=[];var bar,l,r,j;for(j=0;j<calcTrace.length;j++){bar=calcTrace[j];l=bar.p-vpad;r=bar.p+vpad;pts.push(l,r);}if(fullTrace.width||fullTrace.offset){var t=calcTrace0.t;var poffset=t.poffset;var barwidth=t.barwidth;var poffsetIsArray=Array.isArray(poffset);var barwidthIsArray=Array.isArray(barwidth);for(j=0;j<calcTrace.length;j++){bar=calcTrace[j];var calcBarOffset=poffsetIsArray?poffset[j]:poffset;var calcBarWidth=barwidthIsArray?barwidth[j]:barwidth;l=bar.p+calcBarOffset;r=l+calcBarWidth;pts.push(l,r);}}fullTrace._extremes[pa._id]=Axes.findExtremes(pa,pts,{padded:false});}}// store these bar bases and tops in calcdata\n// and make sure the size axis includes zero,\n// along with the bases and tops of each bar.\nfunction setBaseAndTop(gd,sa,sieve){var calcTraces=sieve.traces;var sLetter=getAxisLetter(sa);for(var i=0;i<calcTraces.length;i++){var calcTrace=calcTraces[i];var fullTrace=calcTrace[0].trace;var pts=[];var allBarBaseAboveZero=true;for(var j=0;j<calcTrace.length;j++){var bar=calcTrace[j];var barBase=bar.b;var barTop=barBase+bar.s;bar[sLetter]=barTop;pts.push(barTop);if(bar.hasB)pts.push(barBase);if(!bar.hasB||!(bar.b>0&&bar.s>0)){allBarBaseAboveZero=false;}}fullTrace._extremes[sa._id]=Axes.findExtremes(sa,pts,{tozero:!allBarBaseAboveZero,padded:true});}}function stackBars(gd,sa,sieve){var fullLayout=gd._fullLayout;var barnorm=fullLayout.barnorm;var sLetter=getAxisLetter(sa);var calcTraces=sieve.traces;for(var i=0;i<calcTraces.length;i++){var calcTrace=calcTraces[i];var fullTrace=calcTrace[0].trace;var pts=[];for(var j=0;j<calcTrace.length;j++){var bar=calcTrace[j];if(bar.s!==BADNUM){// stack current bar and get previous sum\nvar barBase=sieve.put(bar.p,bar.b+bar.s);var barTop=barBase+bar.b+bar.s;// store the bar base and top in each calcdata item\nbar.b=barBase;bar[sLetter]=barTop;if(!barnorm){pts.push(barTop);if(bar.hasB)pts.push(barBase);}}}// if barnorm is set, let normalizeBars update the axis range\nif(!barnorm){fullTrace._extremes[sa._id]=Axes.findExtremes(sa,pts,{// N.B. we don't stack base with 'base',\n// so set tozero:true always!\ntozero:true,padded:true});}}}function sieveBars(gd,sa,sieve){var calcTraces=sieve.traces;for(var i=0;i<calcTraces.length;i++){var calcTrace=calcTraces[i];for(var j=0;j<calcTrace.length;j++){var bar=calcTrace[j];if(bar.s!==BADNUM){sieve.put(bar.p,bar.b+bar.s);}}}}function unhideBarsWithinTrace(gd,sa,sieve){var calcTraces=sieve.traces;for(var i=0;i<calcTraces.length;i++){var calcTrace=calcTraces[i];var fullTrace=calcTrace[0].trace;if(fullTrace.base===undefined){var inTraceSieve=new Sieve([calcTrace],{sepNegVal:true,overlapNoMerge:true});for(var j=0;j<calcTrace.length;j++){var bar=calcTrace[j];if(bar.p!==BADNUM){// stack current bar and get previous sum\nvar barBase=inTraceSieve.put(bar.p,bar.b+bar.s);// if previous sum if non-zero, this means:\n// multiple bars have same starting point are potentially hidden,\n// shift them vertically so that all bars are visible by default\nif(barBase)bar.b=barBase;}}}}}// Note:\n//\n// normalizeBars requires that either sieveBars or stackBars has been\n// previously invoked.\nfunction normalizeBars(gd,sa,sieve){var fullLayout=gd._fullLayout;var calcTraces=sieve.traces;var sLetter=getAxisLetter(sa);var sTop=fullLayout.barnorm==='fraction'?1:100;var sTiny=sTop/1e9;// in case of rounding error in sum\nvar sMin=sa.l2c(sa.c2l(0));var sMax=fullLayout.barmode==='stack'?sTop:sMin;function needsPadding(v){return isNumeric(sa.c2l(v))&&(v<sMin-sTiny||v>sMax+sTiny||!isNumeric(sMin));}for(var i=0;i<calcTraces.length;i++){var calcTrace=calcTraces[i];var fullTrace=calcTrace[0].trace;var pts=[];var allBarBaseAboveZero=true;var padded=false;for(var j=0;j<calcTrace.length;j++){var bar=calcTrace[j];if(bar.s!==BADNUM){var scale=Math.abs(sTop/sieve.get(bar.p,bar.s));bar.b*=scale;bar.s*=scale;var barBase=bar.b;var barTop=barBase+bar.s;bar[sLetter]=barTop;pts.push(barTop);padded=padded||needsPadding(barTop);if(bar.hasB){pts.push(barBase);padded=padded||needsPadding(barBase);}if(!bar.hasB||!(bar.b>0&&bar.s>0)){allBarBaseAboveZero=false;}}}fullTrace._extremes[sa._id]=Axes.findExtremes(sa,pts,{tozero:!allBarBaseAboveZero,padded:padded});}}// find the full position span of bars at each position\n// for use by hover, to ensure labels move in if bars are\n// narrower than the space they're in.\n// run once per trace group (subplot & direction) and\n// the same mapping is attached to all calcdata traces\nfunction collectExtents(calcTraces,pa){var pLetter=getAxisLetter(pa);var extents={};var i,j,cd;var pMin=Infinity;var pMax=-Infinity;for(i=0;i<calcTraces.length;i++){cd=calcTraces[i];for(j=0;j<cd.length;j++){var p=cd[j].p;if(isNumeric(p)){pMin=Math.min(pMin,p);pMax=Math.max(pMax,p);}}}// this is just for positioning of hover labels, and nobody will care if\n// the label is 1px too far out; so round positions to 1/10K in case\n// position values don't exactly match from trace to trace\nvar roundFactor=10000/(pMax-pMin);var round=extents.round=function(p){return String(Math.round(roundFactor*(p-pMin)));};for(i=0;i<calcTraces.length;i++){cd=calcTraces[i];cd[0].t.extents=extents;var poffset=cd[0].t.poffset;var poffsetIsArray=Array.isArray(poffset);for(j=0;j<cd.length;j++){var di=cd[j];var p0=di[pLetter]-di.w/2;if(isNumeric(p0)){var p1=di[pLetter]+di.w/2;var pVal=round(di.p);if(extents[pVal]){extents[pVal]=[Math.min(p0,extents[pVal][0]),Math.max(p1,extents[pVal][1])];}else{extents[pVal]=[p0,p1];}}di.p0=di.p+(poffsetIsArray?poffset[j]:poffset);di.p1=di.p0+di.w;di.s0=di.b;di.s1=di.s0+di.s;}}}function getAxisLetter(ax){return ax._id.charAt(0);}module.exports={crossTraceCalc:crossTraceCalc,setGroupPositions:setGroupPositions};},{\"../../constants/numerical\":140,\"../../lib\":159,\"../../plots/cartesian/axes\":203,\"../../plots/cartesian/axis_ids\":206,\"../../registry\":242,\"./sieve.js\":264,\"fast-isnumeric\":10}],256:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var Color=_dereq_('../../components/color');var Registry=_dereq_('../../registry');var handleXYDefaults=_dereq_('../scatter/xy_defaults');var handleStyleDefaults=_dereq_('./style_defaults');var getAxisGroup=_dereq_('../../plots/cartesian/axis_ids').getAxisGroup;var attributes=_dereq_('./attributes');var coerceFont=Lib.coerceFont;function supplyDefaults(traceIn,traceOut,defaultColor,layout){function coerce(attr,dflt){return Lib.coerce(traceIn,traceOut,attributes,attr,dflt);}var len=handleXYDefaults(traceIn,traceOut,layout,coerce);if(!len){traceOut.visible=false;return;}coerce('orientation',traceOut.x&&!traceOut.y?'h':'v');coerce('base');coerce('offset');coerce('width');coerce('text');coerce('hovertext');coerce('hovertemplate');handleText(traceIn,traceOut,layout,coerce,true);handleStyleDefaults(traceIn,traceOut,coerce,defaultColor,layout);var lineColor=(traceOut.marker.line||{}).color;// override defaultColor for error bars with defaultLine\nvar errorBarsSupplyDefaults=Registry.getComponentMethod('errorbars','supplyDefaults');errorBarsSupplyDefaults(traceIn,traceOut,lineColor||Color.defaultLine,{axis:'y'});errorBarsSupplyDefaults(traceIn,traceOut,lineColor||Color.defaultLine,{axis:'x',inherit:'y'});Lib.coerceSelectionMarkerOpacity(traceOut,coerce);}function handleGroupingDefaults(traceIn,traceOut,fullLayout,coerce){var orientation=traceOut.orientation;// N.B. grouping is done across all trace trace types that support it\nvar posAxId=traceOut[{v:'x',h:'y'}[orientation]+'axis'];var groupId=getAxisGroup(fullLayout,posAxId)+orientation;var alignmentOpts=fullLayout._alignmentOpts||{};var alignmentgroup=coerce('alignmentgroup');var alignmentGroups=alignmentOpts[groupId];if(!alignmentGroups)alignmentGroups=alignmentOpts[groupId]={};var alignmentGroupOpts=alignmentGroups[alignmentgroup];if(alignmentGroupOpts){alignmentGroupOpts.traces.push(traceOut);}else{alignmentGroupOpts=alignmentGroups[alignmentgroup]={traces:[traceOut],alignmentIndex:Object.keys(alignmentGroups).length,offsetGroups:{}};}var offsetgroup=coerce('offsetgroup');var offsetGroups=alignmentGroupOpts.offsetGroups;var offsetGroupOpts=offsetGroups[offsetgroup];if(offsetgroup){if(!offsetGroupOpts){offsetGroupOpts=offsetGroups[offsetgroup]={offsetIndex:Object.keys(offsetGroups).length};}traceOut._offsetIndex=offsetGroupOpts.offsetIndex;}}function crossTraceDefaults(fullData,fullLayout){var traceIn,traceOut;function coerce(attr){return Lib.coerce(traceOut._input,traceOut,attributes,attr);}if(fullLayout.barmode==='group'){for(var i=0;i<fullData.length;i++){traceOut=fullData[i];if(traceOut.type==='bar'){traceIn=traceOut._input;handleGroupingDefaults(traceIn,traceOut,fullLayout,coerce);}}}}function handleText(traceIn,traceOut,layout,coerce,moduleHasSelUnselected){var textPosition=coerce('textposition');var hasBoth=Array.isArray(textPosition)||textPosition==='auto';var hasInside=hasBoth||textPosition==='inside';var hasOutside=hasBoth||textPosition==='outside';if(hasInside||hasOutside){var textFont=coerceFont(coerce,'textfont',layout.font);// Note that coercing `insidetextfont` is always needed \n// even if `textposition` is `outside` for each trace  since\n// an outside label can become an inside one, for example because\n// of a bar being stacked on top of it.\nvar insideTextFontDefault=Lib.extendFlat({},textFont);var isTraceTextfontColorSet=traceIn.textfont&&traceIn.textfont.color;var isColorInheritedFromLayoutFont=!isTraceTextfontColorSet;if(isColorInheritedFromLayoutFont){delete insideTextFontDefault.color;}coerceFont(coerce,'insidetextfont',insideTextFontDefault);if(hasOutside)coerceFont(coerce,'outsidetextfont',textFont);coerce('constraintext');if(moduleHasSelUnselected){coerce('selected.textfont.color');coerce('unselected.textfont.color');}coerce('cliponaxis');}}module.exports={supplyDefaults:supplyDefaults,crossTraceDefaults:crossTraceDefaults,handleGroupingDefaults:handleGroupingDefaults,handleText:handleText};},{\"../../components/color\":43,\"../../lib\":159,\"../../plots/cartesian/axis_ids\":206,\"../../registry\":242,\"../scatter/xy_defaults\":306,\"./attributes\":252,\"./style_defaults\":266}],257:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var isNumeric=_dereq_('fast-isnumeric');var tinycolor=_dereq_('tinycolor2');exports.coerceString=function(attributeDefinition,value,defaultValue){if(typeof value==='string'){if(value||!attributeDefinition.noBlank)return value;}else if(typeof value==='number'){if(!attributeDefinition.strict)return String(value);}return defaultValue!==undefined?defaultValue:attributeDefinition.dflt;};exports.coerceNumber=function(attributeDefinition,value,defaultValue){if(isNumeric(value)){value=+value;var min=attributeDefinition.min;var max=attributeDefinition.max;var isOutOfBounds=min!==undefined&&value<min||max!==undefined&&value>max;if(!isOutOfBounds)return value;}return defaultValue!==undefined?defaultValue:attributeDefinition.dflt;};exports.coerceColor=function(attributeDefinition,value,defaultValue){if(tinycolor(value).isValid())return value;return defaultValue!==undefined?defaultValue:attributeDefinition.dflt;};exports.coerceEnumerated=function(attributeDefinition,value,defaultValue){if(attributeDefinition.coerceNumber)value=+value;if(attributeDefinition.values.indexOf(value)!==-1)return value;return defaultValue!==undefined?defaultValue:attributeDefinition.dflt;};exports.getValue=function(arrayOrScalar,index){var value;if(!Array.isArray(arrayOrScalar))value=arrayOrScalar;else if(index<arrayOrScalar.length)value=arrayOrScalar[index];return value;};},{\"fast-isnumeric\":10,\"tinycolor2\":26}],258:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Fx=_dereq_('../../components/fx');var Registry=_dereq_('../../registry');var Color=_dereq_('../../components/color');var fillHoverText=_dereq_('../scatter/fill_hover_text');function hoverPoints(pointData,xval,yval,hovermode){var barPointData=hoverOnBars(pointData,xval,yval,hovermode);if(barPointData){var cd=barPointData.cd;var trace=cd[0].trace;var di=cd[barPointData.index];barPointData.color=getTraceColor(trace,di);Registry.getComponentMethod('errorbars','hoverInfo')(di,trace,barPointData);return[barPointData];}}function hoverOnBars(pointData,xval,yval,hovermode){var cd=pointData.cd;var trace=cd[0].trace;var t=cd[0].t;var isClosest=hovermode==='closest';var isWaterfall=trace.type==='waterfall';var maxHoverDistance=pointData.maxHoverDistance;var maxSpikeDistance=pointData.maxSpikeDistance;var posVal,sizeVal,posLetter,sizeLetter,dx,dy,pRangeCalc;function thisBarMinPos(di){return di[posLetter]-di.w/2;}function thisBarMaxPos(di){return di[posLetter]+di.w/2;}var minPos=isClosest?thisBarMinPos:function(di){/*\n             * In compare mode, accept a bar if you're on it *or* its group.\n             * Nearly always it's the group that matters, but in case the bar\n             * was explicitly set wider than its group we'd better accept the\n             * whole bar.\n             *\n             * use `bardelta` instead of `bargroupwidth` so we accept hover\n             * in the gap. That way hover doesn't flash on and off as you\n             * mouse over the plot in compare modes.\n             * In 'closest' mode though the flashing seems inevitable,\n             * without far more complex logic\n             */return Math.min(thisBarMinPos(di),di.p-t.bardelta/2);};var maxPos=isClosest?thisBarMaxPos:function(di){return Math.max(thisBarMaxPos(di),di.p+t.bardelta/2);};function _positionFn(_minPos,_maxPos){// add a little to the pseudo-distance for wider bars, so that like scatter,\n// if you are over two overlapping bars, the narrower one wins.\nreturn Fx.inbox(_minPos-posVal,_maxPos-posVal,maxHoverDistance+Math.min(1,Math.abs(_maxPos-_minPos)/pRangeCalc)-1);}function positionFn(di){return _positionFn(minPos(di),maxPos(di));}function thisBarPositionFn(di){return _positionFn(thisBarMinPos(di),thisBarMaxPos(di));}function sizeFn(di){var v=sizeVal;var b=di.b;var s=di[sizeLetter];if(isWaterfall){s+=Math.abs(di.rawS||0);}// add a gradient so hovering near the end of a\n// bar makes it a little closer match\nreturn Fx.inbox(b-v,s-v,maxHoverDistance+(s-v)/(s-b)-1);}if(trace.orientation==='h'){posVal=yval;sizeVal=xval;posLetter='y';sizeLetter='x';dx=sizeFn;dy=positionFn;}else{posVal=xval;sizeVal=yval;posLetter='x';sizeLetter='y';dy=sizeFn;dx=positionFn;}var pa=pointData[posLetter+'a'];var sa=pointData[sizeLetter+'a'];pRangeCalc=Math.abs(pa.r2c(pa.range[1])-pa.r2c(pa.range[0]));function dxy(di){return(dx(di)+dy(di))/2;}var distfn=Fx.getDistanceFunction(hovermode,dx,dy,dxy);Fx.getClosest(cd,distfn,pointData);// skip the rest (for this trace) if we didn't find a close point\nif(pointData.index===false)return;// if we get here and we're not in 'closest' mode, push min/max pos back\n// onto the group - even though that means occasionally the mouse will be\n// over the hover label.\nif(!isClosest){minPos=function minPos(di){return Math.min(thisBarMinPos(di),di.p-t.bargroupwidth/2);};maxPos=function maxPos(di){return Math.max(thisBarMaxPos(di),di.p+t.bargroupwidth/2);};}// the closest data point\nvar index=pointData.index;var di=cd[index];var size=trace.base?di.b+di.s:di.s;pointData[sizeLetter+'0']=pointData[sizeLetter+'1']=sa.c2p(di[sizeLetter],true);pointData[sizeLetter+'LabelVal']=size;var extent=t.extents[t.extents.round(di.p)];pointData[posLetter+'0']=pa.c2p(isClosest?minPos(di):extent[0],true);pointData[posLetter+'1']=pa.c2p(isClosest?maxPos(di):extent[1],true);pointData[posLetter+'LabelVal']=di.p;// spikelines always want \"closest\" distance regardless of hovermode\npointData.spikeDistance=(sizeFn(di)+thisBarPositionFn(di))/2+maxSpikeDistance-maxHoverDistance;// they also want to point to the data value, regardless of where the label goes\n// in case of bars shifted within groups\npointData[posLetter+'Spike']=pa.c2p(di.p,true);fillHoverText(di,trace,pointData);pointData.hovertemplate=trace.hovertemplate;return pointData;}function getTraceColor(trace,di){var mc=di.mcc||trace.marker.color;var mlc=di.mlcc||trace.marker.line.color;var mlw=di.mlw||trace.marker.line.width;if(Color.opacity(mc))return mc;else if(Color.opacity(mlc)&&mlw)return mlc;}module.exports={hoverPoints:hoverPoints,hoverOnBars:hoverOnBars,getTraceColor:getTraceColor};},{\"../../components/color\":43,\"../../components/fx\":82,\"../../registry\":242,\"../scatter/fill_hover_text\":288}],259:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Bar={};Bar.attributes=_dereq_('./attributes');Bar.layoutAttributes=_dereq_('./layout_attributes');Bar.supplyDefaults=_dereq_('./defaults').supplyDefaults;Bar.crossTraceDefaults=_dereq_('./defaults').crossTraceDefaults;Bar.supplyLayoutDefaults=_dereq_('./layout_defaults');Bar.calc=_dereq_('./calc');Bar.crossTraceCalc=_dereq_('./cross_trace_calc').crossTraceCalc;Bar.colorbar=_dereq_('../scatter/marker_colorbar');Bar.arraysToCalcdata=_dereq_('./arrays_to_calcdata');Bar.plot=_dereq_('./plot');Bar.style=_dereq_('./style').style;Bar.styleOnSelect=_dereq_('./style').styleOnSelect;Bar.hoverPoints=_dereq_('./hover').hoverPoints;Bar.selectPoints=_dereq_('./select');Bar.moduleType='trace';Bar.name='bar';Bar.basePlotModule=_dereq_('../../plots/cartesian');Bar.categories=['cartesian','svg','bar','oriented','errorBarsOK','showLegend','zoomScale'];Bar.meta={};module.exports=Bar;},{\"../../plots/cartesian\":214,\"../scatter/marker_colorbar\":298,\"./arrays_to_calcdata\":251,\"./attributes\":252,\"./calc\":253,\"./cross_trace_calc\":255,\"./defaults\":256,\"./hover\":258,\"./layout_attributes\":260,\"./layout_defaults\":261,\"./plot\":262,\"./select\":263,\"./style\":265}],260:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports={barmode:{valType:'enumerated',values:['stack','group','overlay','relative'],dflt:'group',editType:'calc'},barnorm:{valType:'enumerated',values:['','fraction','percent'],dflt:'',editType:'calc'},bargap:{valType:'number',min:0,max:1,editType:'calc'},bargroupgap:{valType:'number',min:0,max:1,dflt:0,editType:'calc'}};},{}],261:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Registry=_dereq_('../../registry');var Axes=_dereq_('../../plots/cartesian/axes');var Lib=_dereq_('../../lib');var layoutAttributes=_dereq_('./layout_attributes');module.exports=function(layoutIn,layoutOut,fullData){function coerce(attr,dflt){return Lib.coerce(layoutIn,layoutOut,layoutAttributes,attr,dflt);}var hasBars=false;var shouldBeGapless=false;var gappedAnyway=false;var usedSubplots={};var mode=coerce('barmode');for(var i=0;i<fullData.length;i++){var trace=fullData[i];if(Registry.traceIs(trace,'bar')&&trace.visible)hasBars=true;else continue;// if we have at least 2 grouped bar traces on the same subplot,\n// we should default to a gap anyway, even if the data is histograms\nif(mode==='group'){var subploti=trace.xaxis+trace.yaxis;if(usedSubplots[subploti])gappedAnyway=true;usedSubplots[subploti]=true;}if(trace.visible&&trace.type==='histogram'){var pa=Axes.getFromId({_fullLayout:layoutOut},trace[trace.orientation==='v'?'xaxis':'yaxis']);if(pa.type!=='category')shouldBeGapless=true;}}if(!hasBars){delete layoutOut.barmode;return;}if(mode!=='overlay')coerce('barnorm');coerce('bargap',shouldBeGapless&&!gappedAnyway?0:0.2);coerce('bargroupgap');};},{\"../../lib\":159,\"../../plots/cartesian/axes\":203,\"../../registry\":242,\"./layout_attributes\":260}],262:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var isNumeric=_dereq_('fast-isnumeric');var Lib=_dereq_('../../lib');var svgTextUtils=_dereq_('../../lib/svg_text_utils');var Color=_dereq_('../../components/color');var Drawing=_dereq_('../../components/drawing');var Registry=_dereq_('../../registry');var attributes=_dereq_('./attributes');var attributeText=attributes.text;var attributeTextPosition=attributes.textposition;var helpers=_dereq_('./helpers');var style=_dereq_('./style');// padding in pixels around text\nvar TEXTPAD=3;module.exports=function plot(gd,plotinfo,cdModule,traceLayer){var xa=plotinfo.xaxis;var ya=plotinfo.yaxis;var fullLayout=gd._fullLayout;var bartraces=Lib.makeTraceGroups(traceLayer,cdModule,'trace bars').each(function(cd){var plotGroup=d3.select(this);var cd0=cd[0];var trace=cd0.trace;var adjustDir;var adjustPixel=0;if(trace.type==='waterfall'&&trace.connector.visible&&trace.connector.mode==='between'){adjustPixel=trace.connector.line.width/2;}var isHorizontal=trace.orientation==='h';if(!plotinfo.isRangePlot)cd0.node3=plotGroup;var pointGroup=Lib.ensureSingle(plotGroup,'g','points');var bars=pointGroup.selectAll('g.point').data(Lib.identity);bars.enter().append('g').classed('point',true);bars.exit().remove();bars.each(function(di,i){var bar=d3.select(this);// now display the bar\n// clipped xf/yf (2nd arg true): non-positive\n// log values go off-screen by plotwidth\n// so you see them continue if you drag the plot\nvar x0,x1,y0,y1;if(isHorizontal){y0=ya.c2p(di.p0,true);y1=ya.c2p(di.p1,true);x0=xa.c2p(di.s0,true);x1=xa.c2p(di.s1,true);}else{x0=xa.c2p(di.p0,true);x1=xa.c2p(di.p1,true);y0=ya.c2p(di.s0,true);y1=ya.c2p(di.s1,true);}var isBlank=di.isBlank=!isNumeric(x0)||!isNumeric(x1)||!isNumeric(y0)||!isNumeric(y1)||x0===x1||y0===y1;// in waterfall mode `between` we need to adjust bar end points to match the connector width\nif(adjustPixel){if(isHorizontal){adjustDir=x1<x0?-1:1;x0-=adjustDir*adjustPixel;x1+=adjustDir*adjustPixel;}else{adjustDir=y1<y0?-1:1;y0-=adjustDir*adjustPixel;y1+=adjustDir*adjustPixel;}}var lw;var mc;var prefix;if(trace.type==='waterfall'){if(!isBlank){var cont=trace[di.dir].marker;lw=cont.line.width;mc=cont.color;}prefix='waterfall';}else{lw=(di.mlw+1||trace.marker.line.width+1||(di.trace?di.trace.marker.line.width:0)+1)-1;mc=di.mc||trace.marker.color;prefix='bar';}var offset=d3.round(lw/2%1,2);var bargap=fullLayout[prefix+'gap'];var bargroupgap=fullLayout[prefix+'groupgap'];function roundWithLine(v){// if there are explicit gaps, don't round,\n// it can make the gaps look crappy\nreturn bargap===0&&bargroupgap===0?d3.round(Math.round(v)-offset,2):v;}function expandToVisible(v,vc){// if it's not in danger of disappearing entirely,\n// round more precisely\nreturn Math.abs(v-vc)>=2?roundWithLine(v):// but if it's very thin, expand it so it's\n// necessarily visible, even if it might overlap\n// its neighbor\nv>vc?Math.ceil(v):Math.floor(v);}if(!gd._context.staticPlot){// if bars are not fully opaque or they have a line\n// around them, round to integer pixels, mainly for\n// safari so we prevent overlaps from its expansive\n// pixelation. if the bars ARE fully opaque and have\n// no line, expand to a full pixel to make sure we\n// can see them\nvar op=Color.opacity(mc);var fixpx=op<1||lw>0.01?roundWithLine:expandToVisible;x0=fixpx(x0,x1);x1=fixpx(x1,x0);y0=fixpx(y0,y1);y1=fixpx(y1,y0);}Lib.ensureSingle(bar,'path').style('vector-effect','non-scaling-stroke').attr('d',isBlank?'M0,0Z':'M'+x0+','+y0+'V'+y1+'H'+x1+'V'+y0+'Z').call(Drawing.setClipUrl,plotinfo.layerClipId,gd);appendBarText(gd,plotinfo,bar,cd,i,x0,x1,y0,y1);if(plotinfo.layerClipId){Drawing.hideOutsideRangePoint(di,bar.select('text'),xa,ya,trace.xcalendar,trace.ycalendar);}});// lastly, clip points groups of `cliponaxis !== false` traces\n// on `plotinfo._hasClipOnAxisFalse === true` subplots\nvar hasClipOnAxisFalse=cd0.trace.cliponaxis===false;Drawing.setClipUrl(plotGroup,hasClipOnAxisFalse?null:plotinfo.layerClipId,gd);});// error bars are on the top\nRegistry.getComponentMethod('errorbars','plot')(gd,bartraces,plotinfo);};function appendBarText(gd,plotinfo,bar,calcTrace,i,x0,x1,y0,y1){var fullLayout=gd._fullLayout;var textPosition;function appendTextNode(bar,text,textFont){var textSelection=Lib.ensureSingle(bar,'text').text(text).attr({'class':'bartext bartext-'+textPosition,transform:'','text-anchor':'middle',// prohibit tex interpretation until we can handle\n// tex and regular text together\n'data-notex':1}).call(Drawing.font,textFont).call(svgTextUtils.convertToTspans,gd);return textSelection;}// get trace attributes\nvar trace=calcTrace[0].trace;var orientation=trace.orientation;var text=getText(trace,i);textPosition=getTextPosition(trace,i);// compute text position\nvar prefix=trace.type==='waterfall'?'waterfall':'bar';var barmode=fullLayout[prefix+'mode'];var inStackOrRelativeMode=barmode==='stack'||barmode==='relative';var calcBar=calcTrace[i];var isOutmostBar=!inStackOrRelativeMode||calcBar._outmost;if(!text||textPosition==='none'||calcBar.isBlank&&(textPosition==='auto'||textPosition==='inside')){bar.select('text').remove();return;}var layoutFont=fullLayout.font;var barColor=style.getBarColor(calcTrace[i],trace);var insideTextFont=style.getInsideTextFont(trace,i,layoutFont,barColor);var outsideTextFont=style.getOutsideTextFont(trace,i,layoutFont);// Special case: don't use the c2p(v, true) value on log size axes,\n// so that we can get correctly inside text scaling\nvar di=bar.datum();if(orientation==='h'){var xa=plotinfo.xaxis;if(xa.type==='log'&&di.s0<=0){if(xa.range[0]<xa.range[1]){x0=0;}else{x0=xa._length;}}}else{var ya=plotinfo.yaxis;if(ya.type==='log'&&di.s0<=0){if(ya.range[0]<ya.range[1]){y0=ya._length;}else{y0=0;}}}// padding excluded\nvar barWidth=Math.abs(x1-x0)-2*TEXTPAD;var barHeight=Math.abs(y1-y0)-2*TEXTPAD;var textSelection;var textBB;var textWidth;var textHeight;if(textPosition==='outside'){if(!isOutmostBar&&!calcBar.hasB)textPosition='inside';}if(textPosition==='auto'){if(isOutmostBar){// draw text using insideTextFont and check if it fits inside bar\ntextPosition='inside';textSelection=appendTextNode(bar,text,insideTextFont);textBB=Drawing.bBox(textSelection.node()),textWidth=textBB.width,textHeight=textBB.height;var textHasSize=textWidth>0&&textHeight>0;var fitsInside=textWidth<=barWidth&&textHeight<=barHeight;var fitsInsideIfRotated=textWidth<=barHeight&&textHeight<=barWidth;var fitsInsideIfShrunk=orientation==='h'?barWidth>=textWidth*(barHeight/textHeight):barHeight>=textHeight*(barWidth/textWidth);if(textHasSize&&(fitsInside||fitsInsideIfRotated||fitsInsideIfShrunk)){textPosition='inside';}else{textPosition='outside';textSelection.remove();textSelection=null;}}else{textPosition='inside';}}if(!textSelection){textSelection=appendTextNode(bar,text,textPosition==='outside'?outsideTextFont:insideTextFont);textBB=Drawing.bBox(textSelection.node()),textWidth=textBB.width,textHeight=textBB.height;if(textWidth<=0||textHeight<=0){textSelection.remove();return;}}// compute text transform\nvar transform,constrained;if(textPosition==='outside'){constrained=trace.constraintext==='both'||trace.constraintext==='outside';transform=getTransformToMoveOutsideBar(x0,x1,y0,y1,textBB,orientation,constrained);}else{constrained=trace.constraintext==='both'||trace.constraintext==='inside';transform=getTransformToMoveInsideBar(x0,x1,y0,y1,textBB,orientation,constrained);}textSelection.attr('transform',transform);}function getTransformToMoveInsideBar(x0,x1,y0,y1,textBB,orientation,constrained){// compute text and target positions\nvar textWidth=textBB.width;var textHeight=textBB.height;var textX=(textBB.left+textBB.right)/2;var textY=(textBB.top+textBB.bottom)/2;var barWidth=Math.abs(x1-x0);var barHeight=Math.abs(y1-y0);var targetWidth;var targetHeight;var targetX;var targetY;// apply text padding\nvar textpad;if(barWidth>2*TEXTPAD&&barHeight>2*TEXTPAD){textpad=TEXTPAD;barWidth-=2*textpad;barHeight-=2*textpad;}else textpad=0;// compute rotation and scale\nvar rotate,scale;if(textWidth<=barWidth&&textHeight<=barHeight){// no scale or rotation is required\nrotate=false;scale=1;}else if(textWidth<=barHeight&&textHeight<=barWidth){// only rotation is required\nrotate=true;scale=1;}else if(textWidth<textHeight===barWidth<barHeight){// only scale is required\nrotate=false;scale=constrained?Math.min(barWidth/textWidth,barHeight/textHeight):1;}else{// both scale and rotation are required\nrotate=true;scale=constrained?Math.min(barHeight/textWidth,barWidth/textHeight):1;}if(rotate)rotate=90;// rotate clockwise\n// compute text and target positions\nif(rotate){targetWidth=scale*textHeight;targetHeight=scale*textWidth;}else{targetWidth=scale*textWidth;targetHeight=scale*textHeight;}if(orientation==='h'){if(x1<x0){// bar end is on the left hand side\ntargetX=x1+textpad+targetWidth/2;targetY=(y0+y1)/2;}else{targetX=x1-textpad-targetWidth/2;targetY=(y0+y1)/2;}}else{if(y1>y0){// bar end is on the bottom\ntargetX=(x0+x1)/2;targetY=y1-textpad-targetHeight/2;}else{targetX=(x0+x1)/2;targetY=y1+textpad+targetHeight/2;}}return getTransform(textX,textY,targetX,targetY,scale,rotate);}function getTransformToMoveOutsideBar(x0,x1,y0,y1,textBB,orientation,constrained){var barWidth=orientation==='h'?Math.abs(y1-y0):Math.abs(x1-x0);var textpad;// Keep the padding so the text doesn't sit right against\n// the bars, but don't factor it into barWidth\nif(barWidth>2*TEXTPAD){textpad=TEXTPAD;}// compute rotation and scale\nvar scale=1;if(constrained){scale=orientation==='h'?Math.min(1,barWidth/textBB.height):Math.min(1,barWidth/textBB.width);}// compute text and target positions\nvar textX=(textBB.left+textBB.right)/2;var textY=(textBB.top+textBB.bottom)/2;var targetWidth;var targetHeight;var targetX;var targetY;targetWidth=scale*textBB.width;targetHeight=scale*textBB.height;if(orientation==='h'){if(x1<x0){// bar end is on the left hand side\ntargetX=x1-textpad-targetWidth/2;targetY=(y0+y1)/2;}else{targetX=x1+textpad+targetWidth/2;targetY=(y0+y1)/2;}}else{if(y1>y0){// bar end is on the bottom\ntargetX=(x0+x1)/2;targetY=y1+textpad+targetHeight/2;}else{targetX=(x0+x1)/2;targetY=y1-textpad-targetHeight/2;}}return getTransform(textX,textY,targetX,targetY,scale,false);}function getTransform(textX,textY,targetX,targetY,scale,rotate){var transformScale;var transformRotate;var transformTranslate;if(scale<1)transformScale='scale('+scale+') ';else{scale=1;transformScale='';}transformRotate=rotate?'rotate('+rotate+' '+textX+' '+textY+') ':'';// Note that scaling also affects the center of the text box\nvar translateX=targetX-scale*textX;var translateY=targetY-scale*textY;transformTranslate='translate('+translateX+' '+translateY+')';return transformTranslate+transformScale+transformRotate;}function getText(trace,index){var value=helpers.getValue(trace.text,index);return helpers.coerceString(attributeText,value);}function getTextPosition(trace,index){var value=helpers.getValue(trace.textposition,index);return helpers.coerceEnumerated(attributeTextPosition,value);}},{\"../../components/color\":43,\"../../components/drawing\":64,\"../../lib\":159,\"../../lib/svg_text_utils\":180,\"../../registry\":242,\"./attributes\":252,\"./helpers\":257,\"./style\":265,\"d3\":8,\"fast-isnumeric\":10}],263:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports=function selectPoints(searchInfo,selectionTester){var cd=searchInfo.cd;var xa=searchInfo.xaxis;var ya=searchInfo.yaxis;var trace=cd[0].trace;var selection=[];var i;if(selectionTester===false){// clear selection\nfor(i=0;i<cd.length;i++){cd[i].selected=0;}}else{var getCentroid=trace.orientation==='h'?function(d){return[xa.c2p(d.s1,true),(ya.c2p(d.p0,true)+ya.c2p(d.p1,true))/2];}:function(d){return[(xa.c2p(d.p0,true)+xa.c2p(d.p1,true))/2,ya.c2p(d.s1,true)];};for(i=0;i<cd.length;i++){var di=cd[i];var ct='ct'in di?di.ct:getCentroid(di);if(selectionTester.contains(ct,false,i,searchInfo)){selection.push({pointNumber:i,x:xa.c2d(di.x),y:ya.c2d(di.y)});di.selected=1;}else{di.selected=0;}}}return selection;};},{}],264:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports=Sieve;var Lib=_dereq_('../../lib');var BADNUM=_dereq_('../../constants/numerical').BADNUM;/**\n * Helper class to sieve data from traces into bins\n *\n * @class\n *\n * @param {Array} traces\n*   Array of calculated traces\n * @param {object} opts\n *  - @param {boolean} [sepNegVal]\n *      If true, then split data at the same position into a bar\n *      for positive values and another for negative values\n *  - @param {boolean} [overlapNoMerge]\n *     If true, then don't merge overlapping bars into a single bar\n */function Sieve(traces,opts){this.traces=traces;this.sepNegVal=opts.sepNegVal;this.overlapNoMerge=opts.overlapNoMerge;// for single-bin histograms - see histogram/calc\nvar width1=Infinity;var positions=[];for(var i=0;i<traces.length;i++){var trace=traces[i];for(var j=0;j<trace.length;j++){var bar=trace[j];if(bar.p!==BADNUM)positions.push(bar.p);}if(trace[0]&&trace[0].width1){width1=Math.min(trace[0].width1,width1);}}this.positions=positions;var dv=Lib.distinctVals(positions);this.distinctPositions=dv.vals;if(dv.vals.length===1&&width1!==Infinity)this.minDiff=width1;else this.minDiff=Math.min(dv.minDiff,width1);this.binWidth=this.minDiff;this.bins={};}/**\n * Sieve datum\n *\n * @method\n * @param {number} position\n * @param {number} value\n * @returns {number} Previous bin value\n */Sieve.prototype.put=function put(position,value){var label=this.getLabel(position,value);var oldValue=this.bins[label]||0;this.bins[label]=oldValue+value;return oldValue;};/**\n * Get current bin value for a given datum\n *\n * @method\n * @param {number} position  Position of datum\n * @param {number} [value]   Value of datum\n *                           (required if this.sepNegVal is true)\n * @returns {number} Current bin value\n */Sieve.prototype.get=function get(position,value){var label=this.getLabel(position,value);return this.bins[label]||0;};/**\n * Get bin label for a given datum\n *\n * @method\n * @param {number} position  Position of datum\n * @param {number} [value]   Value of datum\n *                           (required if this.sepNegVal is true)\n * @returns {string} Bin label\n * (prefixed with a 'v' if value is negative and this.sepNegVal is\n * true; otherwise prefixed with '^')\n */Sieve.prototype.getLabel=function getLabel(position,value){var prefix=value<0&&this.sepNegVal?'v':'^';var label=this.overlapNoMerge?position:Math.round(position/this.binWidth);return prefix+label;};},{\"../../constants/numerical\":140,\"../../lib\":159}],265:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var Color=_dereq_('../../components/color');var Drawing=_dereq_('../../components/drawing');var Lib=_dereq_('../../lib');var Registry=_dereq_('../../registry');var attributes=_dereq_('./attributes');var attributeTextFont=attributes.textfont;var attributeInsideTextFont=attributes.insidetextfont;var attributeOutsideTextFont=attributes.outsidetextfont;var helpers=_dereq_('./helpers');function style(gd,cd){var s=cd?cd[0].node3:d3.select(gd).selectAll('g.barlayer').selectAll('g.trace');var barcount=s.size();var fullLayout=gd._fullLayout;// trace styling\ns.style('opacity',function(d){return d[0].trace.opacity;})// for gapless (either stacked or neighboring grouped) bars use\n// crispEdges to turn off antialiasing so an artificial gap\n// isn't introduced.\n.each(function(d){if(fullLayout.barmode==='stack'&&barcount>1||fullLayout.bargap===0&&fullLayout.bargroupgap===0&&!d[0].trace.marker.line.width){d3.select(this).attr('shape-rendering','crispEdges');}});s.selectAll('g.points').each(function(d){var sel=d3.select(this);var trace=d[0].trace;stylePoints(sel,trace,gd);});Registry.getComponentMethod('errorbars','style')(s);}function stylePoints(sel,trace,gd){Drawing.pointStyle(sel.selectAll('path'),trace,gd);styleTextPoints(sel,trace,gd);}function styleTextPoints(sel,trace,gd){sel.selectAll('text').each(function(d){var tx=d3.select(this);var font=determineFont(tx,d,trace,gd);Drawing.font(tx,font);});}function styleOnSelect(gd,cd){var s=cd[0].node3;var trace=cd[0].trace;if(trace.selectedpoints){stylePointsInSelectionMode(s,trace,gd);}else{stylePoints(s,trace,gd);}}function stylePointsInSelectionMode(s,trace,gd){Drawing.selectedPointStyle(s.selectAll('path'),trace);styleTextInSelectionMode(s.selectAll('text'),trace,gd);}function styleTextInSelectionMode(txs,trace,gd){txs.each(function(d){var tx=d3.select(this);var font;if(d.selected){font=Lib.extendFlat({},determineFont(tx,d,trace,gd));var selectedFontColor=trace.selected.textfont&&trace.selected.textfont.color;if(selectedFontColor){font.color=selectedFontColor;}Drawing.font(tx,font);}else{Drawing.selectedTextStyle(tx,trace);}});}function determineFont(tx,d,trace,gd){var layoutFont=gd._fullLayout.font;var textFont=trace.textfont;if(tx.classed('bartext-inside')){var barColor=getBarColor(d,trace);textFont=getInsideTextFont(trace,d.i,layoutFont,barColor);}else if(tx.classed('bartext-outside')){textFont=getOutsideTextFont(trace,d.i,layoutFont);}return textFont;}function getTextFont(trace,index,defaultValue){return getFontValue(attributeTextFont,trace.textfont,index,defaultValue);}function getInsideTextFont(trace,index,layoutFont,barColor){var defaultFont=getTextFont(trace,index,layoutFont);var wouldFallBackToLayoutFont=trace._input.textfont===undefined||trace._input.textfont.color===undefined||Array.isArray(trace.textfont.color)&&trace.textfont.color[index]===undefined;if(wouldFallBackToLayoutFont){defaultFont={color:Color.contrast(barColor),family:defaultFont.family,size:defaultFont.size};}return getFontValue(attributeInsideTextFont,trace.insidetextfont,index,defaultFont);}function getOutsideTextFont(trace,index,layoutFont){var defaultFont=getTextFont(trace,index,layoutFont);return getFontValue(attributeOutsideTextFont,trace.outsidetextfont,index,defaultFont);}function getFontValue(attributeDefinition,attributeValue,index,defaultValue){attributeValue=attributeValue||{};var familyValue=helpers.getValue(attributeValue.family,index);var sizeValue=helpers.getValue(attributeValue.size,index);var colorValue=helpers.getValue(attributeValue.color,index);return{family:helpers.coerceString(attributeDefinition.family,familyValue,defaultValue.family),size:helpers.coerceNumber(attributeDefinition.size,sizeValue,defaultValue.size),color:helpers.coerceColor(attributeDefinition.color,colorValue,defaultValue.color)};}function getBarColor(cd,trace){if(trace.type==='waterfall'){return trace[cd.dir].marker.color;}return cd.mc||trace.marker.color;}module.exports={style:style,styleTextPoints:styleTextPoints,styleOnSelect:styleOnSelect,getInsideTextFont:getInsideTextFont,getOutsideTextFont:getOutsideTextFont,getBarColor:getBarColor};},{\"../../components/color\":43,\"../../components/drawing\":64,\"../../lib\":159,\"../../registry\":242,\"./attributes\":252,\"./helpers\":257,\"d3\":8}],266:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Color=_dereq_('../../components/color');var hasColorscale=_dereq_('../../components/colorscale/helpers').hasColorscale;var colorscaleDefaults=_dereq_('../../components/colorscale/defaults');module.exports=function handleStyleDefaults(traceIn,traceOut,coerce,defaultColor,layout){coerce('marker.color',defaultColor);if(hasColorscale(traceIn,'marker')){colorscaleDefaults(traceIn,traceOut,layout,coerce,{prefix:'marker.',cLetter:'c'});}coerce('marker.line.color',Color.defaultLine);if(hasColorscale(traceIn,'marker.line')){colorscaleDefaults(traceIn,traceOut,layout,coerce,{prefix:'marker.line.',cLetter:'c'});}coerce('marker.line.width');coerce('marker.opacity');coerce('selected.marker.color');coerce('unselected.marker.color');};},{\"../../components/color\":43,\"../../components/colorscale/defaults\":53,\"../../components/colorscale/helpers\":54}],267:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var colorAttrs=_dereq_('../../components/color/attributes');var fontAttrs=_dereq_('../../plots/font_attributes');var plotAttrs=_dereq_('../../plots/attributes');var hovertemplateAttrs=_dereq_('../../components/fx/hovertemplate_attributes');var domainAttrs=_dereq_('../../plots/domain').attributes;var extendFlat=_dereq_('../../lib/extend').extendFlat;var textFontAttrs=fontAttrs({editType:'calc',arrayOk:true,colorEditType:'plot'});module.exports={labels:{valType:'data_array',editType:'calc'},// equivalent of x0 and dx, if label is missing\nlabel0:{valType:'number',dflt:0,editType:'calc'},dlabel:{valType:'number',dflt:1,editType:'calc'},values:{valType:'data_array',editType:'calc'},marker:{colors:{valType:'data_array',// TODO 'color_array' ?\neditType:'calc'},line:{color:{valType:'color',dflt:colorAttrs.defaultLine,arrayOk:true,editType:'style'},width:{valType:'number',min:0,dflt:0,arrayOk:true,editType:'style'},editType:'calc'},editType:'calc'},text:{valType:'data_array',editType:'calc'},hovertext:{valType:'string',dflt:'',arrayOk:true,editType:'style'},// 'see eg:'\n// 'https://www.e-education.psu.edu/natureofgeoinfo/sites/www.e-education.psu.edu.natureofgeoinfo/files/image/hisp_pies.gif',\n// '(this example involves a map too - may someday be a whole trace type',\n// 'of its own. but the point is the size of the whole pie is important.)'\nscalegroup:{valType:'string',dflt:'',editType:'calc'},// labels (legend is handled by plots.attributes.showlegend and layout.hiddenlabels)\ntextinfo:{valType:'flaglist',flags:['label','text','value','percent'],extras:['none'],editType:'calc'},hoverinfo:extendFlat({},plotAttrs.hoverinfo,{flags:['label','text','value','percent','name']}),hovertemplate:hovertemplateAttrs({},{keys:['label','color','value','percent','text']}),textposition:{valType:'enumerated',values:['inside','outside','auto','none'],dflt:'auto',arrayOk:true,editType:'calc'},textfont:extendFlat({},textFontAttrs,{}),insidetextfont:extendFlat({},textFontAttrs,{}),outsidetextfont:extendFlat({},textFontAttrs,{}),title:{text:{valType:'string',dflt:'',editType:'calc'},font:extendFlat({},textFontAttrs,{}),position:{valType:'enumerated',values:['top left','top center','top right','middle center','bottom left','bottom center','bottom right'],editType:'calc'},editType:'calc'},// position and shape\ndomain:domainAttrs({name:'pie',trace:true,editType:'calc'}),hole:{valType:'number',min:0,max:1,dflt:0,editType:'calc'},// ordering and direction\nsort:{valType:'boolean',dflt:true,editType:'calc'},direction:{/**\n         * there are two common conventions, both of which place the first\n         * (largest, if sorted) slice with its left edge at 12 o'clock but\n         * succeeding slices follow either cw or ccw from there.\n         *\n         * see http://visage.co/data-visualization-101-pie-charts/\n         */valType:'enumerated',values:['clockwise','counterclockwise'],dflt:'counterclockwise',editType:'calc'},rotation:{valType:'number',min:-360,max:360,dflt:0,editType:'calc'},pull:{valType:'number',min:0,max:1,dflt:0,arrayOk:true,editType:'calc'},_deprecated:{title:{valType:'string',dflt:'',editType:'calc'},titlefont:extendFlat({},textFontAttrs,{}),titleposition:{valType:'enumerated',values:['top left','top center','top right','middle center','bottom left','bottom center','bottom right'],editType:'calc'}}};},{\"../../components/color/attributes\":42,\"../../components/fx/hovertemplate_attributes\":81,\"../../lib/extend\":153,\"../../plots/attributes\":200,\"../../plots/domain\":228,\"../../plots/font_attributes\":229}],268:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Registry=_dereq_('../../registry');var getModuleCalcData=_dereq_('../../plots/get_data').getModuleCalcData;exports.name='pie';exports.plot=function(gd){var Pie=Registry.getModule('pie');var cdPie=getModuleCalcData(gd.calcdata,Pie)[0];Pie.plot(gd,cdPie);};exports.clean=function(newFullData,newFullLayout,oldFullData,oldFullLayout){var hadPie=oldFullLayout._has&&oldFullLayout._has('pie');var hasPie=newFullLayout._has&&newFullLayout._has('pie');if(hadPie&&!hasPie){oldFullLayout._pielayer.selectAll('g.trace').remove();}};},{\"../../plots/get_data\":231,\"../../registry\":242}],269:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var isNumeric=_dereq_('fast-isnumeric');var isArrayOrTypedArray=_dereq_('../../lib').isArrayOrTypedArray;var tinycolor=_dereq_('tinycolor2');var Color=_dereq_('../../components/color');var helpers=_dereq_('./helpers');var pieExtendedColorWays={};function calc(gd,trace){var vals=trace.values;var hasVals=isArrayOrTypedArray(vals)&&vals.length;var labels=trace.labels;var colors=trace.marker.colors||[];var cd=[];var fullLayout=gd._fullLayout;var allThisTraceLabels={};var vTotal=0;var hiddenLabels=fullLayout.hiddenlabels||[];var i,v,label,hidden,pt;if(trace.dlabel){labels=new Array(vals.length);for(i=0;i<vals.length;i++){labels[i]=String(trace.label0+i*trace.dlabel);}}var pullColor=makePullColorFn(fullLayout._piecolormap);var seriesLen=(hasVals?vals:labels).length;for(i=0;i<seriesLen;i++){if(hasVals){v=vals[i];if(!isNumeric(v))continue;v=+v;if(v<0)continue;}else v=1;label=labels[i];if(label===undefined||label==='')label=i;label=String(label);var thisLabelIndex=allThisTraceLabels[label];if(thisLabelIndex===undefined){allThisTraceLabels[label]=cd.length;hidden=hiddenLabels.indexOf(label)!==-1;if(!hidden)vTotal+=v;cd.push({v:v,label:label,color:pullColor(colors[i],label),i:i,pts:[i],hidden:hidden});}else{pt=cd[thisLabelIndex];pt.v+=v;pt.pts.push(i);if(!pt.hidden)vTotal+=v;if(pt.color===false&&colors[i]){pt.color=pullColor(colors[i],label);}}}if(trace.sort)cd.sort(function(a,b){return b.v-a.v;});// include the sum of all values in the first point\nif(cd[0])cd[0].vTotal=vTotal;// now insert text\nif(trace.textinfo&&trace.textinfo!=='none'){var hasLabel=trace.textinfo.indexOf('label')!==-1;var hasText=trace.textinfo.indexOf('text')!==-1;var hasValue=trace.textinfo.indexOf('value')!==-1;var hasPercent=trace.textinfo.indexOf('percent')!==-1;var separators=fullLayout.separators;var thisText;for(i=0;i<cd.length;i++){pt=cd[i];thisText=hasLabel?[pt.label]:[];if(hasText){var texti=helpers.getFirstFilled(trace.text,pt.pts);if(texti)thisText.push(texti);}if(hasValue)thisText.push(helpers.formatPieValue(pt.v,separators));if(hasPercent)thisText.push(helpers.formatPiePercent(pt.v/vTotal,separators));pt.text=thisText.join('<br>');}}return cd;}function makePullColorFn(colorMap){return function pullColor(color,id){if(!color)return false;color=tinycolor(color);if(!color.isValid())return false;color=Color.addOpacity(color,color.getAlpha());if(!colorMap[id])colorMap[id]=color;return color;};}/*\n * `calc` filled in (and collated) explicit colors.\n * Now we need to propagate these explicit colors to other traces,\n * and fill in default colors.\n * This is done after sorting, so we pick defaults\n * in the order slices will be displayed\n */function crossTraceCalc(gd){var fullLayout=gd._fullLayout;var calcdata=gd.calcdata;var pieColorWay=fullLayout.piecolorway;var colorMap=fullLayout._piecolormap;if(fullLayout.extendpiecolors){pieColorWay=generateExtendedColors(pieColorWay,pieExtendedColorWays);}var dfltColorCount=0;for(var i=0;i<calcdata.length;i++){var cd=calcdata[i];if(cd[0].trace.type!=='pie')continue;for(var j=0;j<cd.length;j++){var pt=cd[j];if(pt.color===false){// have we seen this label and assigned a color to it in a previous trace?\nif(colorMap[pt.label]){pt.color=colorMap[pt.label];}else{colorMap[pt.label]=pt.color=pieColorWay[dfltColorCount%pieColorWay.length];dfltColorCount++;}}}}}/**\n * pick a default color from the main default set, augmented by\n * itself lighter then darker before repeating\n */function generateExtendedColors(colorList,extendedColorWays){var i;var colorString=JSON.stringify(colorList);var pieColors=extendedColorWays[colorString];if(!pieColors){pieColors=colorList.slice();for(i=0;i<colorList.length;i++){pieColors.push(tinycolor(colorList[i]).lighten(20).toHexString());}for(i=0;i<colorList.length;i++){pieColors.push(tinycolor(colorList[i]).darken(20).toHexString());}extendedColorWays[colorString]=pieColors;}return pieColors;}module.exports={calc:calc,crossTraceCalc:crossTraceCalc,makePullColorFn:makePullColorFn,generateExtendedColors:generateExtendedColors};},{\"../../components/color\":43,\"../../lib\":159,\"./helpers\":272,\"fast-isnumeric\":10,\"tinycolor2\":26}],270:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var attributes=_dereq_('./attributes');var handleDomainDefaults=_dereq_('../../plots/domain').defaults;module.exports=function supplyDefaults(traceIn,traceOut,defaultColor,layout){function coerce(attr,dflt){return Lib.coerce(traceIn,traceOut,attributes,attr,dflt);}var coerceFont=Lib.coerceFont;var len;var vals=coerce('values');var hasVals=Lib.isArrayOrTypedArray(vals);var labels=coerce('labels');if(Array.isArray(labels)){len=labels.length;if(hasVals)len=Math.min(len,vals.length);}else if(hasVals){len=vals.length;coerce('label0');coerce('dlabel');}if(!len){traceOut.visible=false;return;}traceOut._length=len;var lineWidth=coerce('marker.line.width');if(lineWidth)coerce('marker.line.color');coerce('marker.colors');coerce('scalegroup');// TODO: hole needs to be coerced to the same value within a scaleegroup\nvar textData=coerce('text');var textInfo=coerce('textinfo',Array.isArray(textData)?'text+percent':'percent');coerce('hovertext');coerce('hovertemplate');if(textInfo&&textInfo!=='none'){var textPosition=coerce('textposition');var hasBoth=Array.isArray(textPosition)||textPosition==='auto';var hasInside=hasBoth||textPosition==='inside';var hasOutside=hasBoth||textPosition==='outside';if(hasInside||hasOutside){var dfltFont=coerceFont(coerce,'textfont',layout.font);if(hasInside){var insideTextFontDefault=Lib.extendFlat({},dfltFont);var isTraceTextfontColorSet=traceIn.textfont&&traceIn.textfont.color;var isColorInheritedFromLayoutFont=!isTraceTextfontColorSet;if(isColorInheritedFromLayoutFont){delete insideTextFontDefault.color;}coerceFont(coerce,'insidetextfont',insideTextFontDefault);}if(hasOutside)coerceFont(coerce,'outsidetextfont',dfltFont);}}handleDomainDefaults(traceOut,layout,coerce);var hole=coerce('hole');var title=coerce('title.text');if(title){var titlePosition=coerce('title.position',hole?'middle center':'top center');if(!hole&&titlePosition==='middle center')traceOut.title.position='top center';coerceFont(coerce,'title.font',layout.font);}coerce('sort');coerce('direction');coerce('rotation');coerce('pull');};},{\"../../lib\":159,\"../../plots/domain\":228,\"./attributes\":267}],271:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var appendArrayMultiPointValues=_dereq_('../../components/fx/helpers').appendArrayMultiPointValues;// Note: like other eventData routines, this creates the data for hover/unhover/click events\n// but it has a different API and goes through a totally different pathway.\n// So to ensure it doesn't get misused, it's not attached to the Pie module.\nmodule.exports=function eventData(pt,trace){var out={curveNumber:trace.index,pointNumbers:pt.pts,data:trace._input,fullData:trace,label:pt.label,color:pt.color,value:pt.v,percent:pt.percent,text:pt.text,// pt.v (and pt.i below) for backward compatibility\nv:pt.v};// Only include pointNumber if it's unambiguous\nif(pt.pts.length===1)out.pointNumber=out.i=pt.pts[0];// Add extra data arrays to the output\n// notice that this is the multi-point version ('s' on the end!)\n// so added data will be arrays matching the pointNumbers array.\nappendArrayMultiPointValues(out,trace,pt.pts);return out;};},{\"../../components/fx/helpers\":78}],272:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');exports.formatPiePercent=function formatPiePercent(v,separators){var vRounded=(v*100).toPrecision(3);if(vRounded.lastIndexOf('.')!==-1){vRounded=vRounded.replace(/[.]?0+$/,'');}return Lib.numSeparate(vRounded,separators)+'%';};exports.formatPieValue=function formatPieValue(v,separators){var vRounded=v.toPrecision(10);if(vRounded.lastIndexOf('.')!==-1){vRounded=vRounded.replace(/[.]?0+$/,'');}return Lib.numSeparate(vRounded,separators);};exports.getFirstFilled=function getFirstFilled(array,indices){if(!Array.isArray(array))return;for(var i=0;i<indices.length;i++){var v=array[indices[i]];if(v||v===0)return v;}};exports.castOption=function castOption(item,indices){if(Array.isArray(item))return exports.getFirstFilled(item,indices);else if(item)return item;};},{\"../../lib\":159}],273:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports={attributes:_dereq_('./attributes'),supplyDefaults:_dereq_('./defaults'),supplyLayoutDefaults:_dereq_('./layout_defaults'),layoutAttributes:_dereq_('./layout_attributes'),calc:_dereq_('./calc').calc,crossTraceCalc:_dereq_('./calc').crossTraceCalc,plot:_dereq_('./plot').plot,style:_dereq_('./style'),styleOne:_dereq_('./style_one'),moduleType:'trace',name:'pie',basePlotModule:_dereq_('./base_plot'),categories:['pie','showLegend'],meta:{}};},{\"./attributes\":267,\"./base_plot\":268,\"./calc\":269,\"./defaults\":270,\"./layout_attributes\":274,\"./layout_defaults\":275,\"./plot\":276,\"./style\":277,\"./style_one\":278}],274:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports={/**\n     * hiddenlabels is the pie chart analog of visible:'legendonly'\n     * but it can contain many labels, and can hide slices\n     * from several pies simultaneously\n     */hiddenlabels:{valType:'data_array',editType:'calc'},piecolorway:{valType:'colorlist',editType:'calc'},extendpiecolors:{valType:'boolean',dflt:true,editType:'calc'}};},{}],275:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var layoutAttributes=_dereq_('./layout_attributes');module.exports=function supplyLayoutDefaults(layoutIn,layoutOut){function coerce(attr,dflt){return Lib.coerce(layoutIn,layoutOut,layoutAttributes,attr,dflt);}coerce('hiddenlabels');coerce('piecolorway',layoutOut.colorway);coerce('extendpiecolors');};},{\"../../lib\":159,\"./layout_attributes\":274}],276:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var Fx=_dereq_('../../components/fx');var Color=_dereq_('../../components/color');var Drawing=_dereq_('../../components/drawing');var Lib=_dereq_('../../lib');var svgTextUtils=_dereq_('../../lib/svg_text_utils');var helpers=_dereq_('./helpers');var eventData=_dereq_('./event_data');function plot(gd,cdpie){var fullLayout=gd._fullLayout;prerenderTitles(cdpie,gd);scalePies(cdpie,fullLayout._size);var pieGroups=Lib.makeTraceGroups(fullLayout._pielayer,cdpie,'trace').each(function(cd){var pieGroup=d3.select(this);var cd0=cd[0];var trace=cd0.trace;setCoords(cd);// TODO: miter might look better but can sometimes cause problems\n// maybe miter with a small-ish stroke-miterlimit?\npieGroup.attr('stroke-linejoin','round');pieGroup.each(function(){var slices=d3.select(this).selectAll('g.slice').data(cd);slices.enter().append('g').classed('slice',true);slices.exit().remove();var quadrants=[[[],[]],// y<0: x<0, x>=0\n[[],[]]// y>=0: x<0, x>=0\n];var hasOutsideText=false;slices.each(function(pt){if(pt.hidden){d3.select(this).selectAll('path,g').remove();return;}// to have consistent event data compared to other traces\npt.pointNumber=pt.i;pt.curveNumber=trace.index;quadrants[pt.pxmid[1]<0?0:1][pt.pxmid[0]<0?0:1].push(pt);var cx=cd0.cx;var cy=cd0.cy;var sliceTop=d3.select(this);var slicePath=sliceTop.selectAll('path.surface').data([pt]);slicePath.enter().append('path').classed('surface',true).style({'pointer-events':'all'});sliceTop.call(attachFxHandlers,gd,cd);if(trace.pull){var pull=+helpers.castOption(trace.pull,pt.pts)||0;if(pull>0){cx+=pull*pt.pxmid[0];cy+=pull*pt.pxmid[1];}}pt.cxFinal=cx;pt.cyFinal=cy;function arc(start,finish,cw,scale){return'a'+scale*cd0.r+','+scale*cd0.r+' 0 '+pt.largeArc+(cw?' 1 ':' 0 ')+scale*(finish[0]-start[0])+','+scale*(finish[1]-start[1]);}var hole=trace.hole;if(pt.v===cd0.vTotal){// 100% fails bcs arc start and end are identical\nvar outerCircle='M'+(cx+pt.px0[0])+','+(cy+pt.px0[1])+arc(pt.px0,pt.pxmid,true,1)+arc(pt.pxmid,pt.px0,true,1)+'Z';if(hole){slicePath.attr('d','M'+(cx+hole*pt.px0[0])+','+(cy+hole*pt.px0[1])+arc(pt.px0,pt.pxmid,false,hole)+arc(pt.pxmid,pt.px0,false,hole)+'Z'+outerCircle);}else slicePath.attr('d',outerCircle);}else{var outerArc=arc(pt.px0,pt.px1,true,1);if(hole){var rim=1-hole;slicePath.attr('d','M'+(cx+hole*pt.px1[0])+','+(cy+hole*pt.px1[1])+arc(pt.px1,pt.px0,false,hole)+'l'+rim*pt.px0[0]+','+rim*pt.px0[1]+outerArc+'Z');}else{slicePath.attr('d','M'+cx+','+cy+'l'+pt.px0[0]+','+pt.px0[1]+outerArc+'Z');}}// add text\nvar textPosition=helpers.castOption(trace.textposition,pt.pts);var sliceTextGroup=sliceTop.selectAll('g.slicetext').data(pt.text&&textPosition!=='none'?[0]:[]);sliceTextGroup.enter().append('g').classed('slicetext',true);sliceTextGroup.exit().remove();sliceTextGroup.each(function(){var sliceText=Lib.ensureSingle(d3.select(this),'text','',function(s){// prohibit tex interpretation until we can handle\n// tex and regular text together\ns.attr('data-notex',1);});sliceText.text(pt.text).attr({'class':'slicetext',transform:'','text-anchor':'middle'}).call(Drawing.font,textPosition==='outside'?determineOutsideTextFont(trace,pt,gd._fullLayout.font):determineInsideTextFont(trace,pt,gd._fullLayout.font)).call(svgTextUtils.convertToTspans,gd);// position the text relative to the slice\nvar textBB=Drawing.bBox(sliceText.node());var transform;if(textPosition==='outside'){transform=transformOutsideText(textBB,pt);}else{transform=transformInsideText(textBB,pt,cd0);if(textPosition==='auto'&&transform.scale<1){sliceText.call(Drawing.font,trace.outsidetextfont);if(trace.outsidetextfont.family!==trace.insidetextfont.family||trace.outsidetextfont.size!==trace.insidetextfont.size){textBB=Drawing.bBox(sliceText.node());}transform=transformOutsideText(textBB,pt);}}var translateX=cx+pt.pxmid[0]*transform.rCenter+(transform.x||0);var translateY=cy+pt.pxmid[1]*transform.rCenter+(transform.y||0);// save some stuff to use later ensure no labels overlap\nif(transform.outside){pt.yLabelMin=translateY-textBB.height/2;pt.yLabelMid=translateY;pt.yLabelMax=translateY+textBB.height/2;pt.labelExtraX=0;pt.labelExtraY=0;hasOutsideText=true;}sliceText.attr('transform','translate('+translateX+','+translateY+')'+(transform.scale<1?'scale('+transform.scale+')':'')+(transform.rotate?'rotate('+transform.rotate+')':'')+'translate('+-(textBB.left+textBB.right)/2+','+-(textBB.top+textBB.bottom)/2+')');});});// add the title\nvar titleTextGroup=d3.select(this).selectAll('g.titletext').data(trace.title.text?[0]:[]);titleTextGroup.enter().append('g').classed('titletext',true);titleTextGroup.exit().remove();titleTextGroup.each(function(){var titleText=Lib.ensureSingle(d3.select(this),'text','',function(s){// prohibit tex interpretation as above\ns.attr('data-notex',1);});var txt=fullLayout.meta?Lib.templateString(trace.title.text,{meta:fullLayout.meta}):trace.title.text;titleText.text(txt).attr({'class':'titletext',transform:'','text-anchor':'middle'}).call(Drawing.font,trace.title.font).call(svgTextUtils.convertToTspans,gd);var transform;if(trace.title.position==='middle center'){transform=positionTitleInside(cd0);}else{transform=positionTitleOutside(cd0,fullLayout._size);}titleText.attr('transform','translate('+transform.x+','+transform.y+')'+(transform.scale<1?'scale('+transform.scale+')':'')+'translate('+transform.tx+','+transform.ty+')');});// now make sure no labels overlap (at least within one pie)\nif(hasOutsideText)scootLabels(quadrants,trace);plotTextLines(slices,trace);});});// This is for a bug in Chrome (as of 2015-07-22, and does not affect FF)\n// if insidetextfont and outsidetextfont are different sizes, sometimes the size\n// of an \"em\" gets taken from the wrong element at first so lines are\n// spaced wrong. You just have to tell it to try again later and it gets fixed.\n// I have no idea why we haven't seen this in other contexts. Also, sometimes\n// it gets the initial draw correct but on redraw it gets confused.\nsetTimeout(function(){pieGroups.selectAll('tspan').each(function(){var s=d3.select(this);if(s.attr('dy'))s.attr('dy',s.attr('dy'));});},0);}// TODO add support for transition\nfunction plotTextLines(slices,trace){slices.each(function(pt){var sliceTop=d3.select(this);if(!pt.labelExtraX&&!pt.labelExtraY){sliceTop.select('path.textline').remove();return;}// first move the text to its new location\nvar sliceText=sliceTop.select('g.slicetext text');sliceText.attr('transform','translate('+pt.labelExtraX+','+pt.labelExtraY+')'+sliceText.attr('transform'));// then add a line to the new location\nvar lineStartX=pt.cxFinal+pt.pxmid[0];var lineStartY=pt.cyFinal+pt.pxmid[1];var textLinePath='M'+lineStartX+','+lineStartY;var finalX=(pt.yLabelMax-pt.yLabelMin)*(pt.pxmid[0]<0?-1:1)/4;if(pt.labelExtraX){var yFromX=pt.labelExtraX*pt.pxmid[1]/pt.pxmid[0];var yNet=pt.yLabelMid+pt.labelExtraY-(pt.cyFinal+pt.pxmid[1]);if(Math.abs(yFromX)>Math.abs(yNet)){textLinePath+='l'+yNet*pt.pxmid[0]/pt.pxmid[1]+','+yNet+'H'+(lineStartX+pt.labelExtraX+finalX);}else{textLinePath+='l'+pt.labelExtraX+','+yFromX+'v'+(yNet-yFromX)+'h'+finalX;}}else{textLinePath+='V'+(pt.yLabelMid+pt.labelExtraY)+'h'+finalX;}Lib.ensureSingle(sliceTop,'path','textline').call(Color.stroke,trace.outsidetextfont.color).attr({'stroke-width':Math.min(2,trace.outsidetextfont.size/8),d:textLinePath,fill:'none'});});}function attachFxHandlers(sliceTop,gd,cd){var cd0=cd[0];var trace=cd0.trace;var cx=cd0.cx;var cy=cd0.cy;// hover state vars\n// have we drawn a hover label, so it should be cleared later\nif(!('_hasHoverLabel'in trace))trace._hasHoverLabel=false;// have we emitted a hover event, so later an unhover event should be emitted\n// note that click events do not depend on this - you can still get them\n// with hovermode: false or if you were earlier dragging, then clicked\n// in the same slice that you moused up in\nif(!('_hasHoverEvent'in trace))trace._hasHoverEvent=false;sliceTop.on('mouseover',function(pt){// in case fullLayout or fullData has changed without a replot\nvar fullLayout2=gd._fullLayout;var trace2=gd._fullData[trace.index];if(gd._dragging||fullLayout2.hovermode===false)return;var hoverinfo=trace2.hoverinfo;if(Array.isArray(hoverinfo)){// super hacky: we need to pull out the *first* hoverinfo from\n// pt.pts, then put it back into an array in a dummy trace\n// and call castHoverinfo on that.\n// TODO: do we want to have Fx.castHoverinfo somehow handle this?\n// it already takes an array for index, for 2D, so this seems tricky.\nhoverinfo=Fx.castHoverinfo({hoverinfo:[helpers.castOption(hoverinfo,pt.pts)],_module:trace._module},fullLayout2,0);}if(hoverinfo==='all')hoverinfo='label+text+value+percent+name';// in case we dragged over the pie from another subplot,\n// or if hover is turned off\nif(trace2.hovertemplate||hoverinfo!=='none'&&hoverinfo!=='skip'&&hoverinfo){var rInscribed=pt.rInscribed;var hoverCenterX=cx+pt.pxmid[0]*(1-rInscribed);var hoverCenterY=cy+pt.pxmid[1]*(1-rInscribed);var separators=fullLayout2.separators;var thisText=[];if(hoverinfo&&hoverinfo.indexOf('label')!==-1)thisText.push(pt.label);pt.text=helpers.castOption(trace2.hovertext||trace2.text,pt.pts);if(hoverinfo&&hoverinfo.indexOf('text')!==-1){var texti=pt.text;if(texti)thisText.push(texti);}pt.value=pt.v;pt.valueLabel=helpers.formatPieValue(pt.v,separators);if(hoverinfo&&hoverinfo.indexOf('value')!==-1)thisText.push(pt.valueLabel);pt.percent=pt.v/cd0.vTotal;pt.percentLabel=helpers.formatPiePercent(pt.percent,separators);if(hoverinfo&&hoverinfo.indexOf('percent')!==-1)thisText.push(pt.percentLabel);var hoverLabel=trace2.hoverlabel;var hoverFont=hoverLabel.font;Fx.loneHover({trace:trace,x0:hoverCenterX-rInscribed*cd0.r,x1:hoverCenterX+rInscribed*cd0.r,y:hoverCenterY,text:thisText.join('<br>'),name:trace2.hovertemplate||hoverinfo.indexOf('name')!==-1?trace2.name:undefined,idealAlign:pt.pxmid[0]<0?'left':'right',color:helpers.castOption(hoverLabel.bgcolor,pt.pts)||pt.color,borderColor:helpers.castOption(hoverLabel.bordercolor,pt.pts),fontFamily:helpers.castOption(hoverFont.family,pt.pts),fontSize:helpers.castOption(hoverFont.size,pt.pts),fontColor:helpers.castOption(hoverFont.color,pt.pts),nameLength:helpers.castOption(hoverLabel.namelength,pt.pts),textAlign:helpers.castOption(hoverLabel.align,pt.pts),hovertemplate:helpers.castOption(trace2.hovertemplate,pt.pts),hovertemplateLabels:pt,eventData:[eventData(pt,trace2)]},{container:fullLayout2._hoverlayer.node(),outerContainer:fullLayout2._paper.node(),gd:gd});trace._hasHoverLabel=true;}trace._hasHoverEvent=true;gd.emit('plotly_hover',{points:[eventData(pt,trace2)],event:d3.event});});sliceTop.on('mouseout',function(evt){var fullLayout2=gd._fullLayout;var trace2=gd._fullData[trace.index];var pt=d3.select(this).datum();if(trace._hasHoverEvent){evt.originalEvent=d3.event;gd.emit('plotly_unhover',{points:[eventData(pt,trace2)],event:d3.event});trace._hasHoverEvent=false;}if(trace._hasHoverLabel){Fx.loneUnhover(fullLayout2._hoverlayer.node());trace._hasHoverLabel=false;}});sliceTop.on('click',function(pt){// TODO: this does not support right-click. If we want to support it, we\n// would likely need to change pie to use dragElement instead of straight\n// mapbox event binding. Or perhaps better, make a simple wrapper with the\n// right mousedown, mousemove, and mouseup handlers just for a left/right click\n// mapbox would use this too.\nvar fullLayout2=gd._fullLayout;var trace2=gd._fullData[trace.index];if(gd._dragging||fullLayout2.hovermode===false)return;gd._hoverdata=[eventData(pt,trace2)];Fx.click(gd,d3.event);});}function determineOutsideTextFont(trace,pt,layoutFont){var color=helpers.castOption(trace.outsidetextfont.color,pt.pts)||helpers.castOption(trace.textfont.color,pt.pts)||layoutFont.color;var family=helpers.castOption(trace.outsidetextfont.family,pt.pts)||helpers.castOption(trace.textfont.family,pt.pts)||layoutFont.family;var size=helpers.castOption(trace.outsidetextfont.size,pt.pts)||helpers.castOption(trace.textfont.size,pt.pts)||layoutFont.size;return{color:color,family:family,size:size};}function determineInsideTextFont(trace,pt,layoutFont){var customColor=helpers.castOption(trace.insidetextfont.color,pt.pts);if(!customColor&&trace._input.textfont){// Why not simply using trace.textfont? Because if not set, it\n// defaults to layout.font which has a default color. But if\n// textfont.color and insidetextfont.color don't supply a value,\n// a contrasting color shall be used.\ncustomColor=helpers.castOption(trace._input.textfont.color,pt.pts);}var family=helpers.castOption(trace.insidetextfont.family,pt.pts)||helpers.castOption(trace.textfont.family,pt.pts)||layoutFont.family;var size=helpers.castOption(trace.insidetextfont.size,pt.pts)||helpers.castOption(trace.textfont.size,pt.pts)||layoutFont.size;return{color:customColor||Color.contrast(pt.color),family:family,size:size};}function prerenderTitles(cdpie,gd){var fullLayout=gd._fullLayout;var cd0,trace;// Determine the width and height of the title for each pie.\nfor(var i=0;i<cdpie.length;i++){cd0=cdpie[i][0];trace=cd0.trace;if(trace.title.text){var txt=fullLayout.meta?Lib.templateString(trace.title.text,{meta:fullLayout.meta}):trace.title.text;var dummyTitle=Drawing.tester.append('text').attr('data-notex',1).text(txt).call(Drawing.font,trace.title.font).call(svgTextUtils.convertToTspans,gd);var bBox=Drawing.bBox(dummyTitle.node(),true);cd0.titleBox={width:bBox.width,height:bBox.height};dummyTitle.remove();}}}function transformInsideText(textBB,pt,cd0){var textDiameter=Math.sqrt(textBB.width*textBB.width+textBB.height*textBB.height);var textAspect=textBB.width/textBB.height;var halfAngle=pt.halfangle;var ring=pt.ring;var rInscribed=pt.rInscribed;var r=cd0.r||pt.rpx1;// max size text can be inserted inside without rotating it\n// this inscribes the text rectangle in a circle, which is then inscribed\n// in the slice, so it will be an underestimate, which some day we may want\n// to improve so this case can get more use\nvar transform={scale:rInscribed*r*2/textDiameter,// and the center position and rotation in this case\nrCenter:1-rInscribed,rotate:0};if(transform.scale>=1)return transform;// max size if text is rotated radially\nvar Qr=textAspect+1/(2*Math.tan(halfAngle));var maxHalfHeightRotRadial=r*Math.min(1/(Math.sqrt(Qr*Qr+0.5)+Qr),ring/(Math.sqrt(textAspect*textAspect+ring/2)+textAspect));var radialTransform={scale:maxHalfHeightRotRadial*2/textBB.height,rCenter:Math.cos(maxHalfHeightRotRadial/r)-maxHalfHeightRotRadial*textAspect/r,rotate:(180/Math.PI*pt.midangle+720)%180-90};// max size if text is rotated tangentially\nvar aspectInv=1/textAspect;var Qt=aspectInv+1/(2*Math.tan(halfAngle));var maxHalfWidthTangential=r*Math.min(1/(Math.sqrt(Qt*Qt+0.5)+Qt),ring/(Math.sqrt(aspectInv*aspectInv+ring/2)+aspectInv));var tangentialTransform={scale:maxHalfWidthTangential*2/textBB.width,rCenter:Math.cos(maxHalfWidthTangential/r)-maxHalfWidthTangential/textAspect/r,rotate:(180/Math.PI*pt.midangle+810)%180-90};// if we need a rotated transform, pick the biggest one\n// even if both are bigger than 1\nvar rotatedTransform=tangentialTransform.scale>radialTransform.scale?tangentialTransform:radialTransform;if(transform.scale<1&&rotatedTransform.scale>transform.scale)return rotatedTransform;return transform;}function getInscribedRadiusFraction(pt,cd0){if(pt.v===cd0.vTotal&&!cd0.trace.hole)return 1;// special case of 100% with no hole\nreturn Math.min(1/(1+1/Math.sin(pt.halfangle)),pt.ring/2);}function transformOutsideText(textBB,pt){var x=pt.pxmid[0];var y=pt.pxmid[1];var dx=textBB.width/2;var dy=textBB.height/2;if(x<0)dx*=-1;if(y<0)dy*=-1;return{scale:1,rCenter:1,rotate:0,x:dx+Math.abs(dy)*(dx>0?1:-1)/2,y:dy/(1+x*x/(y*y)),outside:true};}function positionTitleInside(cd0){var textDiameter=Math.sqrt(cd0.titleBox.width*cd0.titleBox.width+cd0.titleBox.height*cd0.titleBox.height);return{x:cd0.cx,y:cd0.cy,scale:cd0.trace.hole*cd0.r*2/textDiameter,tx:0,ty:-cd0.titleBox.height/2+cd0.trace.title.font.size};}function positionTitleOutside(cd0,plotSize){var scaleX=1;var scaleY=1;var maxWidth,maxPull;var trace=cd0.trace;// position of the baseline point of the text box in the plot, before scaling.\n// we anchored the text in the middle, so the baseline is on the bottom middle\n// of the first line of text.\nvar topMiddle={x:cd0.cx,y:cd0.cy};// relative translation of the text box after scaling\nvar translate={tx:0,ty:0};// we reason below as if the baseline is the top middle point of the text box.\n// so we must add the font size to approximate the y-coord. of the top.\n// note that this correction must happen after scaling.\ntranslate.ty+=trace.title.font.size;maxPull=getMaxPull(trace);if(trace.title.position.indexOf('top')!==-1){topMiddle.y-=(1+maxPull)*cd0.r;translate.ty-=cd0.titleBox.height;}else if(trace.title.position.indexOf('bottom')!==-1){topMiddle.y+=(1+maxPull)*cd0.r;}if(trace.title.position.indexOf('left')!==-1){// we start the text at the left edge of the pie\nmaxWidth=plotSize.w*(trace.domain.x[1]-trace.domain.x[0])/2+cd0.r;topMiddle.x-=(1+maxPull)*cd0.r;translate.tx+=cd0.titleBox.width/2;}else if(trace.title.position.indexOf('center')!==-1){maxWidth=plotSize.w*(trace.domain.x[1]-trace.domain.x[0]);}else if(trace.title.position.indexOf('right')!==-1){maxWidth=plotSize.w*(trace.domain.x[1]-trace.domain.x[0])/2+cd0.r;topMiddle.x+=(1+maxPull)*cd0.r;translate.tx-=cd0.titleBox.width/2;}scaleX=maxWidth/cd0.titleBox.width;scaleY=getTitleSpace(cd0,plotSize)/cd0.titleBox.height;return{x:topMiddle.x,y:topMiddle.y,scale:Math.min(scaleX,scaleY),tx:translate.tx,ty:translate.ty};}function getTitleSpace(cd0,plotSize){var trace=cd0.trace;var pieBoxHeight=plotSize.h*(trace.domain.y[1]-trace.domain.y[0]);// use at most half of the plot for the title\nreturn Math.min(cd0.titleBox.height,pieBoxHeight/2);}function getMaxPull(trace){var maxPull=trace.pull;var j;if(Array.isArray(maxPull)){maxPull=0;for(j=0;j<trace.pull.length;j++){if(trace.pull[j]>maxPull)maxPull=trace.pull[j];}}return maxPull;}function scootLabels(quadrants,trace){var xHalf,yHalf,equatorFirst,farthestX,farthestY,xDiffSign,yDiffSign,thisQuad,oppositeQuad,wholeSide,i,thisQuadOutside,firstOppositeOutsidePt;function topFirst(a,b){return a.pxmid[1]-b.pxmid[1];}function bottomFirst(a,b){return b.pxmid[1]-a.pxmid[1];}function scootOneLabel(thisPt,prevPt){if(!prevPt)prevPt={};var prevOuterY=prevPt.labelExtraY+(yHalf?prevPt.yLabelMax:prevPt.yLabelMin);var thisInnerY=yHalf?thisPt.yLabelMin:thisPt.yLabelMax;var thisOuterY=yHalf?thisPt.yLabelMax:thisPt.yLabelMin;var thisSliceOuterY=thisPt.cyFinal+farthestY(thisPt.px0[1],thisPt.px1[1]);var newExtraY=prevOuterY-thisInnerY;var xBuffer,i,otherPt,otherOuterY,otherOuterX,newExtraX;// make sure this label doesn't overlap other labels\n// this *only* has us move these labels vertically\nif(newExtraY*yDiffSign>0)thisPt.labelExtraY=newExtraY;// make sure this label doesn't overlap any slices\nif(!Array.isArray(trace.pull))return;// this can only happen with array pulls\nfor(i=0;i<wholeSide.length;i++){otherPt=wholeSide[i];// overlap can only happen if the other point is pulled more than this one\nif(otherPt===thisPt||(helpers.castOption(trace.pull,thisPt.pts)||0)>=(helpers.castOption(trace.pull,otherPt.pts)||0)){continue;}if((thisPt.pxmid[1]-otherPt.pxmid[1])*yDiffSign>0){// closer to the equator - by construction all of these happen first\n// move the text vertically to get away from these slices\notherOuterY=otherPt.cyFinal+farthestY(otherPt.px0[1],otherPt.px1[1]);newExtraY=otherOuterY-thisInnerY-thisPt.labelExtraY;if(newExtraY*yDiffSign>0)thisPt.labelExtraY+=newExtraY;}else if((thisOuterY+thisPt.labelExtraY-thisSliceOuterY)*yDiffSign>0){// farther from the equator - happens after we've done all the\n// vertical moving we're going to do\n// move horizontally to get away from these more polar slices\n// if we're moving horz. based on a slice that's several slices away from this one\n// then we need some extra space for the lines to labels between them\nxBuffer=3*xDiffSign*Math.abs(i-wholeSide.indexOf(thisPt));otherOuterX=otherPt.cxFinal+farthestX(otherPt.px0[0],otherPt.px1[0]);newExtraX=otherOuterX+xBuffer-(thisPt.cxFinal+thisPt.pxmid[0])-thisPt.labelExtraX;if(newExtraX*xDiffSign>0)thisPt.labelExtraX+=newExtraX;}}}for(yHalf=0;yHalf<2;yHalf++){equatorFirst=yHalf?topFirst:bottomFirst;farthestY=yHalf?Math.max:Math.min;yDiffSign=yHalf?1:-1;for(xHalf=0;xHalf<2;xHalf++){farthestX=xHalf?Math.max:Math.min;xDiffSign=xHalf?1:-1;// first sort the array\n// note this is a copy of cd, so cd itself doesn't get sorted\n// but we can still modify points in place.\nthisQuad=quadrants[yHalf][xHalf];thisQuad.sort(equatorFirst);oppositeQuad=quadrants[1-yHalf][xHalf];wholeSide=oppositeQuad.concat(thisQuad);thisQuadOutside=[];for(i=0;i<thisQuad.length;i++){if(thisQuad[i].yLabelMid!==undefined)thisQuadOutside.push(thisQuad[i]);}firstOppositeOutsidePt=false;for(i=0;yHalf&&i<oppositeQuad.length;i++){if(oppositeQuad[i].yLabelMid!==undefined){firstOppositeOutsidePt=oppositeQuad[i];break;}}// each needs to avoid the previous\nfor(i=0;i<thisQuadOutside.length;i++){var prevPt=i&&thisQuadOutside[i-1];// bottom half needs to avoid the first label of the top half\n// top half we still need to call scootOneLabel on the first slice\n// so we can avoid other slices, but we don't pass a prevPt\nif(firstOppositeOutsidePt&&!i)prevPt=firstOppositeOutsidePt;scootOneLabel(thisQuadOutside[i],prevPt);}}}}function scalePies(cdpie,plotSize){var scaleGroups=[];var pieBoxWidth,pieBoxHeight,i,j,cd0,trace,maxPull,scaleGroup,minPxPerValUnit;// first figure out the center and maximum radius for each pie\nfor(i=0;i<cdpie.length;i++){cd0=cdpie[i][0];trace=cd0.trace;pieBoxWidth=plotSize.w*(trace.domain.x[1]-trace.domain.x[0]);pieBoxHeight=plotSize.h*(trace.domain.y[1]-trace.domain.y[0]);// leave some space for the title, if it will be displayed outside\nif(trace.title.text&&trace.title.position!=='middle center'){pieBoxHeight-=getTitleSpace(cd0,plotSize);}maxPull=getMaxPull(trace);cd0.r=Math.min(pieBoxWidth,pieBoxHeight)/(2+2*maxPull);cd0.cx=plotSize.l+plotSize.w*(trace.domain.x[1]+trace.domain.x[0])/2;cd0.cy=plotSize.t+plotSize.h*(1-trace.domain.y[0])-pieBoxHeight/2;if(trace.title.text&&trace.title.position.indexOf('bottom')!==-1){cd0.cy-=getTitleSpace(cd0,plotSize);}if(trace.scalegroup&&scaleGroups.indexOf(trace.scalegroup)===-1){scaleGroups.push(trace.scalegroup);}}// Then scale any pies that are grouped\nfor(j=0;j<scaleGroups.length;j++){minPxPerValUnit=Infinity;scaleGroup=scaleGroups[j];for(i=0;i<cdpie.length;i++){cd0=cdpie[i][0];if(cd0.trace.scalegroup===scaleGroup){minPxPerValUnit=Math.min(minPxPerValUnit,cd0.r*cd0.r/cd0.vTotal);}}for(i=0;i<cdpie.length;i++){cd0=cdpie[i][0];if(cd0.trace.scalegroup===scaleGroup){cd0.r=Math.sqrt(minPxPerValUnit*cd0.vTotal);}}}}function setCoords(cd){var cd0=cd[0];var trace=cd0.trace;var currentAngle=trace.rotation*Math.PI/180;var angleFactor=2*Math.PI/cd0.vTotal;var firstPt='px0';var lastPt='px1';var i,cdi,currentCoords;if(trace.direction==='counterclockwise'){for(i=0;i<cd.length;i++){if(!cd[i].hidden)break;// find the first non-hidden slice\n}if(i===cd.length)return;// all slices hidden\ncurrentAngle+=angleFactor*cd[i].v;angleFactor*=-1;firstPt='px1';lastPt='px0';}function getCoords(angle){return[cd0.r*Math.sin(angle),-cd0.r*Math.cos(angle)];}currentCoords=getCoords(currentAngle);for(i=0;i<cd.length;i++){cdi=cd[i];if(cdi.hidden)continue;cdi[firstPt]=currentCoords;currentAngle+=angleFactor*cdi.v/2;cdi.pxmid=getCoords(currentAngle);cdi.midangle=currentAngle;currentAngle+=angleFactor*cdi.v/2;currentCoords=getCoords(currentAngle);cdi[lastPt]=currentCoords;cdi.largeArc=cdi.v>cd0.vTotal/2?1:0;cdi.halfangle=Math.PI*Math.min(cdi.v/cd0.vTotal,0.5);cdi.ring=1-trace.hole;cdi.rInscribed=getInscribedRadiusFraction(cdi,cd0);}}module.exports={plot:plot,transformInsideText:transformInsideText};},{\"../../components/color\":43,\"../../components/drawing\":64,\"../../components/fx\":82,\"../../lib\":159,\"../../lib/svg_text_utils\":180,\"./event_data\":271,\"./helpers\":272,\"d3\":8}],277:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var styleOne=_dereq_('./style_one');module.exports=function style(gd){gd._fullLayout._pielayer.selectAll('.trace').each(function(cd){var cd0=cd[0];var trace=cd0.trace;var traceSelection=d3.select(this);traceSelection.style({opacity:trace.opacity});traceSelection.selectAll('path.surface').each(function(pt){d3.select(this).call(styleOne,pt,trace);});});};},{\"./style_one\":278,\"d3\":8}],278:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Color=_dereq_('../../components/color');var castOption=_dereq_('./helpers').castOption;module.exports=function styleOne(s,pt,trace){var line=trace.marker.line;var lineColor=castOption(line.color,pt.pts)||Color.defaultLine;var lineWidth=castOption(line.width,pt.pts)||0;s.style('stroke-width',lineWidth).call(Color.fill,pt.color).call(Color.stroke,lineColor);};},{\"../../components/color\":43,\"./helpers\":272}],279:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');// arrayOk attributes, merge them into calcdata array\nmodule.exports=function arraysToCalcdata(cd,trace){// so each point knows which index it originally came from\nfor(var i=0;i<cd.length;i++){cd[i].i=i;}Lib.mergeArray(trace.text,cd,'tx');Lib.mergeArray(trace.hovertext,cd,'htx');Lib.mergeArray(trace.customdata,cd,'data');Lib.mergeArray(trace.textposition,cd,'tp');if(trace.textfont){Lib.mergeArray(trace.textfont.size,cd,'ts');Lib.mergeArray(trace.textfont.color,cd,'tc');Lib.mergeArray(trace.textfont.family,cd,'tf');}var marker=trace.marker;if(marker){Lib.mergeArray(marker.size,cd,'ms');Lib.mergeArray(marker.opacity,cd,'mo');Lib.mergeArray(marker.symbol,cd,'mx');Lib.mergeArray(marker.color,cd,'mc');var markerLine=marker.line;if(marker.line){Lib.mergeArray(markerLine.color,cd,'mlc');Lib.mergeArray(markerLine.width,cd,'mlw');}var markerGradient=marker.gradient;if(markerGradient&&markerGradient.type!=='none'){Lib.mergeArray(markerGradient.type,cd,'mgt');Lib.mergeArray(markerGradient.color,cd,'mgc');}}};},{\"../../lib\":159}],280:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var hovertemplateAttrs=_dereq_('../../components/fx/hovertemplate_attributes');var colorAttributes=_dereq_('../../components/colorscale/attributes');var colorbarAttrs=_dereq_('../../components/colorbar/attributes');var fontAttrs=_dereq_('../../plots/font_attributes');var dash=_dereq_('../../components/drawing/attributes').dash;var Drawing=_dereq_('../../components/drawing');var constants=_dereq_('./constants');var extendFlat=_dereq_('../../lib/extend').extendFlat;module.exports={x:{valType:'data_array',editType:'calc+clearAxisTypes',anim:true},x0:{valType:'any',dflt:0,editType:'calc+clearAxisTypes',anim:true},dx:{valType:'number',dflt:1,editType:'calc',anim:true},y:{valType:'data_array',editType:'calc+clearAxisTypes',anim:true},y0:{valType:'any',dflt:0,editType:'calc+clearAxisTypes',anim:true},dy:{valType:'number',dflt:1,editType:'calc',anim:true},stackgroup:{valType:'string',dflt:'',editType:'calc'},orientation:{valType:'enumerated',values:['v','h'],editType:'calc'},groupnorm:{valType:'enumerated',values:['','fraction','percent'],dflt:'',editType:'calc'},stackgaps:{valType:'enumerated',values:['infer zero','interpolate'],dflt:'infer zero',editType:'calc'},text:{valType:'string',dflt:'',arrayOk:true,editType:'calc'},hovertext:{valType:'string',dflt:'',arrayOk:true,editType:'style'},mode:{valType:'flaglist',flags:['lines','markers','text'],extras:['none'],editType:'calc'},hoveron:{valType:'flaglist',flags:['points','fills'],editType:'style'},hovertemplate:hovertemplateAttrs({},{keys:constants.eventDataKeys}),line:{color:{valType:'color',editType:'style',anim:true},width:{valType:'number',min:0,dflt:2,editType:'style',anim:true},shape:{valType:'enumerated',values:['linear','spline','hv','vh','hvh','vhv'],dflt:'linear',editType:'plot'},smoothing:{valType:'number',min:0,max:1.3,dflt:1,editType:'plot'},dash:extendFlat({},dash,{editType:'style'}),simplify:{valType:'boolean',dflt:true,editType:'plot'},editType:'plot'},connectgaps:{valType:'boolean',dflt:false,editType:'calc'},cliponaxis:{valType:'boolean',dflt:true,editType:'plot'},fill:{valType:'enumerated',values:['none','tozeroy','tozerox','tonexty','tonextx','toself','tonext'],editType:'calc'},fillcolor:{valType:'color',editType:'style',anim:true},marker:extendFlat({symbol:{valType:'enumerated',values:Drawing.symbolList,dflt:'circle',arrayOk:true,editType:'style'},opacity:{valType:'number',min:0,max:1,arrayOk:true,editType:'style',anim:true},size:{valType:'number',min:0,dflt:6,arrayOk:true,editType:'calc',anim:true},maxdisplayed:{valType:'number',min:0,dflt:0,editType:'plot'},sizeref:{valType:'number',dflt:1,editType:'calc'},sizemin:{valType:'number',min:0,dflt:0,editType:'calc'},sizemode:{valType:'enumerated',values:['diameter','area'],dflt:'diameter',editType:'calc'},colorbar:colorbarAttrs,line:extendFlat({width:{valType:'number',min:0,arrayOk:true,editType:'style',anim:true},editType:'calc'},colorAttributes('marker.line',{anim:true})),gradient:{type:{valType:'enumerated',values:['radial','horizontal','vertical','none'],arrayOk:true,dflt:'none',editType:'calc'},color:{valType:'color',arrayOk:true,editType:'calc'},editType:'calc'},editType:'calc'},colorAttributes('marker',{anim:true})),selected:{marker:{opacity:{valType:'number',min:0,max:1,editType:'style'},color:{valType:'color',editType:'style'},size:{valType:'number',min:0,editType:'style'},editType:'style'},textfont:{color:{valType:'color',editType:'style'},editType:'style'},editType:'style'},unselected:{marker:{opacity:{valType:'number',min:0,max:1,editType:'style'},color:{valType:'color',editType:'style'},size:{valType:'number',min:0,editType:'style'},editType:'style'},textfont:{color:{valType:'color',editType:'style'},editType:'style'},editType:'style'},textposition:{valType:'enumerated',values:['top left','top center','top right','middle left','middle center','middle right','bottom left','bottom center','bottom right'],dflt:'middle center',arrayOk:true,editType:'calc'},textfont:fontAttrs({editType:'calc',colorEditType:'style',arrayOk:true}),r:{valType:'data_array',editType:'calc'},t:{valType:'data_array',editType:'calc'}};},{\"../../components/colorbar/attributes\":44,\"../../components/colorscale/attributes\":50,\"../../components/drawing\":64,\"../../components/drawing/attributes\":63,\"../../components/fx/hovertemplate_attributes\":81,\"../../lib/extend\":153,\"../../plots/font_attributes\":229,\"./constants\":284}],281:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var isNumeric=_dereq_('fast-isnumeric');var Lib=_dereq_('../../lib');var Axes=_dereq_('../../plots/cartesian/axes');var BADNUM=_dereq_('../../constants/numerical').BADNUM;var subTypes=_dereq_('./subtypes');var calcColorscale=_dereq_('./colorscale_calc');var arraysToCalcdata=_dereq_('./arrays_to_calcdata');var calcSelection=_dereq_('./calc_selection');function calc(gd,trace){var fullLayout=gd._fullLayout;var xa=Axes.getFromId(gd,trace.xaxis||'x');var ya=Axes.getFromId(gd,trace.yaxis||'y');var x=xa.makeCalcdata(trace,'x');var y=ya.makeCalcdata(trace,'y');var serieslen=trace._length;var cd=new Array(serieslen);var ids=trace.ids;var stackGroupOpts=getStackOpts(trace,fullLayout,xa,ya);var interpolateGaps=false;var isV,i,j,k,interpolate,vali;setFirstScatter(fullLayout,trace);var xAttr='x';var yAttr='y';var posAttr;if(stackGroupOpts){Lib.pushUnique(stackGroupOpts.traceIndices,trace._expandedIndex);isV=stackGroupOpts.orientation==='v';// size, like we use for bar\nif(isV){yAttr='s';posAttr='x';}else{xAttr='s';posAttr='y';}interpolate=stackGroupOpts.stackgaps==='interpolate';}else{var ppad=calcMarkerSize(trace,serieslen);calcAxisExpansion(gd,trace,xa,ya,x,y,ppad);}for(i=0;i<serieslen;i++){var cdi=cd[i]={};var xValid=isNumeric(x[i]);var yValid=isNumeric(y[i]);if(xValid&&yValid){cdi[xAttr]=x[i];cdi[yAttr]=y[i];}else if(stackGroupOpts&&(isV?xValid:yValid)){// if we're stacking we need to hold on to all valid positions\n// even with invalid sizes\ncdi[posAttr]=isV?x[i]:y[i];cdi.gap=true;if(interpolate){cdi.s=BADNUM;interpolateGaps=true;}else{cdi.s=0;}}else{cdi[xAttr]=cdi[yAttr]=BADNUM;}if(ids){cdi.id=String(ids[i]);}}arraysToCalcdata(cd,trace);calcColorscale(gd,trace);calcSelection(cd,trace);if(stackGroupOpts){// remove bad positions and sort\n// note that original indices get added to cd in arraysToCalcdata\ni=0;while(i<cd.length){if(cd[i][posAttr]===BADNUM){cd.splice(i,1);}else i++;}Lib.sort(cd,function(a,b){return a[posAttr]-b[posAttr]||a.i-b.i;});if(interpolateGaps){// first fill the beginning with constant from the first point\ni=0;while(i<cd.length-1&&cd[i].gap){i++;}vali=cd[i].s;if(!vali)vali=cd[i].s=0;// in case of no data AT ALL in this trace - use 0\nfor(j=0;j<i;j++){cd[j].s=vali;}// then fill the end with constant from the last point\nk=cd.length-1;while(k>i&&cd[k].gap){k--;}vali=cd[k].s;for(j=cd.length-1;j>k;j--){cd[j].s=vali;}// now interpolate internal gaps linearly\nwhile(i<k){i++;if(cd[i].gap){j=i+1;while(cd[j].gap){j++;}var pos0=cd[i-1][posAttr];var size0=cd[i-1].s;var m=(cd[j].s-size0)/(cd[j][posAttr]-pos0);while(i<j){cd[i].s=size0+(cd[i][posAttr]-pos0)*m;i++;}}}}}return cd;}function calcAxisExpansion(gd,trace,xa,ya,x,y,ppad){var serieslen=trace._length;var fullLayout=gd._fullLayout;var xId=xa._id;var yId=ya._id;var firstScatter=fullLayout._firstScatter[firstScatterGroup(trace)]===trace.uid;var stackOrientation=(getStackOpts(trace,fullLayout,xa,ya)||{}).orientation;var fill=trace.fill;// cancel minimum tick spacings (only applies to bars and boxes)\nxa._minDtick=0;ya._minDtick=0;// check whether bounds should be tight, padded, extended to zero...\n// most cases both should be padded on both ends, so start with that.\nvar xOptions={padded:true};var yOptions={padded:true};if(ppad){xOptions.ppad=yOptions.ppad=ppad;}// TODO: text size\nvar openEnded=serieslen<2||x[0]!==x[serieslen-1]||y[0]!==y[serieslen-1];if(openEnded&&(fill==='tozerox'||fill==='tonextx'&&(firstScatter||stackOrientation==='h'))){// include zero (tight) and extremes (padded) if fill to zero\n// (unless the shape is closed, then it's just filling the shape regardless)\nxOptions.tozero=true;}else if(!(trace.error_y||{}).visible&&(// if no error bars, markers or text, or fill to y=0 remove x padding\nfill==='tonexty'||fill==='tozeroy'||!subTypes.hasMarkers(trace)&&!subTypes.hasText(trace))){xOptions.padded=false;xOptions.ppad=0;}if(openEnded&&(fill==='tozeroy'||fill==='tonexty'&&(firstScatter||stackOrientation==='v'))){// now check for y - rather different logic, though still mostly padded both ends\n// include zero (tight) and extremes (padded) if fill to zero\n// (unless the shape is closed, then it's just filling the shape regardless)\nyOptions.tozero=true;}else if(fill==='tonextx'||fill==='tozerox'){// tight y: any x fill\nyOptions.padded=false;}// N.B. asymmetric splom traces call this with blank {} xa or ya\nif(xId)trace._extremes[xId]=Axes.findExtremes(xa,x,xOptions);if(yId)trace._extremes[yId]=Axes.findExtremes(ya,y,yOptions);}function calcMarkerSize(trace,serieslen){if(!subTypes.hasMarkers(trace))return;// Treat size like x or y arrays --- Run d2c\n// this needs to go before ppad computation\nvar marker=trace.marker;var sizeref=1.6*(trace.marker.sizeref||1);var markerTrans;if(trace.marker.sizemode==='area'){markerTrans=function markerTrans(v){return Math.max(Math.sqrt((v||0)/sizeref),3);};}else{markerTrans=function markerTrans(v){return Math.max((v||0)/sizeref,3);};}if(Lib.isArrayOrTypedArray(marker.size)){// I tried auto-type but category and dates dont make much sense.\nvar ax={type:'linear'};Axes.setConvert(ax);var s=ax.makeCalcdata(trace.marker,'size');var sizeOut=new Array(serieslen);for(var i=0;i<serieslen;i++){sizeOut[i]=markerTrans(s[i]);}return sizeOut;}else{return markerTrans(marker.size);}}/**\n * mark the first scatter trace for each subplot\n * note that scatter and scattergl each get their own first trace\n * note also that I'm doing this during calc rather than supplyDefaults\n * so I don't need to worry about transforms, but if we ever do\n * per-trace calc this will get confused.\n */function setFirstScatter(fullLayout,trace){var group=firstScatterGroup(trace);var firstScatter=fullLayout._firstScatter;if(!firstScatter[group])firstScatter[group]=trace.uid;}function firstScatterGroup(trace){var stackGroup=trace.stackgroup;return trace.xaxis+trace.yaxis+trace.type+(stackGroup?'-'+stackGroup:'');}function getStackOpts(trace,fullLayout,xa,ya){var stackGroup=trace.stackgroup;if(!stackGroup)return;var stackOpts=fullLayout._scatterStackOpts[xa._id+ya._id][stackGroup];var stackAx=stackOpts.orientation==='v'?ya:xa;// Allow stacking only on numeric axes\n// calc is a little late to be figuring this out, but during supplyDefaults\n// we don't know the axis type yet\nif(stackAx.type==='linear'||stackAx.type==='log')return stackOpts;}module.exports={calc:calc,calcMarkerSize:calcMarkerSize,calcAxisExpansion:calcAxisExpansion,setFirstScatter:setFirstScatter,getStackOpts:getStackOpts};},{\"../../constants/numerical\":140,\"../../lib\":159,\"../../plots/cartesian/axes\":203,\"./arrays_to_calcdata\":279,\"./calc_selection\":282,\"./colorscale_calc\":283,\"./subtypes\":304,\"fast-isnumeric\":10}],282:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');module.exports=function calcSelection(cd,trace){if(Lib.isArrayOrTypedArray(trace.selectedpoints)){Lib.tagSelected(cd,trace);}};},{\"../../lib\":159}],283:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var hasColorscale=_dereq_('../../components/colorscale/helpers').hasColorscale;var calcColorscale=_dereq_('../../components/colorscale/calc');var subTypes=_dereq_('./subtypes');module.exports=function calcMarkerColorscale(gd,trace){if(subTypes.hasLines(trace)&&hasColorscale(trace,'line')){calcColorscale(gd,trace,{vals:trace.line.color,containerStr:'line',cLetter:'c'});}if(subTypes.hasMarkers(trace)){if(hasColorscale(trace,'marker')){calcColorscale(gd,trace,{vals:trace.marker.color,containerStr:'marker',cLetter:'c'});}if(hasColorscale(trace,'marker.line')){calcColorscale(gd,trace,{vals:trace.marker.line.color,containerStr:'marker.line',cLetter:'c'});}}};},{\"../../components/colorscale/calc\":51,\"../../components/colorscale/helpers\":54,\"./subtypes\":304}],284:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports={PTS_LINESONLY:20,// fixed parameters of clustering and clipping algorithms\n// fraction of clustering tolerance \"so close we don't even consider it a new point\"\nminTolerance:0.2,// how fast does clustering tolerance increase as you get away from the visible region\ntoleranceGrowth:10,// number of viewport sizes away from the visible region\n// at which we clip all lines to the perimeter\nmaxScreensAway:20,eventDataKeys:[]};},{}],285:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var calc=_dereq_('./calc');/*\n * Scatter stacking & normalization calculations\n * runs per subplot, and can handle multiple stacking groups\n */module.exports=function crossTraceCalc(gd,plotinfo){var xa=plotinfo.xaxis;var ya=plotinfo.yaxis;var subplot=xa._id+ya._id;var subplotStackOpts=gd._fullLayout._scatterStackOpts[subplot];if(!subplotStackOpts)return;var calcTraces=gd.calcdata;var i,j,k,i2,cd,cd0,posj,sumj,norm;var groupOpts,interpolate,groupnorm,posAttr,valAttr;var hasAnyBlanks;for(var stackGroup in subplotStackOpts){groupOpts=subplotStackOpts[stackGroup];var indices=groupOpts.traceIndices;// can get here with no indices if the stack axis is non-numeric\nif(!indices.length)continue;interpolate=groupOpts.stackgaps==='interpolate';groupnorm=groupOpts.groupnorm;if(groupOpts.orientation==='v'){posAttr='x';valAttr='y';}else{posAttr='y';valAttr='x';}hasAnyBlanks=new Array(indices.length);for(i=0;i<hasAnyBlanks.length;i++){hasAnyBlanks[i]=false;}// Collect the complete set of all positions across ALL traces.\n// Start with the first trace, then interleave items from later traces\n// as needed.\n// Fill in mising items as we go.\ncd0=calcTraces[indices[0]];var allPositions=new Array(cd0.length);for(i=0;i<cd0.length;i++){allPositions[i]=cd0[i][posAttr];}for(i=1;i<indices.length;i++){cd=calcTraces[indices[i]];for(j=k=0;j<cd.length;j++){posj=cd[j][posAttr];for(;posj>allPositions[k]&&k<allPositions.length;k++){// the current trace is missing a position from some previous trace(s)\ninsertBlank(cd,j,allPositions[k],i,hasAnyBlanks,interpolate,posAttr);j++;}if(posj!==allPositions[k]){// previous trace(s) are missing a position from the current trace\nfor(i2=0;i2<i;i2++){insertBlank(calcTraces[indices[i2]],k,posj,i2,hasAnyBlanks,interpolate,posAttr);}allPositions.splice(k,0,posj);}k++;}for(;k<allPositions.length;k++){insertBlank(cd,j,allPositions[k],i,hasAnyBlanks,interpolate,posAttr);j++;}}var serieslen=allPositions.length;// stack (and normalize)!\nfor(j=0;j<cd0.length;j++){sumj=cd0[j][valAttr]=cd0[j].s;for(i=1;i<indices.length;i++){cd=calcTraces[indices[i]];cd[0].trace._rawLength=cd[0].trace._length;cd[0].trace._length=serieslen;sumj+=cd[j].s;cd[j][valAttr]=sumj;}if(groupnorm){norm=(groupnorm==='fraction'?sumj:sumj/100)||1;for(i=0;i<indices.length;i++){var cdj=calcTraces[indices[i]][j];cdj[valAttr]/=norm;cdj.sNorm=cdj.s/norm;}}}// autorange\nfor(i=0;i<indices.length;i++){cd=calcTraces[indices[i]];var trace=cd[0].trace;var ppad=calc.calcMarkerSize(trace,trace._rawLength);var arrayPad=Array.isArray(ppad);if(ppad&&hasAnyBlanks[i]||arrayPad){var ppadRaw=ppad;ppad=new Array(serieslen);for(j=0;j<serieslen;j++){ppad[j]=cd[j].gap?0:arrayPad?ppadRaw[cd[j].i]:ppadRaw;}}var x=new Array(serieslen);var y=new Array(serieslen);for(j=0;j<serieslen;j++){x[j]=cd[j].x;y[j]=cd[j].y;}calc.calcAxisExpansion(gd,trace,xa,ya,x,y,ppad);// while we're here (in a loop over all traces in the stack)\n// record the orientation, so hover can find it easily\ncd[0].t.orientation=groupOpts.orientation;}}};function insertBlank(calcTrace,index,position,traceIndex,hasAnyBlanks,interpolate,posAttr){hasAnyBlanks[traceIndex]=true;var newEntry={i:null,gap:true,s:0};newEntry[posAttr]=position;calcTrace.splice(index,0,newEntry);// Even if we're not interpolating, if one trace has multiple\n// values at the same position and this trace only has one value there,\n// we just duplicate that one value rather than insert a zero.\n// We also make it look like a real point - because it's ambiguous which\n// one really is the real one!\nif(index&&position===calcTrace[index-1][posAttr]){var prevEntry=calcTrace[index-1];newEntry.s=prevEntry.s;// TODO is it going to cause any problems to have multiple\n// calcdata points with the same index?\nnewEntry.i=prevEntry.i;newEntry.gap=prevEntry.gap;}else if(interpolate){newEntry.s=getInterp(calcTrace,index,position,posAttr);}if(!index){// t and trace need to stay on the first cd entry\ncalcTrace[0].t=calcTrace[1].t;calcTrace[0].trace=calcTrace[1].trace;delete calcTrace[1].t;delete calcTrace[1].trace;}}function getInterp(calcTrace,index,position,posAttr){var pt0=calcTrace[index-1];var pt1=calcTrace[index+1];if(!pt1)return pt0.s;if(!pt0)return pt1.s;return pt0.s+(pt1.s-pt0.s)*(position-pt0[posAttr])/(pt1[posAttr]-pt0[posAttr]);}},{\"./calc\":281}],286:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';// remove opacity for any trace that has a fill or is filled to\nmodule.exports=function crossTraceDefaults(fullData){for(var i=0;i<fullData.length;i++){var tracei=fullData[i];if(tracei.type!=='scatter')continue;var filli=tracei.fill;if(filli==='none'||filli==='toself')continue;tracei.opacity=undefined;if(filli==='tonexty'||filli==='tonextx'){for(var j=i-1;j>=0;j--){var tracej=fullData[j];if(tracej.type==='scatter'&&tracej.xaxis===tracei.xaxis&&tracej.yaxis===tracei.yaxis){tracej.opacity=undefined;break;}}}}};},{}],287:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var Registry=_dereq_('../../registry');var attributes=_dereq_('./attributes');var constants=_dereq_('./constants');var subTypes=_dereq_('./subtypes');var handleXYDefaults=_dereq_('./xy_defaults');var handleStackDefaults=_dereq_('./stack_defaults');var handleMarkerDefaults=_dereq_('./marker_defaults');var handleLineDefaults=_dereq_('./line_defaults');var handleLineShapeDefaults=_dereq_('./line_shape_defaults');var handleTextDefaults=_dereq_('./text_defaults');var handleFillColorDefaults=_dereq_('./fillcolor_defaults');module.exports=function supplyDefaults(traceIn,traceOut,defaultColor,layout){function coerce(attr,dflt){return Lib.coerce(traceIn,traceOut,attributes,attr,dflt);}var len=handleXYDefaults(traceIn,traceOut,layout,coerce);if(!len)traceOut.visible=false;if(!traceOut.visible)return;var stackGroupOpts=handleStackDefaults(traceIn,traceOut,layout,coerce);var defaultMode=!stackGroupOpts&&len<constants.PTS_LINESONLY?'lines+markers':'lines';coerce('text');coerce('hovertext');coerce('mode',defaultMode);if(subTypes.hasLines(traceOut)){handleLineDefaults(traceIn,traceOut,defaultColor,layout,coerce);handleLineShapeDefaults(traceIn,traceOut,coerce);coerce('connectgaps');coerce('line.simplify');}if(subTypes.hasMarkers(traceOut)){handleMarkerDefaults(traceIn,traceOut,defaultColor,layout,coerce,{gradient:true});}if(subTypes.hasText(traceOut)){handleTextDefaults(traceIn,traceOut,layout,coerce);}var dfltHoverOn=[];if(subTypes.hasMarkers(traceOut)||subTypes.hasText(traceOut)){coerce('cliponaxis');coerce('marker.maxdisplayed');dfltHoverOn.push('points');}// It's possible for this default to be changed by a later trace.\n// We handle that case in some hacky code inside handleStackDefaults.\ncoerce('fill',stackGroupOpts?stackGroupOpts.fillDflt:'none');if(traceOut.fill!=='none'){handleFillColorDefaults(traceIn,traceOut,defaultColor,coerce);if(!subTypes.hasLines(traceOut))handleLineShapeDefaults(traceIn,traceOut,coerce);}var lineColor=(traceOut.line||{}).color;var markerColor=(traceOut.marker||{}).color;if(traceOut.fill==='tonext'||traceOut.fill==='toself'){dfltHoverOn.push('fills');}coerce('hoveron',dfltHoverOn.join('+')||'points');if(traceOut.hoveron!=='fills')coerce('hovertemplate');var errorBarsSupplyDefaults=Registry.getComponentMethod('errorbars','supplyDefaults');errorBarsSupplyDefaults(traceIn,traceOut,lineColor||markerColor||defaultColor,{axis:'y'});errorBarsSupplyDefaults(traceIn,traceOut,lineColor||markerColor||defaultColor,{axis:'x',inherit:'y'});Lib.coerceSelectionMarkerOpacity(traceOut,coerce);};},{\"../../lib\":159,\"../../registry\":242,\"./attributes\":280,\"./constants\":284,\"./fillcolor_defaults\":289,\"./line_defaults\":293,\"./line_shape_defaults\":295,\"./marker_defaults\":299,\"./stack_defaults\":302,\"./subtypes\":304,\"./text_defaults\":305,\"./xy_defaults\":306}],288:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');/** Fill hover 'pointData' container with 'correct' hover text value\n *\n * - If trace hoverinfo contains a 'text' flag and hovertext is not set,\n *   the text elements will be seen in the hover labels.\n *\n * - If trace hoverinfo contains a 'text' flag and hovertext is set,\n *   hovertext takes precedence over text\n *   i.e. the hoverinfo elements will be seen in the hover labels\n *\n *  @param {object} calcPt\n *  @param {object} trace\n *  @param {object || array} contOut (mutated here)\n */module.exports=function fillHoverText(calcPt,trace,contOut){var fill=Array.isArray(contOut)?function(v){contOut.push(v);}:function(v){contOut.text=v;};var htx=Lib.extractOption(calcPt,trace,'htx','hovertext');if(isValid(htx))return fill(htx);var tx=Lib.extractOption(calcPt,trace,'tx','text');if(isValid(tx))return fill(tx);};// accept all truthy values and 0 (which gets cast to '0' in the hover labels)\nfunction isValid(v){return v||v===0;}},{\"../../lib\":159}],289:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Color=_dereq_('../../components/color');var isArrayOrTypedArray=_dereq_('../../lib').isArrayOrTypedArray;module.exports=function fillColorDefaults(traceIn,traceOut,defaultColor,coerce){var inheritColorFromMarker=false;if(traceOut.marker){// don't try to inherit a color array\nvar markerColor=traceOut.marker.color;var markerLineColor=(traceOut.marker.line||{}).color;if(markerColor&&!isArrayOrTypedArray(markerColor)){inheritColorFromMarker=markerColor;}else if(markerLineColor&&!isArrayOrTypedArray(markerLineColor)){inheritColorFromMarker=markerLineColor;}}coerce('fillcolor',Color.addOpacity((traceOut.line||{}).color||inheritColorFromMarker||defaultColor,0.5));};},{\"../../components/color\":43,\"../../lib\":159}],290:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Color=_dereq_('../../components/color');var subtypes=_dereq_('./subtypes');module.exports=function getTraceColor(trace,di){var lc,tc;// TODO: text modes\nif(trace.mode==='lines'){lc=trace.line.color;return lc&&Color.opacity(lc)?lc:trace.fillcolor;}else if(trace.mode==='none'){return trace.fill?trace.fillcolor:'';}else{var mc=di.mcc||(trace.marker||{}).color;var mlc=di.mlcc||((trace.marker||{}).line||{}).color;tc=mc&&Color.opacity(mc)?mc:mlc&&Color.opacity(mlc)&&(di.mlw||((trace.marker||{}).line||{}).width)?mlc:'';if(tc){// make sure the points aren't TOO transparent\nif(Color.opacity(tc)<0.3){return Color.addOpacity(tc,0.3);}else return tc;}else{lc=(trace.line||{}).color;return lc&&Color.opacity(lc)&&subtypes.hasLines(trace)&&trace.line.width?lc:trace.fillcolor;}}};},{\"../../components/color\":43,\"./subtypes\":304}],291:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var Fx=_dereq_('../../components/fx');var Registry=_dereq_('../../registry');var getTraceColor=_dereq_('./get_trace_color');var Color=_dereq_('../../components/color');var fillHoverText=_dereq_('./fill_hover_text');module.exports=function hoverPoints(pointData,xval,yval,hovermode){var cd=pointData.cd;var trace=cd[0].trace;var xa=pointData.xa;var ya=pointData.ya;var xpx=xa.c2p(xval);var ypx=ya.c2p(yval);var pt=[xpx,ypx];var hoveron=trace.hoveron||'';var minRad=trace.mode.indexOf('markers')!==-1?3:0.5;// look for points to hover on first, then take fills only if we\n// didn't find a point\nif(hoveron.indexOf('points')!==-1){var dx=function dx(di){// dx and dy are used in compare modes - here we want to always\n// prioritize the closest data point, at least as long as markers are\n// the same size or nonexistent, but still try to prioritize small markers too.\nvar rad=Math.max(3,di.mrc||0);var kink=1-1/rad;var dxRaw=Math.abs(xa.c2p(di.x)-xpx);var d=dxRaw<rad?kink*dxRaw/rad:dxRaw-rad+kink;return d;};var dy=function dy(di){var rad=Math.max(3,di.mrc||0);var kink=1-1/rad;var dyRaw=Math.abs(ya.c2p(di.y)-ypx);return dyRaw<rad?kink*dyRaw/rad:dyRaw-rad+kink;};var dxy=function dxy(di){// scatter points: d.mrc is the calculated marker radius\n// adjust the distance so if you're inside the marker it\n// always will show up regardless of point size, but\n// prioritize smaller points\nvar rad=Math.max(minRad,di.mrc||0);var dx=xa.c2p(di.x)-xpx;var dy=ya.c2p(di.y)-ypx;return Math.max(Math.sqrt(dx*dx+dy*dy)-rad,1-minRad/rad);};var distfn=Fx.getDistanceFunction(hovermode,dx,dy,dxy);Fx.getClosest(cd,distfn,pointData);// skip the rest (for this trace) if we didn't find a close point\nif(pointData.index!==false){// the closest data point\nvar di=cd[pointData.index];var xc=xa.c2p(di.x,true);var yc=ya.c2p(di.y,true);var rad=di.mrc||1;// now we're done using the whole `calcdata` array, replace the\n// index with the original index (in case of inserted point from\n// stacked area)\npointData.index=di.i;var orientation=cd[0].t.orientation;// TODO: for scatter and bar, option to show (sub)totals and\n// raw data? Currently stacked and/or normalized bars just show\n// the normalized individual sizes, so that's what I'm doing here\n// for now.\nvar sizeVal=orientation&&(di.sNorm||di.s);var xLabelVal=orientation==='h'?sizeVal:di.x;var yLabelVal=orientation==='v'?sizeVal:di.y;Lib.extendFlat(pointData,{color:getTraceColor(trace,di),x0:xc-rad,x1:xc+rad,xLabelVal:xLabelVal,y0:yc-rad,y1:yc+rad,yLabelVal:yLabelVal,spikeDistance:dxy(di),hovertemplate:trace.hovertemplate});fillHoverText(di,trace,pointData);Registry.getComponentMethod('errorbars','hoverInfo')(di,trace,pointData);return[pointData];}}// even if hoveron is 'fills', only use it if we have polygons too\nif(hoveron.indexOf('fills')!==-1&&trace._polygons){var polygons=trace._polygons;var polygonsIn=[];var inside=false;var xmin=Infinity;var xmax=-Infinity;var ymin=Infinity;var ymax=-Infinity;var i,j,polygon,pts,xCross,x0,x1,y0,y1;for(i=0;i<polygons.length;i++){polygon=polygons[i];// TODO: this is not going to work right for curved edges, it will\n// act as though they're straight. That's probably going to need\n// the elements themselves to capture the events. Worth it?\nif(polygon.contains(pt)){inside=!inside;// TODO: need better than just the overall bounding box\npolygonsIn.push(polygon);ymin=Math.min(ymin,polygon.ymin);ymax=Math.max(ymax,polygon.ymax);}}if(inside){// constrain ymin/max to the visible plot, so the label goes\n// at the middle of the piece you can see\nymin=Math.max(ymin,0);ymax=Math.min(ymax,ya._length);// find the overall left-most and right-most points of the\n// polygon(s) we're inside at their combined vertical midpoint.\n// This is where we will draw the hover label.\n// Note that this might not be the vertical midpoint of the\n// whole trace, if it's disjoint.\nvar yAvg=(ymin+ymax)/2;for(i=0;i<polygonsIn.length;i++){pts=polygonsIn[i].pts;for(j=1;j<pts.length;j++){y0=pts[j-1][1];y1=pts[j][1];if(y0>yAvg!==y1>=yAvg){x0=pts[j-1][0];x1=pts[j][0];if(y1-y0){xCross=x0+(x1-x0)*(yAvg-y0)/(y1-y0);xmin=Math.min(xmin,xCross);xmax=Math.max(xmax,xCross);}}}}// constrain xmin/max to the visible plot now too\nxmin=Math.max(xmin,0);xmax=Math.min(xmax,xa._length);// get only fill or line color for the hover color\nvar color=Color.defaultLine;if(Color.opacity(trace.fillcolor))color=trace.fillcolor;else if(Color.opacity((trace.line||{}).color)){color=trace.line.color;}Lib.extendFlat(pointData,{// never let a 2D override 1D type as closest point\n// also: no spikeDistance, it's not allowed for fills\ndistance:pointData.maxHoverDistance,x0:xmin,x1:xmax,y0:yAvg,y1:yAvg,color:color,hovertemplate:false});delete pointData.index;if(trace.text&&!Array.isArray(trace.text)){pointData.text=String(trace.text);}else pointData.text=trace.name;return[pointData];}}};},{\"../../components/color\":43,\"../../components/fx\":82,\"../../lib\":159,\"../../registry\":242,\"./fill_hover_text\":288,\"./get_trace_color\":290}],292:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var subtypes=_dereq_('./subtypes');module.exports={hasLines:subtypes.hasLines,hasMarkers:subtypes.hasMarkers,hasText:subtypes.hasText,isBubble:subtypes.isBubble,attributes:_dereq_('./attributes'),supplyDefaults:_dereq_('./defaults'),crossTraceDefaults:_dereq_('./cross_trace_defaults'),calc:_dereq_('./calc').calc,crossTraceCalc:_dereq_('./cross_trace_calc'),arraysToCalcdata:_dereq_('./arrays_to_calcdata'),plot:_dereq_('./plot'),colorbar:_dereq_('./marker_colorbar'),style:_dereq_('./style').style,styleOnSelect:_dereq_('./style').styleOnSelect,hoverPoints:_dereq_('./hover'),selectPoints:_dereq_('./select'),animatable:true,moduleType:'trace',name:'scatter',basePlotModule:_dereq_('../../plots/cartesian'),categories:['cartesian','svg','symbols','errorBarsOK','showLegend','scatter-like','zoomScale'],meta:{}};},{\"../../plots/cartesian\":214,\"./arrays_to_calcdata\":279,\"./attributes\":280,\"./calc\":281,\"./cross_trace_calc\":285,\"./cross_trace_defaults\":286,\"./defaults\":287,\"./hover\":291,\"./marker_colorbar\":298,\"./plot\":300,\"./select\":301,\"./style\":303,\"./subtypes\":304}],293:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var isArrayOrTypedArray=_dereq_('../../lib').isArrayOrTypedArray;var hasColorscale=_dereq_('../../components/colorscale/helpers').hasColorscale;var colorscaleDefaults=_dereq_('../../components/colorscale/defaults');module.exports=function lineDefaults(traceIn,traceOut,defaultColor,layout,coerce,opts){var markerColor=(traceIn.marker||{}).color;coerce('line.color',defaultColor);if(hasColorscale(traceIn,'line')){colorscaleDefaults(traceIn,traceOut,layout,coerce,{prefix:'line.',cLetter:'c'});}else{var lineColorDflt=(isArrayOrTypedArray(markerColor)?false:markerColor)||defaultColor;coerce('line.color',lineColorDflt);}coerce('line.width');if(!(opts||{}).noDash)coerce('line.dash');};},{\"../../components/colorscale/defaults\":53,\"../../components/colorscale/helpers\":54,\"../../lib\":159}],294:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var numConstants=_dereq_('../../constants/numerical');var BADNUM=numConstants.BADNUM;var LOG_CLIP=numConstants.LOG_CLIP;var LOG_CLIP_PLUS=LOG_CLIP+0.5;var LOG_CLIP_MINUS=LOG_CLIP-0.5;var Lib=_dereq_('../../lib');var segmentsIntersect=Lib.segmentsIntersect;var constrain=Lib.constrain;var constants=_dereq_('./constants');module.exports=function linePoints(d,opts){var xa=opts.xaxis;var ya=opts.yaxis;var xLog=xa.type==='log';var yLog=ya.type==='log';var xLen=xa._length;var yLen=ya._length;var connectGaps=opts.connectGaps;var baseTolerance=opts.baseTolerance;var shape=opts.shape;var linear=shape==='linear';var fill=opts.fill&&opts.fill!=='none';var segments=[];var minTolerance=constants.minTolerance;var len=d.length;var pts=new Array(len);var pti=0;var i;// pt variables are pixel coordinates [x,y] of one point\n// these four are the outputs of clustering on a line\nvar clusterStartPt,clusterEndPt,clusterHighPt,clusterLowPt;// \"this\" is the next point we're considering adding to the cluster\nvar thisPt;// did we encounter the high point first, then a low point, or vice versa?\nvar clusterHighFirst;// the first two points in the cluster determine its unit vector\n// so the second is always in the \"High\" direction\nvar clusterUnitVector;// the pixel delta from clusterStartPt\nvar thisVector;// val variables are (signed) pixel distances along the cluster vector\nvar clusterRefDist,clusterHighVal,clusterLowVal,thisVal;// deviation variables are (signed) pixel distances normal to the cluster vector\nvar clusterMinDeviation,clusterMaxDeviation,thisDeviation;// turn one calcdata point into pixel coordinates\nfunction getPt(index){var di=d[index];if(!di)return false;var x=xa.c2p(di.x);var y=ya.c2p(di.y);// if non-positive log values, set them VERY far off-screen\n// so the line looks essentially straight from the previous point.\nif(x===BADNUM){if(xLog)x=xa.c2p(di.x,true);if(x===BADNUM)return false;// If BOTH were bad log values, make the line follow a constant\n// exponent rather than a constant slope\nif(yLog&&y===BADNUM){x*=Math.abs(xa._m*yLen*(xa._m>0?LOG_CLIP_PLUS:LOG_CLIP_MINUS)/(ya._m*xLen*(ya._m>0?LOG_CLIP_PLUS:LOG_CLIP_MINUS)));}x*=1000;}if(y===BADNUM){if(yLog)y=ya.c2p(di.y,true);if(y===BADNUM)return false;y*=1000;}return[x,y];}function crossesViewport(xFrac0,yFrac0,xFrac1,yFrac1){var dx=xFrac1-xFrac0;var dy=yFrac1-yFrac0;var dx0=0.5-xFrac0;var dy0=0.5-yFrac0;var norm2=dx*dx+dy*dy;var dot=dx*dx0+dy*dy0;if(dot>0&&dot<norm2){var cross=dx0*dy-dy0*dx;if(cross*cross<norm2)return true;}}var latestXFrac,latestYFrac;// if we're off-screen, increase tolerance over baseTolerance\nfunction getTolerance(pt,nextPt){var xFrac=pt[0]/xLen;var yFrac=pt[1]/yLen;var offScreenFraction=Math.max(0,-xFrac,xFrac-1,-yFrac,yFrac-1);if(offScreenFraction&&latestXFrac!==undefined&&crossesViewport(xFrac,yFrac,latestXFrac,latestYFrac)){offScreenFraction=0;}if(offScreenFraction&&nextPt&&crossesViewport(xFrac,yFrac,nextPt[0]/xLen,nextPt[1]/yLen)){offScreenFraction=0;}return(1+constants.toleranceGrowth*offScreenFraction)*baseTolerance;}function ptDist(pt1,pt2){var dx=pt1[0]-pt2[0];var dy=pt1[1]-pt2[1];return Math.sqrt(dx*dx+dy*dy);}// last bit of filtering: clip paths that are VERY far off-screen\n// so we don't get near the browser's hard limit (+/- 2^29 px in Chrome and FF)\nvar maxScreensAway=constants.maxScreensAway;// find the intersections between the segment from pt1 to pt2\n// and the large rectangle maxScreensAway around the viewport\n// if one of pt1 and pt2 is inside and the other outside, there\n// will be only one intersection.\n// if both are outside there will be 0 or 2 intersections\n// (or 1 if it's right at a corner - we'll treat that like 0)\n// returns an array of intersection pts\nvar xEdge0=-xLen*maxScreensAway;var xEdge1=xLen*(1+maxScreensAway);var yEdge0=-yLen*maxScreensAway;var yEdge1=yLen*(1+maxScreensAway);var edges=[[xEdge0,yEdge0,xEdge1,yEdge0],[xEdge1,yEdge0,xEdge1,yEdge1],[xEdge1,yEdge1,xEdge0,yEdge1],[xEdge0,yEdge1,xEdge0,yEdge0]];var xEdge,yEdge,lastXEdge,lastYEdge,lastFarPt,edgePt;// for linear line shape, edge intersections should be linearly interpolated\n// spline uses this too, which isn't precisely correct but is actually pretty\n// good, because Catmull-Rom weights far-away points less in creating the curvature\nfunction getLinearEdgeIntersections(pt1,pt2){var out=[];var ptCount=0;for(var i=0;i<4;i++){var edge=edges[i];var ptInt=segmentsIntersect(pt1[0],pt1[1],pt2[0],pt2[1],edge[0],edge[1],edge[2],edge[3]);if(ptInt&&(!ptCount||Math.abs(ptInt.x-out[0][0])>1||Math.abs(ptInt.y-out[0][1])>1)){ptInt=[ptInt.x,ptInt.y];// if we have 2 intersections, make sure the closest one to pt1 comes first\nif(ptCount&&ptDist(ptInt,pt1)<ptDist(out[0],pt1))out.unshift(ptInt);else out.push(ptInt);ptCount++;}}return out;}function onlyConstrainedPoint(pt){if(pt[0]<xEdge0||pt[0]>xEdge1||pt[1]<yEdge0||pt[1]>yEdge1){return[constrain(pt[0],xEdge0,xEdge1),constrain(pt[1],yEdge0,yEdge1)];}}function sameEdge(pt1,pt2){if(pt1[0]===pt2[0]&&(pt1[0]===xEdge0||pt1[0]===xEdge1))return true;if(pt1[1]===pt2[1]&&(pt1[1]===yEdge0||pt1[1]===yEdge1))return true;}// for line shapes hv and vh, movement in the two dimensions is decoupled,\n// so all we need to do is constrain each dimension independently\nfunction getHVEdgeIntersections(pt1,pt2){var out=[];var ptInt1=onlyConstrainedPoint(pt1);var ptInt2=onlyConstrainedPoint(pt2);if(ptInt1&&ptInt2&&sameEdge(ptInt1,ptInt2))return out;if(ptInt1)out.push(ptInt1);if(ptInt2)out.push(ptInt2);return out;}// hvh and vhv we sometimes have to move one of the intersection points\n// out BEYOND the clipping rect, by a maximum of a factor of 2, so that\n// the midpoint line is drawn in the right place\nfunction getABAEdgeIntersections(dim,limit0,limit1){return function(pt1,pt2){var ptInt1=onlyConstrainedPoint(pt1);var ptInt2=onlyConstrainedPoint(pt2);var out=[];if(ptInt1&&ptInt2&&sameEdge(ptInt1,ptInt2))return out;if(ptInt1)out.push(ptInt1);if(ptInt2)out.push(ptInt2);var midShift=2*Lib.constrain((pt1[dim]+pt2[dim])/2,limit0,limit1)-((ptInt1||pt1)[dim]+(ptInt2||pt2)[dim]);if(midShift){var ptToAlter;if(ptInt1&&ptInt2){ptToAlter=midShift>0===ptInt1[dim]>ptInt2[dim]?ptInt1:ptInt2;}else ptToAlter=ptInt1||ptInt2;ptToAlter[dim]+=midShift;}return out;};}var getEdgeIntersections;if(shape==='linear'||shape==='spline'){getEdgeIntersections=getLinearEdgeIntersections;}else if(shape==='hv'||shape==='vh'){getEdgeIntersections=getHVEdgeIntersections;}else if(shape==='hvh')getEdgeIntersections=getABAEdgeIntersections(0,xEdge0,xEdge1);else if(shape==='vhv')getEdgeIntersections=getABAEdgeIntersections(1,yEdge0,yEdge1);// a segment pt1->pt2 entirely outside the nearby region:\n// find the corner it gets closest to touching\nfunction getClosestCorner(pt1,pt2){var dx=pt2[0]-pt1[0];var m=(pt2[1]-pt1[1])/dx;var b=(pt1[1]*pt2[0]-pt2[1]*pt1[0])/dx;if(b>0)return[m>0?xEdge0:xEdge1,yEdge1];else return[m>0?xEdge1:xEdge0,yEdge0];}function updateEdge(pt){var x=pt[0];var y=pt[1];var xSame=x===pts[pti-1][0];var ySame=y===pts[pti-1][1];// duplicate point?\nif(xSame&&ySame)return;if(pti>1){// backtracking along an edge?\nvar xSame2=x===pts[pti-2][0];var ySame2=y===pts[pti-2][1];if(xSame&&(x===xEdge0||x===xEdge1)&&xSame2){if(ySame2)pti--;// backtracking exactly - drop prev pt and don't add\nelse pts[pti-1]=pt;// not exact: replace the prev pt\n}else if(ySame&&(y===yEdge0||y===yEdge1)&&ySame2){if(xSame2)pti--;else pts[pti-1]=pt;}else pts[pti++]=pt;}else pts[pti++]=pt;}function updateEdgesForReentry(pt){// if we're outside the nearby region and going back in,\n// we may need to loop around a corner point\nif(pts[pti-1][0]!==pt[0]&&pts[pti-1][1]!==pt[1]){updateEdge([lastXEdge,lastYEdge]);}updateEdge(pt);lastFarPt=null;lastXEdge=lastYEdge=0;}function addPt(pt){latestXFrac=pt[0]/xLen;latestYFrac=pt[1]/yLen;// Are we more than maxScreensAway off-screen any direction?\n// if so, clip to this box, but in such a way that on-screen\n// drawing is unchanged\nxEdge=pt[0]<xEdge0?xEdge0:pt[0]>xEdge1?xEdge1:0;yEdge=pt[1]<yEdge0?yEdge0:pt[1]>yEdge1?yEdge1:0;if(xEdge||yEdge){if(!pti){// to get fills right - if first point is far, push it toward the\n// screen in whichever direction(s) are far\npts[pti++]=[xEdge||pt[0],yEdge||pt[1]];}else if(lastFarPt){// both this point and the last are outside the nearby region\n// check if we're crossing the nearby region\nvar intersections=getEdgeIntersections(lastFarPt,pt);if(intersections.length>1){updateEdgesForReentry(intersections[0]);pts[pti++]=intersections[1];}}else{// we're leaving the nearby region - add the point where we left it\nedgePt=getEdgeIntersections(pts[pti-1],pt)[0];pts[pti++]=edgePt;}var lastPt=pts[pti-1];if(xEdge&&yEdge&&(lastPt[0]!==xEdge||lastPt[1]!==yEdge)){// we've gone out beyond a new corner: add the corner too\n// so that the next point will take the right winding\nif(lastFarPt){if(lastXEdge!==xEdge&&lastYEdge!==yEdge){if(lastXEdge&&lastYEdge){// we've gone around to an opposite corner - we\n// need to add the correct extra corner\n// in order to get the right winding\nupdateEdge(getClosestCorner(lastFarPt,pt));}else{// we're coming from a far edge - the extra corner\n// we need is determined uniquely by the sectors\nupdateEdge([lastXEdge||xEdge,lastYEdge||yEdge]);}}else if(lastXEdge&&lastYEdge){updateEdge([lastXEdge,lastYEdge]);}}updateEdge([xEdge,yEdge]);}else if(lastXEdge-xEdge&&lastYEdge-yEdge){// we're coming from an edge or far corner to an edge - again the\n// extra corner we need is uniquely determined by the sectors\nupdateEdge([xEdge||lastXEdge,yEdge||lastYEdge]);}lastFarPt=pt;lastXEdge=xEdge;lastYEdge=yEdge;}else{if(lastFarPt){// this point is in range but the previous wasn't: add its entry pt first\nupdateEdgesForReentry(getEdgeIntersections(lastFarPt,pt)[0]);}pts[pti++]=pt;}}// loop over ALL points in this trace\nfor(i=0;i<len;i++){clusterStartPt=getPt(i);if(!clusterStartPt)continue;pti=0;lastFarPt=null;addPt(clusterStartPt);// loop over one segment of the trace\nfor(i++;i<len;i++){clusterHighPt=getPt(i);if(!clusterHighPt){if(connectGaps)continue;else break;}// can't decimate if nonlinear line shape\n// TODO: we *could* decimate [hv]{2,3} shapes if we restricted clusters to horz or vert again\n// but spline would be verrry awkward to decimate\nif(!linear||!opts.simplify){addPt(clusterHighPt);continue;}var nextPt=getPt(i+1);clusterRefDist=ptDist(clusterHighPt,clusterStartPt);// #3147 - always include the very first and last points for fills\nif(!(fill&&(pti===0||pti===len-1))&&clusterRefDist<getTolerance(clusterHighPt,nextPt)*minTolerance)continue;clusterUnitVector=[(clusterHighPt[0]-clusterStartPt[0])/clusterRefDist,(clusterHighPt[1]-clusterStartPt[1])/clusterRefDist];clusterLowPt=clusterStartPt;clusterHighVal=clusterRefDist;clusterLowVal=clusterMinDeviation=clusterMaxDeviation=0;clusterHighFirst=false;clusterEndPt=clusterHighPt;// loop over one cluster of points that collapse onto one line\nfor(i++;i<d.length;i++){thisPt=nextPt;nextPt=getPt(i+1);if(!thisPt){if(connectGaps)continue;else break;}thisVector=[thisPt[0]-clusterStartPt[0],thisPt[1]-clusterStartPt[1]];// cross product (or dot with normal to the cluster vector)\nthisDeviation=thisVector[0]*clusterUnitVector[1]-thisVector[1]*clusterUnitVector[0];clusterMinDeviation=Math.min(clusterMinDeviation,thisDeviation);clusterMaxDeviation=Math.max(clusterMaxDeviation,thisDeviation);if(clusterMaxDeviation-clusterMinDeviation>getTolerance(thisPt,nextPt))break;clusterEndPt=thisPt;thisVal=thisVector[0]*clusterUnitVector[0]+thisVector[1]*clusterUnitVector[1];if(thisVal>clusterHighVal){clusterHighVal=thisVal;clusterHighPt=thisPt;clusterHighFirst=false;}else if(thisVal<clusterLowVal){clusterLowVal=thisVal;clusterLowPt=thisPt;clusterHighFirst=true;}}// insert this cluster into pts\n// we've already inserted the start pt, now check if we have high and low pts\nif(clusterHighFirst){addPt(clusterHighPt);if(clusterEndPt!==clusterLowPt)addPt(clusterLowPt);}else{if(clusterLowPt!==clusterStartPt)addPt(clusterLowPt);if(clusterEndPt!==clusterHighPt)addPt(clusterHighPt);}// and finally insert the end pt\naddPt(clusterEndPt);// have we reached the end of this segment?\nif(i>=d.length||!thisPt)break;// otherwise we have an out-of-cluster point to insert as next clusterStartPt\naddPt(thisPt);clusterStartPt=thisPt;}// to get fills right - repeat what we did at the start\nif(lastFarPt)updateEdge([lastXEdge||lastFarPt[0],lastYEdge||lastFarPt[1]]);segments.push(pts.slice(0,pti));}return segments;};},{\"../../constants/numerical\":140,\"../../lib\":159,\"./constants\":284}],295:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';// common to 'scatter' and 'scatterternary'\nmodule.exports=function handleLineShapeDefaults(traceIn,traceOut,coerce){var shape=coerce('line.shape');if(shape==='spline')coerce('line.smoothing');};},{}],296:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var LINKEDFILLS={tonextx:1,tonexty:1,tonext:1};module.exports=function linkTraces(gd,plotinfo,cdscatter){var trace,i,group,prevtrace,groupIndex;// first sort traces to keep stacks & filled-together groups together\nvar groupIndices={};var needsSort=false;var prevGroupIndex=-1;var nextGroupIndex=0;var prevUnstackedGroupIndex=-1;for(i=0;i<cdscatter.length;i++){trace=cdscatter[i][0].trace;group=trace.stackgroup||'';if(group){if(group in groupIndices){groupIndex=groupIndices[group];}else{groupIndex=groupIndices[group]=nextGroupIndex;nextGroupIndex++;}}else if(trace.fill in LINKEDFILLS&&prevUnstackedGroupIndex>=0){groupIndex=prevUnstackedGroupIndex;}else{groupIndex=prevUnstackedGroupIndex=nextGroupIndex;nextGroupIndex++;}if(groupIndex<prevGroupIndex)needsSort=true;trace._groupIndex=prevGroupIndex=groupIndex;}var cdscatterSorted=cdscatter.slice();if(needsSort){cdscatterSorted.sort(function(a,b){var traceA=a[0].trace;var traceB=b[0].trace;return traceA._groupIndex-traceB._groupIndex||traceA.index-traceB.index;});}// now link traces to each other\nvar prevtraces={};for(i=0;i<cdscatterSorted.length;i++){trace=cdscatterSorted[i][0].trace;group=trace.stackgroup||'';// Note: The check which ensures all cdscatter here are for the same axis and\n// are either cartesian or scatterternary has been removed. This code assumes\n// the passed scattertraces have been filtered to the proper plot types and\n// the proper subplots.\nif(trace.visible===true){trace._nexttrace=null;if(trace.fill in LINKEDFILLS){prevtrace=prevtraces[group];trace._prevtrace=prevtrace||null;if(prevtrace){prevtrace._nexttrace=trace;}}trace._ownfill=trace.fill&&(trace.fill.substr(0,6)==='tozero'||trace.fill==='toself'||trace.fill.substr(0,2)==='to'&&!trace._prevtrace);prevtraces[group]=trace;}else{trace._prevtrace=trace._nexttrace=trace._ownfill=null;}}return cdscatterSorted;};},{}],297:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var isNumeric=_dereq_('fast-isnumeric');// used in the drawing step for 'scatter' and 'scattegeo' and\n// in the convert step for 'scatter3d'\nmodule.exports=function makeBubbleSizeFn(trace){var marker=trace.marker;var sizeRef=marker.sizeref||1;var sizeMin=marker.sizemin||0;// for bubble charts, allow scaling the provided value linearly\n// and by area or diameter.\n// Note this only applies to the array-value sizes\nvar baseFn=marker.sizemode==='area'?function(v){return Math.sqrt(v/sizeRef);}:function(v){return v/sizeRef;};// TODO add support for position/negative bubbles?\n// TODO add 'sizeoffset' attribute?\nreturn function(v){var baseSize=baseFn(v/2);// don't show non-numeric and negative sizes\nreturn isNumeric(baseSize)&&baseSize>0?Math.max(baseSize,sizeMin):0;};};},{\"fast-isnumeric\":10}],298:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';module.exports={container:'marker',min:'cmin',max:'cmax'};},{}],299:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Color=_dereq_('../../components/color');var hasColorscale=_dereq_('../../components/colorscale/helpers').hasColorscale;var colorscaleDefaults=_dereq_('../../components/colorscale/defaults');var subTypes=_dereq_('./subtypes');/*\n * opts: object of flags to control features not all marker users support\n *   noLine: caller does not support marker lines\n *   gradient: caller supports gradients\n *   noSelect: caller does not support selected/unselected attribute containers\n */module.exports=function markerDefaults(traceIn,traceOut,defaultColor,layout,coerce,opts){var isBubble=subTypes.isBubble(traceIn);var lineColor=(traceIn.line||{}).color;var defaultMLC;opts=opts||{};// marker.color inherit from line.color (even if line.color is an array)\nif(lineColor)defaultColor=lineColor;coerce('marker.symbol');coerce('marker.opacity',isBubble?0.7:1);coerce('marker.size');coerce('marker.color',defaultColor);if(hasColorscale(traceIn,'marker')){colorscaleDefaults(traceIn,traceOut,layout,coerce,{prefix:'marker.',cLetter:'c'});}if(!opts.noSelect){coerce('selected.marker.color');coerce('unselected.marker.color');coerce('selected.marker.size');coerce('unselected.marker.size');}if(!opts.noLine){// if there's a line with a different color than the marker, use\n// that line color as the default marker line color\n// (except when it's an array)\n// mostly this is for transparent markers to behave nicely\nif(lineColor&&!Array.isArray(lineColor)&&traceOut.marker.color!==lineColor){defaultMLC=lineColor;}else if(isBubble)defaultMLC=Color.background;else defaultMLC=Color.defaultLine;coerce('marker.line.color',defaultMLC);if(hasColorscale(traceIn,'marker.line')){colorscaleDefaults(traceIn,traceOut,layout,coerce,{prefix:'marker.line.',cLetter:'c'});}coerce('marker.line.width',isBubble?1:0);}if(isBubble){coerce('marker.sizeref');coerce('marker.sizemin');coerce('marker.sizemode');}if(opts.gradient){var gradientType=coerce('marker.gradient.type');if(gradientType!=='none'){coerce('marker.gradient.color');}}};},{\"../../components/color\":43,\"../../components/colorscale/defaults\":53,\"../../components/colorscale/helpers\":54,\"./subtypes\":304}],300:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var Registry=_dereq_('../../registry');var Lib=_dereq_('../../lib');var ensureSingle=Lib.ensureSingle;var identity=Lib.identity;var Drawing=_dereq_('../../components/drawing');var subTypes=_dereq_('./subtypes');var linePoints=_dereq_('./line_points');var linkTraces=_dereq_('./link_traces');var polygonTester=_dereq_('../../lib/polygon').tester;module.exports=function plot(gd,plotinfo,cdscatter,scatterLayer,transitionOpts,makeOnCompleteCallback){var join,onComplete;// If transition config is provided, then it is only a partial replot and traces not\n// updated are removed.\nvar isFullReplot=!transitionOpts;var hasTransition=!!transitionOpts&&transitionOpts.duration>0;// Link traces so the z-order of fill layers is correct\nvar cdscatterSorted=linkTraces(gd,plotinfo,cdscatter);join=scatterLayer.selectAll('g.trace').data(cdscatterSorted,function(d){return d[0].trace.uid;});// Append new traces:\njoin.enter().append('g').attr('class',function(d){return'trace scatter trace'+d[0].trace.uid;}).style('stroke-miterlimit',2);join.order();createFills(gd,join,plotinfo);if(hasTransition){if(makeOnCompleteCallback){// If it was passed a callback to register completion, make a callback. If\n// this is created, then it must be executed on completion, otherwise the\n// pos-transition redraw will not execute:\nonComplete=makeOnCompleteCallback();}var transition=d3.transition().duration(transitionOpts.duration).ease(transitionOpts.easing).each('end',function(){onComplete&&onComplete();}).each('interrupt',function(){onComplete&&onComplete();});transition.each(function(){// Must run the selection again since otherwise enters/updates get grouped together\n// and these get executed out of order. Except we need them in order!\nscatterLayer.selectAll('g.trace').each(function(d,i){plotOne(gd,i,plotinfo,d,cdscatterSorted,this,transitionOpts);});});}else{join.each(function(d,i){plotOne(gd,i,plotinfo,d,cdscatterSorted,this,transitionOpts);});}if(isFullReplot){join.exit().remove();}// remove paths that didn't get used\nscatterLayer.selectAll('path:not([d])').remove();};function createFills(gd,traceJoin,plotinfo){traceJoin.each(function(d){var fills=ensureSingle(d3.select(this),'g','fills');Drawing.setClipUrl(fills,plotinfo.layerClipId,gd);var trace=d[0].trace;var fillData=[];if(trace._ownfill)fillData.push('_ownFill');if(trace._nexttrace)fillData.push('_nextFill');var fillJoin=fills.selectAll('g').data(fillData,identity);fillJoin.enter().append('g');fillJoin.exit().each(function(d){trace[d]=null;}).remove();fillJoin.order().each(function(d){// make a path element inside the fill group, just so\n// we can give it its own data later on and the group can\n// keep its simple '_*Fill' data\ntrace[d]=ensureSingle(d3.select(this),'path','js-fill');});});}function plotOne(gd,idx,plotinfo,cdscatter,cdscatterAll,element,transitionOpts){var i;// Since this has been reorganized and we're executing this on individual traces,\n// we need to pass it the full list of cdscatter as well as this trace's index (idx)\n// since it does an internal n^2 loop over comparisons with other traces:\nselectMarkers(gd,idx,plotinfo,cdscatter,cdscatterAll);var hasTransition=!!transitionOpts&&transitionOpts.duration>0;function transition(selection){return hasTransition?selection.transition():selection;}var xa=plotinfo.xaxis;var ya=plotinfo.yaxis;var trace=cdscatter[0].trace;var line=trace.line;var tr=d3.select(element);var errorBarGroup=ensureSingle(tr,'g','errorbars');var lines=ensureSingle(tr,'g','lines');var points=ensureSingle(tr,'g','points');var text=ensureSingle(tr,'g','text');// error bars are at the bottom\nRegistry.getComponentMethod('errorbars','plot')(gd,errorBarGroup,plotinfo,transitionOpts);if(trace.visible!==true)return;transition(tr).style('opacity',trace.opacity);// BUILD LINES AND FILLS\nvar ownFillEl3,tonext;var ownFillDir=trace.fill.charAt(trace.fill.length-1);if(ownFillDir!=='x'&&ownFillDir!=='y')ownFillDir='';// store node for tweaking by selectPoints\nif(!plotinfo.isRangePlot)cdscatter[0].node3=tr;var prevRevpath='';var prevPolygons=[];var prevtrace=trace._prevtrace;if(prevtrace){prevRevpath=prevtrace._prevRevpath||'';tonext=prevtrace._nextFill;prevPolygons=prevtrace._polygons;}var thispath;var thisrevpath;// fullpath is all paths for this curve, joined together straight\n// across gaps, for filling\nvar fullpath='';// revpath is fullpath reversed, for fill-to-next\nvar revpath='';// functions for converting a point array to a path\nvar pathfn,revpathbase,revpathfn;// variables used before and after the data join\nvar pt0,lastSegment,pt1,thisPolygons;// initialize line join data / method\nvar segments=[];var makeUpdate=Lib.noop;ownFillEl3=trace._ownFill;if(subTypes.hasLines(trace)||trace.fill!=='none'){if(tonext){// This tells .style which trace to use for fill information:\ntonext.datum(cdscatter);}if(['hv','vh','hvh','vhv'].indexOf(line.shape)!==-1){pathfn=Drawing.steps(line.shape);revpathbase=Drawing.steps(line.shape.split('').reverse().join(''));}else if(line.shape==='spline'){pathfn=revpathbase=function revpathbase(pts){var pLast=pts[pts.length-1];if(pts.length>1&&pts[0][0]===pLast[0]&&pts[0][1]===pLast[1]){// identical start and end points: treat it as a\n// closed curve so we don't get a kink\nreturn Drawing.smoothclosed(pts.slice(1),line.smoothing);}else{return Drawing.smoothopen(pts,line.smoothing);}};}else{pathfn=revpathbase=function revpathbase(pts){return'M'+pts.join('L');};}revpathfn=function revpathfn(pts){// note: this is destructive (reverses pts in place) so can't use pts after this\nreturn revpathbase(pts.reverse());};segments=linePoints(cdscatter,{xaxis:xa,yaxis:ya,connectGaps:trace.connectgaps,baseTolerance:Math.max(line.width||1,3)/4,shape:line.shape,simplify:line.simplify,fill:trace.fill});// since we already have the pixel segments here, use them to make\n// polygons for hover on fill\n// TODO: can we skip this if hoveron!=fills? That would mean we\n// need to redraw when you change hoveron...\nthisPolygons=trace._polygons=new Array(segments.length);for(i=0;i<segments.length;i++){trace._polygons[i]=polygonTester(segments[i]);}if(segments.length){pt0=segments[0][0];lastSegment=segments[segments.length-1];pt1=lastSegment[lastSegment.length-1];}makeUpdate=function makeUpdate(isEnter){return function(pts){thispath=pathfn(pts);thisrevpath=revpathfn(pts);if(!fullpath){fullpath=thispath;revpath=thisrevpath;}else if(ownFillDir){fullpath+='L'+thispath.substr(1);revpath=thisrevpath+('L'+revpath.substr(1));}else{fullpath+='Z'+thispath;revpath=thisrevpath+'Z'+revpath;}if(subTypes.hasLines(trace)&&pts.length>1){var el=d3.select(this);// This makes the coloring work correctly:\nel.datum(cdscatter);if(isEnter){transition(el.style('opacity',0).attr('d',thispath).call(Drawing.lineGroupStyle)).style('opacity',1);}else{var sel=transition(el);sel.attr('d',thispath);Drawing.singleLineStyle(cdscatter,sel);}}};};}var lineJoin=lines.selectAll('.js-line').data(segments);transition(lineJoin.exit()).style('opacity',0).remove();lineJoin.each(makeUpdate(false));lineJoin.enter().append('path').classed('js-line',true).style('vector-effect','non-scaling-stroke').call(Drawing.lineGroupStyle).each(makeUpdate(true));Drawing.setClipUrl(lineJoin,plotinfo.layerClipId,gd);function clearFill(selection){transition(selection).attr('d','M0,0Z');}if(segments.length){if(ownFillEl3){ownFillEl3.datum(cdscatter);if(pt0&&pt1){if(ownFillDir){if(ownFillDir==='y'){pt0[1]=pt1[1]=ya.c2p(0,true);}else if(ownFillDir==='x'){pt0[0]=pt1[0]=xa.c2p(0,true);}// fill to zero: full trace path, plus extension of\n// the endpoints to the appropriate axis\n// For the sake of animations, wrap the points around so that\n// the points on the axes are the first two points. Otherwise\n// animations get a little crazy if the number of points changes.\ntransition(ownFillEl3).attr('d','M'+pt1+'L'+pt0+'L'+fullpath.substr(1)).call(Drawing.singleFillStyle);}else{// fill to self: just join the path to itself\ntransition(ownFillEl3).attr('d',fullpath+'Z').call(Drawing.singleFillStyle);}}}else if(tonext){if(trace.fill.substr(0,6)==='tonext'&&fullpath&&prevRevpath){// fill to next: full trace path, plus the previous path reversed\nif(trace.fill==='tonext'){// tonext: for use by concentric shapes, like manually constructed\n// contours, we just add the two paths closed on themselves.\n// This makes strange results if one path is *not* entirely\n// inside the other, but then that is a strange usage.\ntransition(tonext).attr('d',fullpath+'Z'+prevRevpath+'Z').call(Drawing.singleFillStyle);}else{// tonextx/y: for now just connect endpoints with lines. This is\n// the correct behavior if the endpoints are at the same value of\n// y/x, but if they *aren't*, we should ideally do more complicated\n// things depending on whether the new endpoint projects onto the\n// existing curve or off the end of it\ntransition(tonext).attr('d',fullpath+'L'+prevRevpath.substr(1)+'Z').call(Drawing.singleFillStyle);}trace._polygons=trace._polygons.concat(prevPolygons);}else{clearFill(tonext);trace._polygons=null;}}trace._prevRevpath=revpath;trace._prevPolygons=thisPolygons;}else{if(ownFillEl3)clearFill(ownFillEl3);else if(tonext)clearFill(tonext);trace._polygons=trace._prevRevpath=trace._prevPolygons=null;}function visFilter(d){return d.filter(function(v){return!v.gap&&v.vis;});}function visFilterWithGaps(d){return d.filter(function(v){return v.vis;});}function gapFilter(d){return d.filter(function(v){return!v.gap;});}function keyFunc(d){return d.id;}// Returns a function if the trace is keyed, otherwise returns undefined\nfunction getKeyFunc(trace){if(trace.ids){return keyFunc;}}function hideFilter(){return false;}function makePoints(points,text,cdscatter){var join,selection,hasNode;var trace=cdscatter[0].trace;var showMarkers=subTypes.hasMarkers(trace);var showText=subTypes.hasText(trace);var keyFunc=getKeyFunc(trace);var markerFilter=hideFilter;var textFilter=hideFilter;if(showMarkers||showText){var showFilter=identity;// if we're stacking, \"infer zero\" gap mode gets markers in the\n// gap points - because we've inferred a zero there - but other\n// modes (currently \"interpolate\", later \"interrupt\" hopefully)\n// we don't draw generated markers\nvar stackGroup=trace.stackgroup;var isInferZero=stackGroup&&gd._fullLayout._scatterStackOpts[xa._id+ya._id][stackGroup].stackgaps==='infer zero';if(trace.marker.maxdisplayed||trace._needsCull){showFilter=isInferZero?visFilterWithGaps:visFilter;}else if(stackGroup&&!isInferZero){showFilter=gapFilter;}if(showMarkers)markerFilter=showFilter;if(showText)textFilter=showFilter;}// marker points\nselection=points.selectAll('path.point');join=selection.data(markerFilter,keyFunc);var enter=join.enter().append('path').classed('point',true);if(hasTransition){enter.call(Drawing.pointStyle,trace,gd).call(Drawing.translatePoints,xa,ya).style('opacity',0).transition().style('opacity',1);}join.order();var styleFns;if(showMarkers){styleFns=Drawing.makePointStyleFns(trace);}join.each(function(d){var el=d3.select(this);var sel=transition(el);hasNode=Drawing.translatePoint(d,sel,xa,ya);if(hasNode){Drawing.singlePointStyle(d,sel,trace,styleFns,gd);if(plotinfo.layerClipId){Drawing.hideOutsideRangePoint(d,sel,xa,ya,trace.xcalendar,trace.ycalendar);}if(trace.customdata){el.classed('plotly-customdata',d.data!==null&&d.data!==undefined);}}else{sel.remove();}});if(hasTransition){join.exit().transition().style('opacity',0).remove();}else{join.exit().remove();}// text points\nselection=text.selectAll('g');join=selection.data(textFilter,keyFunc);// each text needs to go in its own 'g' in case\n// it gets converted to mathjax\njoin.enter().append('g').classed('textpoint',true).append('text');join.order();join.each(function(d){var g=d3.select(this);var sel=transition(g.select('text'));hasNode=Drawing.translatePoint(d,sel,xa,ya);if(hasNode){if(plotinfo.layerClipId){Drawing.hideOutsideRangePoint(d,g,xa,ya,trace.xcalendar,trace.ycalendar);}}else{g.remove();}});join.selectAll('text').call(Drawing.textPointStyle,trace,gd).each(function(d){// This just *has* to be totally custom becuase of SVG text positioning :(\n// It's obviously copied from translatePoint; we just can't use that\nvar x=xa.c2p(d.x);var y=ya.c2p(d.y);d3.select(this).selectAll('tspan.line').each(function(){transition(d3.select(this)).attr({x:x,y:y});});});join.exit().remove();}points.datum(cdscatter);text.datum(cdscatter);makePoints(points,text,cdscatter);// lastly, clip points groups of `cliponaxis !== false` traces\n// on `plotinfo._hasClipOnAxisFalse === true` subplots\nvar hasClipOnAxisFalse=trace.cliponaxis===false;var clipUrl=hasClipOnAxisFalse?null:plotinfo.layerClipId;Drawing.setClipUrl(points,clipUrl,gd);Drawing.setClipUrl(text,clipUrl,gd);}function selectMarkers(gd,idx,plotinfo,cdscatter,cdscatterAll){var xa=plotinfo.xaxis;var ya=plotinfo.yaxis;var xr=d3.extent(Lib.simpleMap(xa.range,xa.r2c));var yr=d3.extent(Lib.simpleMap(ya.range,ya.r2c));var trace=cdscatter[0].trace;if(!subTypes.hasMarkers(trace))return;// if marker.maxdisplayed is used, select a maximum of\n// mnum markers to show, from the set that are in the viewport\nvar mnum=trace.marker.maxdisplayed;// TODO: remove some as we get away from the viewport?\nif(mnum===0)return;var cd=cdscatter.filter(function(v){return v.x>=xr[0]&&v.x<=xr[1]&&v.y>=yr[0]&&v.y<=yr[1];});var inc=Math.ceil(cd.length/mnum);var tnum=0;cdscatterAll.forEach(function(cdj,j){var tracei=cdj[0].trace;if(subTypes.hasMarkers(tracei)&&tracei.marker.maxdisplayed>0&&j<idx){tnum++;}});// if multiple traces use maxdisplayed, stagger which markers we\n// display this formula offsets successive traces by 1/3 of the\n// increment, adding an extra small amount after each triplet so\n// it's not quite periodic\nvar i0=Math.round(tnum*inc/3+Math.floor(tnum/3)*inc/7.1);// for error bars: save in cd which markers to show\n// so we don't have to repeat this\ncdscatter.forEach(function(v){delete v.vis;});cd.forEach(function(v,i){if(Math.round((i+i0)%inc)===0)v.vis=true;});}},{\"../../components/drawing\":64,\"../../lib\":159,\"../../lib/polygon\":171,\"../../registry\":242,\"./line_points\":294,\"./link_traces\":296,\"./subtypes\":304,\"d3\":8}],301:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var subtypes=_dereq_('./subtypes');module.exports=function selectPoints(searchInfo,selectionTester){var cd=searchInfo.cd;var xa=searchInfo.xaxis;var ya=searchInfo.yaxis;var selection=[];var trace=cd[0].trace;var i;var di;var x;var y;var hasOnlyLines=!subtypes.hasMarkers(trace)&&!subtypes.hasText(trace);if(hasOnlyLines)return[];if(selectionTester===false){// clear selection\nfor(i=0;i<cd.length;i++){cd[i].selected=0;}}else{for(i=0;i<cd.length;i++){di=cd[i];x=xa.c2p(di.x);y=ya.c2p(di.y);if(di.i!==null&&selectionTester.contains([x,y],false,i,searchInfo)){selection.push({pointNumber:di.i,x:xa.c2d(di.x),y:ya.c2d(di.y)});di.selected=1;}else{di.selected=0;}}}return selection;};},{\"./subtypes\":304}],302:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var perStackAttrs=['orientation','groupnorm','stackgaps'];module.exports=function handleStackDefaults(traceIn,traceOut,layout,coerce){var stackOpts=layout._scatterStackOpts;var stackGroup=coerce('stackgroup');if(stackGroup){// use independent stacking options per subplot\nvar subplot=traceOut.xaxis+traceOut.yaxis;var subplotStackOpts=stackOpts[subplot];if(!subplotStackOpts)subplotStackOpts=stackOpts[subplot]={};var groupOpts=subplotStackOpts[stackGroup];var firstTrace=false;if(groupOpts){groupOpts.traces.push(traceOut);}else{groupOpts=subplotStackOpts[stackGroup]={// keep track of trace indices for use during stacking calculations\n// this will be filled in during `calc` and used during `crossTraceCalc`\n// so it's OK if we don't recreate it during a non-calc edit\ntraceIndices:[],// Hold on to the whole set of prior traces\n// First one is most important, so we can clear defaults\n// there if we find explicit values only in later traces.\n// We're only going to *use* the values stored in groupOpts,\n// but for the editor and validate we want things self-consistent\n// The full set of traces is used only to fix `fill` default if\n// we find `orientation: 'h'` beyond the first trace\ntraces:[traceOut]};firstTrace=true;}// TODO: how is this going to work with groupby transforms?\n// in principle it should be OK I guess, as long as explicit group styles\n// don't override explicit base-trace styles?\nvar dflts={orientation:traceOut.x&&!traceOut.y?'h':'v'};for(var i=0;i<perStackAttrs.length;i++){var attr=perStackAttrs[i];var attrFound=attr+'Found';if(!groupOpts[attrFound]){var traceHasAttr=traceIn[attr]!==undefined;var isOrientation=attr==='orientation';if(traceHasAttr||firstTrace){groupOpts[attr]=coerce(attr,dflts[attr]);if(isOrientation){groupOpts.fillDflt=groupOpts[attr]==='h'?'tonextx':'tonexty';}if(traceHasAttr){// Note: this will show a value here even if it's invalid\n// in which case it will revert to default.\ngroupOpts[attrFound]=true;// Note: only one trace in the stack will get a _fullData\n// entry for a given stack-wide attribute. If no traces\n// (or the first trace) specify that attribute, the\n// first trace will get it. If the first trace does NOT\n// specify it but some later trace does, then it gets\n// removed from the first trace and only included in the\n// one that specified it. This is mostly important for\n// editors (that want to see the full values to know\n// what settings are available) and Plotly.react diffing.\n// Editors may want to use fullLayout._scatterStackOpts\n// directly and make these settings available from all\n// traces in the stack... then set the new value into\n// the first trace, and clear all later traces.\nif(!firstTrace){delete groupOpts.traces[0][attr];// orientation can affect default fill of previous traces\nif(isOrientation){for(var j=0;j<groupOpts.traces.length-1;j++){var trace2=groupOpts.traces[j];if(trace2._input.fill!==trace2.fill){trace2.fill=groupOpts.fillDflt;}}}}}}}}return groupOpts;}};},{}],303:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var d3=_dereq_('d3');var Drawing=_dereq_('../../components/drawing');var Registry=_dereq_('../../registry');function style(gd,cd){var s=cd?cd[0].node3:d3.select(gd).selectAll('g.trace.scatter');s.style('opacity',function(d){return d[0].trace.opacity;});s.selectAll('g.points').each(function(d){var sel=d3.select(this);var trace=d.trace||d[0].trace;stylePoints(sel,trace,gd);});s.selectAll('g.text').each(function(d){var sel=d3.select(this);var trace=d.trace||d[0].trace;styleText(sel,trace,gd);});s.selectAll('g.trace path.js-line').call(Drawing.lineGroupStyle);s.selectAll('g.trace path.js-fill').call(Drawing.fillGroupStyle);Registry.getComponentMethod('errorbars','style')(s);}function stylePoints(sel,trace,gd){Drawing.pointStyle(sel.selectAll('path.point'),trace,gd);}function styleText(sel,trace,gd){Drawing.textPointStyle(sel.selectAll('text'),trace,gd);}function styleOnSelect(gd,cd){var s=cd[0].node3;var trace=cd[0].trace;if(trace.selectedpoints){Drawing.selectedPointStyle(s.selectAll('path.point'),trace);Drawing.selectedTextStyle(s.selectAll('text'),trace);}else{stylePoints(s,trace,gd);styleText(s,trace,gd);}}module.exports={style:style,stylePoints:stylePoints,styleText:styleText,styleOnSelect:styleOnSelect};},{\"../../components/drawing\":64,\"../../registry\":242,\"d3\":8}],304:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');module.exports={hasLines:function hasLines(trace){return trace.visible&&trace.mode&&trace.mode.indexOf('lines')!==-1;},hasMarkers:function hasMarkers(trace){return trace.visible&&(trace.mode&&trace.mode.indexOf('markers')!==-1||// until splom implements 'mode'\ntrace.type==='splom');},hasText:function hasText(trace){return trace.visible&&trace.mode&&trace.mode.indexOf('text')!==-1;},isBubble:function isBubble(trace){return Lib.isPlainObject(trace.marker)&&Lib.isArrayOrTypedArray(trace.marker.size);}};},{\"../../lib\":159}],305:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');/*\n * opts: object of flags to control features not all text users support\n *   noSelect: caller does not support selected/unselected attribute containers\n */module.exports=function(traceIn,traceOut,layout,coerce,opts){opts=opts||{};coerce('textposition');Lib.coerceFont(coerce,'textfont',layout.font);if(!opts.noSelect){coerce('selected.textfont.color');coerce('unselected.textfont.color');}};},{\"../../lib\":159}],306:[function(_dereq_,module,exports){/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/'use strict';var Lib=_dereq_('../../lib');var Registry=_dereq_('../../registry');module.exports=function handleXYDefaults(traceIn,traceOut,layout,coerce){var x=coerce('x');var y=coerce('y');var len;var handleCalendarDefaults=Registry.getComponentMethod('calendars','handleTraceDefaults');handleCalendarDefaults(traceIn,traceOut,['x','y'],layout);if(x){var xlen=Lib.minRowLength(x);if(y){len=Math.min(xlen,Lib.minRowLength(y));}else{len=xlen;coerce('y0');coerce('dy');}}else{if(!y)return 0;len=Lib.minRowLength(y);coerce('x0');coerce('dx');}traceOut._length=len;return len;};},{\"../../lib\":159,\"../../registry\":242}]},{},[5])(5);});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack-stream/node_modules/webpack/buildin/global.js */ \"./node_modules/webpack-stream/node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/plotly.js/dist/plotly-basic.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n  throw new Error('setTimeout has not been defined');\n}\n\nfunction defaultClearTimeout() {\n  throw new Error('clearTimeout has not been defined');\n}\n\n(function () {\n  try {\n    if (typeof setTimeout === 'function') {\n      cachedSetTimeout = setTimeout;\n    } else {\n      cachedSetTimeout = defaultSetTimout;\n    }\n  } catch (e) {\n    cachedSetTimeout = defaultSetTimout;\n  }\n\n  try {\n    if (typeof clearTimeout === 'function') {\n      cachedClearTimeout = clearTimeout;\n    } else {\n      cachedClearTimeout = defaultClearTimeout;\n    }\n  } catch (e) {\n    cachedClearTimeout = defaultClearTimeout;\n  }\n})();\n\nfunction runTimeout(fun) {\n  if (cachedSetTimeout === setTimeout) {\n    //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n  } // if setTimeout wasn't available but was latter defined\n\n\n  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n    cachedSetTimeout = setTimeout;\n    return setTimeout(fun, 0);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedSetTimeout(fun, 0);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n      return cachedSetTimeout.call(null, fun, 0);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n      return cachedSetTimeout.call(this, fun, 0);\n    }\n  }\n}\n\nfunction runClearTimeout(marker) {\n  if (cachedClearTimeout === clearTimeout) {\n    //normal enviroments in sane situations\n    return clearTimeout(marker);\n  } // if clearTimeout wasn't available but was latter defined\n\n\n  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n    cachedClearTimeout = clearTimeout;\n    return clearTimeout(marker);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedClearTimeout(marker);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n      return cachedClearTimeout.call(null, marker);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n      // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n      return cachedClearTimeout.call(this, marker);\n    }\n  }\n}\n\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n  if (!draining || !currentQueue) {\n    return;\n  }\n\n  draining = false;\n\n  if (currentQueue.length) {\n    queue = currentQueue.concat(queue);\n  } else {\n    queueIndex = -1;\n  }\n\n  if (queue.length) {\n    drainQueue();\n  }\n}\n\nfunction drainQueue() {\n  if (draining) {\n    return;\n  }\n\n  var timeout = runTimeout(cleanUpNextTick);\n  draining = true;\n  var len = queue.length;\n\n  while (len) {\n    currentQueue = queue;\n    queue = [];\n\n    while (++queueIndex < len) {\n      if (currentQueue) {\n        currentQueue[queueIndex].run();\n      }\n    }\n\n    queueIndex = -1;\n    len = queue.length;\n  }\n\n  currentQueue = null;\n  draining = false;\n  runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n  var args = new Array(arguments.length - 1);\n\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n  }\n\n  queue.push(new Item(fun, args));\n\n  if (queue.length === 1 && !draining) {\n    runTimeout(drainQueue);\n  }\n}; // v8 likes predictible objects\n\n\nfunction Item(fun, array) {\n  this.fun = fun;\n  this.array = array;\n}\n\nItem.prototype.run = function () {\n  this.fun.apply(null, this.array);\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\n\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n  return [];\n};\n\nprocess.binding = function (name) {\n  throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n  return '/';\n};\n\nprocess.chdir = function (dir) {\n  throw new Error('process.chdir is not supported');\n};\n\nprocess.umask = function () {\n  return 0;\n};\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n  \"use strict\";\n\n  if (global.setImmediate) {\n    return;\n  }\n\n  var nextHandle = 1; // Spec says greater than zero\n\n  var tasksByHandle = {};\n  var currentlyRunningATask = false;\n  var doc = global.document;\n  var registerImmediate;\n\n  function setImmediate(callback) {\n    // Callback can either be a function or a string\n    if (typeof callback !== \"function\") {\n      callback = new Function(\"\" + callback);\n    } // Copy function arguments\n\n\n    var args = new Array(arguments.length - 1);\n\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i + 1];\n    } // Store and register the task\n\n\n    var task = {\n      callback: callback,\n      args: args\n    };\n    tasksByHandle[nextHandle] = task;\n    registerImmediate(nextHandle);\n    return nextHandle++;\n  }\n\n  function clearImmediate(handle) {\n    delete tasksByHandle[handle];\n  }\n\n  function run(task) {\n    var callback = task.callback;\n    var args = task.args;\n\n    switch (args.length) {\n      case 0:\n        callback();\n        break;\n\n      case 1:\n        callback(args[0]);\n        break;\n\n      case 2:\n        callback(args[0], args[1]);\n        break;\n\n      case 3:\n        callback(args[0], args[1], args[2]);\n        break;\n\n      default:\n        callback.apply(undefined, args);\n        break;\n    }\n  }\n\n  function runIfPresent(handle) {\n    // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n    // So if we're currently running a task, we'll need to delay this invocation.\n    if (currentlyRunningATask) {\n      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n      // \"too much recursion\" error.\n      setTimeout(runIfPresent, 0, handle);\n    } else {\n      var task = tasksByHandle[handle];\n\n      if (task) {\n        currentlyRunningATask = true;\n\n        try {\n          run(task);\n        } finally {\n          clearImmediate(handle);\n          currentlyRunningATask = false;\n        }\n      }\n    }\n  }\n\n  function installNextTickImplementation() {\n    registerImmediate = function registerImmediate(handle) {\n      process.nextTick(function () {\n        runIfPresent(handle);\n      });\n    };\n  }\n\n  function canUsePostMessage() {\n    // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n    // where `global.postMessage` means something completely different and can't be used for this purpose.\n    if (global.postMessage && !global.importScripts) {\n      var postMessageIsAsynchronous = true;\n      var oldOnMessage = global.onmessage;\n\n      global.onmessage = function () {\n        postMessageIsAsynchronous = false;\n      };\n\n      global.postMessage(\"\", \"*\");\n      global.onmessage = oldOnMessage;\n      return postMessageIsAsynchronous;\n    }\n  }\n\n  function installPostMessageImplementation() {\n    // Installs an event handler on `global` for the `message` event: see\n    // * https://developer.mozilla.org/en/DOM/window.postMessage\n    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n    var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n\n    var onGlobalMessage = function onGlobalMessage(event) {\n      if (event.source === global && typeof event.data === \"string\" && event.data.indexOf(messagePrefix) === 0) {\n        runIfPresent(+event.data.slice(messagePrefix.length));\n      }\n    };\n\n    if (global.addEventListener) {\n      global.addEventListener(\"message\", onGlobalMessage, false);\n    } else {\n      global.attachEvent(\"onmessage\", onGlobalMessage);\n    }\n\n    registerImmediate = function registerImmediate(handle) {\n      global.postMessage(messagePrefix + handle, \"*\");\n    };\n  }\n\n  function installMessageChannelImplementation() {\n    var channel = new MessageChannel();\n\n    channel.port1.onmessage = function (event) {\n      var handle = event.data;\n      runIfPresent(handle);\n    };\n\n    registerImmediate = function registerImmediate(handle) {\n      channel.port2.postMessage(handle);\n    };\n  }\n\n  function installReadyStateChangeImplementation() {\n    var html = doc.documentElement;\n\n    registerImmediate = function registerImmediate(handle) {\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var script = doc.createElement(\"script\");\n\n      script.onreadystatechange = function () {\n        runIfPresent(handle);\n        script.onreadystatechange = null;\n        html.removeChild(script);\n        script = null;\n      };\n\n      html.appendChild(script);\n    };\n  }\n\n  function installSetTimeoutImplementation() {\n    registerImmediate = function registerImmediate(handle) {\n      setTimeout(runIfPresent, 0, handle);\n    };\n  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n\n\n  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.\n\n  if ({}.toString.call(global.process) === \"[object process]\") {\n    // For Node.js before 0.9\n    installNextTickImplementation();\n  } else if (canUsePostMessage()) {\n    // For non-IE10 modern browsers\n    installPostMessageImplementation();\n  } else if (global.MessageChannel) {\n    // For web workers, where supported\n    installMessageChannelImplementation();\n  } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n    // For IE 68\n    installReadyStateChangeImplementation();\n  } else {\n    // For older browsers\n    installSetTimeoutImplementation();\n  }\n\n  attachTo.setImmediate = setImmediate;\n  attachTo.clearImmediate = clearImmediate;\n})(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack-stream/node_modules/webpack/buildin/global.js */ \"./node_modules/webpack-stream/node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== \"undefined\" && global || typeof self !== \"undefined\" && self || window;\nvar apply = Function.prototype.apply; // DOM APIs, for completeness\n\nexports.setTimeout = function () {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\n\nexports.setInterval = function () {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\n\nexports.clearTimeout = exports.clearInterval = function (timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\n\nTimeout.prototype.unref = Timeout.prototype.ref = function () {};\n\nTimeout.prototype.close = function () {\n  this._clearFn.call(scope, this._id);\n}; // Does not start the time, just sets up the members needed.\n\n\nexports.enroll = function (item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function (item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function (item) {\n  clearTimeout(item._idleTimeoutId);\n  var msecs = item._idleTimeout;\n\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout) item._onTimeout();\n    }, msecs);\n  }\n}; // setimmediate attaches itself to the global object\n\n\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\"); // On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\n\n\nexports.setImmediate = typeof self !== \"undefined\" && self.setImmediate || typeof global !== \"undefined\" && global.setImmediate || this && this.setImmediate;\nexports.clearImmediate = typeof self !== \"undefined\" && self.clearImmediate || typeof global !== \"undefined\" && global.clearImmediate || this && this.clearImmediate;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack-stream/node_modules/webpack/buildin/global.js */ \"./node_modules/webpack-stream/node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/timers-browserify/main.js?");

/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/inputs.vue?vue&type=template&id=028ecd15&":
/*!***************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/inputs.vue?vue&type=template&id=028ecd15& ***!
  \***************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return staticRenderFns; });\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"form\", [\n    _c(\"div\", { staticClass: \"form-group\" }, [\n      _c(\"label\", { attrs: { for: \"a\" } }, [_vm._v(\"a\")]),\n      _vm._v(\" \"),\n      _c(\"input\", {\n        directives: [\n          { name: \"model\", rawName: \"v-model\", value: _vm.a, expression: \"a\" }\n        ],\n        staticClass: \"form-control\",\n        attrs: { type: \"number\", id: \"a\" },\n        domProps: { value: _vm.a },\n        on: {\n          input: function($event) {\n            if ($event.target.composing) {\n              return\n            }\n            _vm.a = $event.target.value\n          }\n        }\n      })\n    ]),\n    _vm._v(\" \"),\n    _c(\"div\", { staticClass: \"form-group\" }, [\n      _c(\"label\", { attrs: { for: \"b\" } }, [_vm._v(\"b\")]),\n      _vm._v(\" \"),\n      _c(\"input\", {\n        directives: [\n          { name: \"model\", rawName: \"v-model\", value: _vm.b, expression: \"b\" }\n        ],\n        staticClass: \"form-control\",\n        attrs: { type: \"number\", id: \"b\" },\n        domProps: { value: _vm.b },\n        on: {\n          input: function($event) {\n            if ($event.target.composing) {\n              return\n            }\n            _vm.b = $event.target.value\n          }\n        }\n      })\n    ]),\n    _vm._v(\" \"),\n    _c(\"div\", { staticClass: \"form-group\" }, [\n      _c(\"label\", { attrs: { for: \"time\" } }, [_vm._v(\"time\")]),\n      _vm._v(\" \"),\n      _c(\"input\", {\n        directives: [\n          {\n            name: \"model\",\n            rawName: \"v-model\",\n            value: _vm.time,\n            expression: \"time\"\n          }\n        ],\n        staticClass: \"form-control\",\n        attrs: { type: \"number\", id: \"time\" },\n        domProps: { value: _vm.time },\n        on: {\n          input: function($event) {\n            if ($event.target.composing) {\n              return\n            }\n            _vm.time = $event.target.value\n          }\n        }\n      })\n    ]),\n    _vm._v(\" \"),\n    _c(\"div\", { staticClass: \"form-group\" }, [\n      _c(\"label\", { attrs: { for: \"poll\" } }, [_vm._v(\"poll\")]),\n      _vm._v(\" \"),\n      _c(\"input\", {\n        directives: [\n          {\n            name: \"model\",\n            rawName: \"v-model\",\n            value: _vm.poll,\n            expression: \"poll\"\n          }\n        ],\n        staticClass: \"form-control\",\n        attrs: { type: \"number\", id: \"poll\" },\n        domProps: { value: _vm.poll },\n        on: {\n          input: function($event) {\n            if ($event.target.composing) {\n              return\n            }\n            _vm.poll = $event.target.value\n          }\n        }\n      })\n    ]),\n    _vm._v(\" \"),\n    _c(\n      \"button\",\n      {\n        staticClass: \"btn btn-red\",\n        attrs: { type: \"submit\" },\n        on: { click: _vm.validate }\n      },\n      [_vm._v(\"Validate\")]\n    ),\n    _vm._v(\" \"),\n    _vm.error.length > 0\n      ? _c(\"div\", { staticClass: \"alert alert-danger mt-3\" }, [\n          _vm._v(\"\\n        \" + _vm._s(_vm.error) + \"\\n    \")\n        ])\n      : _vm._e(),\n    _vm._v(\" \"),\n    _vm.valid\n      ? _c(\"div\", { staticClass: \"alert alert-success mt-3\" }, [\n          _vm._v(\"\\n        These inputs are valid\\n    \")\n        ])\n      : _vm._e()\n  ])\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n\n//# sourceURL=webpack:///./src/js/components/inputs.vue?./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/plotly.vue?vue&type=template&id=4423324c&":
/*!***************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/plotly.vue?vue&type=template&id=4423324c& ***!
  \***************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return staticRenderFns; });\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\", { ref: \"container\", staticClass: \"vue-plotly\" })\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n\n//# sourceURL=webpack:///./src/js/components/plotly.vue?./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/results.vue?vue&type=template&id=0fbc10fa&":
/*!****************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/results.vue?vue&type=template&id=0fbc10fa& ***!
  \****************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return staticRenderFns; });\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\", { staticClass: \"mt-3\" }, [\n    _c(\n      \"ul\",\n      { staticClass: \"list-unstyled\" },\n      _vm._l(_vm.fitted, function(value, name) {\n        return _c(\"li\", [\n          _vm._v(\n            \"\\n            \" +\n              _vm._s(name) +\n              \": \" +\n              _vm._s(value) +\n              \"\\n        \"\n          )\n        ])\n      }),\n      0\n    ),\n    _vm._v(\" \"),\n    _vm.simulation.length > 0\n      ? _c(\"div\", [_c(\"vue-plotly\", { attrs: { data: _vm.simulation } })], 1)\n      : _vm._e()\n  ])\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n\n//# sourceURL=webpack:///./src/js/components/results.vue?./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/runner.vue?vue&type=template&id=4b4e0edc&":
/*!***************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/runner.vue?vue&type=template&id=4b4e0edc& ***!
  \***************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return staticRenderFns; });\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\", [\n    _c(\n      \"button\",\n      {\n        staticClass: \"btn btn-red\",\n        attrs: { disabled: _vm.running || !_vm.inputs },\n        on: { click: _vm.run }\n      },\n      [_vm._v(\"Run model\")]\n    ),\n    _vm._v(\" \"),\n    _vm.error.length > 0\n      ? _c(\"div\", { staticClass: \"alert alert-danger mt-3\" }, [\n          _vm._v(\"\\n        \" + _vm._s(_vm.error) + \"\\n    \")\n        ])\n      : _vm._e()\n  ])\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n\n//# sourceURL=webpack:///./src/js/components/runner.vue?./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/status.vue?vue&type=template&id=84b662c4&":
/*!***************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/status.vue?vue&type=template&id=84b662c4& ***!
  \***************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return staticRenderFns; });\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\", [\n    _vm.runId && _vm.interval\n      ? _c(\"div\", [_vm._v(\"\\n        Running model...\\n    \")])\n      : _vm._e(),\n    _vm._v(\" \"),\n    _vm.error.length > 0\n      ? _c(\"div\", { staticClass: \"alert alert-danger mt-3\" }, [\n          _vm._v(\"\\n        \" + _vm._s(_vm.error) + \"\\n    \")\n        ])\n      : _vm._e()\n  ])\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n\n//# sourceURL=webpack:///./src/js/components/status.vue?./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js":
/*!********************************************************************!*\
  !*** ./node_modules/vue-loader/lib/runtime/componentNormalizer.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return normalizeComponent; });\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nfunction normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/vue-loader/lib/runtime/componentNormalizer.js?");

/***/ }),

/***/ "./node_modules/vue/dist/vue.js":
/*!**************************************!*\
  !*** ./node_modules/vue/dist/vue.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, setImmediate) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n * Vue.js v2.6.10\n * (c) 2014-2019 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);\n})(this, function () {\n  'use strict';\n  /*  */\n\n  var emptyObject = Object.freeze({}); // These helpers produce better VM code in JS engines due to their\n  // explicitness and function inlining.\n\n  function isUndef(v) {\n    return v === undefined || v === null;\n  }\n\n  function isDef(v) {\n    return v !== undefined && v !== null;\n  }\n\n  function isTrue(v) {\n    return v === true;\n  }\n\n  function isFalse(v) {\n    return v === false;\n  }\n  /**\n   * Check if value is primitive.\n   */\n\n\n  function isPrimitive(value) {\n    return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line\n    _typeof(value) === 'symbol' || typeof value === 'boolean';\n  }\n  /**\n   * Quick object check - this is primarily used to tell\n   * Objects from primitive values when we know the value\n   * is a JSON-compliant type.\n   */\n\n\n  function isObject(obj) {\n    return obj !== null && _typeof(obj) === 'object';\n  }\n  /**\n   * Get the raw type string of a value, e.g., [object Object].\n   */\n\n\n  var _toString = Object.prototype.toString;\n\n  function toRawType(value) {\n    return _toString.call(value).slice(8, -1);\n  }\n  /**\n   * Strict object type check. Only returns true\n   * for plain JavaScript objects.\n   */\n\n\n  function isPlainObject(obj) {\n    return _toString.call(obj) === '[object Object]';\n  }\n\n  function isRegExp(v) {\n    return _toString.call(v) === '[object RegExp]';\n  }\n  /**\n   * Check if val is a valid array index.\n   */\n\n\n  function isValidArrayIndex(val) {\n    var n = parseFloat(String(val));\n    return n >= 0 && Math.floor(n) === n && isFinite(val);\n  }\n\n  function isPromise(val) {\n    return isDef(val) && typeof val.then === 'function' && typeof val[\"catch\"] === 'function';\n  }\n  /**\n   * Convert a value to a string that is actually rendered.\n   */\n\n\n  function toString(val) {\n    return val == null ? '' : Array.isArray(val) || isPlainObject(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);\n  }\n  /**\n   * Convert an input value to a number for persistence.\n   * If the conversion fails, return original string.\n   */\n\n\n  function toNumber(val) {\n    var n = parseFloat(val);\n    return isNaN(n) ? val : n;\n  }\n  /**\n   * Make a map and return a function for checking if a key\n   * is in that map.\n   */\n\n\n  function makeMap(str, expectsLowerCase) {\n    var map = Object.create(null);\n    var list = str.split(',');\n\n    for (var i = 0; i < list.length; i++) {\n      map[list[i]] = true;\n    }\n\n    return expectsLowerCase ? function (val) {\n      return map[val.toLowerCase()];\n    } : function (val) {\n      return map[val];\n    };\n  }\n  /**\n   * Check if a tag is a built-in tag.\n   */\n\n\n  var isBuiltInTag = makeMap('slot,component', true);\n  /**\n   * Check if an attribute is a reserved attribute.\n   */\n\n  var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n  /**\n   * Remove an item from an array.\n   */\n\n  function remove(arr, item) {\n    if (arr.length) {\n      var index = arr.indexOf(item);\n\n      if (index > -1) {\n        return arr.splice(index, 1);\n      }\n    }\n  }\n  /**\n   * Check whether an object has the property.\n   */\n\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  function hasOwn(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  }\n  /**\n   * Create a cached version of a pure function.\n   */\n\n\n  function cached(fn) {\n    var cache = Object.create(null);\n    return function cachedFn(str) {\n      var hit = cache[str];\n      return hit || (cache[str] = fn(str));\n    };\n  }\n  /**\n   * Camelize a hyphen-delimited string.\n   */\n\n\n  var camelizeRE = /-(\\w)/g;\n  var camelize = cached(function (str) {\n    return str.replace(camelizeRE, function (_, c) {\n      return c ? c.toUpperCase() : '';\n    });\n  });\n  /**\n   * Capitalize a string.\n   */\n\n  var capitalize = cached(function (str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  });\n  /**\n   * Hyphenate a camelCase string.\n   */\n\n  var hyphenateRE = /\\B([A-Z])/g;\n  var hyphenate = cached(function (str) {\n    return str.replace(hyphenateRE, '-$1').toLowerCase();\n  });\n  /**\n   * Simple bind polyfill for environments that do not support it,\n   * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n   * since native bind is now performant enough in most browsers.\n   * But removing it would mean breaking code that was able to run in\n   * PhantomJS 1.x, so this must be kept for backward compatibility.\n   */\n\n  /* istanbul ignore next */\n\n  function polyfillBind(fn, ctx) {\n    function boundFn(a) {\n      var l = arguments.length;\n      return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n    }\n\n    boundFn._length = fn.length;\n    return boundFn;\n  }\n\n  function nativeBind(fn, ctx) {\n    return fn.bind(ctx);\n  }\n\n  var bind = Function.prototype.bind ? nativeBind : polyfillBind;\n  /**\n   * Convert an Array-like object to a real Array.\n   */\n\n  function toArray(list, start) {\n    start = start || 0;\n    var i = list.length - start;\n    var ret = new Array(i);\n\n    while (i--) {\n      ret[i] = list[i + start];\n    }\n\n    return ret;\n  }\n  /**\n   * Mix properties into target object.\n   */\n\n\n  function extend(to, _from) {\n    for (var key in _from) {\n      to[key] = _from[key];\n    }\n\n    return to;\n  }\n  /**\n   * Merge an Array of Objects into a single Object.\n   */\n\n\n  function toObject(arr) {\n    var res = {};\n\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i]) {\n        extend(res, arr[i]);\n      }\n    }\n\n    return res;\n  }\n  /* eslint-disable no-unused-vars */\n\n  /**\n   * Perform no operation.\n   * Stubbing args to make Flow happy without leaving useless transpiled code\n   * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n   */\n\n\n  function noop(a, b, c) {}\n  /**\n   * Always return false.\n   */\n\n\n  var no = function no(a, b, c) {\n    return false;\n  };\n  /* eslint-enable no-unused-vars */\n\n  /**\n   * Return the same value.\n   */\n\n\n  var identity = function identity(_) {\n    return _;\n  };\n  /**\n   * Generate a string containing static keys from compiler modules.\n   */\n\n\n  function genStaticKeys(modules) {\n    return modules.reduce(function (keys, m) {\n      return keys.concat(m.staticKeys || []);\n    }, []).join(',');\n  }\n  /**\n   * Check if two values are loosely equal - that is,\n   * if they are plain objects, do they have the same shape?\n   */\n\n\n  function looseEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n\n    var isObjectA = isObject(a);\n    var isObjectB = isObject(b);\n\n    if (isObjectA && isObjectB) {\n      try {\n        var isArrayA = Array.isArray(a);\n        var isArrayB = Array.isArray(b);\n\n        if (isArrayA && isArrayB) {\n          return a.length === b.length && a.every(function (e, i) {\n            return looseEqual(e, b[i]);\n          });\n        } else if (a instanceof Date && b instanceof Date) {\n          return a.getTime() === b.getTime();\n        } else if (!isArrayA && !isArrayB) {\n          var keysA = Object.keys(a);\n          var keysB = Object.keys(b);\n          return keysA.length === keysB.length && keysA.every(function (key) {\n            return looseEqual(a[key], b[key]);\n          });\n        } else {\n          /* istanbul ignore next */\n          return false;\n        }\n      } catch (e) {\n        /* istanbul ignore next */\n        return false;\n      }\n    } else if (!isObjectA && !isObjectB) {\n      return String(a) === String(b);\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Return the first index at which a loosely equal value can be\n   * found in the array (if value is a plain object, the array must\n   * contain an object of the same shape), or -1 if it is not present.\n   */\n\n\n  function looseIndexOf(arr, val) {\n    for (var i = 0; i < arr.length; i++) {\n      if (looseEqual(arr[i], val)) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Ensure a function is called only once.\n   */\n\n\n  function once(fn) {\n    var called = false;\n    return function () {\n      if (!called) {\n        called = true;\n        fn.apply(this, arguments);\n      }\n    };\n  }\n\n  var SSR_ATTR = 'data-server-rendered';\n  var ASSET_TYPES = ['component', 'directive', 'filter'];\n  var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'];\n  /*  */\n\n  var config = {\n    /**\n     * Option merge strategies (used in core/util/options)\n     */\n    // $flow-disable-line\n    optionMergeStrategies: Object.create(null),\n\n    /**\n     * Whether to suppress warnings.\n     */\n    silent: false,\n\n    /**\n     * Show production mode tip message on boot?\n     */\n    productionTip: \"development\" !== 'production',\n\n    /**\n     * Whether to enable devtools\n     */\n    devtools: \"development\" !== 'production',\n\n    /**\n     * Whether to record perf\n     */\n    performance: false,\n\n    /**\n     * Error handler for watcher errors\n     */\n    errorHandler: null,\n\n    /**\n     * Warn handler for watcher warns\n     */\n    warnHandler: null,\n\n    /**\n     * Ignore certain custom elements\n     */\n    ignoredElements: [],\n\n    /**\n     * Custom user key aliases for v-on\n     */\n    // $flow-disable-line\n    keyCodes: Object.create(null),\n\n    /**\n     * Check if a tag is reserved so that it cannot be registered as a\n     * component. This is platform-dependent and may be overwritten.\n     */\n    isReservedTag: no,\n\n    /**\n     * Check if an attribute is reserved so that it cannot be used as a component\n     * prop. This is platform-dependent and may be overwritten.\n     */\n    isReservedAttr: no,\n\n    /**\n     * Check if a tag is an unknown element.\n     * Platform-dependent.\n     */\n    isUnknownElement: no,\n\n    /**\n     * Get the namespace of an element\n     */\n    getTagNamespace: noop,\n\n    /**\n     * Parse the real tag name for the specific platform.\n     */\n    parsePlatformTagName: identity,\n\n    /**\n     * Check if an attribute must be bound using property, e.g. value\n     * Platform-dependent.\n     */\n    mustUseProp: no,\n\n    /**\n     * Perform updates asynchronously. Intended to be used by Vue Test Utils\n     * This will significantly reduce performance if set to false.\n     */\n    async: true,\n\n    /**\n     * Exposed for legacy reasons\n     */\n    _lifecycleHooks: LIFECYCLE_HOOKS\n  };\n  /*  */\n\n  /**\n   * unicode letters used for parsing html tags, component names and property paths.\n   * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n   * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n   */\n\n  var unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n  /**\n   * Check if a string starts with $ or _\n   */\n\n  function isReserved(str) {\n    var c = (str + '').charCodeAt(0);\n    return c === 0x24 || c === 0x5F;\n  }\n  /**\n   * Define a property.\n   */\n\n\n  function def(obj, key, val, enumerable) {\n    Object.defineProperty(obj, key, {\n      value: val,\n      enumerable: !!enumerable,\n      writable: true,\n      configurable: true\n    });\n  }\n  /**\n   * Parse simple path.\n   */\n\n\n  var bailRE = new RegExp(\"[^\" + unicodeRegExp.source + \".$_\\\\d]\");\n\n  function parsePath(path) {\n    if (bailRE.test(path)) {\n      return;\n    }\n\n    var segments = path.split('.');\n    return function (obj) {\n      for (var i = 0; i < segments.length; i++) {\n        if (!obj) {\n          return;\n        }\n\n        obj = obj[segments[i]];\n      }\n\n      return obj;\n    };\n  }\n  /*  */\n  // can we use __proto__?\n\n\n  var hasProto = '__proto__' in {}; // Browser environment sniffing\n\n  var inBrowser = typeof window !== 'undefined';\n  var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\n  var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\n  var UA = inBrowser && window.navigator.userAgent.toLowerCase();\n  var isIE = UA && /msie|trident/.test(UA);\n  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;\n  var isEdge = UA && UA.indexOf('edge/') > 0;\n  var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';\n  var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';\n  var isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n  var isPhantomJS = UA && /phantomjs/.test(UA);\n  var isFF = UA && UA.match(/firefox\\/(\\d+)/); // Firefox has a \"watch\" function on Object.prototype...\n\n  var nativeWatch = {}.watch;\n  var supportsPassive = false;\n\n  if (inBrowser) {\n    try {\n      var opts = {};\n      Object.defineProperty(opts, 'passive', {\n        get: function get() {\n          /* istanbul ignore next */\n          supportsPassive = true;\n        }\n      }); // https://github.com/facebook/flow/issues/285\n\n      window.addEventListener('test-passive', null, opts);\n    } catch (e) {}\n  } // this needs to be lazy-evaled because vue may be required before\n  // vue-server-renderer can set VUE_ENV\n\n\n  var _isServer;\n\n  var isServerRendering = function isServerRendering() {\n    if (_isServer === undefined) {\n      /* istanbul ignore if */\n      if (!inBrowser && !inWeex && typeof global !== 'undefined') {\n        // detect presence of vue-server-renderer and avoid\n        // Webpack shimming the process\n        _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';\n      } else {\n        _isServer = false;\n      }\n    }\n\n    return _isServer;\n  }; // detect devtools\n\n\n  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n  /* istanbul ignore next */\n\n  function isNative(Ctor) {\n    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());\n  }\n\n  var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n  var _Set;\n  /* istanbul ignore if */\n  // $flow-disable-line\n\n\n  if (typeof Set !== 'undefined' && isNative(Set)) {\n    // use native Set when available.\n    _Set = Set;\n  } else {\n    // a non-standard Set polyfill that only works with primitive keys.\n    _Set =\n    /*@__PURE__*/\n    function () {\n      function Set() {\n        this.set = Object.create(null);\n      }\n\n      Set.prototype.has = function has(key) {\n        return this.set[key] === true;\n      };\n\n      Set.prototype.add = function add(key) {\n        this.set[key] = true;\n      };\n\n      Set.prototype.clear = function clear() {\n        this.set = Object.create(null);\n      };\n\n      return Set;\n    }();\n  }\n  /*  */\n\n\n  var warn = noop;\n  var tip = noop;\n  var generateComponentTrace = noop; // work around flow check\n\n  var formatComponentName = noop;\n  {\n    var hasConsole = typeof console !== 'undefined';\n    var classifyRE = /(?:^|[-_])(\\w)/g;\n\n    var classify = function classify(str) {\n      return str.replace(classifyRE, function (c) {\n        return c.toUpperCase();\n      }).replace(/[-_]/g, '');\n    };\n\n    warn = function warn(msg, vm) {\n      var trace = vm ? generateComponentTrace(vm) : '';\n\n      if (config.warnHandler) {\n        config.warnHandler.call(null, msg, vm, trace);\n      } else if (hasConsole && !config.silent) {\n        console.error(\"[Vue warn]: \" + msg + trace);\n      }\n    };\n\n    tip = function tip(msg, vm) {\n      if (hasConsole && !config.silent) {\n        console.warn(\"[Vue tip]: \" + msg + (vm ? generateComponentTrace(vm) : ''));\n      }\n    };\n\n    formatComponentName = function formatComponentName(vm, includeFile) {\n      if (vm.$root === vm) {\n        return '<Root>';\n      }\n\n      var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;\n      var name = options.name || options._componentTag;\n      var file = options.__file;\n\n      if (!name && file) {\n        var match = file.match(/([^/\\\\]+)\\.vue$/);\n        name = match && match[1];\n      }\n\n      return (name ? \"<\" + classify(name) + \">\" : \"<Anonymous>\") + (file && includeFile !== false ? \" at \" + file : '');\n    };\n\n    var repeat = function repeat(str, n) {\n      var res = '';\n\n      while (n) {\n        if (n % 2 === 1) {\n          res += str;\n        }\n\n        if (n > 1) {\n          str += str;\n        }\n\n        n >>= 1;\n      }\n\n      return res;\n    };\n\n    generateComponentTrace = function generateComponentTrace(vm) {\n      if (vm._isVue && vm.$parent) {\n        var tree = [];\n        var currentRecursiveSequence = 0;\n\n        while (vm) {\n          if (tree.length > 0) {\n            var last = tree[tree.length - 1];\n\n            if (last.constructor === vm.constructor) {\n              currentRecursiveSequence++;\n              vm = vm.$parent;\n              continue;\n            } else if (currentRecursiveSequence > 0) {\n              tree[tree.length - 1] = [last, currentRecursiveSequence];\n              currentRecursiveSequence = 0;\n            }\n          }\n\n          tree.push(vm);\n          vm = vm.$parent;\n        }\n\n        return '\\n\\nfound in\\n\\n' + tree.map(function (vm, i) {\n          return \"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + \"... (\" + vm[1] + \" recursive calls)\" : formatComponentName(vm));\n        }).join('\\n');\n      } else {\n        return \"\\n\\n(found in \" + formatComponentName(vm) + \")\";\n      }\n    };\n  }\n  /*  */\n\n  var uid = 0;\n  /**\n   * A dep is an observable that can have multiple\n   * directives subscribing to it.\n   */\n\n  var Dep = function Dep() {\n    this.id = uid++;\n    this.subs = [];\n  };\n\n  Dep.prototype.addSub = function addSub(sub) {\n    this.subs.push(sub);\n  };\n\n  Dep.prototype.removeSub = function removeSub(sub) {\n    remove(this.subs, sub);\n  };\n\n  Dep.prototype.depend = function depend() {\n    if (Dep.target) {\n      Dep.target.addDep(this);\n    }\n  };\n\n  Dep.prototype.notify = function notify() {\n    // stabilize the subscriber list first\n    var subs = this.subs.slice();\n\n    if (!config.async) {\n      // subs aren't sorted in scheduler if not running async\n      // we need to sort them now to make sure they fire in correct\n      // order\n      subs.sort(function (a, b) {\n        return a.id - b.id;\n      });\n    }\n\n    for (var i = 0, l = subs.length; i < l; i++) {\n      subs[i].update();\n    }\n  }; // The current target watcher being evaluated.\n  // This is globally unique because only one watcher\n  // can be evaluated at a time.\n\n\n  Dep.target = null;\n  var targetStack = [];\n\n  function pushTarget(target) {\n    targetStack.push(target);\n    Dep.target = target;\n  }\n\n  function popTarget() {\n    targetStack.pop();\n    Dep.target = targetStack[targetStack.length - 1];\n  }\n  /*  */\n\n\n  var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {\n    this.tag = tag;\n    this.data = data;\n    this.children = children;\n    this.text = text;\n    this.elm = elm;\n    this.ns = undefined;\n    this.context = context;\n    this.fnContext = undefined;\n    this.fnOptions = undefined;\n    this.fnScopeId = undefined;\n    this.key = data && data.key;\n    this.componentOptions = componentOptions;\n    this.componentInstance = undefined;\n    this.parent = undefined;\n    this.raw = false;\n    this.isStatic = false;\n    this.isRootInsert = true;\n    this.isComment = false;\n    this.isCloned = false;\n    this.isOnce = false;\n    this.asyncFactory = asyncFactory;\n    this.asyncMeta = undefined;\n    this.isAsyncPlaceholder = false;\n  };\n\n  var prototypeAccessors = {\n    child: {\n      configurable: true\n    }\n  }; // DEPRECATED: alias for componentInstance for backwards compat.\n\n  /* istanbul ignore next */\n\n  prototypeAccessors.child.get = function () {\n    return this.componentInstance;\n  };\n\n  Object.defineProperties(VNode.prototype, prototypeAccessors);\n\n  var createEmptyVNode = function createEmptyVNode(text) {\n    if (text === void 0) text = '';\n    var node = new VNode();\n    node.text = text;\n    node.isComment = true;\n    return node;\n  };\n\n  function createTextVNode(val) {\n    return new VNode(undefined, undefined, undefined, String(val));\n  } // optimized shallow clone\n  // used for static nodes and slot nodes because they may be reused across\n  // multiple renders, cloning them avoids errors when DOM manipulations rely\n  // on their elm reference.\n\n\n  function cloneVNode(vnode) {\n    var cloned = new VNode(vnode.tag, vnode.data, // #7975\n    // clone children array to avoid mutating original in case of cloning\n    // a child.\n    vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);\n    cloned.ns = vnode.ns;\n    cloned.isStatic = vnode.isStatic;\n    cloned.key = vnode.key;\n    cloned.isComment = vnode.isComment;\n    cloned.fnContext = vnode.fnContext;\n    cloned.fnOptions = vnode.fnOptions;\n    cloned.fnScopeId = vnode.fnScopeId;\n    cloned.asyncMeta = vnode.asyncMeta;\n    cloned.isCloned = true;\n    return cloned;\n  }\n  /*\n   * not type checking this file because flow doesn't play well with\n   * dynamically accessing methods on Array prototype\n   */\n\n\n  var arrayProto = Array.prototype;\n  var arrayMethods = Object.create(arrayProto);\n  var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];\n  /**\n   * Intercept mutating methods and emit events\n   */\n\n  methodsToPatch.forEach(function (method) {\n    // cache original method\n    var original = arrayProto[method];\n    def(arrayMethods, method, function mutator() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      var result = original.apply(this, args);\n      var ob = this.__ob__;\n      var inserted;\n\n      switch (method) {\n        case 'push':\n        case 'unshift':\n          inserted = args;\n          break;\n\n        case 'splice':\n          inserted = args.slice(2);\n          break;\n      }\n\n      if (inserted) {\n        ob.observeArray(inserted);\n      } // notify change\n\n\n      ob.dep.notify();\n      return result;\n    });\n  });\n  /*  */\n\n  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n  /**\n   * In some cases we may want to disable observation inside a component's\n   * update computation.\n   */\n\n  var shouldObserve = true;\n\n  function toggleObserving(value) {\n    shouldObserve = value;\n  }\n  /**\n   * Observer class that is attached to each observed\n   * object. Once attached, the observer converts the target\n   * object's property keys into getter/setters that\n   * collect dependencies and dispatch updates.\n   */\n\n\n  var Observer = function Observer(value) {\n    this.value = value;\n    this.dep = new Dep();\n    this.vmCount = 0;\n    def(value, '__ob__', this);\n\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods);\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys);\n      }\n\n      this.observeArray(value);\n    } else {\n      this.walk(value);\n    }\n  };\n  /**\n   * Walk through all properties and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n\n\n  Observer.prototype.walk = function walk(obj) {\n    var keys = Object.keys(obj);\n\n    for (var i = 0; i < keys.length; i++) {\n      defineReactive$$1(obj, keys[i]);\n    }\n  };\n  /**\n   * Observe a list of Array items.\n   */\n\n\n  Observer.prototype.observeArray = function observeArray(items) {\n    for (var i = 0, l = items.length; i < l; i++) {\n      observe(items[i]);\n    }\n  }; // helpers\n\n  /**\n   * Augment a target Object or Array by intercepting\n   * the prototype chain using __proto__\n   */\n\n\n  function protoAugment(target, src) {\n    /* eslint-disable no-proto */\n    target.__proto__ = src;\n    /* eslint-enable no-proto */\n  }\n  /**\n   * Augment a target Object or Array by defining\n   * hidden properties.\n   */\n\n  /* istanbul ignore next */\n\n\n  function copyAugment(target, src, keys) {\n    for (var i = 0, l = keys.length; i < l; i++) {\n      var key = keys[i];\n      def(target, key, src[key]);\n    }\n  }\n  /**\n   * Attempt to create an observer instance for a value,\n   * returns the new observer if successfully observed,\n   * or the existing observer if the value already has one.\n   */\n\n\n  function observe(value, asRootData) {\n    if (!isObject(value) || value instanceof VNode) {\n      return;\n    }\n\n    var ob;\n\n    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n      ob = value.__ob__;\n    } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n      ob = new Observer(value);\n    }\n\n    if (asRootData && ob) {\n      ob.vmCount++;\n    }\n\n    return ob;\n  }\n  /**\n   * Define a reactive property on an Object.\n   */\n\n\n  function defineReactive$$1(obj, key, val, customSetter, shallow) {\n    var dep = new Dep();\n    var property = Object.getOwnPropertyDescriptor(obj, key);\n\n    if (property && property.configurable === false) {\n      return;\n    } // cater for pre-defined getter/setters\n\n\n    var getter = property && property.get;\n    var setter = property && property.set;\n\n    if ((!getter || setter) && arguments.length === 2) {\n      val = obj[key];\n    }\n\n    var childOb = !shallow && observe(val);\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      configurable: true,\n      get: function reactiveGetter() {\n        var value = getter ? getter.call(obj) : val;\n\n        if (Dep.target) {\n          dep.depend();\n\n          if (childOb) {\n            childOb.dep.depend();\n\n            if (Array.isArray(value)) {\n              dependArray(value);\n            }\n          }\n        }\n\n        return value;\n      },\n      set: function reactiveSetter(newVal) {\n        var value = getter ? getter.call(obj) : val;\n        /* eslint-disable no-self-compare */\n\n        if (newVal === value || newVal !== newVal && value !== value) {\n          return;\n        }\n        /* eslint-enable no-self-compare */\n\n\n        if (customSetter) {\n          customSetter();\n        } // #7981: for accessor properties without setter\n\n\n        if (getter && !setter) {\n          return;\n        }\n\n        if (setter) {\n          setter.call(obj, newVal);\n        } else {\n          val = newVal;\n        }\n\n        childOb = !shallow && observe(newVal);\n        dep.notify();\n      }\n    });\n  }\n  /**\n   * Set a property on an object. Adds the new property and\n   * triggers change notification if the property doesn't\n   * already exist.\n   */\n\n\n  function set(target, key, val) {\n    if (isUndef(target) || isPrimitive(target)) {\n      warn(\"Cannot set reactive property on undefined, null, or primitive value: \" + target);\n    }\n\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.length = Math.max(target.length, key);\n      target.splice(key, 1, val);\n      return val;\n    }\n\n    if (key in target && !(key in Object.prototype)) {\n      target[key] = val;\n      return val;\n    }\n\n    var ob = target.__ob__;\n\n    if (target._isVue || ob && ob.vmCount) {\n      warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');\n      return val;\n    }\n\n    if (!ob) {\n      target[key] = val;\n      return val;\n    }\n\n    defineReactive$$1(ob.value, key, val);\n    ob.dep.notify();\n    return val;\n  }\n  /**\n   * Delete a property and trigger change if necessary.\n   */\n\n\n  function del(target, key) {\n    if (isUndef(target) || isPrimitive(target)) {\n      warn(\"Cannot delete reactive property on undefined, null, or primitive value: \" + target);\n    }\n\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.splice(key, 1);\n      return;\n    }\n\n    var ob = target.__ob__;\n\n    if (target._isVue || ob && ob.vmCount) {\n      warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');\n      return;\n    }\n\n    if (!hasOwn(target, key)) {\n      return;\n    }\n\n    delete target[key];\n\n    if (!ob) {\n      return;\n    }\n\n    ob.dep.notify();\n  }\n  /**\n   * Collect dependencies on array elements when the array is touched, since\n   * we cannot intercept array element access like property getters.\n   */\n\n\n  function dependArray(value) {\n    for (var e = void 0, i = 0, l = value.length; i < l; i++) {\n      e = value[i];\n      e && e.__ob__ && e.__ob__.dep.depend();\n\n      if (Array.isArray(e)) {\n        dependArray(e);\n      }\n    }\n  }\n  /*  */\n\n  /**\n   * Option overwriting strategies are functions that handle\n   * how to merge a parent option value and a child option\n   * value into the final value.\n   */\n\n\n  var strats = config.optionMergeStrategies;\n  /**\n   * Options with restrictions\n   */\n\n  {\n    strats.el = strats.propsData = function (parent, child, vm, key) {\n      if (!vm) {\n        warn(\"option \\\"\" + key + \"\\\" can only be used during instance \" + 'creation with the `new` keyword.');\n      }\n\n      return defaultStrat(parent, child);\n    };\n  }\n  /**\n   * Helper that recursively merges two data objects together.\n   */\n\n  function mergeData(to, from) {\n    if (!from) {\n      return to;\n    }\n\n    var key, toVal, fromVal;\n    var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);\n\n    for (var i = 0; i < keys.length; i++) {\n      key = keys[i]; // in case the object is already observed...\n\n      if (key === '__ob__') {\n        continue;\n      }\n\n      toVal = to[key];\n      fromVal = from[key];\n\n      if (!hasOwn(to, key)) {\n        set(to, key, fromVal);\n      } else if (toVal !== fromVal && isPlainObject(toVal) && isPlainObject(fromVal)) {\n        mergeData(toVal, fromVal);\n      }\n    }\n\n    return to;\n  }\n  /**\n   * Data\n   */\n\n\n  function mergeDataOrFn(parentVal, childVal, vm) {\n    if (!vm) {\n      // in a Vue.extend merge, both should be functions\n      if (!childVal) {\n        return parentVal;\n      }\n\n      if (!parentVal) {\n        return childVal;\n      } // when parentVal & childVal are both present,\n      // we need to return a function that returns the\n      // merged result of both functions... no need to\n      // check if parentVal is a function here because\n      // it has to be a function to pass previous merges.\n\n\n      return function mergedDataFn() {\n        return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);\n      };\n    } else {\n      return function mergedInstanceDataFn() {\n        // instance merge\n        var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;\n        var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;\n\n        if (instanceData) {\n          return mergeData(instanceData, defaultData);\n        } else {\n          return defaultData;\n        }\n      };\n    }\n  }\n\n  strats.data = function (parentVal, childVal, vm) {\n    if (!vm) {\n      if (childVal && typeof childVal !== 'function') {\n        warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n        return parentVal;\n      }\n\n      return mergeDataOrFn(parentVal, childVal);\n    }\n\n    return mergeDataOrFn(parentVal, childVal, vm);\n  };\n  /**\n   * Hooks and props are merged as arrays.\n   */\n\n\n  function mergeHook(parentVal, childVal) {\n    var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;\n    return res ? dedupeHooks(res) : res;\n  }\n\n  function dedupeHooks(hooks) {\n    var res = [];\n\n    for (var i = 0; i < hooks.length; i++) {\n      if (res.indexOf(hooks[i]) === -1) {\n        res.push(hooks[i]);\n      }\n    }\n\n    return res;\n  }\n\n  LIFECYCLE_HOOKS.forEach(function (hook) {\n    strats[hook] = mergeHook;\n  });\n  /**\n   * Assets\n   *\n   * When a vm is present (instance creation), we need to do\n   * a three-way merge between constructor options, instance\n   * options and parent options.\n   */\n\n  function mergeAssets(parentVal, childVal, vm, key) {\n    var res = Object.create(parentVal || null);\n\n    if (childVal) {\n      assertObjectType(key, childVal, vm);\n      return extend(res, childVal);\n    } else {\n      return res;\n    }\n  }\n\n  ASSET_TYPES.forEach(function (type) {\n    strats[type + 's'] = mergeAssets;\n  });\n  /**\n   * Watchers.\n   *\n   * Watchers hashes should not overwrite one\n   * another, so we merge them as arrays.\n   */\n\n  strats.watch = function (parentVal, childVal, vm, key) {\n    // work around Firefox's Object.prototype.watch...\n    if (parentVal === nativeWatch) {\n      parentVal = undefined;\n    }\n\n    if (childVal === nativeWatch) {\n      childVal = undefined;\n    }\n    /* istanbul ignore if */\n\n\n    if (!childVal) {\n      return Object.create(parentVal || null);\n    }\n\n    {\n      assertObjectType(key, childVal, vm);\n    }\n\n    if (!parentVal) {\n      return childVal;\n    }\n\n    var ret = {};\n    extend(ret, parentVal);\n\n    for (var key$1 in childVal) {\n      var parent = ret[key$1];\n      var child = childVal[key$1];\n\n      if (parent && !Array.isArray(parent)) {\n        parent = [parent];\n      }\n\n      ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];\n    }\n\n    return ret;\n  };\n  /**\n   * Other object hashes.\n   */\n\n\n  strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {\n    if (childVal && \"development\" !== 'production') {\n      assertObjectType(key, childVal, vm);\n    }\n\n    if (!parentVal) {\n      return childVal;\n    }\n\n    var ret = Object.create(null);\n    extend(ret, parentVal);\n\n    if (childVal) {\n      extend(ret, childVal);\n    }\n\n    return ret;\n  };\n\n  strats.provide = mergeDataOrFn;\n  /**\n   * Default strategy.\n   */\n\n  var defaultStrat = function defaultStrat(parentVal, childVal) {\n    return childVal === undefined ? parentVal : childVal;\n  };\n  /**\n   * Validate component names\n   */\n\n\n  function checkComponents(options) {\n    for (var key in options.components) {\n      validateComponentName(key);\n    }\n  }\n\n  function validateComponentName(name) {\n    if (!new RegExp(\"^[a-zA-Z][\\\\-\\\\.0-9_\" + unicodeRegExp.source + \"]*$\").test(name)) {\n      warn('Invalid component name: \"' + name + '\". Component names ' + 'should conform to valid custom element name in html5 specification.');\n    }\n\n    if (isBuiltInTag(name) || config.isReservedTag(name)) {\n      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);\n    }\n  }\n  /**\n   * Ensure all props option syntax are normalized into the\n   * Object-based format.\n   */\n\n\n  function normalizeProps(options, vm) {\n    var props = options.props;\n\n    if (!props) {\n      return;\n    }\n\n    var res = {};\n    var i, val, name;\n\n    if (Array.isArray(props)) {\n      i = props.length;\n\n      while (i--) {\n        val = props[i];\n\n        if (typeof val === 'string') {\n          name = camelize(val);\n          res[name] = {\n            type: null\n          };\n        } else {\n          warn('props must be strings when using array syntax.');\n        }\n      }\n    } else if (isPlainObject(props)) {\n      for (var key in props) {\n        val = props[key];\n        name = camelize(key);\n        res[name] = isPlainObject(val) ? val : {\n          type: val\n        };\n      }\n    } else {\n      warn(\"Invalid value for option \\\"props\\\": expected an Array or an Object, \" + \"but got \" + toRawType(props) + \".\", vm);\n    }\n\n    options.props = res;\n  }\n  /**\n   * Normalize all injections into Object-based format\n   */\n\n\n  function normalizeInject(options, vm) {\n    var inject = options.inject;\n\n    if (!inject) {\n      return;\n    }\n\n    var normalized = options.inject = {};\n\n    if (Array.isArray(inject)) {\n      for (var i = 0; i < inject.length; i++) {\n        normalized[inject[i]] = {\n          from: inject[i]\n        };\n      }\n    } else if (isPlainObject(inject)) {\n      for (var key in inject) {\n        var val = inject[key];\n        normalized[key] = isPlainObject(val) ? extend({\n          from: key\n        }, val) : {\n          from: val\n        };\n      }\n    } else {\n      warn(\"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" + \"but got \" + toRawType(inject) + \".\", vm);\n    }\n  }\n  /**\n   * Normalize raw function directives into object format.\n   */\n\n\n  function normalizeDirectives(options) {\n    var dirs = options.directives;\n\n    if (dirs) {\n      for (var key in dirs) {\n        var def$$1 = dirs[key];\n\n        if (typeof def$$1 === 'function') {\n          dirs[key] = {\n            bind: def$$1,\n            update: def$$1\n          };\n        }\n      }\n    }\n  }\n\n  function assertObjectType(name, value, vm) {\n    if (!isPlainObject(value)) {\n      warn(\"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" + \"but got \" + toRawType(value) + \".\", vm);\n    }\n  }\n  /**\n   * Merge two option objects into a new one.\n   * Core utility used in both instantiation and inheritance.\n   */\n\n\n  function mergeOptions(parent, child, vm) {\n    {\n      checkComponents(child);\n    }\n\n    if (typeof child === 'function') {\n      child = child.options;\n    }\n\n    normalizeProps(child, vm);\n    normalizeInject(child, vm);\n    normalizeDirectives(child); // Apply extends and mixins on the child options,\n    // but only if it is a raw options object that isn't\n    // the result of another mergeOptions call.\n    // Only merged options has the _base property.\n\n    if (!child._base) {\n      if (child[\"extends\"]) {\n        parent = mergeOptions(parent, child[\"extends\"], vm);\n      }\n\n      if (child.mixins) {\n        for (var i = 0, l = child.mixins.length; i < l; i++) {\n          parent = mergeOptions(parent, child.mixins[i], vm);\n        }\n      }\n    }\n\n    var options = {};\n    var key;\n\n    for (key in parent) {\n      mergeField(key);\n    }\n\n    for (key in child) {\n      if (!hasOwn(parent, key)) {\n        mergeField(key);\n      }\n    }\n\n    function mergeField(key) {\n      var strat = strats[key] || defaultStrat;\n      options[key] = strat(parent[key], child[key], vm, key);\n    }\n\n    return options;\n  }\n  /**\n   * Resolve an asset.\n   * This function is used because child instances need access\n   * to assets defined in its ancestor chain.\n   */\n\n\n  function resolveAsset(options, type, id, warnMissing) {\n    /* istanbul ignore if */\n    if (typeof id !== 'string') {\n      return;\n    }\n\n    var assets = options[type]; // check local registration variations first\n\n    if (hasOwn(assets, id)) {\n      return assets[id];\n    }\n\n    var camelizedId = camelize(id);\n\n    if (hasOwn(assets, camelizedId)) {\n      return assets[camelizedId];\n    }\n\n    var PascalCaseId = capitalize(camelizedId);\n\n    if (hasOwn(assets, PascalCaseId)) {\n      return assets[PascalCaseId];\n    } // fallback to prototype chain\n\n\n    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n\n    if (warnMissing && !res) {\n      warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  function validateProp(key, propOptions, propsData, vm) {\n    var prop = propOptions[key];\n    var absent = !hasOwn(propsData, key);\n    var value = propsData[key]; // boolean casting\n\n    var booleanIndex = getTypeIndex(Boolean, prop.type);\n\n    if (booleanIndex > -1) {\n      if (absent && !hasOwn(prop, 'default')) {\n        value = false;\n      } else if (value === '' || value === hyphenate(key)) {\n        // only cast empty string / same name to boolean if\n        // boolean has higher priority\n        var stringIndex = getTypeIndex(String, prop.type);\n\n        if (stringIndex < 0 || booleanIndex < stringIndex) {\n          value = true;\n        }\n      }\n    } // check default value\n\n\n    if (value === undefined) {\n      value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,\n      // make sure to observe it.\n\n      var prevShouldObserve = shouldObserve;\n      toggleObserving(true);\n      observe(value);\n      toggleObserving(prevShouldObserve);\n    }\n\n    {\n      assertProp(prop, key, value, vm, absent);\n    }\n    return value;\n  }\n  /**\n   * Get the default value of a prop.\n   */\n\n\n  function getPropDefaultValue(vm, prop, key) {\n    // no default, return undefined\n    if (!hasOwn(prop, 'default')) {\n      return undefined;\n    }\n\n    var def = prop[\"default\"]; // warn against non-factory defaults for Object & Array\n\n    if (isObject(def)) {\n      warn('Invalid default value for prop \"' + key + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n    } // the raw prop value was also undefined from previous render,\n    // return previous default value to avoid unnecessary watcher trigger\n\n\n    if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {\n      return vm._props[key];\n    } // call factory function for non-Function types\n    // a value is Function if its prototype is function even across different execution context\n\n\n    return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;\n  }\n  /**\n   * Assert whether a prop is valid.\n   */\n\n\n  function assertProp(prop, name, value, vm, absent) {\n    if (prop.required && absent) {\n      warn('Missing required prop: \"' + name + '\"', vm);\n      return;\n    }\n\n    if (value == null && !prop.required) {\n      return;\n    }\n\n    var type = prop.type;\n    var valid = !type || type === true;\n    var expectedTypes = [];\n\n    if (type) {\n      if (!Array.isArray(type)) {\n        type = [type];\n      }\n\n      for (var i = 0; i < type.length && !valid; i++) {\n        var assertedType = assertType(value, type[i]);\n        expectedTypes.push(assertedType.expectedType || '');\n        valid = assertedType.valid;\n      }\n    }\n\n    if (!valid) {\n      warn(getInvalidTypeMessage(name, value, expectedTypes), vm);\n      return;\n    }\n\n    var validator = prop.validator;\n\n    if (validator) {\n      if (!validator(value)) {\n        warn('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\n      }\n    }\n  }\n\n  var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\n  function assertType(value, type) {\n    var valid;\n    var expectedType = getType(type);\n\n    if (simpleCheckRE.test(expectedType)) {\n      var t = _typeof(value);\n\n      valid = t === expectedType.toLowerCase(); // for primitive wrapper objects\n\n      if (!valid && t === 'object') {\n        valid = value instanceof type;\n      }\n    } else if (expectedType === 'Object') {\n      valid = isPlainObject(value);\n    } else if (expectedType === 'Array') {\n      valid = Array.isArray(value);\n    } else {\n      valid = value instanceof type;\n    }\n\n    return {\n      valid: valid,\n      expectedType: expectedType\n    };\n  }\n  /**\n   * Use function string name to check built-in types,\n   * because a simple equality check will fail when running\n   * across different vms / iframes.\n   */\n\n\n  function getType(fn) {\n    var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n    return match ? match[1] : '';\n  }\n\n  function isSameType(a, b) {\n    return getType(a) === getType(b);\n  }\n\n  function getTypeIndex(type, expectedTypes) {\n    if (!Array.isArray(expectedTypes)) {\n      return isSameType(expectedTypes, type) ? 0 : -1;\n    }\n\n    for (var i = 0, len = expectedTypes.length; i < len; i++) {\n      if (isSameType(expectedTypes[i], type)) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  function getInvalidTypeMessage(name, value, expectedTypes) {\n    var message = \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" + \" Expected \" + expectedTypes.map(capitalize).join(', ');\n    var expectedType = expectedTypes[0];\n    var receivedType = toRawType(value);\n    var expectedValue = styleValue(value, expectedType);\n    var receivedValue = styleValue(value, receivedType); // check if we need to specify expected value\n\n    if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {\n      message += \" with value \" + expectedValue;\n    }\n\n    message += \", got \" + receivedType + \" \"; // check if we need to specify received value\n\n    if (isExplicable(receivedType)) {\n      message += \"with value \" + receivedValue + \".\";\n    }\n\n    return message;\n  }\n\n  function styleValue(value, type) {\n    if (type === 'String') {\n      return \"\\\"\" + value + \"\\\"\";\n    } else if (type === 'Number') {\n      return \"\" + Number(value);\n    } else {\n      return \"\" + value;\n    }\n  }\n\n  function isExplicable(value) {\n    var explicitTypes = ['string', 'number', 'boolean'];\n    return explicitTypes.some(function (elem) {\n      return value.toLowerCase() === elem;\n    });\n  }\n\n  function isBoolean() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return args.some(function (elem) {\n      return elem.toLowerCase() === 'boolean';\n    });\n  }\n  /*  */\n\n\n  function handleError(err, vm, info) {\n    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n    // See: https://github.com/vuejs/vuex/issues/1505\n    pushTarget();\n\n    try {\n      if (vm) {\n        var cur = vm;\n\n        while (cur = cur.$parent) {\n          var hooks = cur.$options.errorCaptured;\n\n          if (hooks) {\n            for (var i = 0; i < hooks.length; i++) {\n              try {\n                var capture = hooks[i].call(cur, err, vm, info) === false;\n\n                if (capture) {\n                  return;\n                }\n              } catch (e) {\n                globalHandleError(e, cur, 'errorCaptured hook');\n              }\n            }\n          }\n        }\n      }\n\n      globalHandleError(err, vm, info);\n    } finally {\n      popTarget();\n    }\n  }\n\n  function invokeWithErrorHandling(handler, context, args, vm, info) {\n    var res;\n\n    try {\n      res = args ? handler.apply(context, args) : handler.call(context);\n\n      if (res && !res._isVue && isPromise(res) && !res._handled) {\n        res[\"catch\"](function (e) {\n          return handleError(e, vm, info + \" (Promise/async)\");\n        }); // issue #9511\n        // avoid catch triggering multiple times when nested calls\n\n        res._handled = true;\n      }\n    } catch (e) {\n      handleError(e, vm, info);\n    }\n\n    return res;\n  }\n\n  function globalHandleError(err, vm, info) {\n    if (config.errorHandler) {\n      try {\n        return config.errorHandler.call(null, err, vm, info);\n      } catch (e) {\n        // if the user intentionally throws the original error in the handler,\n        // do not log it twice\n        if (e !== err) {\n          logError(e, null, 'config.errorHandler');\n        }\n      }\n    }\n\n    logError(err, vm, info);\n  }\n\n  function logError(err, vm, info) {\n    {\n      warn(\"Error in \" + info + \": \\\"\" + err.toString() + \"\\\"\", vm);\n    }\n    /* istanbul ignore else */\n\n    if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err;\n    }\n  }\n  /*  */\n\n\n  var isUsingMicroTask = false;\n  var callbacks = [];\n  var pending = false;\n\n  function flushCallbacks() {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  } // Here we have async deferring wrappers using microtasks.\n  // In 2.5 we used (macro) tasks (in combination with microtasks).\n  // However, it has subtle problems when state is changed right before repaint\n  // (e.g. #6813, out-in transitions).\n  // Also, using (macro) tasks in event handler would cause some weird behaviors\n  // that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n  // So we now use microtasks everywhere, again.\n  // A major drawback of this tradeoff is that there are some scenarios\n  // where microtasks have too high a priority and fire in between supposedly\n  // sequential events (e.g. #4521, #6690, which have workarounds)\n  // or even between bubbling of the same event (#6566).\n\n\n  var timerFunc; // The nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n\n  /* istanbul ignore next, $flow-disable-line */\n\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n\n    timerFunc = function timerFunc() {\n      p.then(flushCallbacks); // In problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n\n      if (isIOS) {\n        setTimeout(noop);\n      }\n    };\n\n    isUsingMicroTask = true;\n  } else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) || // PhantomJS and iOS 7.x\n  MutationObserver.toString() === '[object MutationObserverConstructor]')) {\n    // Use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS, iOS7, Android 4.4\n    // (#6466 MutationObserver is unreliable in IE11)\n    var counter = 1;\n    var observer = new MutationObserver(flushCallbacks);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n\n    timerFunc = function timerFunc() {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n\n    isUsingMicroTask = true;\n  } else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n    // Fallback to setImmediate.\n    // Techinically it leverages the (macro) task queue,\n    // but it is still a better choice than setTimeout.\n    timerFunc = function timerFunc() {\n      setImmediate(flushCallbacks);\n    };\n  } else {\n    // Fallback to setTimeout.\n    timerFunc = function timerFunc() {\n      setTimeout(flushCallbacks, 0);\n    };\n  }\n\n  function nextTick(cb, ctx) {\n    var _resolve;\n\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    } // $flow-disable-line\n\n\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve) {\n        _resolve = resolve;\n      });\n    }\n  }\n  /*  */\n\n\n  var mark;\n  var measure;\n  {\n    var perf = inBrowser && window.performance;\n    /* istanbul ignore if */\n\n    if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {\n      mark = function mark(tag) {\n        return perf.mark(tag);\n      };\n\n      measure = function measure(name, startTag, endTag) {\n        perf.measure(name, startTag, endTag);\n        perf.clearMarks(startTag);\n        perf.clearMarks(endTag); // perf.clearMeasures(name)\n      };\n    }\n  }\n  /* not type checking this file because flow doesn't play well with Proxy */\n\n  var initProxy;\n  {\n    var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify\n    );\n\n    var warnNonPresent = function warnNonPresent(target, key) {\n      warn(\"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);\n    };\n\n    var warnReservedPrefix = function warnReservedPrefix(target, key) {\n      warn(\"Property \\\"\" + key + \"\\\" must be accessed with \\\"$data.\" + key + \"\\\" because \" + 'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals' + 'See: https://vuejs.org/v2/api/#data', target);\n    };\n\n    var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);\n\n    if (hasProxy) {\n      var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n      config.keyCodes = new Proxy(config.keyCodes, {\n        set: function set(target, key, value) {\n          if (isBuiltInModifier(key)) {\n            warn(\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key);\n            return false;\n          } else {\n            target[key] = value;\n            return true;\n          }\n        }\n      });\n    }\n\n    var hasHandler = {\n      has: function has(target, key) {\n        var has = key in target;\n        var isAllowed = allowedGlobals(key) || typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data);\n\n        if (!has && !isAllowed) {\n          if (key in target.$data) {\n            warnReservedPrefix(target, key);\n          } else {\n            warnNonPresent(target, key);\n          }\n        }\n\n        return has || !isAllowed;\n      }\n    };\n    var getHandler = {\n      get: function get(target, key) {\n        if (typeof key === 'string' && !(key in target)) {\n          if (key in target.$data) {\n            warnReservedPrefix(target, key);\n          } else {\n            warnNonPresent(target, key);\n          }\n        }\n\n        return target[key];\n      }\n    };\n\n    initProxy = function initProxy(vm) {\n      if (hasProxy) {\n        // determine which proxy handler to use\n        var options = vm.$options;\n        var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;\n        vm._renderProxy = new Proxy(vm, handlers);\n      } else {\n        vm._renderProxy = vm;\n      }\n    };\n  }\n  /*  */\n\n  var seenObjects = new _Set();\n  /**\n   * Recursively traverse an object to evoke all converted\n   * getters, so that every nested property inside the object\n   * is collected as a \"deep\" dependency.\n   */\n\n  function traverse(val) {\n    _traverse(val, seenObjects);\n\n    seenObjects.clear();\n  }\n\n  function _traverse(val, seen) {\n    var i, keys;\n    var isA = Array.isArray(val);\n\n    if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {\n      return;\n    }\n\n    if (val.__ob__) {\n      var depId = val.__ob__.dep.id;\n\n      if (seen.has(depId)) {\n        return;\n      }\n\n      seen.add(depId);\n    }\n\n    if (isA) {\n      i = val.length;\n\n      while (i--) {\n        _traverse(val[i], seen);\n      }\n    } else {\n      keys = Object.keys(val);\n      i = keys.length;\n\n      while (i--) {\n        _traverse(val[keys[i]], seen);\n      }\n    }\n  }\n  /*  */\n\n\n  var normalizeEvent = cached(function (name) {\n    var passive = name.charAt(0) === '&';\n    name = passive ? name.slice(1) : name;\n    var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n\n    name = once$$1 ? name.slice(1) : name;\n    var capture = name.charAt(0) === '!';\n    name = capture ? name.slice(1) : name;\n    return {\n      name: name,\n      once: once$$1,\n      capture: capture,\n      passive: passive\n    };\n  });\n\n  function createFnInvoker(fns, vm) {\n    function invoker() {\n      var arguments$1 = arguments;\n      var fns = invoker.fns;\n\n      if (Array.isArray(fns)) {\n        var cloned = fns.slice();\n\n        for (var i = 0; i < cloned.length; i++) {\n          invokeWithErrorHandling(cloned[i], null, arguments$1, vm, \"v-on handler\");\n        }\n      } else {\n        // return handler return value for single handlers\n        return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\");\n      }\n    }\n\n    invoker.fns = fns;\n    return invoker;\n  }\n\n  function updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {\n    var name, def$$1, cur, old, event;\n\n    for (name in on) {\n      def$$1 = cur = on[name];\n      old = oldOn[name];\n      event = normalizeEvent(name);\n\n      if (isUndef(cur)) {\n        warn(\"Invalid handler for event \\\"\" + event.name + \"\\\": got \" + String(cur), vm);\n      } else if (isUndef(old)) {\n        if (isUndef(cur.fns)) {\n          cur = on[name] = createFnInvoker(cur, vm);\n        }\n\n        if (isTrue(event.once)) {\n          cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n        }\n\n        add(event.name, cur, event.capture, event.passive, event.params);\n      } else if (cur !== old) {\n        old.fns = cur;\n        on[name] = old;\n      }\n    }\n\n    for (name in oldOn) {\n      if (isUndef(on[name])) {\n        event = normalizeEvent(name);\n        remove$$1(event.name, oldOn[name], event.capture);\n      }\n    }\n  }\n  /*  */\n\n\n  function mergeVNodeHook(def, hookKey, hook) {\n    if (def instanceof VNode) {\n      def = def.data.hook || (def.data.hook = {});\n    }\n\n    var invoker;\n    var oldHook = def[hookKey];\n\n    function wrappedHook() {\n      hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once\n      // and prevent memory leak\n\n      remove(invoker.fns, wrappedHook);\n    }\n\n    if (isUndef(oldHook)) {\n      // no existing hook\n      invoker = createFnInvoker([wrappedHook]);\n    } else {\n      /* istanbul ignore if */\n      if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n        // already a merged invoker\n        invoker = oldHook;\n        invoker.fns.push(wrappedHook);\n      } else {\n        // existing plain hook\n        invoker = createFnInvoker([oldHook, wrappedHook]);\n      }\n    }\n\n    invoker.merged = true;\n    def[hookKey] = invoker;\n  }\n  /*  */\n\n\n  function extractPropsFromVNodeData(data, Ctor, tag) {\n    // we are only extracting raw values here.\n    // validation and default values are handled in the child\n    // component itself.\n    var propOptions = Ctor.options.props;\n\n    if (isUndef(propOptions)) {\n      return;\n    }\n\n    var res = {};\n    var attrs = data.attrs;\n    var props = data.props;\n\n    if (isDef(attrs) || isDef(props)) {\n      for (var key in propOptions) {\n        var altKey = hyphenate(key);\n        {\n          var keyInLowerCase = key.toLowerCase();\n\n          if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {\n            tip(\"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" + formatComponentName(tag || Ctor) + \", but the declared prop name is\" + \" \\\"\" + key + \"\\\". \" + \"Note that HTML attributes are case-insensitive and camelCased \" + \"props need to use their kebab-case equivalents when using in-DOM \" + \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\");\n          }\n        }\n        checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);\n      }\n    }\n\n    return res;\n  }\n\n  function checkProp(res, hash, key, altKey, preserve) {\n    if (isDef(hash)) {\n      if (hasOwn(hash, key)) {\n        res[key] = hash[key];\n\n        if (!preserve) {\n          delete hash[key];\n        }\n\n        return true;\n      } else if (hasOwn(hash, altKey)) {\n        res[key] = hash[altKey];\n\n        if (!preserve) {\n          delete hash[altKey];\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /*  */\n  // The template compiler attempts to minimize the need for normalization by\n  // statically analyzing the template at compile time.\n  //\n  // For plain HTML markup, normalization can be completely skipped because the\n  // generated render function is guaranteed to return Array<VNode>. There are\n  // two cases where extra normalization is needed:\n  // 1. When the children contains components - because a functional component\n  // may return an Array instead of a single root. In this case, just a simple\n  // normalization is needed - if any child is an Array, we flatten the whole\n  // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n  // because functional components already normalize their own children.\n\n\n  function simpleNormalizeChildren(children) {\n    for (var i = 0; i < children.length; i++) {\n      if (Array.isArray(children[i])) {\n        return Array.prototype.concat.apply([], children);\n      }\n    }\n\n    return children;\n  } // 2. When the children contains constructs that always generated nested Arrays,\n  // e.g. <template>, <slot>, v-for, or when the children is provided by user\n  // with hand-written render functions / JSX. In such cases a full normalization\n  // is needed to cater to all possible types of children values.\n\n\n  function normalizeChildren(children) {\n    return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;\n  }\n\n  function isTextNode(node) {\n    return isDef(node) && isDef(node.text) && isFalse(node.isComment);\n  }\n\n  function normalizeArrayChildren(children, nestedIndex) {\n    var res = [];\n    var i, c, lastIndex, last;\n\n    for (i = 0; i < children.length; i++) {\n      c = children[i];\n\n      if (isUndef(c) || typeof c === 'boolean') {\n        continue;\n      }\n\n      lastIndex = res.length - 1;\n      last = res[lastIndex]; //  nested\n\n      if (Array.isArray(c)) {\n        if (c.length > 0) {\n          c = normalizeArrayChildren(c, (nestedIndex || '') + \"_\" + i); // merge adjacent text nodes\n\n          if (isTextNode(c[0]) && isTextNode(last)) {\n            res[lastIndex] = createTextVNode(last.text + c[0].text);\n            c.shift();\n          }\n\n          res.push.apply(res, c);\n        }\n      } else if (isPrimitive(c)) {\n        if (isTextNode(last)) {\n          // merge adjacent text nodes\n          // this is necessary for SSR hydration because text nodes are\n          // essentially merged when rendered to HTML strings\n          res[lastIndex] = createTextVNode(last.text + c);\n        } else if (c !== '') {\n          // convert primitive to vnode\n          res.push(createTextVNode(c));\n        }\n      } else {\n        if (isTextNode(c) && isTextNode(last)) {\n          // merge adjacent text nodes\n          res[lastIndex] = createTextVNode(last.text + c.text);\n        } else {\n          // default key for nested array children (likely generated by v-for)\n          if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {\n            c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n          }\n\n          res.push(c);\n        }\n      }\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  function initProvide(vm) {\n    var provide = vm.$options.provide;\n\n    if (provide) {\n      vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;\n    }\n  }\n\n  function initInjections(vm) {\n    var result = resolveInject(vm.$options.inject, vm);\n\n    if (result) {\n      toggleObserving(false);\n      Object.keys(result).forEach(function (key) {\n        /* istanbul ignore else */\n        {\n          defineReactive$$1(vm, key, result[key], function () {\n            warn(\"Avoid mutating an injected value directly since the changes will be \" + \"overwritten whenever the provided component re-renders. \" + \"injection being mutated: \\\"\" + key + \"\\\"\", vm);\n          });\n        }\n      });\n      toggleObserving(true);\n    }\n  }\n\n  function resolveInject(inject, vm) {\n    if (inject) {\n      // inject is :any because flow is not smart enough to figure out cached\n      var result = Object.create(null);\n      var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i]; // #6574 in case the inject object is observed...\n\n        if (key === '__ob__') {\n          continue;\n        }\n\n        var provideKey = inject[key].from;\n        var source = vm;\n\n        while (source) {\n          if (source._provided && hasOwn(source._provided, provideKey)) {\n            result[key] = source._provided[provideKey];\n            break;\n          }\n\n          source = source.$parent;\n        }\n\n        if (!source) {\n          if ('default' in inject[key]) {\n            var provideDefault = inject[key][\"default\"];\n            result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;\n          } else {\n            warn(\"Injection \\\"\" + key + \"\\\" not found\", vm);\n          }\n        }\n      }\n\n      return result;\n    }\n  }\n  /*  */\n\n  /**\n   * Runtime helper for resolving raw children VNodes into a slot object.\n   */\n\n\n  function resolveSlots(children, context) {\n    if (!children || !children.length) {\n      return {};\n    }\n\n    var slots = {};\n\n    for (var i = 0, l = children.length; i < l; i++) {\n      var child = children[i];\n      var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node\n\n      if (data && data.attrs && data.attrs.slot) {\n        delete data.attrs.slot;\n      } // named slots should only be respected if the vnode was rendered in the\n      // same context.\n\n\n      if ((child.context === context || child.fnContext === context) && data && data.slot != null) {\n        var name = data.slot;\n        var slot = slots[name] || (slots[name] = []);\n\n        if (child.tag === 'template') {\n          slot.push.apply(slot, child.children || []);\n        } else {\n          slot.push(child);\n        }\n      } else {\n        (slots[\"default\"] || (slots[\"default\"] = [])).push(child);\n      }\n    } // ignore slots that contains only whitespace\n\n\n    for (var name$1 in slots) {\n      if (slots[name$1].every(isWhitespace)) {\n        delete slots[name$1];\n      }\n    }\n\n    return slots;\n  }\n\n  function isWhitespace(node) {\n    return node.isComment && !node.asyncFactory || node.text === ' ';\n  }\n  /*  */\n\n\n  function normalizeScopedSlots(slots, normalSlots, prevSlots) {\n    var res;\n    var hasNormalSlots = Object.keys(normalSlots).length > 0;\n    var isStable = slots ? !!slots.$stable : !hasNormalSlots;\n    var key = slots && slots.$key;\n\n    if (!slots) {\n      res = {};\n    } else if (slots._normalized) {\n      // fast path 1: child component re-render only, parent did not change\n      return slots._normalized;\n    } else if (isStable && prevSlots && prevSlots !== emptyObject && key === prevSlots.$key && !hasNormalSlots && !prevSlots.$hasNormal) {\n      // fast path 2: stable scoped slots w/ no normal slots to proxy,\n      // only need to normalize once\n      return prevSlots;\n    } else {\n      res = {};\n\n      for (var key$1 in slots) {\n        if (slots[key$1] && key$1[0] !== '$') {\n          res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);\n        }\n      }\n    } // expose normal slots on scopedSlots\n\n\n    for (var key$2 in normalSlots) {\n      if (!(key$2 in res)) {\n        res[key$2] = proxyNormalSlot(normalSlots, key$2);\n      }\n    } // avoriaz seems to mock a non-extensible $scopedSlots object\n    // and when that is passed down this would cause an error\n\n\n    if (slots && Object.isExtensible(slots)) {\n      slots._normalized = res;\n    }\n\n    def(res, '$stable', isStable);\n    def(res, '$key', key);\n    def(res, '$hasNormal', hasNormalSlots);\n    return res;\n  }\n\n  function normalizeScopedSlot(normalSlots, key, fn) {\n    var normalized = function normalized() {\n      var res = arguments.length ? fn.apply(null, arguments) : fn({});\n      res = res && _typeof(res) === 'object' && !Array.isArray(res) ? [res] // single vnode\n      : normalizeChildren(res);\n      return res && (res.length === 0 || res.length === 1 && res[0].isComment // #9658\n      ) ? undefined : res;\n    }; // this is a slot using the new v-slot syntax without scope. although it is\n    // compiled as a scoped slot, render fn users would expect it to be present\n    // on this.$slots because the usage is semantically a normal slot.\n\n\n    if (fn.proxy) {\n      Object.defineProperty(normalSlots, key, {\n        get: normalized,\n        enumerable: true,\n        configurable: true\n      });\n    }\n\n    return normalized;\n  }\n\n  function proxyNormalSlot(slots, key) {\n    return function () {\n      return slots[key];\n    };\n  }\n  /*  */\n\n  /**\n   * Runtime helper for rendering v-for lists.\n   */\n\n\n  function renderList(val, render) {\n    var ret, i, l, keys, key;\n\n    if (Array.isArray(val) || typeof val === 'string') {\n      ret = new Array(val.length);\n\n      for (i = 0, l = val.length; i < l; i++) {\n        ret[i] = render(val[i], i);\n      }\n    } else if (typeof val === 'number') {\n      ret = new Array(val);\n\n      for (i = 0; i < val; i++) {\n        ret[i] = render(i + 1, i);\n      }\n    } else if (isObject(val)) {\n      if (hasSymbol && val[Symbol.iterator]) {\n        ret = [];\n        var iterator = val[Symbol.iterator]();\n        var result = iterator.next();\n\n        while (!result.done) {\n          ret.push(render(result.value, ret.length));\n          result = iterator.next();\n        }\n      } else {\n        keys = Object.keys(val);\n        ret = new Array(keys.length);\n\n        for (i = 0, l = keys.length; i < l; i++) {\n          key = keys[i];\n          ret[i] = render(val[key], key, i);\n        }\n      }\n    }\n\n    if (!isDef(ret)) {\n      ret = [];\n    }\n\n    ret._isVList = true;\n    return ret;\n  }\n  /*  */\n\n  /**\n   * Runtime helper for rendering <slot>\n   */\n\n\n  function renderSlot(name, fallback, props, bindObject) {\n    var scopedSlotFn = this.$scopedSlots[name];\n    var nodes;\n\n    if (scopedSlotFn) {\n      // scoped slot\n      props = props || {};\n\n      if (bindObject) {\n        if (!isObject(bindObject)) {\n          warn('slot v-bind without argument expects an Object', this);\n        }\n\n        props = extend(extend({}, bindObject), props);\n      }\n\n      nodes = scopedSlotFn(props) || fallback;\n    } else {\n      nodes = this.$slots[name] || fallback;\n    }\n\n    var target = props && props.slot;\n\n    if (target) {\n      return this.$createElement('template', {\n        slot: target\n      }, nodes);\n    } else {\n      return nodes;\n    }\n  }\n  /*  */\n\n  /**\n   * Runtime helper for resolving filters\n   */\n\n\n  function resolveFilter(id) {\n    return resolveAsset(this.$options, 'filters', id, true) || identity;\n  }\n  /*  */\n\n\n  function isKeyNotMatch(expect, actual) {\n    if (Array.isArray(expect)) {\n      return expect.indexOf(actual) === -1;\n    } else {\n      return expect !== actual;\n    }\n  }\n  /**\n   * Runtime helper for checking keyCodes from config.\n   * exposed as Vue.prototype._k\n   * passing in eventKeyName as last argument separately for backwards compat\n   */\n\n\n  function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {\n    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n\n    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n      return isKeyNotMatch(builtInKeyName, eventKeyName);\n    } else if (mappedKeyCode) {\n      return isKeyNotMatch(mappedKeyCode, eventKeyCode);\n    } else if (eventKeyName) {\n      return hyphenate(eventKeyName) !== key;\n    }\n  }\n  /*  */\n\n  /**\n   * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n   */\n\n\n  function bindObjectProps(data, tag, value, asProp, isSync) {\n    if (value) {\n      if (!isObject(value)) {\n        warn('v-bind without argument expects an Object or Array value', this);\n      } else {\n        if (Array.isArray(value)) {\n          value = toObject(value);\n        }\n\n        var hash;\n\n        var loop = function loop(key) {\n          if (key === 'class' || key === 'style' || isReservedAttribute(key)) {\n            hash = data;\n          } else {\n            var type = data.attrs && data.attrs.type;\n            hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});\n          }\n\n          var camelizedKey = camelize(key);\n          var hyphenatedKey = hyphenate(key);\n\n          if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\n            hash[key] = value[key];\n\n            if (isSync) {\n              var on = data.on || (data.on = {});\n\n              on[\"update:\" + key] = function ($event) {\n                value[key] = $event;\n              };\n            }\n          }\n        };\n\n        for (var key in value) {\n          loop(key);\n        }\n      }\n    }\n\n    return data;\n  }\n  /*  */\n\n  /**\n   * Runtime helper for rendering static trees.\n   */\n\n\n  function renderStatic(index, isInFor) {\n    var cached = this._staticTrees || (this._staticTrees = []);\n    var tree = cached[index]; // if has already-rendered static tree and not inside v-for,\n    // we can reuse the same tree.\n\n    if (tree && !isInFor) {\n      return tree;\n    } // otherwise, render a fresh tree.\n\n\n    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates\n    );\n    markStatic(tree, \"__static__\" + index, false);\n    return tree;\n  }\n  /**\n   * Runtime helper for v-once.\n   * Effectively it means marking the node as static with a unique key.\n   */\n\n\n  function markOnce(tree, index, key) {\n    markStatic(tree, \"__once__\" + index + (key ? \"_\" + key : \"\"), true);\n    return tree;\n  }\n\n  function markStatic(tree, key, isOnce) {\n    if (Array.isArray(tree)) {\n      for (var i = 0; i < tree.length; i++) {\n        if (tree[i] && typeof tree[i] !== 'string') {\n          markStaticNode(tree[i], key + \"_\" + i, isOnce);\n        }\n      }\n    } else {\n      markStaticNode(tree, key, isOnce);\n    }\n  }\n\n  function markStaticNode(node, key, isOnce) {\n    node.isStatic = true;\n    node.key = key;\n    node.isOnce = isOnce;\n  }\n  /*  */\n\n\n  function bindObjectListeners(data, value) {\n    if (value) {\n      if (!isPlainObject(value)) {\n        warn('v-on without argument expects an Object value', this);\n      } else {\n        var on = data.on = data.on ? extend({}, data.on) : {};\n\n        for (var key in value) {\n          var existing = on[key];\n          var ours = value[key];\n          on[key] = existing ? [].concat(existing, ours) : ours;\n        }\n      }\n    }\n\n    return data;\n  }\n  /*  */\n\n\n  function resolveScopedSlots(fns, // see flow/vnode\n  res, // the following are added in 2.6\n  hasDynamicKeys, contentHashKey) {\n    res = res || {\n      $stable: !hasDynamicKeys\n    };\n\n    for (var i = 0; i < fns.length; i++) {\n      var slot = fns[i];\n\n      if (Array.isArray(slot)) {\n        resolveScopedSlots(slot, res, hasDynamicKeys);\n      } else if (slot) {\n        // marker for reverse proxying v-slot without scope on this.$slots\n        if (slot.proxy) {\n          slot.fn.proxy = true;\n        }\n\n        res[slot.key] = slot.fn;\n      }\n    }\n\n    if (contentHashKey) {\n      res.$key = contentHashKey;\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  function bindDynamicKeys(baseObj, values) {\n    for (var i = 0; i < values.length; i += 2) {\n      var key = values[i];\n\n      if (typeof key === 'string' && key) {\n        baseObj[values[i]] = values[i + 1];\n      } else if (key !== '' && key !== null) {\n        // null is a speical value for explicitly removing a binding\n        warn(\"Invalid value for dynamic directive argument (expected string or null): \" + key, this);\n      }\n    }\n\n    return baseObj;\n  } // helper to dynamically append modifier runtime markers to event names.\n  // ensure only append when value is already string, otherwise it will be cast\n  // to string and cause the type check to miss.\n\n\n  function prependModifier(value, symbol) {\n    return typeof value === 'string' ? symbol + value : value;\n  }\n  /*  */\n\n\n  function installRenderHelpers(target) {\n    target._o = markOnce;\n    target._n = toNumber;\n    target._s = toString;\n    target._l = renderList;\n    target._t = renderSlot;\n    target._q = looseEqual;\n    target._i = looseIndexOf;\n    target._m = renderStatic;\n    target._f = resolveFilter;\n    target._k = checkKeyCodes;\n    target._b = bindObjectProps;\n    target._v = createTextVNode;\n    target._e = createEmptyVNode;\n    target._u = resolveScopedSlots;\n    target._g = bindObjectListeners;\n    target._d = bindDynamicKeys;\n    target._p = prependModifier;\n  }\n  /*  */\n\n\n  function FunctionalRenderContext(data, props, children, parent, Ctor) {\n    var this$1 = this;\n    var options = Ctor.options; // ensure the createElement function in functional components\n    // gets a unique context - this is necessary for correct named slot check\n\n    var contextVm;\n\n    if (hasOwn(parent, '_uid')) {\n      contextVm = Object.create(parent); // $flow-disable-line\n\n      contextVm._original = parent;\n    } else {\n      // the context vm passed in is a functional context as well.\n      // in this case we want to make sure we are able to get a hold to the\n      // real context instance.\n      contextVm = parent; // $flow-disable-line\n\n      parent = parent._original;\n    }\n\n    var isCompiled = isTrue(options._compiled);\n    var needNormalization = !isCompiled;\n    this.data = data;\n    this.props = props;\n    this.children = children;\n    this.parent = parent;\n    this.listeners = data.on || emptyObject;\n    this.injections = resolveInject(options.inject, parent);\n\n    this.slots = function () {\n      if (!this$1.$slots) {\n        normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));\n      }\n\n      return this$1.$slots;\n    };\n\n    Object.defineProperty(this, 'scopedSlots', {\n      enumerable: true,\n      get: function get() {\n        return normalizeScopedSlots(data.scopedSlots, this.slots());\n      }\n    }); // support for compiled functional template\n\n    if (isCompiled) {\n      // exposing $options for renderStatic()\n      this.$options = options; // pre-resolve slots for renderSlot()\n\n      this.$slots = this.slots();\n      this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);\n    }\n\n    if (options._scopeId) {\n      this._c = function (a, b, c, d) {\n        var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n\n        if (vnode && !Array.isArray(vnode)) {\n          vnode.fnScopeId = options._scopeId;\n          vnode.fnContext = parent;\n        }\n\n        return vnode;\n      };\n    } else {\n      this._c = function (a, b, c, d) {\n        return createElement(contextVm, a, b, c, d, needNormalization);\n      };\n    }\n  }\n\n  installRenderHelpers(FunctionalRenderContext.prototype);\n\n  function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {\n    var options = Ctor.options;\n    var props = {};\n    var propOptions = options.props;\n\n    if (isDef(propOptions)) {\n      for (var key in propOptions) {\n        props[key] = validateProp(key, propOptions, propsData || emptyObject);\n      }\n    } else {\n      if (isDef(data.attrs)) {\n        mergeProps(props, data.attrs);\n      }\n\n      if (isDef(data.props)) {\n        mergeProps(props, data.props);\n      }\n    }\n\n    var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);\n    var vnode = options.render.call(null, renderContext._c, renderContext);\n\n    if (vnode instanceof VNode) {\n      return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);\n    } else if (Array.isArray(vnode)) {\n      var vnodes = normalizeChildren(vnode) || [];\n      var res = new Array(vnodes.length);\n\n      for (var i = 0; i < vnodes.length; i++) {\n        res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n      }\n\n      return res;\n    }\n  }\n\n  function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {\n    // #7817 clone node before setting fnContext, otherwise if the node is reused\n    // (e.g. it was from a cached normal slot) the fnContext causes named slots\n    // that should not be matched to match.\n    var clone = cloneVNode(vnode);\n    clone.fnContext = contextVm;\n    clone.fnOptions = options;\n    {\n      (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;\n    }\n\n    if (data.slot) {\n      (clone.data || (clone.data = {})).slot = data.slot;\n    }\n\n    return clone;\n  }\n\n  function mergeProps(to, from) {\n    for (var key in from) {\n      to[camelize(key)] = from[key];\n    }\n  }\n  /*  */\n\n  /*  */\n\n  /*  */\n\n  /*  */\n  // inline hooks to be invoked on component VNodes during patch\n\n\n  var componentVNodeHooks = {\n    init: function init(vnode, hydrating) {\n      if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {\n        // kept-alive components, treat as a patch\n        var mountedNode = vnode; // work around flow\n\n        componentVNodeHooks.prepatch(mountedNode, mountedNode);\n      } else {\n        var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);\n        child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n      }\n    },\n    prepatch: function prepatch(oldVnode, vnode) {\n      var options = vnode.componentOptions;\n      var child = vnode.componentInstance = oldVnode.componentInstance;\n      updateChildComponent(child, options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n      );\n    },\n    insert: function insert(vnode) {\n      var context = vnode.context;\n      var componentInstance = vnode.componentInstance;\n\n      if (!componentInstance._isMounted) {\n        componentInstance._isMounted = true;\n        callHook(componentInstance, 'mounted');\n      }\n\n      if (vnode.data.keepAlive) {\n        if (context._isMounted) {\n          // vue-router#1212\n          // During updates, a kept-alive component's child components may\n          // change, so directly walking the tree here may call activated hooks\n          // on incorrect children. Instead we push them into a queue which will\n          // be processed after the whole patch process ended.\n          queueActivatedComponent(componentInstance);\n        } else {\n          activateChildComponent(componentInstance, true\n          /* direct */\n          );\n        }\n      }\n    },\n    destroy: function destroy(vnode) {\n      var componentInstance = vnode.componentInstance;\n\n      if (!componentInstance._isDestroyed) {\n        if (!vnode.data.keepAlive) {\n          componentInstance.$destroy();\n        } else {\n          deactivateChildComponent(componentInstance, true\n          /* direct */\n          );\n        }\n      }\n    }\n  };\n  var hooksToMerge = Object.keys(componentVNodeHooks);\n\n  function createComponent(Ctor, data, context, children, tag) {\n    if (isUndef(Ctor)) {\n      return;\n    }\n\n    var baseCtor = context.$options._base; // plain options object: turn it into a constructor\n\n    if (isObject(Ctor)) {\n      Ctor = baseCtor.extend(Ctor);\n    } // if at this stage it's not a constructor or an async component factory,\n    // reject.\n\n\n    if (typeof Ctor !== 'function') {\n      {\n        warn(\"Invalid Component definition: \" + String(Ctor), context);\n      }\n      return;\n    } // async component\n\n\n    var asyncFactory;\n\n    if (isUndef(Ctor.cid)) {\n      asyncFactory = Ctor;\n      Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n\n      if (Ctor === undefined) {\n        // return a placeholder node for async component, which is rendered\n        // as a comment node but preserves all the raw information for the node.\n        // the information will be used for async server-rendering and hydration.\n        return createAsyncPlaceholder(asyncFactory, data, context, children, tag);\n      }\n    }\n\n    data = data || {}; // resolve constructor options in case global mixins are applied after\n    // component constructor creation\n\n    resolveConstructorOptions(Ctor); // transform component v-model data into props & events\n\n    if (isDef(data.model)) {\n      transformModel(Ctor.options, data);\n    } // extract props\n\n\n    var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component\n\n    if (isTrue(Ctor.options.functional)) {\n      return createFunctionalComponent(Ctor, propsData, data, context, children);\n    } // extract listeners, since these needs to be treated as\n    // child component listeners instead of DOM listeners\n\n\n    var listeners = data.on; // replace with listeners with .native modifier\n    // so it gets processed during parent component patch.\n\n    data.on = data.nativeOn;\n\n    if (isTrue(Ctor.options[\"abstract\"])) {\n      // abstract components do not keep anything\n      // other than props & listeners & slot\n      // work around flow\n      var slot = data.slot;\n      data = {};\n\n      if (slot) {\n        data.slot = slot;\n      }\n    } // install component management hooks onto the placeholder node\n\n\n    installComponentHooks(data); // return a placeholder vnode\n\n    var name = Ctor.options.name || tag;\n    var vnode = new VNode(\"vue-component-\" + Ctor.cid + (name ? \"-\" + name : ''), data, undefined, undefined, undefined, context, {\n      Ctor: Ctor,\n      propsData: propsData,\n      listeners: listeners,\n      tag: tag,\n      children: children\n    }, asyncFactory);\n    return vnode;\n  }\n\n  function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent // activeInstance in lifecycle state\n  ) {\n    var options = {\n      _isComponent: true,\n      _parentVnode: vnode,\n      parent: parent\n    }; // check inline-template render functions\n\n    var inlineTemplate = vnode.data.inlineTemplate;\n\n    if (isDef(inlineTemplate)) {\n      options.render = inlineTemplate.render;\n      options.staticRenderFns = inlineTemplate.staticRenderFns;\n    }\n\n    return new vnode.componentOptions.Ctor(options);\n  }\n\n  function installComponentHooks(data) {\n    var hooks = data.hook || (data.hook = {});\n\n    for (var i = 0; i < hooksToMerge.length; i++) {\n      var key = hooksToMerge[i];\n      var existing = hooks[key];\n      var toMerge = componentVNodeHooks[key];\n\n      if (existing !== toMerge && !(existing && existing._merged)) {\n        hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;\n      }\n    }\n  }\n\n  function mergeHook$1(f1, f2) {\n    var merged = function merged(a, b) {\n      // flow complains about extra args which is why we use any\n      f1(a, b);\n      f2(a, b);\n    };\n\n    merged._merged = true;\n    return merged;\n  } // transform component v-model info (value and callback) into\n  // prop and event handler respectively.\n\n\n  function transformModel(options, data) {\n    var prop = options.model && options.model.prop || 'value';\n    var event = options.model && options.model.event || 'input';\n    (data.attrs || (data.attrs = {}))[prop] = data.model.value;\n    var on = data.on || (data.on = {});\n    var existing = on[event];\n    var callback = data.model.callback;\n\n    if (isDef(existing)) {\n      if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {\n        on[event] = [callback].concat(existing);\n      }\n    } else {\n      on[event] = callback;\n    }\n  }\n  /*  */\n\n\n  var SIMPLE_NORMALIZE = 1;\n  var ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface\n  // without getting yelled at by flow\n\n  function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {\n    if (Array.isArray(data) || isPrimitive(data)) {\n      normalizationType = children;\n      children = data;\n      data = undefined;\n    }\n\n    if (isTrue(alwaysNormalize)) {\n      normalizationType = ALWAYS_NORMALIZE;\n    }\n\n    return _createElement(context, tag, data, children, normalizationType);\n  }\n\n  function _createElement(context, tag, data, children, normalizationType) {\n    if (isDef(data) && isDef(data.__ob__)) {\n      warn(\"Avoid using observed data object as vnode data: \" + JSON.stringify(data) + \"\\n\" + 'Always create fresh vnode data objects in each render!', context);\n      return createEmptyVNode();\n    } // object syntax in v-bind\n\n\n    if (isDef(data) && isDef(data.is)) {\n      tag = data.is;\n    }\n\n    if (!tag) {\n      // in case of component :is set to falsy value\n      return createEmptyVNode();\n    } // warn against non-primitive key\n\n\n    if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {\n      {\n        warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);\n      }\n    } // support single function children as default scoped slot\n\n\n    if (Array.isArray(children) && typeof children[0] === 'function') {\n      data = data || {};\n      data.scopedSlots = {\n        \"default\": children[0]\n      };\n      children.length = 0;\n    }\n\n    if (normalizationType === ALWAYS_NORMALIZE) {\n      children = normalizeChildren(children);\n    } else if (normalizationType === SIMPLE_NORMALIZE) {\n      children = simpleNormalizeChildren(children);\n    }\n\n    var vnode, ns;\n\n    if (typeof tag === 'string') {\n      var Ctor;\n      ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);\n\n      if (config.isReservedTag(tag)) {\n        // platform built-in elements\n        vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\n      } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n        // component\n        vnode = createComponent(Ctor, data, context, children, tag);\n      } else {\n        // unknown or unlisted namespaced elements\n        // check at runtime because it may get assigned a namespace when its\n        // parent normalizes children\n        vnode = new VNode(tag, data, children, undefined, undefined, context);\n      }\n    } else {\n      // direct component options / constructor\n      vnode = createComponent(tag, data, context, children);\n    }\n\n    if (Array.isArray(vnode)) {\n      return vnode;\n    } else if (isDef(vnode)) {\n      if (isDef(ns)) {\n        applyNS(vnode, ns);\n      }\n\n      if (isDef(data)) {\n        registerDeepBindings(data);\n      }\n\n      return vnode;\n    } else {\n      return createEmptyVNode();\n    }\n  }\n\n  function applyNS(vnode, ns, force) {\n    vnode.ns = ns;\n\n    if (vnode.tag === 'foreignObject') {\n      // use default namespace inside foreignObject\n      ns = undefined;\n      force = true;\n    }\n\n    if (isDef(vnode.children)) {\n      for (var i = 0, l = vnode.children.length; i < l; i++) {\n        var child = vnode.children[i];\n\n        if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {\n          applyNS(child, ns, force);\n        }\n      }\n    }\n  } // ref #5318\n  // necessary to ensure parent re-render when deep bindings like :style and\n  // :class are used on slot nodes\n\n\n  function registerDeepBindings(data) {\n    if (isObject(data.style)) {\n      traverse(data.style);\n    }\n\n    if (isObject(data[\"class\"])) {\n      traverse(data[\"class\"]);\n    }\n  }\n  /*  */\n\n\n  function initRender(vm) {\n    vm._vnode = null; // the root of the child tree\n\n    vm._staticTrees = null; // v-once cached trees\n\n    var options = vm.$options;\n    var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n\n    var renderContext = parentVnode && parentVnode.context;\n    vm.$slots = resolveSlots(options._renderChildren, renderContext);\n    vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance\n    // so that we get proper render context inside it.\n    // args order: tag, data, children, normalizationType, alwaysNormalize\n    // internal version is used by render functions compiled from templates\n\n    vm._c = function (a, b, c, d) {\n      return createElement(vm, a, b, c, d, false);\n    }; // normalization is always applied for the public version, used in\n    // user-written render functions.\n\n\n    vm.$createElement = function (a, b, c, d) {\n      return createElement(vm, a, b, c, d, true);\n    }; // $attrs & $listeners are exposed for easier HOC creation.\n    // they need to be reactive so that HOCs using them are always updated\n\n\n    var parentData = parentVnode && parentVnode.data;\n    /* istanbul ignore else */\n\n    {\n      defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n      }, true);\n      defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n      }, true);\n    }\n  }\n\n  var currentRenderingInstance = null;\n\n  function renderMixin(Vue) {\n    // install runtime convenience helpers\n    installRenderHelpers(Vue.prototype);\n\n    Vue.prototype.$nextTick = function (fn) {\n      return nextTick(fn, this);\n    };\n\n    Vue.prototype._render = function () {\n      var vm = this;\n      var ref = vm.$options;\n      var render = ref.render;\n      var _parentVnode = ref._parentVnode;\n\n      if (_parentVnode) {\n        vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);\n      } // set parent vnode. this allows render functions to have access\n      // to the data on the placeholder node.\n\n\n      vm.$vnode = _parentVnode; // render self\n\n      var vnode;\n\n      try {\n        // There's no need to maintain a stack becaues all render fns are called\n        // separately from one another. Nested component's render fns are called\n        // when parent component is patched.\n        currentRenderingInstance = vm;\n        vnode = render.call(vm._renderProxy, vm.$createElement);\n      } catch (e) {\n        handleError(e, vm, \"render\"); // return error render result,\n        // or previous vnode to prevent render error causing blank component\n\n        /* istanbul ignore else */\n\n        if (vm.$options.renderError) {\n          try {\n            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n          } catch (e) {\n            handleError(e, vm, \"renderError\");\n            vnode = vm._vnode;\n          }\n        } else {\n          vnode = vm._vnode;\n        }\n      } finally {\n        currentRenderingInstance = null;\n      } // if the returned array contains only a single node, allow it\n\n\n      if (Array.isArray(vnode) && vnode.length === 1) {\n        vnode = vnode[0];\n      } // return empty vnode in case the render function errored out\n\n\n      if (!(vnode instanceof VNode)) {\n        if (Array.isArray(vnode)) {\n          warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);\n        }\n\n        vnode = createEmptyVNode();\n      } // set parent\n\n\n      vnode.parent = _parentVnode;\n      return vnode;\n    };\n  }\n  /*  */\n\n\n  function ensureCtor(comp, base) {\n    if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {\n      comp = comp[\"default\"];\n    }\n\n    return isObject(comp) ? base.extend(comp) : comp;\n  }\n\n  function createAsyncPlaceholder(factory, data, context, children, tag) {\n    var node = createEmptyVNode();\n    node.asyncFactory = factory;\n    node.asyncMeta = {\n      data: data,\n      context: context,\n      children: children,\n      tag: tag\n    };\n    return node;\n  }\n\n  function resolveAsyncComponent(factory, baseCtor) {\n    if (isTrue(factory.error) && isDef(factory.errorComp)) {\n      return factory.errorComp;\n    }\n\n    if (isDef(factory.resolved)) {\n      return factory.resolved;\n    }\n\n    var owner = currentRenderingInstance;\n\n    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\n      // already pending\n      factory.owners.push(owner);\n    }\n\n    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n      return factory.loadingComp;\n    }\n\n    if (owner && !isDef(factory.owners)) {\n      var owners = factory.owners = [owner];\n      var sync = true;\n      var timerLoading = null;\n      var timerTimeout = null;\n      owner.$on('hook:destroyed', function () {\n        return remove(owners, owner);\n      });\n\n      var forceRender = function forceRender(renderCompleted) {\n        for (var i = 0, l = owners.length; i < l; i++) {\n          owners[i].$forceUpdate();\n        }\n\n        if (renderCompleted) {\n          owners.length = 0;\n\n          if (timerLoading !== null) {\n            clearTimeout(timerLoading);\n            timerLoading = null;\n          }\n\n          if (timerTimeout !== null) {\n            clearTimeout(timerTimeout);\n            timerTimeout = null;\n          }\n        }\n      };\n\n      var resolve = once(function (res) {\n        // cache resolved\n        factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve\n        // (async resolves are shimmed as synchronous during SSR)\n\n        if (!sync) {\n          forceRender(true);\n        } else {\n          owners.length = 0;\n        }\n      });\n      var reject = once(function (reason) {\n        warn(\"Failed to resolve async component: \" + String(factory) + (reason ? \"\\nReason: \" + reason : ''));\n\n        if (isDef(factory.errorComp)) {\n          factory.error = true;\n          forceRender(true);\n        }\n      });\n      var res = factory(resolve, reject);\n\n      if (isObject(res)) {\n        if (isPromise(res)) {\n          // () => Promise\n          if (isUndef(factory.resolved)) {\n            res.then(resolve, reject);\n          }\n        } else if (isPromise(res.component)) {\n          res.component.then(resolve, reject);\n\n          if (isDef(res.error)) {\n            factory.errorComp = ensureCtor(res.error, baseCtor);\n          }\n\n          if (isDef(res.loading)) {\n            factory.loadingComp = ensureCtor(res.loading, baseCtor);\n\n            if (res.delay === 0) {\n              factory.loading = true;\n            } else {\n              timerLoading = setTimeout(function () {\n                timerLoading = null;\n\n                if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                  factory.loading = true;\n                  forceRender(false);\n                }\n              }, res.delay || 200);\n            }\n          }\n\n          if (isDef(res.timeout)) {\n            timerTimeout = setTimeout(function () {\n              timerTimeout = null;\n\n              if (isUndef(factory.resolved)) {\n                reject(\"timeout (\" + res.timeout + \"ms)\");\n              }\n            }, res.timeout);\n          }\n        }\n      }\n\n      sync = false; // return in case resolved synchronously\n\n      return factory.loading ? factory.loadingComp : factory.resolved;\n    }\n  }\n  /*  */\n\n\n  function isAsyncPlaceholder(node) {\n    return node.isComment && node.asyncFactory;\n  }\n  /*  */\n\n\n  function getFirstComponentChild(children) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; i++) {\n        var c = children[i];\n\n        if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n          return c;\n        }\n      }\n    }\n  }\n  /*  */\n\n  /*  */\n\n\n  function initEvents(vm) {\n    vm._events = Object.create(null);\n    vm._hasHookEvent = false; // init parent attached events\n\n    var listeners = vm.$options._parentListeners;\n\n    if (listeners) {\n      updateComponentListeners(vm, listeners);\n    }\n  }\n\n  var target;\n\n  function add(event, fn) {\n    target.$on(event, fn);\n  }\n\n  function remove$1(event, fn) {\n    target.$off(event, fn);\n  }\n\n  function createOnceHandler(event, fn) {\n    var _target = target;\n    return function onceHandler() {\n      var res = fn.apply(null, arguments);\n\n      if (res !== null) {\n        _target.$off(event, onceHandler);\n      }\n    };\n  }\n\n  function updateComponentListeners(vm, listeners, oldListeners) {\n    target = vm;\n    updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);\n    target = undefined;\n  }\n\n  function eventsMixin(Vue) {\n    var hookRE = /^hook:/;\n\n    Vue.prototype.$on = function (event, fn) {\n      var vm = this;\n\n      if (Array.isArray(event)) {\n        for (var i = 0, l = event.length; i < l; i++) {\n          vm.$on(event[i], fn);\n        }\n      } else {\n        (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration\n        // instead of a hash lookup\n\n        if (hookRE.test(event)) {\n          vm._hasHookEvent = true;\n        }\n      }\n\n      return vm;\n    };\n\n    Vue.prototype.$once = function (event, fn) {\n      var vm = this;\n\n      function on() {\n        vm.$off(event, on);\n        fn.apply(vm, arguments);\n      }\n\n      on.fn = fn;\n      vm.$on(event, on);\n      return vm;\n    };\n\n    Vue.prototype.$off = function (event, fn) {\n      var vm = this; // all\n\n      if (!arguments.length) {\n        vm._events = Object.create(null);\n        return vm;\n      } // array of events\n\n\n      if (Array.isArray(event)) {\n        for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n          vm.$off(event[i$1], fn);\n        }\n\n        return vm;\n      } // specific event\n\n\n      var cbs = vm._events[event];\n\n      if (!cbs) {\n        return vm;\n      }\n\n      if (!fn) {\n        vm._events[event] = null;\n        return vm;\n      } // specific handler\n\n\n      var cb;\n      var i = cbs.length;\n\n      while (i--) {\n        cb = cbs[i];\n\n        if (cb === fn || cb.fn === fn) {\n          cbs.splice(i, 1);\n          break;\n        }\n      }\n\n      return vm;\n    };\n\n    Vue.prototype.$emit = function (event) {\n      var vm = this;\n      {\n        var lowerCaseEvent = event.toLowerCase();\n\n        if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n          tip(\"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" + formatComponentName(vm) + \" but the handler is registered for \\\"\" + event + \"\\\". \" + \"Note that HTML attributes are case-insensitive and you cannot use \" + \"v-on to listen to camelCase events when using in-DOM templates. \" + \"You should probably use \\\"\" + hyphenate(event) + \"\\\" instead of \\\"\" + event + \"\\\".\");\n        }\n      }\n      var cbs = vm._events[event];\n\n      if (cbs) {\n        cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n        var args = toArray(arguments, 1);\n        var info = \"event handler for \\\"\" + event + \"\\\"\";\n\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n        }\n      }\n\n      return vm;\n    };\n  }\n  /*  */\n\n\n  var activeInstance = null;\n  var isUpdatingChildComponent = false;\n\n  function setActiveInstance(vm) {\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    return function () {\n      activeInstance = prevActiveInstance;\n    };\n  }\n\n  function initLifecycle(vm) {\n    var options = vm.$options; // locate first non-abstract parent\n\n    var parent = options.parent;\n\n    if (parent && !options[\"abstract\"]) {\n      while (parent.$options[\"abstract\"] && parent.$parent) {\n        parent = parent.$parent;\n      }\n\n      parent.$children.push(vm);\n    }\n\n    vm.$parent = parent;\n    vm.$root = parent ? parent.$root : vm;\n    vm.$children = [];\n    vm.$refs = {};\n    vm._watcher = null;\n    vm._inactive = null;\n    vm._directInactive = false;\n    vm._isMounted = false;\n    vm._isDestroyed = false;\n    vm._isBeingDestroyed = false;\n  }\n\n  function lifecycleMixin(Vue) {\n    Vue.prototype._update = function (vnode, hydrating) {\n      var vm = this;\n      var prevEl = vm.$el;\n      var prevVnode = vm._vnode;\n      var restoreActiveInstance = setActiveInstance(vm);\n      vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points\n      // based on the rendering backend used.\n\n      if (!prevVnode) {\n        // initial render\n        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false\n        /* removeOnly */\n        );\n      } else {\n        // updates\n        vm.$el = vm.__patch__(prevVnode, vnode);\n      }\n\n      restoreActiveInstance(); // update __vue__ reference\n\n      if (prevEl) {\n        prevEl.__vue__ = null;\n      }\n\n      if (vm.$el) {\n        vm.$el.__vue__ = vm;\n      } // if parent is an HOC, update its $el as well\n\n\n      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n        vm.$parent.$el = vm.$el;\n      } // updated hook is called by the scheduler to ensure that children are\n      // updated in a parent's updated hook.\n\n    };\n\n    Vue.prototype.$forceUpdate = function () {\n      var vm = this;\n\n      if (vm._watcher) {\n        vm._watcher.update();\n      }\n    };\n\n    Vue.prototype.$destroy = function () {\n      var vm = this;\n\n      if (vm._isBeingDestroyed) {\n        return;\n      }\n\n      callHook(vm, 'beforeDestroy');\n      vm._isBeingDestroyed = true; // remove self from parent\n\n      var parent = vm.$parent;\n\n      if (parent && !parent._isBeingDestroyed && !vm.$options[\"abstract\"]) {\n        remove(parent.$children, vm);\n      } // teardown watchers\n\n\n      if (vm._watcher) {\n        vm._watcher.teardown();\n      }\n\n      var i = vm._watchers.length;\n\n      while (i--) {\n        vm._watchers[i].teardown();\n      } // remove reference from data ob\n      // frozen object may not have observer.\n\n\n      if (vm._data.__ob__) {\n        vm._data.__ob__.vmCount--;\n      } // call the last hook...\n\n\n      vm._isDestroyed = true; // invoke destroy hooks on current rendered tree\n\n      vm.__patch__(vm._vnode, null); // fire destroyed hook\n\n\n      callHook(vm, 'destroyed'); // turn off all instance listeners.\n\n      vm.$off(); // remove __vue__ reference\n\n      if (vm.$el) {\n        vm.$el.__vue__ = null;\n      } // release circular reference (#6759)\n\n\n      if (vm.$vnode) {\n        vm.$vnode.parent = null;\n      }\n    };\n  }\n\n  function mountComponent(vm, el, hydrating) {\n    vm.$el = el;\n\n    if (!vm.$options.render) {\n      vm.$options.render = createEmptyVNode;\n      {\n        /* istanbul ignore if */\n        if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {\n          warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);\n        } else {\n          warn('Failed to mount component: template or render function not defined.', vm);\n        }\n      }\n    }\n\n    callHook(vm, 'beforeMount');\n    var updateComponent;\n    /* istanbul ignore if */\n\n    if (config.performance && mark) {\n      updateComponent = function updateComponent() {\n        var name = vm._name;\n        var id = vm._uid;\n        var startTag = \"vue-perf-start:\" + id;\n        var endTag = \"vue-perf-end:\" + id;\n        mark(startTag);\n\n        var vnode = vm._render();\n\n        mark(endTag);\n        measure(\"vue \" + name + \" render\", startTag, endTag);\n        mark(startTag);\n\n        vm._update(vnode, hydrating);\n\n        mark(endTag);\n        measure(\"vue \" + name + \" patch\", startTag, endTag);\n      };\n    } else {\n      updateComponent = function updateComponent() {\n        vm._update(vm._render(), hydrating);\n      };\n    } // we set this to vm._watcher inside the watcher's constructor\n    // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n    // component's mounted hook), which relies on vm._watcher being already defined\n\n\n    new Watcher(vm, updateComponent, noop, {\n      before: function before() {\n        if (vm._isMounted && !vm._isDestroyed) {\n          callHook(vm, 'beforeUpdate');\n        }\n      }\n    }, true\n    /* isRenderWatcher */\n    );\n    hydrating = false; // manually mounted instance, call mounted on self\n    // mounted is called for render-created child components in its inserted hook\n\n    if (vm.$vnode == null) {\n      vm._isMounted = true;\n      callHook(vm, 'mounted');\n    }\n\n    return vm;\n  }\n\n  function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\n    {\n      isUpdatingChildComponent = true;\n    } // determine whether component has slot children\n    // we need to do this before overwriting $options._renderChildren.\n    // check if there are dynamic scopedSlots (hand-written or compiled but with\n    // dynamic slot names). Static scoped slots compiled from template has the\n    // \"$stable\" marker.\n\n    var newScopedSlots = parentVnode.data.scopedSlots;\n    var oldScopedSlots = vm.$scopedSlots;\n    var hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key); // Any static slot children from the parent may have changed during parent's\n    // update. Dynamic scoped slots may also have changed. In such cases, a forced\n    // update is necessary to ensure correctness.\n\n    var needsForceUpdate = !!(renderChildren || // has new static slots\n    vm.$options._renderChildren || // has old static slots\n    hasDynamicScopedSlot);\n    vm.$options._parentVnode = parentVnode;\n    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n    if (vm._vnode) {\n      // update child tree's parent\n      vm._vnode.parent = parentVnode;\n    }\n\n    vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash\n    // these are also reactive so they may trigger child update if the child\n    // used them during render\n\n    vm.$attrs = parentVnode.data.attrs || emptyObject;\n    vm.$listeners = listeners || emptyObject; // update props\n\n    if (propsData && vm.$options.props) {\n      toggleObserving(false);\n      var props = vm._props;\n      var propKeys = vm.$options._propKeys || [];\n\n      for (var i = 0; i < propKeys.length; i++) {\n        var key = propKeys[i];\n        var propOptions = vm.$options.props; // wtf flow?\n\n        props[key] = validateProp(key, propOptions, propsData, vm);\n      }\n\n      toggleObserving(true); // keep a copy of raw propsData\n\n      vm.$options.propsData = propsData;\n    } // update listeners\n\n\n    listeners = listeners || emptyObject;\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children\n\n    if (needsForceUpdate) {\n      vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n      vm.$forceUpdate();\n    }\n\n    {\n      isUpdatingChildComponent = false;\n    }\n  }\n\n  function isInInactiveTree(vm) {\n    while (vm && (vm = vm.$parent)) {\n      if (vm._inactive) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function activateChildComponent(vm, direct) {\n    if (direct) {\n      vm._directInactive = false;\n\n      if (isInInactiveTree(vm)) {\n        return;\n      }\n    } else if (vm._directInactive) {\n      return;\n    }\n\n    if (vm._inactive || vm._inactive === null) {\n      vm._inactive = false;\n\n      for (var i = 0; i < vm.$children.length; i++) {\n        activateChildComponent(vm.$children[i]);\n      }\n\n      callHook(vm, 'activated');\n    }\n  }\n\n  function deactivateChildComponent(vm, direct) {\n    if (direct) {\n      vm._directInactive = true;\n\n      if (isInInactiveTree(vm)) {\n        return;\n      }\n    }\n\n    if (!vm._inactive) {\n      vm._inactive = true;\n\n      for (var i = 0; i < vm.$children.length; i++) {\n        deactivateChildComponent(vm.$children[i]);\n      }\n\n      callHook(vm, 'deactivated');\n    }\n  }\n\n  function callHook(vm, hook) {\n    // #7573 disable dep collection when invoking lifecycle hooks\n    pushTarget();\n    var handlers = vm.$options[hook];\n    var info = hook + \" hook\";\n\n    if (handlers) {\n      for (var i = 0, j = handlers.length; i < j; i++) {\n        invokeWithErrorHandling(handlers[i], vm, null, vm, info);\n      }\n    }\n\n    if (vm._hasHookEvent) {\n      vm.$emit('hook:' + hook);\n    }\n\n    popTarget();\n  }\n  /*  */\n\n\n  var MAX_UPDATE_COUNT = 100;\n  var queue = [];\n  var activatedChildren = [];\n  var has = {};\n  var circular = {};\n  var waiting = false;\n  var flushing = false;\n  var index = 0;\n  /**\n   * Reset the scheduler's state.\n   */\n\n  function resetSchedulerState() {\n    index = queue.length = activatedChildren.length = 0;\n    has = {};\n    {\n      circular = {};\n    }\n    waiting = flushing = false;\n  } // Async edge case #6566 requires saving the timestamp when event listeners are\n  // attached. However, calling performance.now() has a perf overhead especially\n  // if the page has thousands of event listeners. Instead, we take a timestamp\n  // every time the scheduler flushes and use that for all event listeners\n  // attached during that flush.\n\n\n  var currentFlushTimestamp = 0; // Async edge case fix requires storing an event listener's attach timestamp.\n\n  var getNow = Date.now; // Determine what event timestamp the browser is using. Annoyingly, the\n  // timestamp can either be hi-res (relative to page load) or low-res\n  // (relative to UNIX epoch), so in order to compare time we have to use the\n  // same timestamp type when saving the flush timestamp.\n  // All IE versions use low-res event timestamps, and have problematic clock\n  // implementations (#9632)\n\n  if (inBrowser && !isIE) {\n    var performance = window.performance;\n\n    if (performance && typeof performance.now === 'function' && getNow() > document.createEvent('Event').timeStamp) {\n      // if the event timestamp, although evaluated AFTER the Date.now(), is\n      // smaller than it, it means the event is using a hi-res timestamp,\n      // and we need to use the hi-res version for event listener timestamps as\n      // well.\n      getNow = function getNow() {\n        return performance.now();\n      };\n    }\n  }\n  /**\n   * Flush both queues and run the watchers.\n   */\n\n\n  function flushSchedulerQueue() {\n    currentFlushTimestamp = getNow();\n    flushing = true;\n    var watcher, id; // Sort queue before flush.\n    // This ensures that:\n    // 1. Components are updated from parent to child. (because parent is always\n    //    created before the child)\n    // 2. A component's user watchers are run before its render watcher (because\n    //    user watchers are created before the render watcher)\n    // 3. If a component is destroyed during a parent component's watcher run,\n    //    its watchers can be skipped.\n\n    queue.sort(function (a, b) {\n      return a.id - b.id;\n    }); // do not cache length because more watchers might be pushed\n    // as we run existing watchers\n\n    for (index = 0; index < queue.length; index++) {\n      watcher = queue[index];\n\n      if (watcher.before) {\n        watcher.before();\n      }\n\n      id = watcher.id;\n      has[id] = null;\n      watcher.run(); // in dev build, check and stop circular updates.\n\n      if (has[id] != null) {\n        circular[id] = (circular[id] || 0) + 1;\n\n        if (circular[id] > MAX_UPDATE_COUNT) {\n          warn('You may have an infinite update loop ' + (watcher.user ? \"in watcher with expression \\\"\" + watcher.expression + \"\\\"\" : \"in a component render function.\"), watcher.vm);\n          break;\n        }\n      }\n    } // keep copies of post queues before resetting state\n\n\n    var activatedQueue = activatedChildren.slice();\n    var updatedQueue = queue.slice();\n    resetSchedulerState(); // call component updated and activated hooks\n\n    callActivatedHooks(activatedQueue);\n    callUpdatedHooks(updatedQueue); // devtool hook\n\n    /* istanbul ignore if */\n\n    if (devtools && config.devtools) {\n      devtools.emit('flush');\n    }\n  }\n\n  function callUpdatedHooks(queue) {\n    var i = queue.length;\n\n    while (i--) {\n      var watcher = queue[i];\n      var vm = watcher.vm;\n\n      if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'updated');\n      }\n    }\n  }\n  /**\n   * Queue a kept-alive component that was activated during patch.\n   * The queue will be processed after the entire tree has been patched.\n   */\n\n\n  function queueActivatedComponent(vm) {\n    // setting _inactive to false here so that a render function can\n    // rely on checking whether it's in an inactive tree (e.g. router-view)\n    vm._inactive = false;\n    activatedChildren.push(vm);\n  }\n\n  function callActivatedHooks(queue) {\n    for (var i = 0; i < queue.length; i++) {\n      queue[i]._inactive = true;\n      activateChildComponent(queue[i], true\n      /* true */\n      );\n    }\n  }\n  /**\n   * Push a watcher into the watcher queue.\n   * Jobs with duplicate IDs will be skipped unless it's\n   * pushed when the queue is being flushed.\n   */\n\n\n  function queueWatcher(watcher) {\n    var id = watcher.id;\n\n    if (has[id] == null) {\n      has[id] = true;\n\n      if (!flushing) {\n        queue.push(watcher);\n      } else {\n        // if already flushing, splice the watcher based on its id\n        // if already past its id, it will be run next immediately.\n        var i = queue.length - 1;\n\n        while (i > index && queue[i].id > watcher.id) {\n          i--;\n        }\n\n        queue.splice(i + 1, 0, watcher);\n      } // queue the flush\n\n\n      if (!waiting) {\n        waiting = true;\n\n        if (!config.async) {\n          flushSchedulerQueue();\n          return;\n        }\n\n        nextTick(flushSchedulerQueue);\n      }\n    }\n  }\n  /*  */\n\n\n  var uid$2 = 0;\n  /**\n   * A watcher parses an expression, collects dependencies,\n   * and fires callback when the expression value changes.\n   * This is used for both the $watch() api and directives.\n   */\n\n  var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {\n    this.vm = vm;\n\n    if (isRenderWatcher) {\n      vm._watcher = this;\n    }\n\n    vm._watchers.push(this); // options\n\n\n    if (options) {\n      this.deep = !!options.deep;\n      this.user = !!options.user;\n      this.lazy = !!options.lazy;\n      this.sync = !!options.sync;\n      this.before = options.before;\n    } else {\n      this.deep = this.user = this.lazy = this.sync = false;\n    }\n\n    this.cb = cb;\n    this.id = ++uid$2; // uid for batching\n\n    this.active = true;\n    this.dirty = this.lazy; // for lazy watchers\n\n    this.deps = [];\n    this.newDeps = [];\n    this.depIds = new _Set();\n    this.newDepIds = new _Set();\n    this.expression = expOrFn.toString(); // parse expression for getter\n\n    if (typeof expOrFn === 'function') {\n      this.getter = expOrFn;\n    } else {\n      this.getter = parsePath(expOrFn);\n\n      if (!this.getter) {\n        this.getter = noop;\n        warn(\"Failed watching path: \\\"\" + expOrFn + \"\\\" \" + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);\n      }\n    }\n\n    this.value = this.lazy ? undefined : this.get();\n  };\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n\n\n  Watcher.prototype.get = function get() {\n    pushTarget(this);\n    var value;\n    var vm = this.vm;\n\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, \"getter for watcher \\\"\" + this.expression + \"\\\"\");\n      } else {\n        throw e;\n      }\n    } finally {\n      // \"touch\" every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        traverse(value);\n      }\n\n      popTarget();\n      this.cleanupDeps();\n    }\n\n    return value;\n  };\n  /**\n   * Add a dependency to this directive.\n   */\n\n\n  Watcher.prototype.addDep = function addDep(dep) {\n    var id = dep.id;\n\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id);\n      this.newDeps.push(dep);\n\n      if (!this.depIds.has(id)) {\n        dep.addSub(this);\n      }\n    }\n  };\n  /**\n   * Clean up for dependency collection.\n   */\n\n\n  Watcher.prototype.cleanupDeps = function cleanupDeps() {\n    var i = this.deps.length;\n\n    while (i--) {\n      var dep = this.deps[i];\n\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this);\n      }\n    }\n\n    var tmp = this.depIds;\n    this.depIds = this.newDepIds;\n    this.newDepIds = tmp;\n    this.newDepIds.clear();\n    tmp = this.deps;\n    this.deps = this.newDeps;\n    this.newDeps = tmp;\n    this.newDeps.length = 0;\n  };\n  /**\n   * Subscriber interface.\n   * Will be called when a dependency changes.\n   */\n\n\n  Watcher.prototype.update = function update() {\n    /* istanbul ignore else */\n    if (this.lazy) {\n      this.dirty = true;\n    } else if (this.sync) {\n      this.run();\n    } else {\n      queueWatcher(this);\n    }\n  };\n  /**\n   * Scheduler job interface.\n   * Will be called by the scheduler.\n   */\n\n\n  Watcher.prototype.run = function run() {\n    if (this.active) {\n      var value = this.get();\n\n      if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) || this.deep) {\n        // set new value\n        var oldValue = this.value;\n        this.value = value;\n\n        if (this.user) {\n          try {\n            this.cb.call(this.vm, value, oldValue);\n          } catch (e) {\n            handleError(e, this.vm, \"callback for watcher \\\"\" + this.expression + \"\\\"\");\n          }\n        } else {\n          this.cb.call(this.vm, value, oldValue);\n        }\n      }\n    }\n  };\n  /**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   */\n\n\n  Watcher.prototype.evaluate = function evaluate() {\n    this.value = this.get();\n    this.dirty = false;\n  };\n  /**\n   * Depend on all deps collected by this watcher.\n   */\n\n\n  Watcher.prototype.depend = function depend() {\n    var i = this.deps.length;\n\n    while (i--) {\n      this.deps[i].depend();\n    }\n  };\n  /**\n   * Remove self from all dependencies' subscriber list.\n   */\n\n\n  Watcher.prototype.teardown = function teardown() {\n    if (this.active) {\n      // remove self from vm's watcher list\n      // this is a somewhat expensive operation so we skip it\n      // if the vm is being destroyed.\n      if (!this.vm._isBeingDestroyed) {\n        remove(this.vm._watchers, this);\n      }\n\n      var i = this.deps.length;\n\n      while (i--) {\n        this.deps[i].removeSub(this);\n      }\n\n      this.active = false;\n    }\n  };\n  /*  */\n\n\n  var sharedPropertyDefinition = {\n    enumerable: true,\n    configurable: true,\n    get: noop,\n    set: noop\n  };\n\n  function proxy(target, sourceKey, key) {\n    sharedPropertyDefinition.get = function proxyGetter() {\n      return this[sourceKey][key];\n    };\n\n    sharedPropertyDefinition.set = function proxySetter(val) {\n      this[sourceKey][key] = val;\n    };\n\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function initState(vm) {\n    vm._watchers = [];\n    var opts = vm.$options;\n\n    if (opts.props) {\n      initProps(vm, opts.props);\n    }\n\n    if (opts.methods) {\n      initMethods(vm, opts.methods);\n    }\n\n    if (opts.data) {\n      initData(vm);\n    } else {\n      observe(vm._data = {}, true\n      /* asRootData */\n      );\n    }\n\n    if (opts.computed) {\n      initComputed(vm, opts.computed);\n    }\n\n    if (opts.watch && opts.watch !== nativeWatch) {\n      initWatch(vm, opts.watch);\n    }\n  }\n\n  function initProps(vm, propsOptions) {\n    var propsData = vm.$options.propsData || {};\n    var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array\n    // instead of dynamic object key enumeration.\n\n    var keys = vm.$options._propKeys = [];\n    var isRoot = !vm.$parent; // root instance props should be converted\n\n    if (!isRoot) {\n      toggleObserving(false);\n    }\n\n    var loop = function loop(key) {\n      keys.push(key);\n      var value = validateProp(key, propsOptions, propsData, vm);\n      /* istanbul ignore else */\n\n      {\n        var hyphenatedKey = hyphenate(key);\n\n        if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {\n          warn(\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\", vm);\n        }\n\n        defineReactive$$1(props, key, value, function () {\n          if (!isRoot && !isUpdatingChildComponent) {\n            warn(\"Avoid mutating a prop directly since the value will be \" + \"overwritten whenever the parent component re-renders. \" + \"Instead, use a data or computed property based on the prop's \" + \"value. Prop being mutated: \\\"\" + key + \"\\\"\", vm);\n          }\n        });\n      } // static props are already proxied on the component's prototype\n      // during Vue.extend(). We only need to proxy props defined at\n      // instantiation here.\n\n      if (!(key in vm)) {\n        proxy(vm, \"_props\", key);\n      }\n    };\n\n    for (var key in propsOptions) {\n      loop(key);\n    }\n\n    toggleObserving(true);\n  }\n\n  function initData(vm) {\n    var data = vm.$options.data;\n    data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};\n\n    if (!isPlainObject(data)) {\n      data = {};\n      warn('data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);\n    } // proxy data on instance\n\n\n    var keys = Object.keys(data);\n    var props = vm.$options.props;\n    var methods = vm.$options.methods;\n    var i = keys.length;\n\n    while (i--) {\n      var key = keys[i];\n      {\n        if (methods && hasOwn(methods, key)) {\n          warn(\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\", vm);\n        }\n      }\n\n      if (props && hasOwn(props, key)) {\n        warn(\"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" + \"Use prop default value instead.\", vm);\n      } else if (!isReserved(key)) {\n        proxy(vm, \"_data\", key);\n      }\n    } // observe data\n\n\n    observe(data, true\n    /* asRootData */\n    );\n  }\n\n  function getData(data, vm) {\n    // #7573 disable dep collection when invoking data getters\n    pushTarget();\n\n    try {\n      return data.call(vm, vm);\n    } catch (e) {\n      handleError(e, vm, \"data()\");\n      return {};\n    } finally {\n      popTarget();\n    }\n  }\n\n  var computedWatcherOptions = {\n    lazy: true\n  };\n\n  function initComputed(vm, computed) {\n    // $flow-disable-line\n    var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR\n\n    var isSSR = isServerRendering();\n\n    for (var key in computed) {\n      var userDef = computed[key];\n      var getter = typeof userDef === 'function' ? userDef : userDef.get;\n\n      if (getter == null) {\n        warn(\"Getter is missing for computed property \\\"\" + key + \"\\\".\", vm);\n      }\n\n      if (!isSSR) {\n        // create internal watcher for the computed property.\n        watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);\n      } // component-defined computed properties are already defined on the\n      // component prototype. We only need to define computed properties defined\n      // at instantiation here.\n\n\n      if (!(key in vm)) {\n        defineComputed(vm, key, userDef);\n      } else {\n        if (key in vm.$data) {\n          warn(\"The computed property \\\"\" + key + \"\\\" is already defined in data.\", vm);\n        } else if (vm.$options.props && key in vm.$options.props) {\n          warn(\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\", vm);\n        }\n      }\n    }\n  }\n\n  function defineComputed(target, key, userDef) {\n    var shouldCache = !isServerRendering();\n\n    if (typeof userDef === 'function') {\n      sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);\n      sharedPropertyDefinition.set = noop;\n    } else {\n      sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop;\n      sharedPropertyDefinition.set = userDef.set || noop;\n    }\n\n    if (sharedPropertyDefinition.set === noop) {\n      sharedPropertyDefinition.set = function () {\n        warn(\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\", this);\n      };\n    }\n\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function createComputedGetter(key) {\n    return function computedGetter() {\n      var watcher = this._computedWatchers && this._computedWatchers[key];\n\n      if (watcher) {\n        if (watcher.dirty) {\n          watcher.evaluate();\n        }\n\n        if (Dep.target) {\n          watcher.depend();\n        }\n\n        return watcher.value;\n      }\n    };\n  }\n\n  function createGetterInvoker(fn) {\n    return function computedGetter() {\n      return fn.call(this, this);\n    };\n  }\n\n  function initMethods(vm, methods) {\n    var props = vm.$options.props;\n\n    for (var key in methods) {\n      {\n        if (typeof methods[key] !== 'function') {\n          warn(\"Method \\\"\" + key + \"\\\" has type \\\"\" + _typeof(methods[key]) + \"\\\" in the component definition. \" + \"Did you reference the function correctly?\", vm);\n        }\n\n        if (props && hasOwn(props, key)) {\n          warn(\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\", vm);\n        }\n\n        if (key in vm && isReserved(key)) {\n          warn(\"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" + \"Avoid defining component methods that start with _ or $.\");\n        }\n      }\n      vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n    }\n  }\n\n  function initWatch(vm, watch) {\n    for (var key in watch) {\n      var handler = watch[key];\n\n      if (Array.isArray(handler)) {\n        for (var i = 0; i < handler.length; i++) {\n          createWatcher(vm, key, handler[i]);\n        }\n      } else {\n        createWatcher(vm, key, handler);\n      }\n    }\n  }\n\n  function createWatcher(vm, expOrFn, handler, options) {\n    if (isPlainObject(handler)) {\n      options = handler;\n      handler = handler.handler;\n    }\n\n    if (typeof handler === 'string') {\n      handler = vm[handler];\n    }\n\n    return vm.$watch(expOrFn, handler, options);\n  }\n\n  function stateMixin(Vue) {\n    // flow somehow has problems with directly declared definition object\n    // when using Object.defineProperty, so we have to procedurally build up\n    // the object here.\n    var dataDef = {};\n\n    dataDef.get = function () {\n      return this._data;\n    };\n\n    var propsDef = {};\n\n    propsDef.get = function () {\n      return this._props;\n    };\n\n    {\n      dataDef.set = function () {\n        warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);\n      };\n\n      propsDef.set = function () {\n        warn(\"$props is readonly.\", this);\n      };\n    }\n    Object.defineProperty(Vue.prototype, '$data', dataDef);\n    Object.defineProperty(Vue.prototype, '$props', propsDef);\n    Vue.prototype.$set = set;\n    Vue.prototype.$delete = del;\n\n    Vue.prototype.$watch = function (expOrFn, cb, options) {\n      var vm = this;\n\n      if (isPlainObject(cb)) {\n        return createWatcher(vm, expOrFn, cb, options);\n      }\n\n      options = options || {};\n      options.user = true;\n      var watcher = new Watcher(vm, expOrFn, cb, options);\n\n      if (options.immediate) {\n        try {\n          cb.call(vm, watcher.value);\n        } catch (error) {\n          handleError(error, vm, \"callback for immediate watcher \\\"\" + watcher.expression + \"\\\"\");\n        }\n      }\n\n      return function unwatchFn() {\n        watcher.teardown();\n      };\n    };\n  }\n  /*  */\n\n\n  var uid$3 = 0;\n\n  function initMixin(Vue) {\n    Vue.prototype._init = function (options) {\n      var vm = this; // a uid\n\n      vm._uid = uid$3++;\n      var startTag, endTag;\n      /* istanbul ignore if */\n\n      if (config.performance && mark) {\n        startTag = \"vue-perf-start:\" + vm._uid;\n        endTag = \"vue-perf-end:\" + vm._uid;\n        mark(startTag);\n      } // a flag to avoid this being observed\n\n\n      vm._isVue = true; // merge options\n\n      if (options && options._isComponent) {\n        // optimize internal component instantiation\n        // since dynamic options merging is pretty slow, and none of the\n        // internal component options needs special treatment.\n        initInternalComponent(vm, options);\n      } else {\n        vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\n      }\n      /* istanbul ignore else */\n\n\n      {\n        initProxy(vm);\n      } // expose real self\n\n      vm._self = vm;\n      initLifecycle(vm);\n      initEvents(vm);\n      initRender(vm);\n      callHook(vm, 'beforeCreate');\n      initInjections(vm); // resolve injections before data/props\n\n      initState(vm);\n      initProvide(vm); // resolve provide after data/props\n\n      callHook(vm, 'created');\n      /* istanbul ignore if */\n\n      if (config.performance && mark) {\n        vm._name = formatComponentName(vm, false);\n        mark(endTag);\n        measure(\"vue \" + vm._name + \" init\", startTag, endTag);\n      }\n\n      if (vm.$options.el) {\n        vm.$mount(vm.$options.el);\n      }\n    };\n  }\n\n  function initInternalComponent(vm, options) {\n    var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.\n\n    var parentVnode = options._parentVnode;\n    opts.parent = options.parent;\n    opts._parentVnode = parentVnode;\n    var vnodeComponentOptions = parentVnode.componentOptions;\n    opts.propsData = vnodeComponentOptions.propsData;\n    opts._parentListeners = vnodeComponentOptions.listeners;\n    opts._renderChildren = vnodeComponentOptions.children;\n    opts._componentTag = vnodeComponentOptions.tag;\n\n    if (options.render) {\n      opts.render = options.render;\n      opts.staticRenderFns = options.staticRenderFns;\n    }\n  }\n\n  function resolveConstructorOptions(Ctor) {\n    var options = Ctor.options;\n\n    if (Ctor[\"super\"]) {\n      var superOptions = resolveConstructorOptions(Ctor[\"super\"]);\n      var cachedSuperOptions = Ctor.superOptions;\n\n      if (superOptions !== cachedSuperOptions) {\n        // super option changed,\n        // need to resolve new options.\n        Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)\n\n        var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options\n\n        if (modifiedOptions) {\n          extend(Ctor.extendOptions, modifiedOptions);\n        }\n\n        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n\n        if (options.name) {\n          options.components[options.name] = Ctor;\n        }\n      }\n    }\n\n    return options;\n  }\n\n  function resolveModifiedOptions(Ctor) {\n    var modified;\n    var latest = Ctor.options;\n    var sealed = Ctor.sealedOptions;\n\n    for (var key in latest) {\n      if (latest[key] !== sealed[key]) {\n        if (!modified) {\n          modified = {};\n        }\n\n        modified[key] = latest[key];\n      }\n    }\n\n    return modified;\n  }\n\n  function Vue(options) {\n    if (!(this instanceof Vue)) {\n      warn('Vue is a constructor and should be called with the `new` keyword');\n    }\n\n    this._init(options);\n  }\n\n  initMixin(Vue);\n  stateMixin(Vue);\n  eventsMixin(Vue);\n  lifecycleMixin(Vue);\n  renderMixin(Vue);\n  /*  */\n\n  function initUse(Vue) {\n    Vue.use = function (plugin) {\n      var installedPlugins = this._installedPlugins || (this._installedPlugins = []);\n\n      if (installedPlugins.indexOf(plugin) > -1) {\n        return this;\n      } // additional parameters\n\n\n      var args = toArray(arguments, 1);\n      args.unshift(this);\n\n      if (typeof plugin.install === 'function') {\n        plugin.install.apply(plugin, args);\n      } else if (typeof plugin === 'function') {\n        plugin.apply(null, args);\n      }\n\n      installedPlugins.push(plugin);\n      return this;\n    };\n  }\n  /*  */\n\n\n  function initMixin$1(Vue) {\n    Vue.mixin = function (mixin) {\n      this.options = mergeOptions(this.options, mixin);\n      return this;\n    };\n  }\n  /*  */\n\n\n  function initExtend(Vue) {\n    /**\n     * Each instance constructor, including Vue, has a unique\n     * cid. This enables us to create wrapped \"child\n     * constructors\" for prototypal inheritance and cache them.\n     */\n    Vue.cid = 0;\n    var cid = 1;\n    /**\n     * Class inheritance\n     */\n\n    Vue.extend = function (extendOptions) {\n      extendOptions = extendOptions || {};\n      var Super = this;\n      var SuperId = Super.cid;\n      var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n\n      if (cachedCtors[SuperId]) {\n        return cachedCtors[SuperId];\n      }\n\n      var name = extendOptions.name || Super.options.name;\n\n      if (name) {\n        validateComponentName(name);\n      }\n\n      var Sub = function VueComponent(options) {\n        this._init(options);\n      };\n\n      Sub.prototype = Object.create(Super.prototype);\n      Sub.prototype.constructor = Sub;\n      Sub.cid = cid++;\n      Sub.options = mergeOptions(Super.options, extendOptions);\n      Sub['super'] = Super; // For props and computed properties, we define the proxy getters on\n      // the Vue instances at extension time, on the extended prototype. This\n      // avoids Object.defineProperty calls for each instance created.\n\n      if (Sub.options.props) {\n        initProps$1(Sub);\n      }\n\n      if (Sub.options.computed) {\n        initComputed$1(Sub);\n      } // allow further extension/mixin/plugin usage\n\n\n      Sub.extend = Super.extend;\n      Sub.mixin = Super.mixin;\n      Sub.use = Super.use; // create asset registers, so extended classes\n      // can have their private assets too.\n\n      ASSET_TYPES.forEach(function (type) {\n        Sub[type] = Super[type];\n      }); // enable recursive self-lookup\n\n      if (name) {\n        Sub.options.components[name] = Sub;\n      } // keep a reference to the super options at extension time.\n      // later at instantiation we can check if Super's options have\n      // been updated.\n\n\n      Sub.superOptions = Super.options;\n      Sub.extendOptions = extendOptions;\n      Sub.sealedOptions = extend({}, Sub.options); // cache constructor\n\n      cachedCtors[SuperId] = Sub;\n      return Sub;\n    };\n  }\n\n  function initProps$1(Comp) {\n    var props = Comp.options.props;\n\n    for (var key in props) {\n      proxy(Comp.prototype, \"_props\", key);\n    }\n  }\n\n  function initComputed$1(Comp) {\n    var computed = Comp.options.computed;\n\n    for (var key in computed) {\n      defineComputed(Comp.prototype, key, computed[key]);\n    }\n  }\n  /*  */\n\n\n  function initAssetRegisters(Vue) {\n    /**\n     * Create asset registration methods.\n     */\n    ASSET_TYPES.forEach(function (type) {\n      Vue[type] = function (id, definition) {\n        if (!definition) {\n          return this.options[type + 's'][id];\n        } else {\n          /* istanbul ignore if */\n          if (type === 'component') {\n            validateComponentName(id);\n          }\n\n          if (type === 'component' && isPlainObject(definition)) {\n            definition.name = definition.name || id;\n            definition = this.options._base.extend(definition);\n          }\n\n          if (type === 'directive' && typeof definition === 'function') {\n            definition = {\n              bind: definition,\n              update: definition\n            };\n          }\n\n          this.options[type + 's'][id] = definition;\n          return definition;\n        }\n      };\n    });\n  }\n  /*  */\n\n\n  function getComponentName(opts) {\n    return opts && (opts.Ctor.options.name || opts.tag);\n  }\n\n  function matches(pattern, name) {\n    if (Array.isArray(pattern)) {\n      return pattern.indexOf(name) > -1;\n    } else if (typeof pattern === 'string') {\n      return pattern.split(',').indexOf(name) > -1;\n    } else if (isRegExp(pattern)) {\n      return pattern.test(name);\n    }\n    /* istanbul ignore next */\n\n\n    return false;\n  }\n\n  function pruneCache(keepAliveInstance, filter) {\n    var cache = keepAliveInstance.cache;\n    var keys = keepAliveInstance.keys;\n    var _vnode = keepAliveInstance._vnode;\n\n    for (var key in cache) {\n      var cachedNode = cache[key];\n\n      if (cachedNode) {\n        var name = getComponentName(cachedNode.componentOptions);\n\n        if (name && !filter(name)) {\n          pruneCacheEntry(cache, key, keys, _vnode);\n        }\n      }\n    }\n  }\n\n  function pruneCacheEntry(cache, key, keys, current) {\n    var cached$$1 = cache[key];\n\n    if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n      cached$$1.componentInstance.$destroy();\n    }\n\n    cache[key] = null;\n    remove(keys, key);\n  }\n\n  var patternTypes = [String, RegExp, Array];\n  var KeepAlive = {\n    name: 'keep-alive',\n    \"abstract\": true,\n    props: {\n      include: patternTypes,\n      exclude: patternTypes,\n      max: [String, Number]\n    },\n    created: function created() {\n      this.cache = Object.create(null);\n      this.keys = [];\n    },\n    destroyed: function destroyed() {\n      for (var key in this.cache) {\n        pruneCacheEntry(this.cache, key, this.keys);\n      }\n    },\n    mounted: function mounted() {\n      var this$1 = this;\n      this.$watch('include', function (val) {\n        pruneCache(this$1, function (name) {\n          return matches(val, name);\n        });\n      });\n      this.$watch('exclude', function (val) {\n        pruneCache(this$1, function (name) {\n          return !matches(val, name);\n        });\n      });\n    },\n    render: function render() {\n      var slot = this.$slots[\"default\"];\n      var vnode = getFirstComponentChild(slot);\n      var componentOptions = vnode && vnode.componentOptions;\n\n      if (componentOptions) {\n        // check pattern\n        var name = getComponentName(componentOptions);\n        var ref = this;\n        var include = ref.include;\n        var exclude = ref.exclude;\n\n        if ( // not included\n        include && (!name || !matches(include, name)) || // excluded\n        exclude && name && matches(exclude, name)) {\n          return vnode;\n        }\n\n        var ref$1 = this;\n        var cache = ref$1.cache;\n        var keys = ref$1.keys;\n        var key = vnode.key == null // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? \"::\" + componentOptions.tag : '') : vnode.key;\n\n        if (cache[key]) {\n          vnode.componentInstance = cache[key].componentInstance; // make current key freshest\n\n          remove(keys, key);\n          keys.push(key);\n        } else {\n          cache[key] = vnode;\n          keys.push(key); // prune oldest entry\n\n          if (this.max && keys.length > parseInt(this.max)) {\n            pruneCacheEntry(cache, keys[0], keys, this._vnode);\n          }\n        }\n\n        vnode.data.keepAlive = true;\n      }\n\n      return vnode || slot && slot[0];\n    }\n  };\n  var builtInComponents = {\n    KeepAlive: KeepAlive\n  };\n  /*  */\n\n  function initGlobalAPI(Vue) {\n    // config\n    var configDef = {};\n\n    configDef.get = function () {\n      return config;\n    };\n\n    {\n      configDef.set = function () {\n        warn('Do not replace the Vue.config object, set individual fields instead.');\n      };\n    }\n    Object.defineProperty(Vue, 'config', configDef); // exposed util methods.\n    // NOTE: these are not considered part of the public API - avoid relying on\n    // them unless you are aware of the risk.\n\n    Vue.util = {\n      warn: warn,\n      extend: extend,\n      mergeOptions: mergeOptions,\n      defineReactive: defineReactive$$1\n    };\n    Vue.set = set;\n    Vue[\"delete\"] = del;\n    Vue.nextTick = nextTick; // 2.6 explicit observable API\n\n    Vue.observable = function (obj) {\n      observe(obj);\n      return obj;\n    };\n\n    Vue.options = Object.create(null);\n    ASSET_TYPES.forEach(function (type) {\n      Vue.options[type + 's'] = Object.create(null);\n    }); // this is used to identify the \"base\" constructor to extend all plain-object\n    // components with in Weex's multi-instance scenarios.\n\n    Vue.options._base = Vue;\n    extend(Vue.options.components, builtInComponents);\n    initUse(Vue);\n    initMixin$1(Vue);\n    initExtend(Vue);\n    initAssetRegisters(Vue);\n  }\n\n  initGlobalAPI(Vue);\n  Object.defineProperty(Vue.prototype, '$isServer', {\n    get: isServerRendering\n  });\n  Object.defineProperty(Vue.prototype, '$ssrContext', {\n    get: function get() {\n      /* istanbul ignore next */\n      return this.$vnode && this.$vnode.ssrContext;\n    }\n  }); // expose FunctionalRenderContext for ssr runtime helper installation\n\n  Object.defineProperty(Vue, 'FunctionalRenderContext', {\n    value: FunctionalRenderContext\n  });\n  Vue.version = '2.6.10';\n  /*  */\n  // these are reserved for web because they are directly compiled away\n  // during template compilation\n\n  var isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding\n\n  var acceptValue = makeMap('input,textarea,option,select,progress');\n\n  var mustUseProp = function mustUseProp(tag, type, attr) {\n    return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';\n  };\n\n  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n  var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\n\n  var convertEnumeratedValue = function convertEnumeratedValue(key, value) {\n    return isFalsyAttrValue(value) || value === 'false' ? 'false' // allow arbitrary string value for contenteditable\n    : key === 'contenteditable' && isValidContentEditableValue(value) ? value : 'true';\n  };\n\n  var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');\n  var xlinkNS = 'http://www.w3.org/1999/xlink';\n\n  var isXlink = function isXlink(name) {\n    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\n  };\n\n  var getXlinkProp = function getXlinkProp(name) {\n    return isXlink(name) ? name.slice(6, name.length) : '';\n  };\n\n  var isFalsyAttrValue = function isFalsyAttrValue(val) {\n    return val == null || val === false;\n  };\n  /*  */\n\n\n  function genClassForVnode(vnode) {\n    var data = vnode.data;\n    var parentNode = vnode;\n    var childNode = vnode;\n\n    while (isDef(childNode.componentInstance)) {\n      childNode = childNode.componentInstance._vnode;\n\n      if (childNode && childNode.data) {\n        data = mergeClassData(childNode.data, data);\n      }\n    }\n\n    while (isDef(parentNode = parentNode.parent)) {\n      if (parentNode && parentNode.data) {\n        data = mergeClassData(data, parentNode.data);\n      }\n    }\n\n    return renderClass(data.staticClass, data[\"class\"]);\n  }\n\n  function mergeClassData(child, parent) {\n    return {\n      staticClass: concat(child.staticClass, parent.staticClass),\n      \"class\": isDef(child[\"class\"]) ? [child[\"class\"], parent[\"class\"]] : parent[\"class\"]\n    };\n  }\n\n  function renderClass(staticClass, dynamicClass) {\n    if (isDef(staticClass) || isDef(dynamicClass)) {\n      return concat(staticClass, stringifyClass(dynamicClass));\n    }\n    /* istanbul ignore next */\n\n\n    return '';\n  }\n\n  function concat(a, b) {\n    return a ? b ? a + ' ' + b : a : b || '';\n  }\n\n  function stringifyClass(value) {\n    if (Array.isArray(value)) {\n      return stringifyArray(value);\n    }\n\n    if (isObject(value)) {\n      return stringifyObject(value);\n    }\n\n    if (typeof value === 'string') {\n      return value;\n    }\n    /* istanbul ignore next */\n\n\n    return '';\n  }\n\n  function stringifyArray(value) {\n    var res = '';\n    var stringified;\n\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n        if (res) {\n          res += ' ';\n        }\n\n        res += stringified;\n      }\n    }\n\n    return res;\n  }\n\n  function stringifyObject(value) {\n    var res = '';\n\n    for (var key in value) {\n      if (value[key]) {\n        if (res) {\n          res += ' ';\n        }\n\n        res += key;\n      }\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  var namespaceMap = {\n    svg: 'http://www.w3.org/2000/svg',\n    math: 'http://www.w3.org/1998/Math/MathML'\n  };\n  var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may\n  // contain child elements.\n\n  var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\n\n  var isPreTag = function isPreTag(tag) {\n    return tag === 'pre';\n  };\n\n  var isReservedTag = function isReservedTag(tag) {\n    return isHTMLTag(tag) || isSVG(tag);\n  };\n\n  function getTagNamespace(tag) {\n    if (isSVG(tag)) {\n      return 'svg';\n    } // basic support for MathML\n    // note it doesn't support other MathML elements being component roots\n\n\n    if (tag === 'math') {\n      return 'math';\n    }\n  }\n\n  var unknownElementCache = Object.create(null);\n\n  function isUnknownElement(tag) {\n    /* istanbul ignore if */\n    if (!inBrowser) {\n      return true;\n    }\n\n    if (isReservedTag(tag)) {\n      return false;\n    }\n\n    tag = tag.toLowerCase();\n    /* istanbul ignore if */\n\n    if (unknownElementCache[tag] != null) {\n      return unknownElementCache[tag];\n    }\n\n    var el = document.createElement(tag);\n\n    if (tag.indexOf('-') > -1) {\n      // http://stackoverflow.com/a/28210364/1070244\n      return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n    } else {\n      return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());\n    }\n  }\n\n  var isTextInputType = makeMap('text,number,password,search,email,tel,url');\n  /*  */\n\n  /**\n   * Query an element selector if it's not an element already.\n   */\n\n  function query(el) {\n    if (typeof el === 'string') {\n      var selected = document.querySelector(el);\n\n      if (!selected) {\n        warn('Cannot find element: ' + el);\n        return document.createElement('div');\n      }\n\n      return selected;\n    } else {\n      return el;\n    }\n  }\n  /*  */\n\n\n  function createElement$1(tagName, vnode) {\n    var elm = document.createElement(tagName);\n\n    if (tagName !== 'select') {\n      return elm;\n    } // false or null will remove the attribute but undefined will not\n\n\n    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n      elm.setAttribute('multiple', 'multiple');\n    }\n\n    return elm;\n  }\n\n  function createElementNS(namespace, tagName) {\n    return document.createElementNS(namespaceMap[namespace], tagName);\n  }\n\n  function createTextNode(text) {\n    return document.createTextNode(text);\n  }\n\n  function createComment(text) {\n    return document.createComment(text);\n  }\n\n  function insertBefore(parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n  }\n\n  function removeChild(node, child) {\n    node.removeChild(child);\n  }\n\n  function appendChild(node, child) {\n    node.appendChild(child);\n  }\n\n  function parentNode(node) {\n    return node.parentNode;\n  }\n\n  function nextSibling(node) {\n    return node.nextSibling;\n  }\n\n  function tagName(node) {\n    return node.tagName;\n  }\n\n  function setTextContent(node, text) {\n    node.textContent = text;\n  }\n\n  function setStyleScope(node, scopeId) {\n    node.setAttribute(scopeId, '');\n  }\n\n  var nodeOps =\n  /*#__PURE__*/\n  Object.freeze({\n    createElement: createElement$1,\n    createElementNS: createElementNS,\n    createTextNode: createTextNode,\n    createComment: createComment,\n    insertBefore: insertBefore,\n    removeChild: removeChild,\n    appendChild: appendChild,\n    parentNode: parentNode,\n    nextSibling: nextSibling,\n    tagName: tagName,\n    setTextContent: setTextContent,\n    setStyleScope: setStyleScope\n  });\n  /*  */\n\n  var ref = {\n    create: function create(_, vnode) {\n      registerRef(vnode);\n    },\n    update: function update(oldVnode, vnode) {\n      if (oldVnode.data.ref !== vnode.data.ref) {\n        registerRef(oldVnode, true);\n        registerRef(vnode);\n      }\n    },\n    destroy: function destroy(vnode) {\n      registerRef(vnode, true);\n    }\n  };\n\n  function registerRef(vnode, isRemoval) {\n    var key = vnode.data.ref;\n\n    if (!isDef(key)) {\n      return;\n    }\n\n    var vm = vnode.context;\n    var ref = vnode.componentInstance || vnode.elm;\n    var refs = vm.$refs;\n\n    if (isRemoval) {\n      if (Array.isArray(refs[key])) {\n        remove(refs[key], ref);\n      } else if (refs[key] === ref) {\n        refs[key] = undefined;\n      }\n    } else {\n      if (vnode.data.refInFor) {\n        if (!Array.isArray(refs[key])) {\n          refs[key] = [ref];\n        } else if (refs[key].indexOf(ref) < 0) {\n          // $flow-disable-line\n          refs[key].push(ref);\n        }\n      } else {\n        refs[key] = ref;\n      }\n    }\n  }\n  /**\n   * Virtual DOM patching algorithm based on Snabbdom by\n   * Simon Friis Vindum (@paldepind)\n   * Licensed under the MIT License\n   * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n   *\n   * modified by Evan You (@yyx990803)\n   *\n   * Not type-checking this because this file is perf-critical and the cost\n   * of making flow understand it is not worth it.\n   */\n\n\n  var emptyNode = new VNode('', {}, []);\n  var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\n  function sameVnode(a, b) {\n    return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));\n  }\n\n  function sameInputType(a, b) {\n    if (a.tag !== 'input') {\n      return true;\n    }\n\n    var i;\n    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);\n  }\n\n  function createKeyToOldIdx(children, beginIdx, endIdx) {\n    var i, key;\n    var map = {};\n\n    for (i = beginIdx; i <= endIdx; ++i) {\n      key = children[i].key;\n\n      if (isDef(key)) {\n        map[key] = i;\n      }\n    }\n\n    return map;\n  }\n\n  function createPatchFunction(backend) {\n    var i, j;\n    var cbs = {};\n    var modules = backend.modules;\n    var nodeOps = backend.nodeOps;\n\n    for (i = 0; i < hooks.length; ++i) {\n      cbs[hooks[i]] = [];\n\n      for (j = 0; j < modules.length; ++j) {\n        if (isDef(modules[j][hooks[i]])) {\n          cbs[hooks[i]].push(modules[j][hooks[i]]);\n        }\n      }\n    }\n\n    function emptyNodeAt(elm) {\n      return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\n    }\n\n    function createRmCb(childElm, listeners) {\n      function remove$$1() {\n        if (--remove$$1.listeners === 0) {\n          removeNode(childElm);\n        }\n      }\n\n      remove$$1.listeners = listeners;\n      return remove$$1;\n    }\n\n    function removeNode(el) {\n      var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text\n\n      if (isDef(parent)) {\n        nodeOps.removeChild(parent, el);\n      }\n    }\n\n    function isUnknownElement$$1(vnode, inVPre) {\n      return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {\n        return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;\n      })) && config.isUnknownElement(vnode.tag);\n    }\n\n    var creatingElmInVPre = 0;\n\n    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {\n      if (isDef(vnode.elm) && isDef(ownerArray)) {\n        // This vnode was used in a previous render!\n        // now it's used as a new node, overwriting its elm would cause\n        // potential patch errors down the road when it's used as an insertion\n        // reference node. Instead, we clone the node on-demand before creating\n        // associated DOM element for it.\n        vnode = ownerArray[index] = cloneVNode(vnode);\n      }\n\n      vnode.isRootInsert = !nested; // for transition enter check\n\n      if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n        return;\n      }\n\n      var data = vnode.data;\n      var children = vnode.children;\n      var tag = vnode.tag;\n\n      if (isDef(tag)) {\n        {\n          if (data && data.pre) {\n            creatingElmInVPre++;\n          }\n\n          if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n            warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.', vnode.context);\n          }\n        }\n        vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);\n        setScope(vnode);\n        /* istanbul ignore if */\n\n        {\n          createChildren(vnode, children, insertedVnodeQueue);\n\n          if (isDef(data)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n          }\n\n          insert(parentElm, vnode.elm, refElm);\n        }\n\n        if (data && data.pre) {\n          creatingElmInVPre--;\n        }\n      } else if (isTrue(vnode.isComment)) {\n        vnode.elm = nodeOps.createComment(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      } else {\n        vnode.elm = nodeOps.createTextNode(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      }\n    }\n\n    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i = vnode.data;\n\n      if (isDef(i)) {\n        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n\n        if (isDef(i = i.hook) && isDef(i = i.init)) {\n          i(vnode, false\n          /* hydrating */\n          );\n        } // after calling the init hook, if the vnode is a child component\n        // it should've created a child instance and mounted it. the child\n        // component also has set the placeholder vnode's elm.\n        // in that case we can just return the element and be done.\n\n\n        if (isDef(vnode.componentInstance)) {\n          initComponent(vnode, insertedVnodeQueue);\n          insert(parentElm, vnode.elm, refElm);\n\n          if (isTrue(isReactivated)) {\n            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n          }\n\n          return true;\n        }\n      }\n    }\n\n    function initComponent(vnode, insertedVnodeQueue) {\n      if (isDef(vnode.data.pendingInsert)) {\n        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n        vnode.data.pendingInsert = null;\n      }\n\n      vnode.elm = vnode.componentInstance.$el;\n\n      if (isPatchable(vnode)) {\n        invokeCreateHooks(vnode, insertedVnodeQueue);\n        setScope(vnode);\n      } else {\n        // empty component root.\n        // skip all element-related modules except for ref (#3455)\n        registerRef(vnode); // make sure to invoke the insert hook\n\n        insertedVnodeQueue.push(vnode);\n      }\n    }\n\n    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i; // hack for #4339: a reactivated component with inner transition\n      // does not trigger because the inner node's created hooks are not called\n      // again. It's not ideal to involve module-specific logic in here but\n      // there doesn't seem to be a better way to do it.\n\n      var innerNode = vnode;\n\n      while (innerNode.componentInstance) {\n        innerNode = innerNode.componentInstance._vnode;\n\n        if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n          for (i = 0; i < cbs.activate.length; ++i) {\n            cbs.activate[i](emptyNode, innerNode);\n          }\n\n          insertedVnodeQueue.push(innerNode);\n          break;\n        }\n      } // unlike a newly created component,\n      // a reactivated keep-alive component doesn't insert itself\n\n\n      insert(parentElm, vnode.elm, refElm);\n    }\n\n    function insert(parent, elm, ref$$1) {\n      if (isDef(parent)) {\n        if (isDef(ref$$1)) {\n          if (nodeOps.parentNode(ref$$1) === parent) {\n            nodeOps.insertBefore(parent, elm, ref$$1);\n          }\n        } else {\n          nodeOps.appendChild(parent, elm);\n        }\n      }\n    }\n\n    function createChildren(vnode, children, insertedVnodeQueue) {\n      if (Array.isArray(children)) {\n        {\n          checkDuplicateKeys(children);\n        }\n\n        for (var i = 0; i < children.length; ++i) {\n          createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n        }\n      } else if (isPrimitive(vnode.text)) {\n        nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n      }\n    }\n\n    function isPatchable(vnode) {\n      while (vnode.componentInstance) {\n        vnode = vnode.componentInstance._vnode;\n      }\n\n      return isDef(vnode.tag);\n    }\n\n    function invokeCreateHooks(vnode, insertedVnodeQueue) {\n      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n        cbs.create[i$1](emptyNode, vnode);\n      }\n\n      i = vnode.data.hook; // Reuse variable\n\n      if (isDef(i)) {\n        if (isDef(i.create)) {\n          i.create(emptyNode, vnode);\n        }\n\n        if (isDef(i.insert)) {\n          insertedVnodeQueue.push(vnode);\n        }\n      }\n    } // set scope id attribute for scoped CSS.\n    // this is implemented as a special case to avoid the overhead\n    // of going through the normal attribute patching process.\n\n\n    function setScope(vnode) {\n      var i;\n\n      if (isDef(i = vnode.fnScopeId)) {\n        nodeOps.setStyleScope(vnode.elm, i);\n      } else {\n        var ancestor = vnode;\n\n        while (ancestor) {\n          if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n            nodeOps.setStyleScope(vnode.elm, i);\n          }\n\n          ancestor = ancestor.parent;\n        }\n      } // for slot content they should also get the scopeId from the host instance.\n\n\n      if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {\n        nodeOps.setStyleScope(vnode.elm, i);\n      }\n    }\n\n    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n      }\n    }\n\n    function invokeDestroyHook(vnode) {\n      var i, j;\n      var data = vnode.data;\n\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.destroy)) {\n          i(vnode);\n        }\n\n        for (i = 0; i < cbs.destroy.length; ++i) {\n          cbs.destroy[i](vnode);\n        }\n      }\n\n      if (isDef(i = vnode.children)) {\n        for (j = 0; j < vnode.children.length; ++j) {\n          invokeDestroyHook(vnode.children[j]);\n        }\n      }\n    }\n\n    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        var ch = vnodes[startIdx];\n\n        if (isDef(ch)) {\n          if (isDef(ch.tag)) {\n            removeAndInvokeRemoveHook(ch);\n            invokeDestroyHook(ch);\n          } else {\n            // Text node\n            removeNode(ch.elm);\n          }\n        }\n      }\n    }\n\n    function removeAndInvokeRemoveHook(vnode, rm) {\n      if (isDef(rm) || isDef(vnode.data)) {\n        var i;\n        var listeners = cbs.remove.length + 1;\n\n        if (isDef(rm)) {\n          // we have a recursively passed down rm callback\n          // increase the listeners count\n          rm.listeners += listeners;\n        } else {\n          // directly removing\n          rm = createRmCb(vnode.elm, listeners);\n        } // recursively invoke hooks on child component root node\n\n\n        if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n          removeAndInvokeRemoveHook(i, rm);\n        }\n\n        for (i = 0; i < cbs.remove.length; ++i) {\n          cbs.remove[i](vnode, rm);\n        }\n\n        if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n          i(vnode, rm);\n        } else {\n          rm();\n        }\n      } else {\n        removeNode(vnode.elm);\n      }\n    }\n\n    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n      var oldStartIdx = 0;\n      var newStartIdx = 0;\n      var oldEndIdx = oldCh.length - 1;\n      var oldStartVnode = oldCh[0];\n      var oldEndVnode = oldCh[oldEndIdx];\n      var newEndIdx = newCh.length - 1;\n      var newStartVnode = newCh[0];\n      var newEndVnode = newCh[newEndIdx];\n      var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>\n      // to ensure removed elements stay in correct relative positions\n      // during leaving transitions\n\n      var canMove = !removeOnly;\n      {\n        checkDuplicateKeys(newCh);\n      }\n\n      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (isUndef(oldStartVnode)) {\n          oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n        } else if (isUndef(oldEndVnode)) {\n          oldEndVnode = oldCh[--oldEndIdx];\n        } else if (sameVnode(oldStartVnode, newStartVnode)) {\n          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n          oldStartVnode = oldCh[++oldStartIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else if (sameVnode(oldEndVnode, newEndVnode)) {\n          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldStartVnode, newEndVnode)) {\n          // Vnode moved right\n          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n          canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n          oldStartVnode = oldCh[++oldStartIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldEndVnode, newStartVnode)) {\n          // Vnode moved left\n          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n          canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          if (isUndef(oldKeyToIdx)) {\n            oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n          }\n\n          idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n\n          if (isUndef(idxInOld)) {\n            // New element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          } else {\n            vnodeToMove = oldCh[idxInOld];\n\n            if (sameVnode(vnodeToMove, newStartVnode)) {\n              patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n              oldCh[idxInOld] = undefined;\n              canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n            } else {\n              // same key but different element. treat as new element\n              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n            }\n          }\n\n          newStartVnode = newCh[++newStartIdx];\n        }\n      }\n\n      if (oldStartIdx > oldEndIdx) {\n        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n      } else if (newStartIdx > newEndIdx) {\n        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n      }\n    }\n\n    function checkDuplicateKeys(children) {\n      var seenKeys = {};\n\n      for (var i = 0; i < children.length; i++) {\n        var vnode = children[i];\n        var key = vnode.key;\n\n        if (isDef(key)) {\n          if (seenKeys[key]) {\n            warn(\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\", vnode.context);\n          } else {\n            seenKeys[key] = true;\n          }\n        }\n      }\n    }\n\n    function findIdxInOld(node, oldCh, start, end) {\n      for (var i = start; i < end; i++) {\n        var c = oldCh[i];\n\n        if (isDef(c) && sameVnode(node, c)) {\n          return i;\n        }\n      }\n    }\n\n    function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {\n      if (oldVnode === vnode) {\n        return;\n      }\n\n      if (isDef(vnode.elm) && isDef(ownerArray)) {\n        // clone reused vnode\n        vnode = ownerArray[index] = cloneVNode(vnode);\n      }\n\n      var elm = vnode.elm = oldVnode.elm;\n\n      if (isTrue(oldVnode.isAsyncPlaceholder)) {\n        if (isDef(vnode.asyncFactory.resolved)) {\n          hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n        } else {\n          vnode.isAsyncPlaceholder = true;\n        }\n\n        return;\n      } // reuse element for static trees.\n      // note we only do this if the vnode is cloned -\n      // if the new node is not cloned it means the render functions have been\n      // reset by the hot-reload-api and we need to do a proper re-render.\n\n\n      if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\n        vnode.componentInstance = oldVnode.componentInstance;\n        return;\n      }\n\n      var i;\n      var data = vnode.data;\n\n      if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n        i(oldVnode, vnode);\n      }\n\n      var oldCh = oldVnode.children;\n      var ch = vnode.children;\n\n      if (isDef(data) && isPatchable(vnode)) {\n        for (i = 0; i < cbs.update.length; ++i) {\n          cbs.update[i](oldVnode, vnode);\n        }\n\n        if (isDef(i = data.hook) && isDef(i = i.update)) {\n          i(oldVnode, vnode);\n        }\n      }\n\n      if (isUndef(vnode.text)) {\n        if (isDef(oldCh) && isDef(ch)) {\n          if (oldCh !== ch) {\n            updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\n          }\n        } else if (isDef(ch)) {\n          {\n            checkDuplicateKeys(ch);\n          }\n\n          if (isDef(oldVnode.text)) {\n            nodeOps.setTextContent(elm, '');\n          }\n\n          addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n        } else if (isDef(oldCh)) {\n          removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n        } else if (isDef(oldVnode.text)) {\n          nodeOps.setTextContent(elm, '');\n        }\n      } else if (oldVnode.text !== vnode.text) {\n        nodeOps.setTextContent(elm, vnode.text);\n      }\n\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.postpatch)) {\n          i(oldVnode, vnode);\n        }\n      }\n    }\n\n    function invokeInsertHook(vnode, queue, initial) {\n      // delay insert hooks for component root nodes, invoke them after the\n      // element is really inserted\n      if (isTrue(initial) && isDef(vnode.parent)) {\n        vnode.parent.data.pendingInsert = queue;\n      } else {\n        for (var i = 0; i < queue.length; ++i) {\n          queue[i].data.hook.insert(queue[i]);\n        }\n      }\n    }\n\n    var hydrationBailed = false; // list of modules that can skip create hook during hydration because they\n    // are already rendered on the client or has no need for initialization\n    // Note: style is excluded because it relies on initial clone for future\n    // deep updates (#7063).\n\n    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.\n\n    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {\n      var i;\n      var tag = vnode.tag;\n      var data = vnode.data;\n      var children = vnode.children;\n      inVPre = inVPre || data && data.pre;\n      vnode.elm = elm;\n\n      if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n        vnode.isAsyncPlaceholder = true;\n        return true;\n      } // assert node match\n\n\n      {\n        if (!assertNodeMatch(elm, vnode, inVPre)) {\n          return false;\n        }\n      }\n\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.init)) {\n          i(vnode, true\n          /* hydrating */\n          );\n        }\n\n        if (isDef(i = vnode.componentInstance)) {\n          // child component. it should have hydrated its own tree.\n          initComponent(vnode, insertedVnodeQueue);\n          return true;\n        }\n      }\n\n      if (isDef(tag)) {\n        if (isDef(children)) {\n          // empty element, allow client to pick up and populate children\n          if (!elm.hasChildNodes()) {\n            createChildren(vnode, children, insertedVnodeQueue);\n          } else {\n            // v-html and domProps: innerHTML\n            if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n              if (i !== elm.innerHTML) {\n                /* istanbul ignore if */\n                if (typeof console !== 'undefined' && !hydrationBailed) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('server innerHTML: ', i);\n                  console.warn('client innerHTML: ', elm.innerHTML);\n                }\n\n                return false;\n              }\n            } else {\n              // iterate and compare children lists\n              var childrenMatch = true;\n              var childNode = elm.firstChild;\n\n              for (var i$1 = 0; i$1 < children.length; i$1++) {\n                if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                  childrenMatch = false;\n                  break;\n                }\n\n                childNode = childNode.nextSibling;\n              } // if childNode is not null, it means the actual childNodes list is\n              // longer than the virtual children list.\n\n\n              if (!childrenMatch || childNode) {\n                /* istanbul ignore if */\n                if (typeof console !== 'undefined' && !hydrationBailed) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n                }\n\n                return false;\n              }\n            }\n          }\n        }\n\n        if (isDef(data)) {\n          var fullInvoke = false;\n\n          for (var key in data) {\n            if (!isRenderedModule(key)) {\n              fullInvoke = true;\n              invokeCreateHooks(vnode, insertedVnodeQueue);\n              break;\n            }\n          }\n\n          if (!fullInvoke && data['class']) {\n            // ensure collecting deps for deep class bindings for future updates\n            traverse(data['class']);\n          }\n        }\n      } else if (elm.data !== vnode.text) {\n        elm.data = vnode.text;\n      }\n\n      return true;\n    }\n\n    function assertNodeMatch(node, vnode, inVPre) {\n      if (isDef(vnode.tag)) {\n        return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());\n      } else {\n        return node.nodeType === (vnode.isComment ? 8 : 3);\n      }\n    }\n\n    return function patch(oldVnode, vnode, hydrating, removeOnly) {\n      if (isUndef(vnode)) {\n        if (isDef(oldVnode)) {\n          invokeDestroyHook(oldVnode);\n        }\n\n        return;\n      }\n\n      var isInitialPatch = false;\n      var insertedVnodeQueue = [];\n\n      if (isUndef(oldVnode)) {\n        // empty mount (likely as component), create new root element\n        isInitialPatch = true;\n        createElm(vnode, insertedVnodeQueue);\n      } else {\n        var isRealElement = isDef(oldVnode.nodeType);\n\n        if (!isRealElement && sameVnode(oldVnode, vnode)) {\n          // patch existing root node\n          patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n        } else {\n          if (isRealElement) {\n            // mounting to a real element\n            // check if this is server-rendered content and if we can perform\n            // a successful hydration.\n            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n              oldVnode.removeAttribute(SSR_ATTR);\n              hydrating = true;\n            }\n\n            if (isTrue(hydrating)) {\n              if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n                invokeInsertHook(vnode, insertedVnodeQueue, true);\n                return oldVnode;\n              } else {\n                warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');\n              }\n            } // either not server-rendered, or hydration failed.\n            // create an empty node and replace it\n\n\n            oldVnode = emptyNodeAt(oldVnode);\n          } // replacing existing element\n\n\n          var oldElm = oldVnode.elm;\n          var parentElm = nodeOps.parentNode(oldElm); // create new node\n\n          createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively\n\n          if (isDef(vnode.parent)) {\n            var ancestor = vnode.parent;\n            var patchable = isPatchable(vnode);\n\n            while (ancestor) {\n              for (var i = 0; i < cbs.destroy.length; ++i) {\n                cbs.destroy[i](ancestor);\n              }\n\n              ancestor.elm = vnode.elm;\n\n              if (patchable) {\n                for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                  cbs.create[i$1](emptyNode, ancestor);\n                } // #6513\n                // invoke insert hooks that may have been merged by create hooks.\n                // e.g. for directives that uses the \"inserted\" hook.\n\n\n                var insert = ancestor.data.hook.insert;\n\n                if (insert.merged) {\n                  // start at index 1 to avoid re-invoking component mounted hook\n                  for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                    insert.fns[i$2]();\n                  }\n                }\n              } else {\n                registerRef(ancestor);\n              }\n\n              ancestor = ancestor.parent;\n            }\n          } // destroy old node\n\n\n          if (isDef(parentElm)) {\n            removeVnodes(parentElm, [oldVnode], 0, 0);\n          } else if (isDef(oldVnode.tag)) {\n            invokeDestroyHook(oldVnode);\n          }\n        }\n      }\n\n      invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n      return vnode.elm;\n    };\n  }\n  /*  */\n\n\n  var directives = {\n    create: updateDirectives,\n    update: updateDirectives,\n    destroy: function unbindDirectives(vnode) {\n      updateDirectives(vnode, emptyNode);\n    }\n  };\n\n  function updateDirectives(oldVnode, vnode) {\n    if (oldVnode.data.directives || vnode.data.directives) {\n      _update(oldVnode, vnode);\n    }\n  }\n\n  function _update(oldVnode, vnode) {\n    var isCreate = oldVnode === emptyNode;\n    var isDestroy = vnode === emptyNode;\n    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n    var dirsWithInsert = [];\n    var dirsWithPostpatch = [];\n    var key, oldDir, dir;\n\n    for (key in newDirs) {\n      oldDir = oldDirs[key];\n      dir = newDirs[key];\n\n      if (!oldDir) {\n        // new directive, bind\n        callHook$1(dir, 'bind', vnode, oldVnode);\n\n        if (dir.def && dir.def.inserted) {\n          dirsWithInsert.push(dir);\n        }\n      } else {\n        // existing directive, update\n        dir.oldValue = oldDir.value;\n        dir.oldArg = oldDir.arg;\n        callHook$1(dir, 'update', vnode, oldVnode);\n\n        if (dir.def && dir.def.componentUpdated) {\n          dirsWithPostpatch.push(dir);\n        }\n      }\n    }\n\n    if (dirsWithInsert.length) {\n      var callInsert = function callInsert() {\n        for (var i = 0; i < dirsWithInsert.length; i++) {\n          callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n        }\n      };\n\n      if (isCreate) {\n        mergeVNodeHook(vnode, 'insert', callInsert);\n      } else {\n        callInsert();\n      }\n    }\n\n    if (dirsWithPostpatch.length) {\n      mergeVNodeHook(vnode, 'postpatch', function () {\n        for (var i = 0; i < dirsWithPostpatch.length; i++) {\n          callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n        }\n      });\n    }\n\n    if (!isCreate) {\n      for (key in oldDirs) {\n        if (!newDirs[key]) {\n          // no longer present, unbind\n          callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n        }\n      }\n    }\n  }\n\n  var emptyModifiers = Object.create(null);\n\n  function normalizeDirectives$1(dirs, vm) {\n    var res = Object.create(null);\n\n    if (!dirs) {\n      // $flow-disable-line\n      return res;\n    }\n\n    var i, dir;\n\n    for (i = 0; i < dirs.length; i++) {\n      dir = dirs[i];\n\n      if (!dir.modifiers) {\n        // $flow-disable-line\n        dir.modifiers = emptyModifiers;\n      }\n\n      res[getRawDirName(dir)] = dir;\n      dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n    } // $flow-disable-line\n\n\n    return res;\n  }\n\n  function getRawDirName(dir) {\n    return dir.rawName || dir.name + \".\" + Object.keys(dir.modifiers || {}).join('.');\n  }\n\n  function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {\n    var fn = dir.def && dir.def[hook];\n\n    if (fn) {\n      try {\n        fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n      } catch (e) {\n        handleError(e, vnode.context, \"directive \" + dir.name + \" \" + hook + \" hook\");\n      }\n    }\n  }\n\n  var baseModules = [ref, directives];\n  /*  */\n\n  function updateAttrs(oldVnode, vnode) {\n    var opts = vnode.componentOptions;\n\n    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n      return;\n    }\n\n    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n      return;\n    }\n\n    var key, cur, old;\n    var elm = vnode.elm;\n    var oldAttrs = oldVnode.data.attrs || {};\n    var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it\n\n    if (isDef(attrs.__ob__)) {\n      attrs = vnode.data.attrs = extend({}, attrs);\n    }\n\n    for (key in attrs) {\n      cur = attrs[key];\n      old = oldAttrs[key];\n\n      if (old !== cur) {\n        setAttr(elm, key, cur);\n      }\n    } // #4391: in IE9, setting type can reset value for input[type=radio]\n    // #6666: IE/Edge forces progress value down to 1 before setting a max\n\n    /* istanbul ignore if */\n\n\n    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n      setAttr(elm, 'value', attrs.value);\n    }\n\n    for (key in oldAttrs) {\n      if (isUndef(attrs[key])) {\n        if (isXlink(key)) {\n          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n        } else if (!isEnumeratedAttr(key)) {\n          elm.removeAttribute(key);\n        }\n      }\n    }\n  }\n\n  function setAttr(el, key, value) {\n    if (el.tagName.indexOf('-') > -1) {\n      baseSetAttr(el, key, value);\n    } else if (isBooleanAttr(key)) {\n      // set attribute for blank value\n      // e.g. <option disabled>Select one</option>\n      if (isFalsyAttrValue(value)) {\n        el.removeAttribute(key);\n      } else {\n        // technically allowfullscreen is a boolean attribute for <iframe>,\n        // but Flash expects a value of \"true\" when used on <embed> tag\n        value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;\n        el.setAttribute(key, value);\n      }\n    } else if (isEnumeratedAttr(key)) {\n      el.setAttribute(key, convertEnumeratedValue(key, value));\n    } else if (isXlink(key)) {\n      if (isFalsyAttrValue(value)) {\n        el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else {\n        el.setAttributeNS(xlinkNS, key, value);\n      }\n    } else {\n      baseSetAttr(el, key, value);\n    }\n  }\n\n  function baseSetAttr(el, key, value) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // #7138: IE10 & 11 fires input event when setting placeholder on\n      // <textarea>... block the first input event and remove the blocker\n      // immediately.\n\n      /* istanbul ignore if */\n      if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && value !== '' && !el.__ieph) {\n        var blocker = function blocker(e) {\n          e.stopImmediatePropagation();\n          el.removeEventListener('input', blocker);\n        };\n\n        el.addEventListener('input', blocker); // $flow-disable-line\n\n        el.__ieph = true;\n        /* IE placeholder patched */\n      }\n\n      el.setAttribute(key, value);\n    }\n  }\n\n  var attrs = {\n    create: updateAttrs,\n    update: updateAttrs\n  };\n  /*  */\n\n  function updateClass(oldVnode, vnode) {\n    var el = vnode.elm;\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n\n    if (isUndef(data.staticClass) && isUndef(data[\"class\"]) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData[\"class\"]))) {\n      return;\n    }\n\n    var cls = genClassForVnode(vnode); // handle transition classes\n\n    var transitionClass = el._transitionClasses;\n\n    if (isDef(transitionClass)) {\n      cls = concat(cls, stringifyClass(transitionClass));\n    } // set the class\n\n\n    if (cls !== el._prevClass) {\n      el.setAttribute('class', cls);\n      el._prevClass = cls;\n    }\n  }\n\n  var klass = {\n    create: updateClass,\n    update: updateClass\n  };\n  /*  */\n\n  var validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\n  function parseFilters(exp) {\n    var inSingle = false;\n    var inDouble = false;\n    var inTemplateString = false;\n    var inRegex = false;\n    var curly = 0;\n    var square = 0;\n    var paren = 0;\n    var lastFilterIndex = 0;\n    var c, prev, i, expression, filters;\n\n    for (i = 0; i < exp.length; i++) {\n      prev = c;\n      c = exp.charCodeAt(i);\n\n      if (inSingle) {\n        if (c === 0x27 && prev !== 0x5C) {\n          inSingle = false;\n        }\n      } else if (inDouble) {\n        if (c === 0x22 && prev !== 0x5C) {\n          inDouble = false;\n        }\n      } else if (inTemplateString) {\n        if (c === 0x60 && prev !== 0x5C) {\n          inTemplateString = false;\n        }\n      } else if (inRegex) {\n        if (c === 0x2f && prev !== 0x5C) {\n          inRegex = false;\n        }\n      } else if (c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {\n        if (expression === undefined) {\n          // first filter, end of expression\n          lastFilterIndex = i + 1;\n          expression = exp.slice(0, i).trim();\n        } else {\n          pushFilter();\n        }\n      } else {\n        switch (c) {\n          case 0x22:\n            inDouble = true;\n            break;\n          // \"\n\n          case 0x27:\n            inSingle = true;\n            break;\n          // '\n\n          case 0x60:\n            inTemplateString = true;\n            break;\n          // `\n\n          case 0x28:\n            paren++;\n            break;\n          // (\n\n          case 0x29:\n            paren--;\n            break;\n          // )\n\n          case 0x5B:\n            square++;\n            break;\n          // [\n\n          case 0x5D:\n            square--;\n            break;\n          // ]\n\n          case 0x7B:\n            curly++;\n            break;\n          // {\n\n          case 0x7D:\n            curly--;\n            break;\n          // }\n        }\n\n        if (c === 0x2f) {\n          // /\n          var j = i - 1;\n          var p = void 0; // find first non-whitespace prev char\n\n          for (; j >= 0; j--) {\n            p = exp.charAt(j);\n\n            if (p !== ' ') {\n              break;\n            }\n          }\n\n          if (!p || !validDivisionCharRE.test(p)) {\n            inRegex = true;\n          }\n        }\n      }\n    }\n\n    if (expression === undefined) {\n      expression = exp.slice(0, i).trim();\n    } else if (lastFilterIndex !== 0) {\n      pushFilter();\n    }\n\n    function pushFilter() {\n      (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n      lastFilterIndex = i + 1;\n    }\n\n    if (filters) {\n      for (i = 0; i < filters.length; i++) {\n        expression = wrapFilter(expression, filters[i]);\n      }\n    }\n\n    return expression;\n  }\n\n  function wrapFilter(exp, filter) {\n    var i = filter.indexOf('(');\n\n    if (i < 0) {\n      // _f: resolveFilter\n      return \"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\";\n    } else {\n      var name = filter.slice(0, i);\n      var args = filter.slice(i + 1);\n      return \"_f(\\\"\" + name + \"\\\")(\" + exp + (args !== ')' ? ',' + args : args);\n    }\n  }\n  /*  */\n\n  /* eslint-disable no-unused-vars */\n\n\n  function baseWarn(msg, range) {\n    console.error(\"[Vue compiler]: \" + msg);\n  }\n  /* eslint-enable no-unused-vars */\n\n\n  function pluckModuleFunction(modules, key) {\n    return modules ? modules.map(function (m) {\n      return m[key];\n    }).filter(function (_) {\n      return _;\n    }) : [];\n  }\n\n  function addProp(el, name, value, range, dynamic) {\n    (el.props || (el.props = [])).push(rangeSetItem({\n      name: name,\n      value: value,\n      dynamic: dynamic\n    }, range));\n    el.plain = false;\n  }\n\n  function addAttr(el, name, value, range, dynamic) {\n    var attrs = dynamic ? el.dynamicAttrs || (el.dynamicAttrs = []) : el.attrs || (el.attrs = []);\n    attrs.push(rangeSetItem({\n      name: name,\n      value: value,\n      dynamic: dynamic\n    }, range));\n    el.plain = false;\n  } // add a raw attr (use this in preTransforms)\n\n\n  function addRawAttr(el, name, value, range) {\n    el.attrsMap[name] = value;\n    el.attrsList.push(rangeSetItem({\n      name: name,\n      value: value\n    }, range));\n  }\n\n  function addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {\n    (el.directives || (el.directives = [])).push(rangeSetItem({\n      name: name,\n      rawName: rawName,\n      value: value,\n      arg: arg,\n      isDynamicArg: isDynamicArg,\n      modifiers: modifiers\n    }, range));\n    el.plain = false;\n  }\n\n  function prependModifierMarker(symbol, name, dynamic) {\n    return dynamic ? \"_p(\" + name + \",\\\"\" + symbol + \"\\\")\" : symbol + name; // mark the event as captured\n  }\n\n  function addHandler(el, name, value, modifiers, important, warn, range, dynamic) {\n    modifiers = modifiers || emptyObject; // warn prevent and passive modifier\n\n    /* istanbul ignore if */\n\n    if (warn && modifiers.prevent && modifiers.passive) {\n      warn('passive and prevent can\\'t be used together. ' + 'Passive handler can\\'t prevent default event.', range);\n    } // normalize click.right and click.middle since they don't actually fire\n    // this is technically browser-specific, but at least for now browsers are\n    // the only target envs that have right/middle clicks.\n\n\n    if (modifiers.right) {\n      if (dynamic) {\n        name = \"(\" + name + \")==='click'?'contextmenu':(\" + name + \")\";\n      } else if (name === 'click') {\n        name = 'contextmenu';\n        delete modifiers.right;\n      }\n    } else if (modifiers.middle) {\n      if (dynamic) {\n        name = \"(\" + name + \")==='click'?'mouseup':(\" + name + \")\";\n      } else if (name === 'click') {\n        name = 'mouseup';\n      }\n    } // check capture modifier\n\n\n    if (modifiers.capture) {\n      delete modifiers.capture;\n      name = prependModifierMarker('!', name, dynamic);\n    }\n\n    if (modifiers.once) {\n      delete modifiers.once;\n      name = prependModifierMarker('~', name, dynamic);\n    }\n    /* istanbul ignore if */\n\n\n    if (modifiers.passive) {\n      delete modifiers.passive;\n      name = prependModifierMarker('&', name, dynamic);\n    }\n\n    var events;\n\n    if (modifiers[\"native\"]) {\n      delete modifiers[\"native\"];\n      events = el.nativeEvents || (el.nativeEvents = {});\n    } else {\n      events = el.events || (el.events = {});\n    }\n\n    var newHandler = rangeSetItem({\n      value: value.trim(),\n      dynamic: dynamic\n    }, range);\n\n    if (modifiers !== emptyObject) {\n      newHandler.modifiers = modifiers;\n    }\n\n    var handlers = events[name];\n    /* istanbul ignore if */\n\n    if (Array.isArray(handlers)) {\n      important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n    } else if (handlers) {\n      events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n    } else {\n      events[name] = newHandler;\n    }\n\n    el.plain = false;\n  }\n\n  function getRawBindingAttr(el, name) {\n    return el.rawAttrsMap[':' + name] || el.rawAttrsMap['v-bind:' + name] || el.rawAttrsMap[name];\n  }\n\n  function getBindingAttr(el, name, getStatic) {\n    var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);\n\n    if (dynamicValue != null) {\n      return parseFilters(dynamicValue);\n    } else if (getStatic !== false) {\n      var staticValue = getAndRemoveAttr(el, name);\n\n      if (staticValue != null) {\n        return JSON.stringify(staticValue);\n      }\n    }\n  } // note: this only removes the attr from the Array (attrsList) so that it\n  // doesn't get processed by processAttrs.\n  // By default it does NOT remove it from the map (attrsMap) because the map is\n  // needed during codegen.\n\n\n  function getAndRemoveAttr(el, name, removeFromMap) {\n    var val;\n\n    if ((val = el.attrsMap[name]) != null) {\n      var list = el.attrsList;\n\n      for (var i = 0, l = list.length; i < l; i++) {\n        if (list[i].name === name) {\n          list.splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    if (removeFromMap) {\n      delete el.attrsMap[name];\n    }\n\n    return val;\n  }\n\n  function getAndRemoveAttrByRegex(el, name) {\n    var list = el.attrsList;\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      var attr = list[i];\n\n      if (name.test(attr.name)) {\n        list.splice(i, 1);\n        return attr;\n      }\n    }\n  }\n\n  function rangeSetItem(item, range) {\n    if (range) {\n      if (range.start != null) {\n        item.start = range.start;\n      }\n\n      if (range.end != null) {\n        item.end = range.end;\n      }\n    }\n\n    return item;\n  }\n  /*  */\n\n  /**\n   * Cross-platform code generation for component v-model\n   */\n\n\n  function genComponentModel(el, value, modifiers) {\n    var ref = modifiers || {};\n    var number = ref.number;\n    var trim = ref.trim;\n    var baseValueExpression = '$$v';\n    var valueExpression = baseValueExpression;\n\n    if (trim) {\n      valueExpression = \"(typeof \" + baseValueExpression + \" === 'string'\" + \"? \" + baseValueExpression + \".trim()\" + \": \" + baseValueExpression + \")\";\n    }\n\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n\n    var assignment = genAssignmentCode(value, valueExpression);\n    el.model = {\n      value: \"(\" + value + \")\",\n      expression: JSON.stringify(value),\n      callback: \"function (\" + baseValueExpression + \") {\" + assignment + \"}\"\n    };\n  }\n  /**\n   * Cross-platform codegen helper for generating v-model value assignment code.\n   */\n\n\n  function genAssignmentCode(value, assignment) {\n    var res = parseModel(value);\n\n    if (res.key === null) {\n      return value + \"=\" + assignment;\n    } else {\n      return \"$set(\" + res.exp + \", \" + res.key + \", \" + assignment + \")\";\n    }\n  }\n  /**\n   * Parse a v-model expression into a base path and a final key segment.\n   * Handles both dot-path and possible square brackets.\n   *\n   * Possible cases:\n   *\n   * - test\n   * - test[key]\n   * - test[test1[key]]\n   * - test[\"a\"][key]\n   * - xxx.test[a[a].test1[key]]\n   * - test.xxx.a[\"asa\"][test1[key]]\n   *\n   */\n\n\n  var len, str, chr, index$1, expressionPos, expressionEndPos;\n\n  function parseModel(val) {\n    // Fix https://github.com/vuejs/vue/pull/7730\n    // allow v-model=\"obj.val \" (trailing whitespace)\n    val = val.trim();\n    len = val.length;\n\n    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n      index$1 = val.lastIndexOf('.');\n\n      if (index$1 > -1) {\n        return {\n          exp: val.slice(0, index$1),\n          key: '\"' + val.slice(index$1 + 1) + '\"'\n        };\n      } else {\n        return {\n          exp: val,\n          key: null\n        };\n      }\n    }\n\n    str = val;\n    index$1 = expressionPos = expressionEndPos = 0;\n\n    while (!eof()) {\n      chr = next();\n      /* istanbul ignore if */\n\n      if (isStringStart(chr)) {\n        parseString(chr);\n      } else if (chr === 0x5B) {\n        parseBracket(chr);\n      }\n    }\n\n    return {\n      exp: val.slice(0, expressionPos),\n      key: val.slice(expressionPos + 1, expressionEndPos)\n    };\n  }\n\n  function next() {\n    return str.charCodeAt(++index$1);\n  }\n\n  function eof() {\n    return index$1 >= len;\n  }\n\n  function isStringStart(chr) {\n    return chr === 0x22 || chr === 0x27;\n  }\n\n  function parseBracket(chr) {\n    var inBracket = 1;\n    expressionPos = index$1;\n\n    while (!eof()) {\n      chr = next();\n\n      if (isStringStart(chr)) {\n        parseString(chr);\n        continue;\n      }\n\n      if (chr === 0x5B) {\n        inBracket++;\n      }\n\n      if (chr === 0x5D) {\n        inBracket--;\n      }\n\n      if (inBracket === 0) {\n        expressionEndPos = index$1;\n        break;\n      }\n    }\n  }\n\n  function parseString(chr) {\n    var stringQuote = chr;\n\n    while (!eof()) {\n      chr = next();\n\n      if (chr === stringQuote) {\n        break;\n      }\n    }\n  }\n  /*  */\n\n\n  var warn$1; // in some cases, the event used has to be determined at runtime\n  // so we used some reserved tokens during compile.\n\n  var RANGE_TOKEN = '__r';\n  var CHECKBOX_RADIO_TOKEN = '__c';\n\n  function model(el, dir, _warn) {\n    warn$1 = _warn;\n    var value = dir.value;\n    var modifiers = dir.modifiers;\n    var tag = el.tag;\n    var type = el.attrsMap.type;\n    {\n      // inputs with type=\"file\" are read only and setting the input's\n      // value will throw an error.\n      if (tag === 'input' && type === 'file') {\n        warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" + \"File inputs are read only. Use a v-on:change listener instead.\", el.rawAttrsMap['v-model']);\n      }\n    }\n\n    if (el.component) {\n      genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime\n\n      return false;\n    } else if (tag === 'select') {\n      genSelect(el, value, modifiers);\n    } else if (tag === 'input' && type === 'checkbox') {\n      genCheckboxModel(el, value, modifiers);\n    } else if (tag === 'input' && type === 'radio') {\n      genRadioModel(el, value, modifiers);\n    } else if (tag === 'input' || tag === 'textarea') {\n      genDefaultModel(el, value, modifiers);\n    } else if (!config.isReservedTag(tag)) {\n      genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime\n\n      return false;\n    } else {\n      warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"v-model is not supported on this element type. \" + 'If you are working with contenteditable, it\\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.', el.rawAttrsMap['v-model']);\n    } // ensure runtime directive metadata\n\n\n    return true;\n  }\n\n  function genCheckboxModel(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n    addProp(el, 'checked', \"Array.isArray(\" + value + \")\" + \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (trueValueBinding === 'true' ? \":(\" + value + \")\" : \":_q(\" + value + \",\" + trueValueBinding + \")\"));\n    addHandler(el, 'change', \"var $$a=\" + value + \",\" + '$$el=$event.target,' + \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" + 'if(Array.isArray($$a)){' + \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" + '$$i=_i($$a,$$v);' + \"if($$el.checked){$$i<0&&(\" + genAssignmentCode(value, '$$a.concat([$$v])') + \")}\" + \"else{$$i>-1&&(\" + genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))') + \")}\" + \"}else{\" + genAssignmentCode(value, '$$c') + \"}\", null, true);\n  }\n\n  function genRadioModel(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    valueBinding = number ? \"_n(\" + valueBinding + \")\" : valueBinding;\n    addProp(el, 'checked', \"_q(\" + value + \",\" + valueBinding + \")\");\n    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n  }\n\n  function genSelect(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var selectedVal = \"Array.prototype.filter\" + \".call($event.target.options,function(o){return o.selected})\" + \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" + \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n    var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n    var code = \"var $$selectedVal = \" + selectedVal + \";\";\n    code = code + \" \" + genAssignmentCode(value, assignment);\n    addHandler(el, 'change', code, null, true);\n  }\n\n  function genDefaultModel(el, value, modifiers) {\n    var type = el.attrsMap.type; // warn if v-bind:value conflicts with v-model\n    // except for inputs with v-bind:type\n\n    {\n      var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n      var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n\n      if (value$1 && !typeBinding) {\n        var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n        warn$1(binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" + 'because the latter already expands to a value binding internally', el.rawAttrsMap[binding]);\n      }\n    }\n    var ref = modifiers || {};\n    var lazy = ref.lazy;\n    var number = ref.number;\n    var trim = ref.trim;\n    var needCompositionGuard = !lazy && type !== 'range';\n    var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';\n    var valueExpression = '$event.target.value';\n\n    if (trim) {\n      valueExpression = \"$event.target.value.trim()\";\n    }\n\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n\n    var code = genAssignmentCode(value, valueExpression);\n\n    if (needCompositionGuard) {\n      code = \"if($event.target.composing)return;\" + code;\n    }\n\n    addProp(el, 'value', \"(\" + value + \")\");\n    addHandler(el, event, code, null, true);\n\n    if (trim || number) {\n      addHandler(el, 'blur', '$forceUpdate()');\n    }\n  }\n  /*  */\n  // normalize v-model event tokens that can only be determined at runtime.\n  // it's important to place the event as the first in the array because\n  // the whole point is ensuring the v-model callback gets called before\n  // user-attached handlers.\n\n\n  function normalizeEvents(on) {\n    /* istanbul ignore if */\n    if (isDef(on[RANGE_TOKEN])) {\n      // IE input[type=range] only supports `change` event\n      var event = isIE ? 'change' : 'input';\n      on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n      delete on[RANGE_TOKEN];\n    } // This was originally intended to fix #4521 but no longer necessary\n    // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n\n    /* istanbul ignore if */\n\n\n    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n      on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n      delete on[CHECKBOX_RADIO_TOKEN];\n    }\n  }\n\n  var target$1;\n\n  function createOnceHandler$1(event, handler, capture) {\n    var _target = target$1; // save current target element in closure\n\n    return function onceHandler() {\n      var res = handler.apply(null, arguments);\n\n      if (res !== null) {\n        remove$2(event, onceHandler, capture, _target);\n      }\n    };\n  } // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n  // implementation and does not fire microtasks in between event propagation, so\n  // safe to exclude.\n\n\n  var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\n\n  function add$1(name, handler, capture, passive) {\n    // async edge case #6566: inner click event triggers patch, event handler\n    // attached to outer element during patch, and triggered again. This\n    // happens because browsers fire microtask ticks between event propagation.\n    // the solution is simple: we save the timestamp when a handler is attached,\n    // and the handler would only fire if the event passed to it was fired\n    // AFTER it was attached.\n    if (useMicrotaskFix) {\n      var attachedTimestamp = currentFlushTimestamp;\n      var original = handler;\n\n      handler = original._wrapper = function (e) {\n        if ( // no bubbling, should always fire.\n        // this is just a safety net in case event.timeStamp is unreliable in\n        // certain weird environments...\n        e.target === e.currentTarget || // event is fired after handler attachment\n        e.timeStamp >= attachedTimestamp || // bail for environments that have buggy event.timeStamp implementations\n        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\n        // #9681 QtWebEngine event.timeStamp is negative value\n        e.timeStamp <= 0 || // #9448 bail if event is fired in another document in a multi-page\n        // electron/nw.js app, since event.timeStamp will be using a different\n        // starting reference\n        e.target.ownerDocument !== document) {\n          return original.apply(this, arguments);\n        }\n      };\n    }\n\n    target$1.addEventListener(name, handler, supportsPassive ? {\n      capture: capture,\n      passive: passive\n    } : capture);\n  }\n\n  function remove$2(name, handler, capture, _target) {\n    (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);\n  }\n\n  function updateDOMListeners(oldVnode, vnode) {\n    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n      return;\n    }\n\n    var on = vnode.data.on || {};\n    var oldOn = oldVnode.data.on || {};\n    target$1 = vnode.elm;\n    normalizeEvents(on);\n    updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);\n    target$1 = undefined;\n  }\n\n  var events = {\n    create: updateDOMListeners,\n    update: updateDOMListeners\n  };\n  /*  */\n\n  var svgContainer;\n\n  function updateDOMProps(oldVnode, vnode) {\n    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n      return;\n    }\n\n    var key, cur;\n    var elm = vnode.elm;\n    var oldProps = oldVnode.data.domProps || {};\n    var props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it\n\n    if (isDef(props.__ob__)) {\n      props = vnode.data.domProps = extend({}, props);\n    }\n\n    for (key in oldProps) {\n      if (!(key in props)) {\n        elm[key] = '';\n      }\n    }\n\n    for (key in props) {\n      cur = props[key]; // ignore children if the node has textContent or innerHTML,\n      // as these will throw away existing DOM nodes and cause removal errors\n      // on subsequent patches (#3360)\n\n      if (key === 'textContent' || key === 'innerHTML') {\n        if (vnode.children) {\n          vnode.children.length = 0;\n        }\n\n        if (cur === oldProps[key]) {\n          continue;\n        } // #6601 work around Chrome version <= 55 bug where single textNode\n        // replaced by innerHTML/textContent retains its parentNode property\n\n\n        if (elm.childNodes.length === 1) {\n          elm.removeChild(elm.childNodes[0]);\n        }\n      }\n\n      if (key === 'value' && elm.tagName !== 'PROGRESS') {\n        // store value as _value as well since\n        // non-string values will be stringified\n        elm._value = cur; // avoid resetting cursor position when value is the same\n\n        var strCur = isUndef(cur) ? '' : String(cur);\n\n        if (shouldUpdateValue(elm, strCur)) {\n          elm.value = strCur;\n        }\n      } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {\n        // IE doesn't support innerHTML for SVG elements\n        svgContainer = svgContainer || document.createElement('div');\n        svgContainer.innerHTML = \"<svg>\" + cur + \"</svg>\";\n        var svg = svgContainer.firstChild;\n\n        while (elm.firstChild) {\n          elm.removeChild(elm.firstChild);\n        }\n\n        while (svg.firstChild) {\n          elm.appendChild(svg.firstChild);\n        }\n      } else if ( // skip the update if old and new VDOM state is the same.\n      // `value` is handled separately because the DOM value may be temporarily\n      // out of sync with VDOM state due to focus, composition and modifiers.\n      // This  #4521 by skipping the unnecesarry `checked` update.\n      cur !== oldProps[key]) {\n        // some property updates can throw\n        // e.g. `value` on <progress> w/ non-finite value\n        try {\n          elm[key] = cur;\n        } catch (e) {}\n      }\n    }\n  } // check platforms/web/util/attrs.js acceptValue\n\n\n  function shouldUpdateValue(elm, checkVal) {\n    return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));\n  }\n\n  function isNotInFocusAndDirty(elm, checkVal) {\n    // return true when textbox (.number and .trim) loses focus and its value is\n    // not equal to the updated value\n    var notInFocus = true; // #6157\n    // work around IE bug when accessing document.activeElement in an iframe\n\n    try {\n      notInFocus = document.activeElement !== elm;\n    } catch (e) {}\n\n    return notInFocus && elm.value !== checkVal;\n  }\n\n  function isDirtyWithModifiers(elm, newVal) {\n    var value = elm.value;\n    var modifiers = elm._vModifiers; // injected by v-model runtime\n\n    if (isDef(modifiers)) {\n      if (modifiers.number) {\n        return toNumber(value) !== toNumber(newVal);\n      }\n\n      if (modifiers.trim) {\n        return value.trim() !== newVal.trim();\n      }\n    }\n\n    return value !== newVal;\n  }\n\n  var domProps = {\n    create: updateDOMProps,\n    update: updateDOMProps\n  };\n  /*  */\n\n  var parseStyleText = cached(function (cssText) {\n    var res = {};\n    var listDelimiter = /;(?![^(]*\\))/g;\n    var propertyDelimiter = /:(.+)/;\n    cssText.split(listDelimiter).forEach(function (item) {\n      if (item) {\n        var tmp = item.split(propertyDelimiter);\n        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n      }\n    });\n    return res;\n  }); // merge static and dynamic style data on the same vnode\n\n  function normalizeStyleData(data) {\n    var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation\n    // and is always a fresh object, so it's safe to merge into it\n\n    return data.staticStyle ? extend(data.staticStyle, style) : style;\n  } // normalize possible array / string values into Object\n\n\n  function normalizeStyleBinding(bindingStyle) {\n    if (Array.isArray(bindingStyle)) {\n      return toObject(bindingStyle);\n    }\n\n    if (typeof bindingStyle === 'string') {\n      return parseStyleText(bindingStyle);\n    }\n\n    return bindingStyle;\n  }\n  /**\n   * parent component style should be after child's\n   * so that parent component's style could override it\n   */\n\n\n  function getStyle(vnode, checkChild) {\n    var res = {};\n    var styleData;\n\n    if (checkChild) {\n      var childNode = vnode;\n\n      while (childNode.componentInstance) {\n        childNode = childNode.componentInstance._vnode;\n\n        if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n          extend(res, styleData);\n        }\n      }\n    }\n\n    if (styleData = normalizeStyleData(vnode.data)) {\n      extend(res, styleData);\n    }\n\n    var parentNode = vnode;\n\n    while (parentNode = parentNode.parent) {\n      if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n        extend(res, styleData);\n      }\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  var cssVarRE = /^--/;\n  var importantRE = /\\s*!important$/;\n\n  var setProp = function setProp(el, name, val) {\n    /* istanbul ignore if */\n    if (cssVarRE.test(name)) {\n      el.style.setProperty(name, val);\n    } else if (importantRE.test(val)) {\n      el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n    } else {\n      var normalizedName = normalize(name);\n\n      if (Array.isArray(val)) {\n        // Support values array created by autoprefixer, e.g.\n        // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n        // Set them one by one, and the browser will only set those it can recognize\n        for (var i = 0, len = val.length; i < len; i++) {\n          el.style[normalizedName] = val[i];\n        }\n      } else {\n        el.style[normalizedName] = val;\n      }\n    }\n  };\n\n  var vendorNames = ['Webkit', 'Moz', 'ms'];\n  var emptyStyle;\n  var normalize = cached(function (prop) {\n    emptyStyle = emptyStyle || document.createElement('div').style;\n    prop = camelize(prop);\n\n    if (prop !== 'filter' && prop in emptyStyle) {\n      return prop;\n    }\n\n    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n\n    for (var i = 0; i < vendorNames.length; i++) {\n      var name = vendorNames[i] + capName;\n\n      if (name in emptyStyle) {\n        return name;\n      }\n    }\n  });\n\n  function updateStyle(oldVnode, vnode) {\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n\n    if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {\n      return;\n    }\n\n    var cur, name;\n    var el = vnode.elm;\n    var oldStaticStyle = oldData.staticStyle;\n    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n\n    var oldStyle = oldStaticStyle || oldStyleBinding;\n    var style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff\n    // make sure to clone it if it's reactive, since the user likely wants\n    // to mutate it.\n\n    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;\n    var newStyle = getStyle(vnode, true);\n\n    for (name in oldStyle) {\n      if (isUndef(newStyle[name])) {\n        setProp(el, name, '');\n      }\n    }\n\n    for (name in newStyle) {\n      cur = newStyle[name];\n\n      if (cur !== oldStyle[name]) {\n        // ie9 setting to null has no effect, must use empty string\n        setProp(el, name, cur == null ? '' : cur);\n      }\n    }\n  }\n\n  var style = {\n    create: updateStyle,\n    update: updateStyle\n  };\n  /*  */\n\n  var whitespaceRE = /\\s+/;\n  /**\n   * Add class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n\n  function addClass(el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return;\n    }\n    /* istanbul ignore else */\n\n\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(whitespaceRE).forEach(function (c) {\n          return el.classList.add(c);\n        });\n      } else {\n        el.classList.add(cls);\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n\n      if (cur.indexOf(' ' + cls + ' ') < 0) {\n        el.setAttribute('class', (cur + cls).trim());\n      }\n    }\n  }\n  /**\n   * Remove class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n\n\n  function removeClass(el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return;\n    }\n    /* istanbul ignore else */\n\n\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(whitespaceRE).forEach(function (c) {\n          return el.classList.remove(c);\n        });\n      } else {\n        el.classList.remove(cls);\n      }\n\n      if (!el.classList.length) {\n        el.removeAttribute('class');\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n      var tar = ' ' + cls + ' ';\n\n      while (cur.indexOf(tar) >= 0) {\n        cur = cur.replace(tar, ' ');\n      }\n\n      cur = cur.trim();\n\n      if (cur) {\n        el.setAttribute('class', cur);\n      } else {\n        el.removeAttribute('class');\n      }\n    }\n  }\n  /*  */\n\n\n  function resolveTransition(def$$1) {\n    if (!def$$1) {\n      return;\n    }\n    /* istanbul ignore else */\n\n\n    if (_typeof(def$$1) === 'object') {\n      var res = {};\n\n      if (def$$1.css !== false) {\n        extend(res, autoCssTransition(def$$1.name || 'v'));\n      }\n\n      extend(res, def$$1);\n      return res;\n    } else if (typeof def$$1 === 'string') {\n      return autoCssTransition(def$$1);\n    }\n  }\n\n  var autoCssTransition = cached(function (name) {\n    return {\n      enterClass: name + \"-enter\",\n      enterToClass: name + \"-enter-to\",\n      enterActiveClass: name + \"-enter-active\",\n      leaveClass: name + \"-leave\",\n      leaveToClass: name + \"-leave-to\",\n      leaveActiveClass: name + \"-leave-active\"\n    };\n  });\n  var hasTransition = inBrowser && !isIE9;\n  var TRANSITION = 'transition';\n  var ANIMATION = 'animation'; // Transition property/event sniffing\n\n  var transitionProp = 'transition';\n  var transitionEndEvent = 'transitionend';\n  var animationProp = 'animation';\n  var animationEndEvent = 'animationend';\n\n  if (hasTransition) {\n    /* istanbul ignore if */\n    if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n      transitionProp = 'WebkitTransition';\n      transitionEndEvent = 'webkitTransitionEnd';\n    }\n\n    if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n      animationProp = 'WebkitAnimation';\n      animationEndEvent = 'webkitAnimationEnd';\n    }\n  } // binding to window is necessary to make hot reload work in IE in strict mode\n\n\n  var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :\n  /* istanbul ignore next */\n  function (fn) {\n    return fn();\n  };\n\n  function nextFrame(fn) {\n    raf(function () {\n      raf(fn);\n    });\n  }\n\n  function addTransitionClass(el, cls) {\n    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n\n    if (transitionClasses.indexOf(cls) < 0) {\n      transitionClasses.push(cls);\n      addClass(el, cls);\n    }\n  }\n\n  function removeTransitionClass(el, cls) {\n    if (el._transitionClasses) {\n      remove(el._transitionClasses, cls);\n    }\n\n    removeClass(el, cls);\n  }\n\n  function whenTransitionEnds(el, expectedType, cb) {\n    var ref = getTransitionInfo(el, expectedType);\n    var type = ref.type;\n    var timeout = ref.timeout;\n    var propCount = ref.propCount;\n\n    if (!type) {\n      return cb();\n    }\n\n    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n    var ended = 0;\n\n    var end = function end() {\n      el.removeEventListener(event, onEnd);\n      cb();\n    };\n\n    var onEnd = function onEnd(e) {\n      if (e.target === el) {\n        if (++ended >= propCount) {\n          end();\n        }\n      }\n    };\n\n    setTimeout(function () {\n      if (ended < propCount) {\n        end();\n      }\n    }, timeout + 1);\n    el.addEventListener(event, onEnd);\n  }\n\n  var transformRE = /\\b(transform|all)(,|$)/;\n\n  function getTransitionInfo(el, expectedType) {\n    var styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties\n\n    var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n    var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n    var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n    var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n    var animationTimeout = getTimeout(animationDelays, animationDurations);\n    var type;\n    var timeout = 0;\n    var propCount = 0;\n    /* istanbul ignore if */\n\n    if (expectedType === TRANSITION) {\n      if (transitionTimeout > 0) {\n        type = TRANSITION;\n        timeout = transitionTimeout;\n        propCount = transitionDurations.length;\n      }\n    } else if (expectedType === ANIMATION) {\n      if (animationTimeout > 0) {\n        type = ANIMATION;\n        timeout = animationTimeout;\n        propCount = animationDurations.length;\n      }\n    } else {\n      timeout = Math.max(transitionTimeout, animationTimeout);\n      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n    }\n\n    var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\n    return {\n      type: type,\n      timeout: timeout,\n      propCount: propCount,\n      hasTransform: hasTransform\n    };\n  }\n\n  function getTimeout(delays, durations) {\n    /* istanbul ignore next */\n    while (delays.length < durations.length) {\n      delays = delays.concat(delays);\n    }\n\n    return Math.max.apply(null, durations.map(function (d, i) {\n      return toMs(d) + toMs(delays[i]);\n    }));\n  } // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n  // in a locale-dependent way, using a comma instead of a dot.\n  // If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n  // as a floor function) causing unexpected behaviors\n\n\n  function toMs(s) {\n    return Number(s.slice(0, -1).replace(',', '.')) * 1000;\n  }\n  /*  */\n\n\n  function enter(vnode, toggleDisplay) {\n    var el = vnode.elm; // call leave callback now\n\n    if (isDef(el._leaveCb)) {\n      el._leaveCb.cancelled = true;\n\n      el._leaveCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n\n    if (isUndef(data)) {\n      return;\n    }\n    /* istanbul ignore if */\n\n\n    if (isDef(el._enterCb) || el.nodeType !== 1) {\n      return;\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var enterClass = data.enterClass;\n    var enterToClass = data.enterToClass;\n    var enterActiveClass = data.enterActiveClass;\n    var appearClass = data.appearClass;\n    var appearToClass = data.appearToClass;\n    var appearActiveClass = data.appearActiveClass;\n    var beforeEnter = data.beforeEnter;\n    var enter = data.enter;\n    var afterEnter = data.afterEnter;\n    var enterCancelled = data.enterCancelled;\n    var beforeAppear = data.beforeAppear;\n    var appear = data.appear;\n    var afterAppear = data.afterAppear;\n    var appearCancelled = data.appearCancelled;\n    var duration = data.duration; // activeInstance will always be the <transition> component managing this\n    // transition. One edge case to check is when the <transition> is placed\n    // as the root node of a child component. In that case we need to check\n    // <transition>'s parent for appear check.\n\n    var context = activeInstance;\n    var transitionNode = activeInstance.$vnode;\n\n    while (transitionNode && transitionNode.parent) {\n      context = transitionNode.context;\n      transitionNode = transitionNode.parent;\n    }\n\n    var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n    if (isAppear && !appear && appear !== '') {\n      return;\n    }\n\n    var startClass = isAppear && appearClass ? appearClass : enterClass;\n    var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\n    var toClass = isAppear && appearToClass ? appearToClass : enterToClass;\n    var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\n    var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;\n    var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\n    var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;\n    var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\n\n    if (explicitEnterDuration != null) {\n      checkDuration(explicitEnterDuration, 'enter', vnode);\n    }\n\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(enterHook);\n    var cb = el._enterCb = once(function () {\n      if (expectsCSS) {\n        removeTransitionClass(el, toClass);\n        removeTransitionClass(el, activeClass);\n      }\n\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, startClass);\n        }\n\n        enterCancelledHook && enterCancelledHook(el);\n      } else {\n        afterEnterHook && afterEnterHook(el);\n      }\n\n      el._enterCb = null;\n    });\n\n    if (!vnode.data.show) {\n      // remove pending leave element on enter by injecting an insert hook\n      mergeVNodeHook(vnode, 'insert', function () {\n        var parent = el.parentNode;\n        var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n\n        if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {\n          pendingNode.elm._leaveCb();\n        }\n\n        enterHook && enterHook(el, cb);\n      });\n    } // start enter transition\n\n\n    beforeEnterHook && beforeEnterHook(el);\n\n    if (expectsCSS) {\n      addTransitionClass(el, startClass);\n      addTransitionClass(el, activeClass);\n      nextFrame(function () {\n        removeTransitionClass(el, startClass);\n\n        if (!cb.cancelled) {\n          addTransitionClass(el, toClass);\n\n          if (!userWantsControl) {\n            if (isValidDuration(explicitEnterDuration)) {\n              setTimeout(cb, explicitEnterDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n\n    if (vnode.data.show) {\n      toggleDisplay && toggleDisplay();\n      enterHook && enterHook(el, cb);\n    }\n\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n\n  function leave(vnode, rm) {\n    var el = vnode.elm; // call enter callback now\n\n    if (isDef(el._enterCb)) {\n      el._enterCb.cancelled = true;\n\n      el._enterCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n\n    if (isUndef(data) || el.nodeType !== 1) {\n      return rm();\n    }\n    /* istanbul ignore if */\n\n\n    if (isDef(el._leaveCb)) {\n      return;\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var leaveClass = data.leaveClass;\n    var leaveToClass = data.leaveToClass;\n    var leaveActiveClass = data.leaveActiveClass;\n    var beforeLeave = data.beforeLeave;\n    var leave = data.leave;\n    var afterLeave = data.afterLeave;\n    var leaveCancelled = data.leaveCancelled;\n    var delayLeave = data.delayLeave;\n    var duration = data.duration;\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(leave);\n    var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\n\n    if (isDef(explicitLeaveDuration)) {\n      checkDuration(explicitLeaveDuration, 'leave', vnode);\n    }\n\n    var cb = el._leaveCb = once(function () {\n      if (el.parentNode && el.parentNode._pending) {\n        el.parentNode._pending[vnode.key] = null;\n      }\n\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveActiveClass);\n      }\n\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, leaveClass);\n        }\n\n        leaveCancelled && leaveCancelled(el);\n      } else {\n        rm();\n        afterLeave && afterLeave(el);\n      }\n\n      el._leaveCb = null;\n    });\n\n    if (delayLeave) {\n      delayLeave(performLeave);\n    } else {\n      performLeave();\n    }\n\n    function performLeave() {\n      // the delayed leave may have already been cancelled\n      if (cb.cancelled) {\n        return;\n      } // record leaving element\n\n\n      if (!vnode.data.show && el.parentNode) {\n        (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n      }\n\n      beforeLeave && beforeLeave(el);\n\n      if (expectsCSS) {\n        addTransitionClass(el, leaveClass);\n        addTransitionClass(el, leaveActiveClass);\n        nextFrame(function () {\n          removeTransitionClass(el, leaveClass);\n\n          if (!cb.cancelled) {\n            addTransitionClass(el, leaveToClass);\n\n            if (!userWantsControl) {\n              if (isValidDuration(explicitLeaveDuration)) {\n                setTimeout(cb, explicitLeaveDuration);\n              } else {\n                whenTransitionEnds(el, type, cb);\n              }\n            }\n          }\n        });\n      }\n\n      leave && leave(el, cb);\n\n      if (!expectsCSS && !userWantsControl) {\n        cb();\n      }\n    }\n  } // only used in dev mode\n\n\n  function checkDuration(val, name, vnode) {\n    if (typeof val !== 'number') {\n      warn(\"<transition> explicit \" + name + \" duration is not a valid number - \" + \"got \" + JSON.stringify(val) + \".\", vnode.context);\n    } else if (isNaN(val)) {\n      warn(\"<transition> explicit \" + name + \" duration is NaN - \" + 'the duration expression might be incorrect.', vnode.context);\n    }\n  }\n\n  function isValidDuration(val) {\n    return typeof val === 'number' && !isNaN(val);\n  }\n  /**\n   * Normalize a transition hook's argument length. The hook may be:\n   * - a merged hook (invoker) with the original in .fns\n   * - a wrapped component method (check ._length)\n   * - a plain function (.length)\n   */\n\n\n  function getHookArgumentsLength(fn) {\n    if (isUndef(fn)) {\n      return false;\n    }\n\n    var invokerFns = fn.fns;\n\n    if (isDef(invokerFns)) {\n      // invoker\n      return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\n    } else {\n      return (fn._length || fn.length) > 1;\n    }\n  }\n\n  function _enter(_, vnode) {\n    if (vnode.data.show !== true) {\n      enter(vnode);\n    }\n  }\n\n  var transition = inBrowser ? {\n    create: _enter,\n    activate: _enter,\n    remove: function remove$$1(vnode, rm) {\n      /* istanbul ignore else */\n      if (vnode.data.show !== true) {\n        leave(vnode, rm);\n      } else {\n        rm();\n      }\n    }\n  } : {};\n  var platformModules = [attrs, klass, events, domProps, style, transition];\n  /*  */\n  // the directive module should be applied last, after all\n  // built-in modules have been applied.\n\n  var modules = platformModules.concat(baseModules);\n  var patch = createPatchFunction({\n    nodeOps: nodeOps,\n    modules: modules\n  });\n  /**\n   * Not type checking this file because flow doesn't like attaching\n   * properties to Elements.\n   */\n\n  /* istanbul ignore if */\n\n  if (isIE9) {\n    // http://www.matts411.com/post/internet-explorer-9-oninput/\n    document.addEventListener('selectionchange', function () {\n      var el = document.activeElement;\n\n      if (el && el.vmodel) {\n        trigger(el, 'input');\n      }\n    });\n  }\n\n  var directive = {\n    inserted: function inserted(el, binding, vnode, oldVnode) {\n      if (vnode.tag === 'select') {\n        // #6903\n        if (oldVnode.elm && !oldVnode.elm._vOptions) {\n          mergeVNodeHook(vnode, 'postpatch', function () {\n            directive.componentUpdated(el, binding, vnode);\n          });\n        } else {\n          setSelected(el, binding, vnode.context);\n        }\n\n        el._vOptions = [].map.call(el.options, getValue);\n      } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n        el._vModifiers = binding.modifiers;\n\n        if (!binding.modifiers.lazy) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when\n          // switching focus before confirming composition choice\n          // this also fixes the issue where some browsers e.g. iOS Chrome\n          // fires \"change\" instead of \"input\" on autocomplete.\n\n          el.addEventListener('change', onCompositionEnd);\n          /* istanbul ignore if */\n\n          if (isIE9) {\n            el.vmodel = true;\n          }\n        }\n      }\n    },\n    componentUpdated: function componentUpdated(el, binding, vnode) {\n      if (vnode.tag === 'select') {\n        setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,\n        // it's possible that the value is out-of-sync with the rendered options.\n        // detect such cases and filter out values that no longer has a matching\n        // option in the DOM.\n\n        var prevOptions = el._vOptions;\n        var curOptions = el._vOptions = [].map.call(el.options, getValue);\n\n        if (curOptions.some(function (o, i) {\n          return !looseEqual(o, prevOptions[i]);\n        })) {\n          // trigger change event if\n          // no matching option found for at least one value\n          var needReset = el.multiple ? binding.value.some(function (v) {\n            return hasNoMatchingOption(v, curOptions);\n          }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n\n          if (needReset) {\n            trigger(el, 'change');\n          }\n        }\n      }\n    }\n  };\n\n  function setSelected(el, binding, vm) {\n    actuallySetSelected(el, binding, vm);\n    /* istanbul ignore if */\n\n    if (isIE || isEdge) {\n      setTimeout(function () {\n        actuallySetSelected(el, binding, vm);\n      }, 0);\n    }\n  }\n\n  function actuallySetSelected(el, binding, vm) {\n    var value = binding.value;\n    var isMultiple = el.multiple;\n\n    if (isMultiple && !Array.isArray(value)) {\n      warn(\"<select multiple v-model=\\\"\" + binding.expression + \"\\\"> \" + \"expects an Array value for its binding, but got \" + Object.prototype.toString.call(value).slice(8, -1), vm);\n      return;\n    }\n\n    var selected, option;\n\n    for (var i = 0, l = el.options.length; i < l; i++) {\n      option = el.options[i];\n\n      if (isMultiple) {\n        selected = looseIndexOf(value, getValue(option)) > -1;\n\n        if (option.selected !== selected) {\n          option.selected = selected;\n        }\n      } else {\n        if (looseEqual(getValue(option), value)) {\n          if (el.selectedIndex !== i) {\n            el.selectedIndex = i;\n          }\n\n          return;\n        }\n      }\n    }\n\n    if (!isMultiple) {\n      el.selectedIndex = -1;\n    }\n  }\n\n  function hasNoMatchingOption(value, options) {\n    return options.every(function (o) {\n      return !looseEqual(o, value);\n    });\n  }\n\n  function getValue(option) {\n    return '_value' in option ? option._value : option.value;\n  }\n\n  function onCompositionStart(e) {\n    e.target.composing = true;\n  }\n\n  function onCompositionEnd(e) {\n    // prevent triggering an input event for no reason\n    if (!e.target.composing) {\n      return;\n    }\n\n    e.target.composing = false;\n    trigger(e.target, 'input');\n  }\n\n  function trigger(el, type) {\n    var e = document.createEvent('HTMLEvents');\n    e.initEvent(type, true, true);\n    el.dispatchEvent(e);\n  }\n  /*  */\n  // recursively search for possible transition defined inside the component root\n\n\n  function locateNode(vnode) {\n    return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;\n  }\n\n  var show = {\n    bind: function bind(el, ref, vnode) {\n      var value = ref.value;\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n      var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;\n\n      if (value && transition$$1) {\n        vnode.data.show = true;\n        enter(vnode, function () {\n          el.style.display = originalDisplay;\n        });\n      } else {\n        el.style.display = value ? originalDisplay : 'none';\n      }\n    },\n    update: function update(el, ref, vnode) {\n      var value = ref.value;\n      var oldValue = ref.oldValue;\n      /* istanbul ignore if */\n\n      if (!value === !oldValue) {\n        return;\n      }\n\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n\n      if (transition$$1) {\n        vnode.data.show = true;\n\n        if (value) {\n          enter(vnode, function () {\n            el.style.display = el.__vOriginalDisplay;\n          });\n        } else {\n          leave(vnode, function () {\n            el.style.display = 'none';\n          });\n        }\n      } else {\n        el.style.display = value ? el.__vOriginalDisplay : 'none';\n      }\n    },\n    unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {\n      if (!isDestroy) {\n        el.style.display = el.__vOriginalDisplay;\n      }\n    }\n  };\n  var platformDirectives = {\n    model: directive,\n    show: show\n  };\n  /*  */\n\n  var transitionProps = {\n    name: String,\n    appear: Boolean,\n    css: Boolean,\n    mode: String,\n    type: String,\n    enterClass: String,\n    leaveClass: String,\n    enterToClass: String,\n    leaveToClass: String,\n    enterActiveClass: String,\n    leaveActiveClass: String,\n    appearClass: String,\n    appearActiveClass: String,\n    appearToClass: String,\n    duration: [Number, String, Object]\n  }; // in case the child is also an abstract component, e.g. <keep-alive>\n  // we want to recursively retrieve the real component to be rendered\n\n  function getRealChild(vnode) {\n    var compOptions = vnode && vnode.componentOptions;\n\n    if (compOptions && compOptions.Ctor.options[\"abstract\"]) {\n      return getRealChild(getFirstComponentChild(compOptions.children));\n    } else {\n      return vnode;\n    }\n  }\n\n  function extractTransitionData(comp) {\n    var data = {};\n    var options = comp.$options; // props\n\n    for (var key in options.propsData) {\n      data[key] = comp[key];\n    } // events.\n    // extract listeners and pass them directly to the transition methods\n\n\n    var listeners = options._parentListeners;\n\n    for (var key$1 in listeners) {\n      data[camelize(key$1)] = listeners[key$1];\n    }\n\n    return data;\n  }\n\n  function placeholder(h, rawChild) {\n    if (/\\d-keep-alive$/.test(rawChild.tag)) {\n      return h('keep-alive', {\n        props: rawChild.componentOptions.propsData\n      });\n    }\n  }\n\n  function hasParentTransition(vnode) {\n    while (vnode = vnode.parent) {\n      if (vnode.data.transition) {\n        return true;\n      }\n    }\n  }\n\n  function isSameChild(child, oldChild) {\n    return oldChild.key === child.key && oldChild.tag === child.tag;\n  }\n\n  var isNotTextNode = function isNotTextNode(c) {\n    return c.tag || isAsyncPlaceholder(c);\n  };\n\n  var isVShowDirective = function isVShowDirective(d) {\n    return d.name === 'show';\n  };\n\n  var Transition = {\n    name: 'transition',\n    props: transitionProps,\n    \"abstract\": true,\n    render: function render(h) {\n      var this$1 = this;\n      var children = this.$slots[\"default\"];\n\n      if (!children) {\n        return;\n      } // filter out text nodes (possible whitespaces)\n\n\n      children = children.filter(isNotTextNode);\n      /* istanbul ignore if */\n\n      if (!children.length) {\n        return;\n      } // warn multiple elements\n\n\n      if (children.length > 1) {\n        warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);\n      }\n\n      var mode = this.mode; // warn invalid mode\n\n      if (mode && mode !== 'in-out' && mode !== 'out-in') {\n        warn('invalid <transition> mode: ' + mode, this.$parent);\n      }\n\n      var rawChild = children[0]; // if this is a component root node and the component's\n      // parent container node also has transition, skip.\n\n      if (hasParentTransition(this.$vnode)) {\n        return rawChild;\n      } // apply transition data to child\n      // use getRealChild() to ignore abstract components e.g. keep-alive\n\n\n      var child = getRealChild(rawChild);\n      /* istanbul ignore if */\n\n      if (!child) {\n        return rawChild;\n      }\n\n      if (this._leaving) {\n        return placeholder(h, rawChild);\n      } // ensure a key that is unique to the vnode type and to this transition\n      // component instance. This key will be used to remove pending leaving nodes\n      // during entering.\n\n\n      var id = \"__transition-\" + this._uid + \"-\";\n      child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;\n      var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n      var oldRawChild = this._vnode;\n      var oldChild = getRealChild(oldRawChild); // mark v-show\n      // so that the transition module can hand over the control to the directive\n\n      if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n        child.data.show = true;\n      }\n\n      if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node\n      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {\n        // replace old child transition data with fresh one\n        // important for dynamic transitions!\n        var oldData = oldChild.data.transition = extend({}, data); // handle transition mode\n\n        if (mode === 'out-in') {\n          // return placeholder node and queue update when leave finishes\n          this._leaving = true;\n          mergeVNodeHook(oldData, 'afterLeave', function () {\n            this$1._leaving = false;\n            this$1.$forceUpdate();\n          });\n          return placeholder(h, rawChild);\n        } else if (mode === 'in-out') {\n          if (isAsyncPlaceholder(child)) {\n            return oldRawChild;\n          }\n\n          var delayedLeave;\n\n          var performLeave = function performLeave() {\n            delayedLeave();\n          };\n\n          mergeVNodeHook(data, 'afterEnter', performLeave);\n          mergeVNodeHook(data, 'enterCancelled', performLeave);\n          mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n            delayedLeave = leave;\n          });\n        }\n      }\n\n      return rawChild;\n    }\n  };\n  /*  */\n\n  var props = extend({\n    tag: String,\n    moveClass: String\n  }, transitionProps);\n  delete props.mode;\n  var TransitionGroup = {\n    props: props,\n    beforeMount: function beforeMount() {\n      var this$1 = this;\n      var update = this._update;\n\n      this._update = function (vnode, hydrating) {\n        var restoreActiveInstance = setActiveInstance(this$1); // force removing pass\n\n        this$1.__patch__(this$1._vnode, this$1.kept, false, // hydrating\n        true // removeOnly (!important, avoids unnecessary moves)\n        );\n\n        this$1._vnode = this$1.kept;\n        restoreActiveInstance();\n        update.call(this$1, vnode, hydrating);\n      };\n    },\n    render: function render(h) {\n      var tag = this.tag || this.$vnode.data.tag || 'span';\n      var map = Object.create(null);\n      var prevChildren = this.prevChildren = this.children;\n      var rawChildren = this.$slots[\"default\"] || [];\n      var children = this.children = [];\n      var transitionData = extractTransitionData(this);\n\n      for (var i = 0; i < rawChildren.length; i++) {\n        var c = rawChildren[i];\n\n        if (c.tag) {\n          if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n            children.push(c);\n            map[c.key] = c;\n            (c.data || (c.data = {})).transition = transitionData;\n          } else {\n            var opts = c.componentOptions;\n            var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;\n            warn(\"<transition-group> children must be keyed: <\" + name + \">\");\n          }\n        }\n      }\n\n      if (prevChildren) {\n        var kept = [];\n        var removed = [];\n\n        for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n          var c$1 = prevChildren[i$1];\n          c$1.data.transition = transitionData;\n          c$1.data.pos = c$1.elm.getBoundingClientRect();\n\n          if (map[c$1.key]) {\n            kept.push(c$1);\n          } else {\n            removed.push(c$1);\n          }\n        }\n\n        this.kept = h(tag, null, kept);\n        this.removed = removed;\n      }\n\n      return h(tag, null, children);\n    },\n    updated: function updated() {\n      var children = this.prevChildren;\n      var moveClass = this.moveClass || (this.name || 'v') + '-move';\n\n      if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n        return;\n      } // we divide the work into three loops to avoid mixing DOM reads and writes\n      // in each iteration - which helps prevent layout thrashing.\n\n\n      children.forEach(callPendingCbs);\n      children.forEach(recordPosition);\n      children.forEach(applyTranslation); // force reflow to put everything in position\n      // assign to this to avoid being removed in tree-shaking\n      // $flow-disable-line\n\n      this._reflow = document.body.offsetHeight;\n      children.forEach(function (c) {\n        if (c.data.moved) {\n          var el = c.elm;\n          var s = el.style;\n          addTransitionClass(el, moveClass);\n          s.transform = s.WebkitTransform = s.transitionDuration = '';\n          el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {\n            if (e && e.target !== el) {\n              return;\n            }\n\n            if (!e || /transform$/.test(e.propertyName)) {\n              el.removeEventListener(transitionEndEvent, cb);\n              el._moveCb = null;\n              removeTransitionClass(el, moveClass);\n            }\n          });\n        }\n      });\n    },\n    methods: {\n      hasMove: function hasMove(el, moveClass) {\n        /* istanbul ignore if */\n        if (!hasTransition) {\n          return false;\n        }\n        /* istanbul ignore if */\n\n\n        if (this._hasMove) {\n          return this._hasMove;\n        } // Detect whether an element with the move class applied has\n        // CSS transitions. Since the element may be inside an entering\n        // transition at this very moment, we make a clone of it and remove\n        // all other transition classes applied to ensure only the move class\n        // is applied.\n\n\n        var clone = el.cloneNode();\n\n        if (el._transitionClasses) {\n          el._transitionClasses.forEach(function (cls) {\n            removeClass(clone, cls);\n          });\n        }\n\n        addClass(clone, moveClass);\n        clone.style.display = 'none';\n        this.$el.appendChild(clone);\n        var info = getTransitionInfo(clone);\n        this.$el.removeChild(clone);\n        return this._hasMove = info.hasTransform;\n      }\n    }\n  };\n\n  function callPendingCbs(c) {\n    /* istanbul ignore if */\n    if (c.elm._moveCb) {\n      c.elm._moveCb();\n    }\n    /* istanbul ignore if */\n\n\n    if (c.elm._enterCb) {\n      c.elm._enterCb();\n    }\n  }\n\n  function recordPosition(c) {\n    c.data.newPos = c.elm.getBoundingClientRect();\n  }\n\n  function applyTranslation(c) {\n    var oldPos = c.data.pos;\n    var newPos = c.data.newPos;\n    var dx = oldPos.left - newPos.left;\n    var dy = oldPos.top - newPos.top;\n\n    if (dx || dy) {\n      c.data.moved = true;\n      var s = c.elm.style;\n      s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n      s.transitionDuration = '0s';\n    }\n  }\n\n  var platformComponents = {\n    Transition: Transition,\n    TransitionGroup: TransitionGroup\n  };\n  /*  */\n  // install platform specific utils\n\n  Vue.config.mustUseProp = mustUseProp;\n  Vue.config.isReservedTag = isReservedTag;\n  Vue.config.isReservedAttr = isReservedAttr;\n  Vue.config.getTagNamespace = getTagNamespace;\n  Vue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components\n\n  extend(Vue.options.directives, platformDirectives);\n  extend(Vue.options.components, platformComponents); // install platform patch function\n\n  Vue.prototype.__patch__ = inBrowser ? patch : noop; // public mount method\n\n  Vue.prototype.$mount = function (el, hydrating) {\n    el = el && inBrowser ? query(el) : undefined;\n    return mountComponent(this, el, hydrating);\n  }; // devtools global hook\n\n  /* istanbul ignore next */\n\n\n  if (inBrowser) {\n    setTimeout(function () {\n      if (config.devtools) {\n        if (devtools) {\n          devtools.emit('init', Vue);\n        } else {\n          console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n        }\n      }\n\n      if (config.productionTip !== false && typeof console !== 'undefined') {\n        console[console.info ? 'info' : 'log'](\"You are running Vue in development mode.\\n\" + \"Make sure to turn on production mode when deploying for production.\\n\" + \"See more tips at https://vuejs.org/guide/deployment.html\");\n      }\n    }, 0);\n  }\n  /*  */\n\n\n  var defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\n  var regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n  var buildRegex = cached(function (delimiters) {\n    var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n    var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n    return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g');\n  });\n\n  function parseText(text, delimiters) {\n    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n\n    if (!tagRE.test(text)) {\n      return;\n    }\n\n    var tokens = [];\n    var rawTokens = [];\n    var lastIndex = tagRE.lastIndex = 0;\n    var match, index, tokenValue;\n\n    while (match = tagRE.exec(text)) {\n      index = match.index; // push text token\n\n      if (index > lastIndex) {\n        rawTokens.push(tokenValue = text.slice(lastIndex, index));\n        tokens.push(JSON.stringify(tokenValue));\n      } // tag token\n\n\n      var exp = parseFilters(match[1].trim());\n      tokens.push(\"_s(\" + exp + \")\");\n      rawTokens.push({\n        '@binding': exp\n      });\n      lastIndex = index + match[0].length;\n    }\n\n    if (lastIndex < text.length) {\n      rawTokens.push(tokenValue = text.slice(lastIndex));\n      tokens.push(JSON.stringify(tokenValue));\n    }\n\n    return {\n      expression: tokens.join('+'),\n      tokens: rawTokens\n    };\n  }\n  /*  */\n\n\n  function transformNode(el, options) {\n    var warn = options.warn || baseWarn;\n    var staticClass = getAndRemoveAttr(el, 'class');\n\n    if (staticClass) {\n      var res = parseText(staticClass, options.delimiters);\n\n      if (res) {\n        warn(\"class=\\\"\" + staticClass + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.', el.rawAttrsMap['class']);\n      }\n    }\n\n    if (staticClass) {\n      el.staticClass = JSON.stringify(staticClass);\n    }\n\n    var classBinding = getBindingAttr(el, 'class', false\n    /* getStatic */\n    );\n\n    if (classBinding) {\n      el.classBinding = classBinding;\n    }\n  }\n\n  function genData(el) {\n    var data = '';\n\n    if (el.staticClass) {\n      data += \"staticClass:\" + el.staticClass + \",\";\n    }\n\n    if (el.classBinding) {\n      data += \"class:\" + el.classBinding + \",\";\n    }\n\n    return data;\n  }\n\n  var klass$1 = {\n    staticKeys: ['staticClass'],\n    transformNode: transformNode,\n    genData: genData\n  };\n  /*  */\n\n  function transformNode$1(el, options) {\n    var warn = options.warn || baseWarn;\n    var staticStyle = getAndRemoveAttr(el, 'style');\n\n    if (staticStyle) {\n      /* istanbul ignore if */\n      {\n        var res = parseText(staticStyle, options.delimiters);\n\n        if (res) {\n          warn(\"style=\\\"\" + staticStyle + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.', el.rawAttrsMap['style']);\n        }\n      }\n      el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n    }\n\n    var styleBinding = getBindingAttr(el, 'style', false\n    /* getStatic */\n    );\n\n    if (styleBinding) {\n      el.styleBinding = styleBinding;\n    }\n  }\n\n  function genData$1(el) {\n    var data = '';\n\n    if (el.staticStyle) {\n      data += \"staticStyle:\" + el.staticStyle + \",\";\n    }\n\n    if (el.styleBinding) {\n      data += \"style:(\" + el.styleBinding + \"),\";\n    }\n\n    return data;\n  }\n\n  var style$1 = {\n    staticKeys: ['staticStyle'],\n    transformNode: transformNode$1,\n    genData: genData$1\n  };\n  /*  */\n\n  var decoder;\n  var he = {\n    decode: function decode(html) {\n      decoder = decoder || document.createElement('div');\n      decoder.innerHTML = html;\n      return decoder.textContent;\n    }\n  };\n  /*  */\n\n  var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr'); // Elements that you can, intentionally, leave open\n  // (and which close themselves)\n\n  var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'); // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n  // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\n\n  var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');\n  /**\n   * Not type-checking this file because it's mostly vendor code.\n   */\n  // Regular Expressions for parsing tags and attributes\n\n  var attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n  var dynamicArgAttribute = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n  var ncname = \"[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z\" + unicodeRegExp.source + \"]*\";\n  var qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\n  var startTagOpen = new RegExp(\"^<\" + qnameCapture);\n  var startTagClose = /^\\s*(\\/?)>/;\n  var endTag = new RegExp(\"^<\\\\/\" + qnameCapture + \"[^>]*>\");\n  var doctype = /^<!DOCTYPE [^>]+>/i; // #7298: escape - to avoid being pased as HTML comment when inlined in page\n\n  var comment = /^<!\\--/;\n  var conditionalComment = /^<!\\[/; // Special Elements (can contain anything)\n\n  var isPlainTextElement = makeMap('script,style,textarea', true);\n  var reCache = {};\n  var decodingMap = {\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&amp;': '&',\n    '&#10;': '\\n',\n    '&#9;': '\\t',\n    '&#39;': \"'\"\n  };\n  var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;\n  var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g; // #5992\n\n  var isIgnoreNewlineTag = makeMap('pre,textarea', true);\n\n  var shouldIgnoreFirstNewline = function shouldIgnoreFirstNewline(tag, html) {\n    return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n';\n  };\n\n  function decodeAttr(value, shouldDecodeNewlines) {\n    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n    return value.replace(re, function (match) {\n      return decodingMap[match];\n    });\n  }\n\n  function parseHTML(html, options) {\n    var stack = [];\n    var expectHTML = options.expectHTML;\n    var isUnaryTag$$1 = options.isUnaryTag || no;\n    var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n    var index = 0;\n    var last, lastTag;\n\n    while (html) {\n      last = html; // Make sure we're not in a plaintext content element like script/style\n\n      if (!lastTag || !isPlainTextElement(lastTag)) {\n        var textEnd = html.indexOf('<');\n\n        if (textEnd === 0) {\n          // Comment:\n          if (comment.test(html)) {\n            var commentEnd = html.indexOf('-->');\n\n            if (commentEnd >= 0) {\n              if (options.shouldKeepComment) {\n                options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);\n              }\n\n              advance(commentEnd + 3);\n              continue;\n            }\n          } // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n\n\n          if (conditionalComment.test(html)) {\n            var conditionalEnd = html.indexOf(']>');\n\n            if (conditionalEnd >= 0) {\n              advance(conditionalEnd + 2);\n              continue;\n            }\n          } // Doctype:\n\n\n          var doctypeMatch = html.match(doctype);\n\n          if (doctypeMatch) {\n            advance(doctypeMatch[0].length);\n            continue;\n          } // End tag:\n\n\n          var endTagMatch = html.match(endTag);\n\n          if (endTagMatch) {\n            var curIndex = index;\n            advance(endTagMatch[0].length);\n            parseEndTag(endTagMatch[1], curIndex, index);\n            continue;\n          } // Start tag:\n\n\n          var startTagMatch = parseStartTag();\n\n          if (startTagMatch) {\n            handleStartTag(startTagMatch);\n\n            if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\n              advance(1);\n            }\n\n            continue;\n          }\n        }\n\n        var text = void 0,\n            rest = void 0,\n            next = void 0;\n\n        if (textEnd >= 0) {\n          rest = html.slice(textEnd);\n\n          while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {\n            // < in plain text, be forgiving and treat it as text\n            next = rest.indexOf('<', 1);\n\n            if (next < 0) {\n              break;\n            }\n\n            textEnd += next;\n            rest = html.slice(textEnd);\n          }\n\n          text = html.substring(0, textEnd);\n        }\n\n        if (textEnd < 0) {\n          text = html;\n        }\n\n        if (text) {\n          advance(text.length);\n        }\n\n        if (options.chars && text) {\n          options.chars(text, index - text.length, index);\n        }\n      } else {\n        var endTagLength = 0;\n        var stackedTag = lastTag.toLowerCase();\n        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n        var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n          endTagLength = endTag.length;\n\n          if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n            text = text.replace(/<!\\--([\\s\\S]*?)-->/g, '$1') // #7298\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n          }\n\n          if (shouldIgnoreFirstNewline(stackedTag, text)) {\n            text = text.slice(1);\n          }\n\n          if (options.chars) {\n            options.chars(text);\n          }\n\n          return '';\n        });\n        index += html.length - rest$1.length;\n        html = rest$1;\n        parseEndTag(stackedTag, index - endTagLength, index);\n      }\n\n      if (html === last) {\n        options.chars && options.chars(html);\n\n        if (!stack.length && options.warn) {\n          options.warn(\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\", {\n            start: index + html.length\n          });\n        }\n\n        break;\n      }\n    } // Clean up any remaining tags\n\n\n    parseEndTag();\n\n    function advance(n) {\n      index += n;\n      html = html.substring(n);\n    }\n\n    function parseStartTag() {\n      var start = html.match(startTagOpen);\n\n      if (start) {\n        var match = {\n          tagName: start[1],\n          attrs: [],\n          start: index\n        };\n        advance(start[0].length);\n        var end, attr;\n\n        while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {\n          attr.start = index;\n          advance(attr[0].length);\n          attr.end = index;\n          match.attrs.push(attr);\n        }\n\n        if (end) {\n          match.unarySlash = end[1];\n          advance(end[0].length);\n          match.end = index;\n          return match;\n        }\n      }\n    }\n\n    function handleStartTag(match) {\n      var tagName = match.tagName;\n      var unarySlash = match.unarySlash;\n\n      if (expectHTML) {\n        if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n          parseEndTag(lastTag);\n        }\n\n        if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n          parseEndTag(tagName);\n        }\n      }\n\n      var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n      var l = match.attrs.length;\n      var attrs = new Array(l);\n\n      for (var i = 0; i < l; i++) {\n        var args = match.attrs[i];\n        var value = args[3] || args[4] || args[5] || '';\n        var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;\n        attrs[i] = {\n          name: args[1],\n          value: decodeAttr(value, shouldDecodeNewlines)\n        };\n\n        if (options.outputSourceRange) {\n          attrs[i].start = args.start + args[0].match(/^\\s*/).length;\n          attrs[i].end = args.end;\n        }\n      }\n\n      if (!unary) {\n        stack.push({\n          tag: tagName,\n          lowerCasedTag: tagName.toLowerCase(),\n          attrs: attrs,\n          start: match.start,\n          end: match.end\n        });\n        lastTag = tagName;\n      }\n\n      if (options.start) {\n        options.start(tagName, attrs, unary, match.start, match.end);\n      }\n    }\n\n    function parseEndTag(tagName, start, end) {\n      var pos, lowerCasedTagName;\n\n      if (start == null) {\n        start = index;\n      }\n\n      if (end == null) {\n        end = index;\n      } // Find the closest opened tag of the same type\n\n\n      if (tagName) {\n        lowerCasedTagName = tagName.toLowerCase();\n\n        for (pos = stack.length - 1; pos >= 0; pos--) {\n          if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n            break;\n          }\n        }\n      } else {\n        // If no tag name is provided, clean shop\n        pos = 0;\n      }\n\n      if (pos >= 0) {\n        // Close all the open elements, up the stack\n        for (var i = stack.length - 1; i >= pos; i--) {\n          if (i > pos || !tagName && options.warn) {\n            options.warn(\"tag <\" + stack[i].tag + \"> has no matching end tag.\", {\n              start: stack[i].start,\n              end: stack[i].end\n            });\n          }\n\n          if (options.end) {\n            options.end(stack[i].tag, start, end);\n          }\n        } // Remove the open elements from the stack\n\n\n        stack.length = pos;\n        lastTag = pos && stack[pos - 1].tag;\n      } else if (lowerCasedTagName === 'br') {\n        if (options.start) {\n          options.start(tagName, [], true, start, end);\n        }\n      } else if (lowerCasedTagName === 'p') {\n        if (options.start) {\n          options.start(tagName, [], false, start, end);\n        }\n\n        if (options.end) {\n          options.end(tagName, start, end);\n        }\n      }\n    }\n  }\n  /*  */\n\n\n  var onRE = /^@|^v-on:/;\n  var dirRE = /^v-|^@|^:/;\n  var forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n  var forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n  var stripParensRE = /^\\(|\\)$/g;\n  var dynamicArgRE = /^\\[.*\\]$/;\n  var argRE = /:(.*)$/;\n  var bindRE = /^:|^\\.|^v-bind:/;\n  var modifierRE = /\\.[^.\\]]+(?=[^\\]]*$)/g;\n  var slotRE = /^v-slot(:|$)|^#/;\n  var lineBreakRE = /[\\r\\n]/;\n  var whitespaceRE$1 = /\\s+/g;\n  var invalidAttributeRE = /[\\s\"'<>\\/=]/;\n  var decodeHTMLCached = cached(he.decode);\n  var emptySlotScopeToken = \"_empty_\"; // configurable state\n\n  var warn$2;\n  var delimiters;\n  var transforms;\n  var preTransforms;\n  var postTransforms;\n  var platformIsPreTag;\n  var platformMustUseProp;\n  var platformGetTagNamespace;\n  var maybeComponent;\n\n  function createASTElement(tag, attrs, parent) {\n    return {\n      type: 1,\n      tag: tag,\n      attrsList: attrs,\n      attrsMap: makeAttrsMap(attrs),\n      rawAttrsMap: {},\n      parent: parent,\n      children: []\n    };\n  }\n  /**\n   * Convert HTML string to AST.\n   */\n\n\n  function parse(template, options) {\n    warn$2 = options.warn || baseWarn;\n    platformIsPreTag = options.isPreTag || no;\n    platformMustUseProp = options.mustUseProp || no;\n    platformGetTagNamespace = options.getTagNamespace || no;\n    var isReservedTag = options.isReservedTag || no;\n\n    maybeComponent = function maybeComponent(el) {\n      return !!el.component || !isReservedTag(el.tag);\n    };\n\n    transforms = pluckModuleFunction(options.modules, 'transformNode');\n    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n    delimiters = options.delimiters;\n    var stack = [];\n    var preserveWhitespace = options.preserveWhitespace !== false;\n    var whitespaceOption = options.whitespace;\n    var root;\n    var currentParent;\n    var inVPre = false;\n    var inPre = false;\n    var warned = false;\n\n    function warnOnce(msg, range) {\n      if (!warned) {\n        warned = true;\n        warn$2(msg, range);\n      }\n    }\n\n    function closeElement(element) {\n      trimEndingWhitespace(element);\n\n      if (!inVPre && !element.processed) {\n        element = processElement(element, options);\n      } // tree management\n\n\n      if (!stack.length && element !== root) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root[\"if\"] && (element.elseif || element[\"else\"])) {\n          {\n            checkRootConstraints(element);\n          }\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else {\n          warnOnce(\"Component template should contain exactly one root element. \" + \"If you are using v-if on multiple elements, \" + \"use v-else-if to chain them instead.\", {\n            start: element.start\n          });\n        }\n      }\n\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element[\"else\"]) {\n          processIfConditions(element, currentParent);\n        } else {\n          if (element.slotScope) {\n            // scoped slot\n            // keep it in the children list so that v-else(-if) conditions can\n            // find it as the prev node.\n            var name = element.slotTarget || '\"default\"';\n            (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n          }\n\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      } // final children cleanup\n      // filter out scoped slots\n\n\n      element.children = element.children.filter(function (c) {\n        return !c.slotScope;\n      }); // remove trailing whitespace node again\n\n      trimEndingWhitespace(element); // check pre state\n\n      if (element.pre) {\n        inVPre = false;\n      }\n\n      if (platformIsPreTag(element.tag)) {\n        inPre = false;\n      } // apply post-transforms\n\n\n      for (var i = 0; i < postTransforms.length; i++) {\n        postTransforms[i](element, options);\n      }\n    }\n\n    function trimEndingWhitespace(el) {\n      // remove trailing whitespace node\n      if (!inPre) {\n        var lastNode;\n\n        while ((lastNode = el.children[el.children.length - 1]) && lastNode.type === 3 && lastNode.text === ' ') {\n          el.children.pop();\n        }\n      }\n    }\n\n    function checkRootConstraints(el) {\n      if (el.tag === 'slot' || el.tag === 'template') {\n        warnOnce(\"Cannot use <\" + el.tag + \"> as component root element because it may \" + 'contain multiple nodes.', {\n          start: el.start\n        });\n      }\n\n      if (el.attrsMap.hasOwnProperty('v-for')) {\n        warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.', el.rawAttrsMap['v-for']);\n      }\n    }\n\n    parseHTML(template, {\n      warn: warn$2,\n      expectHTML: options.expectHTML,\n      isUnaryTag: options.isUnaryTag,\n      canBeLeftOpenTag: options.canBeLeftOpenTag,\n      shouldDecodeNewlines: options.shouldDecodeNewlines,\n      shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n      shouldKeepComment: options.comments,\n      outputSourceRange: options.outputSourceRange,\n      start: function start(tag, attrs, unary, start$1, end) {\n        // check namespace.\n        // inherit parent ns if there is one\n        var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag); // handle IE svg bug\n\n        /* istanbul ignore if */\n\n        if (isIE && ns === 'svg') {\n          attrs = guardIESVGBug(attrs);\n        }\n\n        var element = createASTElement(tag, attrs, currentParent);\n\n        if (ns) {\n          element.ns = ns;\n        }\n\n        {\n          if (options.outputSourceRange) {\n            element.start = start$1;\n            element.end = end;\n            element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {\n              cumulated[attr.name] = attr;\n              return cumulated;\n            }, {});\n          }\n\n          attrs.forEach(function (attr) {\n            if (invalidAttributeRE.test(attr.name)) {\n              warn$2(\"Invalid dynamic argument expression: attribute names cannot contain \" + \"spaces, quotes, <, >, / or =.\", {\n                start: attr.start + attr.name.indexOf(\"[\"),\n                end: attr.start + attr.name.length\n              });\n            }\n          });\n        }\n\n        if (isForbiddenTag(element) && !isServerRendering()) {\n          element.forbidden = true;\n          warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + \"<\" + tag + \">\" + ', as they will not be parsed.', {\n            start: element.start\n          });\n        } // apply pre-transforms\n\n\n        for (var i = 0; i < preTransforms.length; i++) {\n          element = preTransforms[i](element, options) || element;\n        }\n\n        if (!inVPre) {\n          processPre(element);\n\n          if (element.pre) {\n            inVPre = true;\n          }\n        }\n\n        if (platformIsPreTag(element.tag)) {\n          inPre = true;\n        }\n\n        if (inVPre) {\n          processRawAttrs(element);\n        } else if (!element.processed) {\n          // structural directives\n          processFor(element);\n          processIf(element);\n          processOnce(element);\n        }\n\n        if (!root) {\n          root = element;\n          {\n            checkRootConstraints(root);\n          }\n        }\n\n        if (!unary) {\n          currentParent = element;\n          stack.push(element);\n        } else {\n          closeElement(element);\n        }\n      },\n      end: function end(tag, start, end$1) {\n        var element = stack[stack.length - 1]; // pop stack\n\n        stack.length -= 1;\n        currentParent = stack[stack.length - 1];\n\n        if (options.outputSourceRange) {\n          element.end = end$1;\n        }\n\n        closeElement(element);\n      },\n      chars: function chars(text, start, end) {\n        if (!currentParent) {\n          {\n            if (text === template) {\n              warnOnce('Component template requires a root element, rather than just text.', {\n                start: start\n              });\n            } else if (text = text.trim()) {\n              warnOnce(\"text \\\"\" + text + \"\\\" outside root element will be ignored.\", {\n                start: start\n              });\n            }\n          }\n          return;\n        } // IE textarea placeholder bug\n\n        /* istanbul ignore if */\n\n\n        if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {\n          return;\n        }\n\n        var children = currentParent.children;\n\n        if (inPre || text.trim()) {\n          text = isTextTag(currentParent) ? text : decodeHTMLCached(text);\n        } else if (!children.length) {\n          // remove the whitespace-only node right after an opening tag\n          text = '';\n        } else if (whitespaceOption) {\n          if (whitespaceOption === 'condense') {\n            // in condense mode, remove the whitespace node if it contains\n            // line break, otherwise condense to a single space\n            text = lineBreakRE.test(text) ? '' : ' ';\n          } else {\n            text = ' ';\n          }\n        } else {\n          text = preserveWhitespace ? ' ' : '';\n        }\n\n        if (text) {\n          if (!inPre && whitespaceOption === 'condense') {\n            // condense consecutive whitespaces into single space\n            text = text.replace(whitespaceRE$1, ' ');\n          }\n\n          var res;\n          var child;\n\n          if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n            child = {\n              type: 2,\n              expression: res.expression,\n              tokens: res.tokens,\n              text: text\n            };\n          } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n            child = {\n              type: 3,\n              text: text\n            };\n          }\n\n          if (child) {\n            if (options.outputSourceRange) {\n              child.start = start;\n              child.end = end;\n            }\n\n            children.push(child);\n          }\n        }\n      },\n      comment: function comment(text, start, end) {\n        // adding anyting as a sibling to the root node is forbidden\n        // comments should still be allowed, but ignored\n        if (currentParent) {\n          var child = {\n            type: 3,\n            text: text,\n            isComment: true\n          };\n\n          if (options.outputSourceRange) {\n            child.start = start;\n            child.end = end;\n          }\n\n          currentParent.children.push(child);\n        }\n      }\n    });\n    return root;\n  }\n\n  function processPre(el) {\n    if (getAndRemoveAttr(el, 'v-pre') != null) {\n      el.pre = true;\n    }\n  }\n\n  function processRawAttrs(el) {\n    var list = el.attrsList;\n    var len = list.length;\n\n    if (len) {\n      var attrs = el.attrs = new Array(len);\n\n      for (var i = 0; i < len; i++) {\n        attrs[i] = {\n          name: list[i].name,\n          value: JSON.stringify(list[i].value)\n        };\n\n        if (list[i].start != null) {\n          attrs[i].start = list[i].start;\n          attrs[i].end = list[i].end;\n        }\n      }\n    } else if (!el.pre) {\n      // non root node in pre blocks with no attributes\n      el.plain = true;\n    }\n  }\n\n  function processElement(element, options) {\n    processKey(element); // determine whether this is a plain element after\n    // removing structural attributes\n\n    element.plain = !element.key && !element.scopedSlots && !element.attrsList.length;\n    processRef(element);\n    processSlotContent(element);\n    processSlotOutlet(element);\n    processComponent(element);\n\n    for (var i = 0; i < transforms.length; i++) {\n      element = transforms[i](element, options) || element;\n    }\n\n    processAttrs(element);\n    return element;\n  }\n\n  function processKey(el) {\n    var exp = getBindingAttr(el, 'key');\n\n    if (exp) {\n      {\n        if (el.tag === 'template') {\n          warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\", getRawBindingAttr(el, 'key'));\n        }\n\n        if (el[\"for\"]) {\n          var iterator = el.iterator2 || el.iterator1;\n          var parent = el.parent;\n\n          if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {\n            warn$2(\"Do not use v-for index as key on <transition-group> children, \" + \"this is the same as not using keys.\", getRawBindingAttr(el, 'key'), true\n            /* tip */\n            );\n          }\n        }\n      }\n      el.key = exp;\n    }\n  }\n\n  function processRef(el) {\n    var ref = getBindingAttr(el, 'ref');\n\n    if (ref) {\n      el.ref = ref;\n      el.refInFor = checkInFor(el);\n    }\n  }\n\n  function processFor(el) {\n    var exp;\n\n    if (exp = getAndRemoveAttr(el, 'v-for')) {\n      var res = parseFor(exp);\n\n      if (res) {\n        extend(el, res);\n      } else {\n        warn$2(\"Invalid v-for expression: \" + exp, el.rawAttrsMap['v-for']);\n      }\n    }\n  }\n\n  function parseFor(exp) {\n    var inMatch = exp.match(forAliasRE);\n\n    if (!inMatch) {\n      return;\n    }\n\n    var res = {};\n    res[\"for\"] = inMatch[2].trim();\n    var alias = inMatch[1].trim().replace(stripParensRE, '');\n    var iteratorMatch = alias.match(forIteratorRE);\n\n    if (iteratorMatch) {\n      res.alias = alias.replace(forIteratorRE, '').trim();\n      res.iterator1 = iteratorMatch[1].trim();\n\n      if (iteratorMatch[2]) {\n        res.iterator2 = iteratorMatch[2].trim();\n      }\n    } else {\n      res.alias = alias;\n    }\n\n    return res;\n  }\n\n  function processIf(el) {\n    var exp = getAndRemoveAttr(el, 'v-if');\n\n    if (exp) {\n      el[\"if\"] = exp;\n      addIfCondition(el, {\n        exp: exp,\n        block: el\n      });\n    } else {\n      if (getAndRemoveAttr(el, 'v-else') != null) {\n        el[\"else\"] = true;\n      }\n\n      var elseif = getAndRemoveAttr(el, 'v-else-if');\n\n      if (elseif) {\n        el.elseif = elseif;\n      }\n    }\n  }\n\n  function processIfConditions(el, parent) {\n    var prev = findPrevElement(parent.children);\n\n    if (prev && prev[\"if\"]) {\n      addIfCondition(prev, {\n        exp: el.elseif,\n        block: el\n      });\n    } else {\n      warn$2(\"v-\" + (el.elseif ? 'else-if=\"' + el.elseif + '\"' : 'else') + \" \" + \"used on element <\" + el.tag + \"> without corresponding v-if.\", el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']);\n    }\n  }\n\n  function findPrevElement(children) {\n    var i = children.length;\n\n    while (i--) {\n      if (children[i].type === 1) {\n        return children[i];\n      } else {\n        if (children[i].text !== ' ') {\n          warn$2(\"text \\\"\" + children[i].text.trim() + \"\\\" between v-if and v-else(-if) \" + \"will be ignored.\", children[i]);\n        }\n\n        children.pop();\n      }\n    }\n  }\n\n  function addIfCondition(el, condition) {\n    if (!el.ifConditions) {\n      el.ifConditions = [];\n    }\n\n    el.ifConditions.push(condition);\n  }\n\n  function processOnce(el) {\n    var once$$1 = getAndRemoveAttr(el, 'v-once');\n\n    if (once$$1 != null) {\n      el.once = true;\n    }\n  } // handle content being passed to a component as slot,\n  // e.g. <template slot=\"xxx\">, <div slot-scope=\"xxx\">\n\n\n  function processSlotContent(el) {\n    var slotScope;\n\n    if (el.tag === 'template') {\n      slotScope = getAndRemoveAttr(el, 'scope');\n      /* istanbul ignore if */\n\n      if (slotScope) {\n        warn$2(\"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" + \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" + \"can also be used on plain elements in addition to <template> to \" + \"denote scoped slots.\", el.rawAttrsMap['scope'], true);\n      }\n\n      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n    } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {\n      /* istanbul ignore if */\n      if (el.attrsMap['v-for']) {\n        warn$2(\"Ambiguous combined usage of slot-scope and v-for on <\" + el.tag + \"> \" + \"(v-for takes higher priority). Use a wrapper <template> for the \" + \"scoped slot to make it clearer.\", el.rawAttrsMap['slot-scope'], true);\n      }\n\n      el.slotScope = slotScope;\n    } // slot=\"xxx\"\n\n\n    var slotTarget = getBindingAttr(el, 'slot');\n\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n      el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']); // preserve slot as an attribute for native shadow DOM compat\n      // only for non-scoped slots.\n\n      if (el.tag !== 'template' && !el.slotScope) {\n        addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));\n      }\n    } // 2.6 v-slot syntax\n\n\n    {\n      if (el.tag === 'template') {\n        // v-slot on <template>\n        var slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n\n        if (slotBinding) {\n          {\n            if (el.slotTarget || el.slotScope) {\n              warn$2(\"Unexpected mixed usage of different slot syntaxes.\", el);\n            }\n\n            if (el.parent && !maybeComponent(el.parent)) {\n              warn$2(\"<template v-slot> can only appear at the root level inside \" + \"the receiving the component\", el);\n            }\n          }\n          var ref = getSlotName(slotBinding);\n          var name = ref.name;\n          var dynamic = ref.dynamic;\n          el.slotTarget = name;\n          el.slotTargetDynamic = dynamic;\n          el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf\n        }\n      } else {\n        // v-slot on component, denotes default slot\n        var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);\n\n        if (slotBinding$1) {\n          {\n            if (!maybeComponent(el)) {\n              warn$2(\"v-slot can only be used on components or <template>.\", slotBinding$1);\n            }\n\n            if (el.slotScope || el.slotTarget) {\n              warn$2(\"Unexpected mixed usage of different slot syntaxes.\", el);\n            }\n\n            if (el.scopedSlots) {\n              warn$2(\"To avoid scope ambiguity, the default slot should also use \" + \"<template> syntax when there are other named slots.\", slotBinding$1);\n            }\n          } // add the component's children to its default slot\n\n          var slots = el.scopedSlots || (el.scopedSlots = {});\n          var ref$1 = getSlotName(slotBinding$1);\n          var name$1 = ref$1.name;\n          var dynamic$1 = ref$1.dynamic;\n          var slotContainer = slots[name$1] = createASTElement('template', [], el);\n          slotContainer.slotTarget = name$1;\n          slotContainer.slotTargetDynamic = dynamic$1;\n          slotContainer.children = el.children.filter(function (c) {\n            if (!c.slotScope) {\n              c.parent = slotContainer;\n              return true;\n            }\n          });\n          slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken; // remove children as they are returned from scopedSlots now\n\n          el.children = []; // mark el non-plain so data gets generated\n\n          el.plain = false;\n        }\n      }\n    }\n  }\n\n  function getSlotName(binding) {\n    var name = binding.name.replace(slotRE, '');\n\n    if (!name) {\n      if (binding.name[0] !== '#') {\n        name = 'default';\n      } else {\n        warn$2(\"v-slot shorthand syntax requires a slot name.\", binding);\n      }\n    }\n\n    return dynamicArgRE.test(name) // dynamic [name]\n    ? {\n      name: name.slice(1, -1),\n      dynamic: true // static name\n\n    } : {\n      name: \"\\\"\" + name + \"\\\"\",\n      dynamic: false\n    };\n  } // handle <slot/> outlets\n\n\n  function processSlotOutlet(el) {\n    if (el.tag === 'slot') {\n      el.slotName = getBindingAttr(el, 'name');\n\n      if (el.key) {\n        warn$2(\"`key` does not work on <slot> because slots are abstract outlets \" + \"and can possibly expand into multiple elements. \" + \"Use the key on a wrapping element instead.\", getRawBindingAttr(el, 'key'));\n      }\n    }\n  }\n\n  function processComponent(el) {\n    var binding;\n\n    if (binding = getBindingAttr(el, 'is')) {\n      el.component = binding;\n    }\n\n    if (getAndRemoveAttr(el, 'inline-template') != null) {\n      el.inlineTemplate = true;\n    }\n  }\n\n  function processAttrs(el) {\n    var list = el.attrsList;\n    var i, l, name, rawName, value, modifiers, syncGen, isDynamic;\n\n    for (i = 0, l = list.length; i < l; i++) {\n      name = rawName = list[i].name;\n      value = list[i].value;\n\n      if (dirRE.test(name)) {\n        // mark element as dynamic\n        el.hasBindings = true; // modifiers\n\n        modifiers = parseModifiers(name.replace(dirRE, '')); // support .foo shorthand syntax for the .prop modifier\n\n        if (modifiers) {\n          name = name.replace(modifierRE, '');\n        }\n\n        if (bindRE.test(name)) {\n          // v-bind\n          name = name.replace(bindRE, '');\n          value = parseFilters(value);\n          isDynamic = dynamicArgRE.test(name);\n\n          if (isDynamic) {\n            name = name.slice(1, -1);\n          }\n\n          if (value.trim().length === 0) {\n            warn$2(\"The value for a v-bind expression cannot be empty. Found in \\\"v-bind:\" + name + \"\\\"\");\n          }\n\n          if (modifiers) {\n            if (modifiers.prop && !isDynamic) {\n              name = camelize(name);\n\n              if (name === 'innerHtml') {\n                name = 'innerHTML';\n              }\n            }\n\n            if (modifiers.camel && !isDynamic) {\n              name = camelize(name);\n            }\n\n            if (modifiers.sync) {\n              syncGen = genAssignmentCode(value, \"$event\");\n\n              if (!isDynamic) {\n                addHandler(el, \"update:\" + camelize(name), syncGen, null, false, warn$2, list[i]);\n\n                if (hyphenate(name) !== camelize(name)) {\n                  addHandler(el, \"update:\" + hyphenate(name), syncGen, null, false, warn$2, list[i]);\n                }\n              } else {\n                // handler w/ dynamic event name\n                addHandler(el, \"\\\"update:\\\"+(\" + name + \")\", syncGen, null, false, warn$2, list[i], true // dynamic\n                );\n              }\n            }\n          }\n\n          if (modifiers && modifiers.prop || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n            addProp(el, name, value, list[i], isDynamic);\n          } else {\n            addAttr(el, name, value, list[i], isDynamic);\n          }\n        } else if (onRE.test(name)) {\n          // v-on\n          name = name.replace(onRE, '');\n          isDynamic = dynamicArgRE.test(name);\n\n          if (isDynamic) {\n            name = name.slice(1, -1);\n          }\n\n          addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);\n        } else {\n          // normal directives\n          name = name.replace(dirRE, ''); // parse arg\n\n          var argMatch = name.match(argRE);\n          var arg = argMatch && argMatch[1];\n          isDynamic = false;\n\n          if (arg) {\n            name = name.slice(0, -(arg.length + 1));\n\n            if (dynamicArgRE.test(arg)) {\n              arg = arg.slice(1, -1);\n              isDynamic = true;\n            }\n          }\n\n          addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\n\n          if (name === 'model') {\n            checkForAliasModel(el, value);\n          }\n        }\n      } else {\n        // literal attribute\n        {\n          var res = parseText(value, delimiters);\n\n          if (res) {\n            warn$2(name + \"=\\\"\" + value + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.', list[i]);\n          }\n        }\n        addAttr(el, name, JSON.stringify(value), list[i]); // #6887 firefox doesn't update muted state if set via attribute\n        // even immediately after element creation\n\n        if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, 'true', list[i]);\n        }\n      }\n    }\n  }\n\n  function checkInFor(el) {\n    var parent = el;\n\n    while (parent) {\n      if (parent[\"for\"] !== undefined) {\n        return true;\n      }\n\n      parent = parent.parent;\n    }\n\n    return false;\n  }\n\n  function parseModifiers(name) {\n    var match = name.match(modifierRE);\n\n    if (match) {\n      var ret = {};\n      match.forEach(function (m) {\n        ret[m.slice(1)] = true;\n      });\n      return ret;\n    }\n  }\n\n  function makeAttrsMap(attrs) {\n    var map = {};\n\n    for (var i = 0, l = attrs.length; i < l; i++) {\n      if (map[attrs[i].name] && !isIE && !isEdge) {\n        warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);\n      }\n\n      map[attrs[i].name] = attrs[i].value;\n    }\n\n    return map;\n  } // for script (e.g. type=\"x/template\") or style, do not decode content\n\n\n  function isTextTag(el) {\n    return el.tag === 'script' || el.tag === 'style';\n  }\n\n  function isForbiddenTag(el) {\n    return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');\n  }\n\n  var ieNSBug = /^xmlns:NS\\d+/;\n  var ieNSPrefix = /^NS\\d+:/;\n  /* istanbul ignore next */\n\n  function guardIESVGBug(attrs) {\n    var res = [];\n\n    for (var i = 0; i < attrs.length; i++) {\n      var attr = attrs[i];\n\n      if (!ieNSBug.test(attr.name)) {\n        attr.name = attr.name.replace(ieNSPrefix, '');\n        res.push(attr);\n      }\n    }\n\n    return res;\n  }\n\n  function checkForAliasModel(el, value) {\n    var _el = el;\n\n    while (_el) {\n      if (_el[\"for\"] && _el.alias === value) {\n        warn$2(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"You are binding v-model directly to a v-for iteration alias. \" + \"This will not be able to modify the v-for source array because \" + \"writing to the alias is like modifying a function local variable. \" + \"Consider using an array of objects and use v-model on an object property instead.\", el.rawAttrsMap['v-model']);\n      }\n\n      _el = _el.parent;\n    }\n  }\n  /*  */\n\n\n  function preTransformNode(el, options) {\n    if (el.tag === 'input') {\n      var map = el.attrsMap;\n\n      if (!map['v-model']) {\n        return;\n      }\n\n      var typeBinding;\n\n      if (map[':type'] || map['v-bind:type']) {\n        typeBinding = getBindingAttr(el, 'type');\n      }\n\n      if (!map.type && !typeBinding && map['v-bind']) {\n        typeBinding = \"(\" + map['v-bind'] + \").type\";\n      }\n\n      if (typeBinding) {\n        var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n        var ifConditionExtra = ifCondition ? \"&&(\" + ifCondition + \")\" : \"\";\n        var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n        var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true); // 1. checkbox\n\n        var branch0 = cloneASTElement(el); // process for on the main node\n\n        processFor(branch0);\n        addRawAttr(branch0, 'type', 'checkbox');\n        processElement(branch0, options);\n        branch0.processed = true; // prevent it from double-processed\n\n        branch0[\"if\"] = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n        addIfCondition(branch0, {\n          exp: branch0[\"if\"],\n          block: branch0\n        }); // 2. add radio else-if condition\n\n        var branch1 = cloneASTElement(el);\n        getAndRemoveAttr(branch1, 'v-for', true);\n        addRawAttr(branch1, 'type', 'radio');\n        processElement(branch1, options);\n        addIfCondition(branch0, {\n          exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n          block: branch1\n        }); // 3. other\n\n        var branch2 = cloneASTElement(el);\n        getAndRemoveAttr(branch2, 'v-for', true);\n        addRawAttr(branch2, ':type', typeBinding);\n        processElement(branch2, options);\n        addIfCondition(branch0, {\n          exp: ifCondition,\n          block: branch2\n        });\n\n        if (hasElse) {\n          branch0[\"else\"] = true;\n        } else if (elseIfCondition) {\n          branch0.elseif = elseIfCondition;\n        }\n\n        return branch0;\n      }\n    }\n  }\n\n  function cloneASTElement(el) {\n    return createASTElement(el.tag, el.attrsList.slice(), el.parent);\n  }\n\n  var model$1 = {\n    preTransformNode: preTransformNode\n  };\n  var modules$1 = [klass$1, style$1, model$1];\n  /*  */\n\n  function text(el, dir) {\n    if (dir.value) {\n      addProp(el, 'textContent', \"_s(\" + dir.value + \")\", dir);\n    }\n  }\n  /*  */\n\n\n  function html(el, dir) {\n    if (dir.value) {\n      addProp(el, 'innerHTML', \"_s(\" + dir.value + \")\", dir);\n    }\n  }\n\n  var directives$1 = {\n    model: model,\n    text: text,\n    html: html\n  };\n  /*  */\n\n  var baseOptions = {\n    expectHTML: true,\n    modules: modules$1,\n    directives: directives$1,\n    isPreTag: isPreTag,\n    isUnaryTag: isUnaryTag,\n    mustUseProp: mustUseProp,\n    canBeLeftOpenTag: canBeLeftOpenTag,\n    isReservedTag: isReservedTag,\n    getTagNamespace: getTagNamespace,\n    staticKeys: genStaticKeys(modules$1)\n  };\n  /*  */\n\n  var isStaticKey;\n  var isPlatformReservedTag;\n  var genStaticKeysCached = cached(genStaticKeys$1);\n  /**\n   * Goal of the optimizer: walk the generated template AST tree\n   * and detect sub-trees that are purely static, i.e. parts of\n   * the DOM that never needs to change.\n   *\n   * Once we detect these sub-trees, we can:\n   *\n   * 1. Hoist them into constants, so that we no longer need to\n   *    create fresh nodes for them on each re-render;\n   * 2. Completely skip them in the patching process.\n   */\n\n  function optimize(root, options) {\n    if (!root) {\n      return;\n    }\n\n    isStaticKey = genStaticKeysCached(options.staticKeys || '');\n    isPlatformReservedTag = options.isReservedTag || no; // first pass: mark all non-static nodes.\n\n    markStatic$1(root); // second pass: mark static roots.\n\n    markStaticRoots(root, false);\n  }\n\n  function genStaticKeys$1(keys) {\n    return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' + (keys ? ',' + keys : ''));\n  }\n\n  function markStatic$1(node) {\n    node[\"static\"] = isStatic(node);\n\n    if (node.type === 1) {\n      // do not make component slot content static. this avoids\n      // 1. components not able to mutate slot nodes\n      // 2. static slot content fails for hot-reloading\n      if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {\n        return;\n      }\n\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        var child = node.children[i];\n        markStatic$1(child);\n\n        if (!child[\"static\"]) {\n          node[\"static\"] = false;\n        }\n      }\n\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          var block = node.ifConditions[i$1].block;\n          markStatic$1(block);\n\n          if (!block[\"static\"]) {\n            node[\"static\"] = false;\n          }\n        }\n      }\n    }\n  }\n\n  function markStaticRoots(node, isInFor) {\n    if (node.type === 1) {\n      if (node[\"static\"] || node.once) {\n        node.staticInFor = isInFor;\n      } // For a node to qualify as a static root, it should have children that\n      // are not just static text. Otherwise the cost of hoisting out will\n      // outweigh the benefits and it's better off to just always render it fresh.\n\n\n      if (node[\"static\"] && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {\n        node.staticRoot = true;\n        return;\n      } else {\n        node.staticRoot = false;\n      }\n\n      if (node.children) {\n        for (var i = 0, l = node.children.length; i < l; i++) {\n          markStaticRoots(node.children[i], isInFor || !!node[\"for\"]);\n        }\n      }\n\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          markStaticRoots(node.ifConditions[i$1].block, isInFor);\n        }\n      }\n    }\n  }\n\n  function isStatic(node) {\n    if (node.type === 2) {\n      // expression\n      return false;\n    }\n\n    if (node.type === 3) {\n      // text\n      return true;\n    }\n\n    return !!(node.pre || !node.hasBindings && // no dynamic bindings\n    !node[\"if\"] && !node[\"for\"] && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));\n  }\n\n  function isDirectChildOfTemplateFor(node) {\n    while (node.parent) {\n      node = node.parent;\n\n      if (node.tag !== 'template') {\n        return false;\n      }\n\n      if (node[\"for\"]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /*  */\n\n\n  var fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*(?:[\\w$]+)?\\s*\\(/;\n  var fnInvokeRE = /\\([^)]*?\\);*$/;\n  var simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/; // KeyboardEvent.keyCode aliases\n\n  var keyCodes = {\n    esc: 27,\n    tab: 9,\n    enter: 13,\n    space: 32,\n    up: 38,\n    left: 37,\n    right: 39,\n    down: 40,\n    'delete': [8, 46]\n  }; // KeyboardEvent.key aliases\n\n  var keyNames = {\n    // #7880: IE11 and Edge use `Esc` for Escape key name.\n    esc: ['Esc', 'Escape'],\n    tab: 'Tab',\n    enter: 'Enter',\n    // #9112: IE11 uses `Spacebar` for Space key name.\n    space: [' ', 'Spacebar'],\n    // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n    up: ['Up', 'ArrowUp'],\n    left: ['Left', 'ArrowLeft'],\n    right: ['Right', 'ArrowRight'],\n    down: ['Down', 'ArrowDown'],\n    // #9112: IE11 uses `Del` for Delete key name.\n    'delete': ['Backspace', 'Delete', 'Del']\n  }; // #4868: modifiers that prevent the execution of the listener\n  // need to explicitly return null so that we can determine whether to remove\n  // the listener for .once\n\n  var genGuard = function genGuard(condition) {\n    return \"if(\" + condition + \")return null;\";\n  };\n\n  var modifierCode = {\n    stop: '$event.stopPropagation();',\n    prevent: '$event.preventDefault();',\n    self: genGuard(\"$event.target !== $event.currentTarget\"),\n    ctrl: genGuard(\"!$event.ctrlKey\"),\n    shift: genGuard(\"!$event.shiftKey\"),\n    alt: genGuard(\"!$event.altKey\"),\n    meta: genGuard(\"!$event.metaKey\"),\n    left: genGuard(\"'button' in $event && $event.button !== 0\"),\n    middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n    right: genGuard(\"'button' in $event && $event.button !== 2\")\n  };\n\n  function genHandlers(events, isNative) {\n    var prefix = isNative ? 'nativeOn:' : 'on:';\n    var staticHandlers = \"\";\n    var dynamicHandlers = \"\";\n\n    for (var name in events) {\n      var handlerCode = genHandler(events[name]);\n\n      if (events[name] && events[name].dynamic) {\n        dynamicHandlers += name + \",\" + handlerCode + \",\";\n      } else {\n        staticHandlers += \"\\\"\" + name + \"\\\":\" + handlerCode + \",\";\n      }\n    }\n\n    staticHandlers = \"{\" + staticHandlers.slice(0, -1) + \"}\";\n\n    if (dynamicHandlers) {\n      return prefix + \"_d(\" + staticHandlers + \",[\" + dynamicHandlers.slice(0, -1) + \"])\";\n    } else {\n      return prefix + staticHandlers;\n    }\n  }\n\n  function genHandler(handler) {\n    if (!handler) {\n      return 'function(){}';\n    }\n\n    if (Array.isArray(handler)) {\n      return \"[\" + handler.map(function (handler) {\n        return genHandler(handler);\n      }).join(',') + \"]\";\n    }\n\n    var isMethodPath = simplePathRE.test(handler.value);\n    var isFunctionExpression = fnExpRE.test(handler.value);\n    var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));\n\n    if (!handler.modifiers) {\n      if (isMethodPath || isFunctionExpression) {\n        return handler.value;\n      }\n\n      return \"function($event){\" + (isFunctionInvocation ? \"return \" + handler.value : handler.value) + \"}\"; // inline statement\n    } else {\n      var code = '';\n      var genModifierCode = '';\n      var keys = [];\n\n      for (var key in handler.modifiers) {\n        if (modifierCode[key]) {\n          genModifierCode += modifierCode[key]; // left/right\n\n          if (keyCodes[key]) {\n            keys.push(key);\n          }\n        } else if (key === 'exact') {\n          var modifiers = handler.modifiers;\n          genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {\n            return !modifiers[keyModifier];\n          }).map(function (keyModifier) {\n            return \"$event.\" + keyModifier + \"Key\";\n          }).join('||'));\n        } else {\n          keys.push(key);\n        }\n      }\n\n      if (keys.length) {\n        code += genKeyFilter(keys);\n      } // Make sure modifiers like prevent and stop get executed after key filtering\n\n\n      if (genModifierCode) {\n        code += genModifierCode;\n      }\n\n      var handlerCode = isMethodPath ? \"return \" + handler.value + \"($event)\" : isFunctionExpression ? \"return (\" + handler.value + \")($event)\" : isFunctionInvocation ? \"return \" + handler.value : handler.value;\n      return \"function($event){\" + code + handlerCode + \"}\";\n    }\n  }\n\n  function genKeyFilter(keys) {\n    return (// make sure the key filters only apply to KeyboardEvents\n      // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake\n      // key events that do not have keyCode property...\n      \"if(!$event.type.indexOf('key')&&\" + keys.map(genFilterCode).join('&&') + \")return null;\"\n    );\n  }\n\n  function genFilterCode(key) {\n    var keyVal = parseInt(key, 10);\n\n    if (keyVal) {\n      return \"$event.keyCode!==\" + keyVal;\n    }\n\n    var keyCode = keyCodes[key];\n    var keyName = keyNames[key];\n    return \"_k($event.keyCode,\" + JSON.stringify(key) + \",\" + JSON.stringify(keyCode) + \",\" + \"$event.key,\" + \"\" + JSON.stringify(keyName) + \")\";\n  }\n  /*  */\n\n\n  function on(el, dir) {\n    if (dir.modifiers) {\n      warn(\"v-on without argument does not support modifiers.\");\n    }\n\n    el.wrapListeners = function (code) {\n      return \"_g(\" + code + \",\" + dir.value + \")\";\n    };\n  }\n  /*  */\n\n\n  function bind$1(el, dir) {\n    el.wrapData = function (code) {\n      return \"_b(\" + code + \",'\" + el.tag + \"',\" + dir.value + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\";\n    };\n  }\n  /*  */\n\n\n  var baseDirectives = {\n    on: on,\n    bind: bind$1,\n    cloak: noop\n  };\n  /*  */\n\n  var CodegenState = function CodegenState(options) {\n    this.options = options;\n    this.warn = options.warn || baseWarn;\n    this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n    this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n    this.directives = extend(extend({}, baseDirectives), options.directives);\n    var isReservedTag = options.isReservedTag || no;\n\n    this.maybeComponent = function (el) {\n      return !!el.component || !isReservedTag(el.tag);\n    };\n\n    this.onceId = 0;\n    this.staticRenderFns = [];\n    this.pre = false;\n  };\n\n  function generate(ast, options) {\n    var state = new CodegenState(options);\n    var code = ast ? genElement(ast, state) : '_c(\"div\")';\n    return {\n      render: \"with(this){return \" + code + \"}\",\n      staticRenderFns: state.staticRenderFns\n    };\n  }\n\n  function genElement(el, state) {\n    if (el.parent) {\n      el.pre = el.pre || el.parent.pre;\n    }\n\n    if (el.staticRoot && !el.staticProcessed) {\n      return genStatic(el, state);\n    } else if (el.once && !el.onceProcessed) {\n      return genOnce(el, state);\n    } else if (el[\"for\"] && !el.forProcessed) {\n      return genFor(el, state);\n    } else if (el[\"if\"] && !el.ifProcessed) {\n      return genIf(el, state);\n    } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n      return genChildren(el, state) || 'void 0';\n    } else if (el.tag === 'slot') {\n      return genSlot(el, state);\n    } else {\n      // component or element\n      var code;\n\n      if (el.component) {\n        code = genComponent(el.component, el, state);\n      } else {\n        var data;\n\n        if (!el.plain || el.pre && state.maybeComponent(el)) {\n          data = genData$2(el, state);\n        }\n\n        var children = el.inlineTemplate ? null : genChildren(el, state, true);\n        code = \"_c('\" + el.tag + \"'\" + (data ? \",\" + data : '') + (children ? \",\" + children : '') + \")\";\n      } // module transforms\n\n\n      for (var i = 0; i < state.transforms.length; i++) {\n        code = state.transforms[i](el, code);\n      }\n\n      return code;\n    }\n  } // hoist static sub-trees out\n\n\n  function genStatic(el, state) {\n    el.staticProcessed = true; // Some elements (templates) need to behave differently inside of a v-pre\n    // node.  All pre nodes are static roots, so we can use this as a location to\n    // wrap a state change and reset it upon exiting the pre node.\n\n    var originalPreState = state.pre;\n\n    if (el.pre) {\n      state.pre = el.pre;\n    }\n\n    state.staticRenderFns.push(\"with(this){return \" + genElement(el, state) + \"}\");\n    state.pre = originalPreState;\n    return \"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\";\n  } // v-once\n\n\n  function genOnce(el, state) {\n    el.onceProcessed = true;\n\n    if (el[\"if\"] && !el.ifProcessed) {\n      return genIf(el, state);\n    } else if (el.staticInFor) {\n      var key = '';\n      var parent = el.parent;\n\n      while (parent) {\n        if (parent[\"for\"]) {\n          key = parent.key;\n          break;\n        }\n\n        parent = parent.parent;\n      }\n\n      if (!key) {\n        state.warn(\"v-once can only be used inside v-for that is keyed. \", el.rawAttrsMap['v-once']);\n        return genElement(el, state);\n      }\n\n      return \"_o(\" + genElement(el, state) + \",\" + state.onceId++ + \",\" + key + \")\";\n    } else {\n      return genStatic(el, state);\n    }\n  }\n\n  function genIf(el, state, altGen, altEmpty) {\n    el.ifProcessed = true; // avoid recursion\n\n    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);\n  }\n\n  function genIfConditions(conditions, state, altGen, altEmpty) {\n    if (!conditions.length) {\n      return altEmpty || '_e()';\n    }\n\n    var condition = conditions.shift();\n\n    if (condition.exp) {\n      return \"(\" + condition.exp + \")?\" + genTernaryExp(condition.block) + \":\" + genIfConditions(conditions, state, altGen, altEmpty);\n    } else {\n      return \"\" + genTernaryExp(condition.block);\n    } // v-if with v-once should generate code like (a)?_m(0):_m(1)\n\n\n    function genTernaryExp(el) {\n      return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);\n    }\n  }\n\n  function genFor(el, state, altGen, altHelper) {\n    var exp = el[\"for\"];\n    var alias = el.alias;\n    var iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n    var iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n\n    if (state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {\n      state.warn(\"<\" + el.tag + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" + \"v-for should have explicit keys. \" + \"See https://vuejs.org/guide/list.html#key for more info.\", el.rawAttrsMap['v-for'], true\n      /* tip */\n      );\n    }\n\n    el.forProcessed = true; // avoid recursion\n\n    return (altHelper || '_l') + \"((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + (altGen || genElement)(el, state) + '})';\n  }\n\n  function genData$2(el, state) {\n    var data = '{'; // directives first.\n    // directives may mutate the el's other properties before they are generated.\n\n    var dirs = genDirectives(el, state);\n\n    if (dirs) {\n      data += dirs + ',';\n    } // key\n\n\n    if (el.key) {\n      data += \"key:\" + el.key + \",\";\n    } // ref\n\n\n    if (el.ref) {\n      data += \"ref:\" + el.ref + \",\";\n    }\n\n    if (el.refInFor) {\n      data += \"refInFor:true,\";\n    } // pre\n\n\n    if (el.pre) {\n      data += \"pre:true,\";\n    } // record original tag name for components using \"is\" attribute\n\n\n    if (el.component) {\n      data += \"tag:\\\"\" + el.tag + \"\\\",\";\n    } // module data generation functions\n\n\n    for (var i = 0; i < state.dataGenFns.length; i++) {\n      data += state.dataGenFns[i](el);\n    } // attributes\n\n\n    if (el.attrs) {\n      data += \"attrs:\" + genProps(el.attrs) + \",\";\n    } // DOM props\n\n\n    if (el.props) {\n      data += \"domProps:\" + genProps(el.props) + \",\";\n    } // event handlers\n\n\n    if (el.events) {\n      data += genHandlers(el.events, false) + \",\";\n    }\n\n    if (el.nativeEvents) {\n      data += genHandlers(el.nativeEvents, true) + \",\";\n    } // slot target\n    // only for non-scoped slots\n\n\n    if (el.slotTarget && !el.slotScope) {\n      data += \"slot:\" + el.slotTarget + \",\";\n    } // scoped slots\n\n\n    if (el.scopedSlots) {\n      data += genScopedSlots(el, el.scopedSlots, state) + \",\";\n    } // component v-model\n\n\n    if (el.model) {\n      data += \"model:{value:\" + el.model.value + \",callback:\" + el.model.callback + \",expression:\" + el.model.expression + \"},\";\n    } // inline-template\n\n\n    if (el.inlineTemplate) {\n      var inlineTemplate = genInlineTemplate(el, state);\n\n      if (inlineTemplate) {\n        data += inlineTemplate + \",\";\n      }\n    }\n\n    data = data.replace(/,$/, '') + '}'; // v-bind dynamic argument wrap\n    // v-bind with dynamic arguments must be applied using the same v-bind object\n    // merge helper so that class/style/mustUseProp attrs are handled correctly.\n\n    if (el.dynamicAttrs) {\n      data = \"_b(\" + data + \",\\\"\" + el.tag + \"\\\",\" + genProps(el.dynamicAttrs) + \")\";\n    } // v-bind data wrap\n\n\n    if (el.wrapData) {\n      data = el.wrapData(data);\n    } // v-on data wrap\n\n\n    if (el.wrapListeners) {\n      data = el.wrapListeners(data);\n    }\n\n    return data;\n  }\n\n  function genDirectives(el, state) {\n    var dirs = el.directives;\n\n    if (!dirs) {\n      return;\n    }\n\n    var res = 'directives:[';\n    var hasRuntime = false;\n    var i, l, dir, needRuntime;\n\n    for (i = 0, l = dirs.length; i < l; i++) {\n      dir = dirs[i];\n      needRuntime = true;\n      var gen = state.directives[dir.name];\n\n      if (gen) {\n        // compile-time directive that manipulates AST.\n        // returns true if it also needs a runtime counterpart.\n        needRuntime = !!gen(el, dir, state.warn);\n      }\n\n      if (needRuntime) {\n        hasRuntime = true;\n        res += \"{name:\\\"\" + dir.name + \"\\\",rawName:\\\"\" + dir.rawName + \"\\\"\" + (dir.value ? \",value:(\" + dir.value + \"),expression:\" + JSON.stringify(dir.value) : '') + (dir.arg ? \",arg:\" + (dir.isDynamicArg ? dir.arg : \"\\\"\" + dir.arg + \"\\\"\") : '') + (dir.modifiers ? \",modifiers:\" + JSON.stringify(dir.modifiers) : '') + \"},\";\n      }\n    }\n\n    if (hasRuntime) {\n      return res.slice(0, -1) + ']';\n    }\n  }\n\n  function genInlineTemplate(el, state) {\n    var ast = el.children[0];\n\n    if (el.children.length !== 1 || ast.type !== 1) {\n      state.warn('Inline-template components must have exactly one child element.', {\n        start: el.start\n      });\n    }\n\n    if (ast && ast.type === 1) {\n      var inlineRenderFns = generate(ast, state.options);\n      return \"inlineTemplate:{render:function(){\" + inlineRenderFns.render + \"},staticRenderFns:[\" + inlineRenderFns.staticRenderFns.map(function (code) {\n        return \"function(){\" + code + \"}\";\n      }).join(',') + \"]}\";\n    }\n  }\n\n  function genScopedSlots(el, slots, state) {\n    // by default scoped slots are considered \"stable\", this allows child\n    // components with only scoped slots to skip forced updates from parent.\n    // but in some cases we have to bail-out of this optimization\n    // for example if the slot contains dynamic names, has v-if or v-for on them...\n    var needsForceUpdate = el[\"for\"] || Object.keys(slots).some(function (key) {\n      var slot = slots[key];\n      return slot.slotTargetDynamic || slot[\"if\"] || slot[\"for\"] || containsSlotChild(slot) // is passing down slot from parent which may be dynamic\n      ;\n    }); // #9534: if a component with scoped slots is inside a conditional branch,\n    // it's possible for the same component to be reused but with different\n    // compiled slot content. To avoid that, we generate a unique key based on\n    // the generated code of all the slot contents.\n\n    var needsKey = !!el[\"if\"]; // OR when it is inside another scoped slot or v-for (the reactivity may be\n    // disconnected due to the intermediate scope variable)\n    // #9438, #9506\n    // TODO: this can be further optimized by properly analyzing in-scope bindings\n    // and skip force updating ones that do not actually use scope variables.\n\n    if (!needsForceUpdate) {\n      var parent = el.parent;\n\n      while (parent) {\n        if (parent.slotScope && parent.slotScope !== emptySlotScopeToken || parent[\"for\"]) {\n          needsForceUpdate = true;\n          break;\n        }\n\n        if (parent[\"if\"]) {\n          needsKey = true;\n        }\n\n        parent = parent.parent;\n      }\n    }\n\n    var generatedSlots = Object.keys(slots).map(function (key) {\n      return genScopedSlot(slots[key], state);\n    }).join(',');\n    return \"scopedSlots:_u([\" + generatedSlots + \"]\" + (needsForceUpdate ? \",null,true\" : \"\") + (!needsForceUpdate && needsKey ? \",null,false,\" + hash(generatedSlots) : \"\") + \")\";\n  }\n\n  function hash(str) {\n    var hash = 5381;\n    var i = str.length;\n\n    while (i) {\n      hash = hash * 33 ^ str.charCodeAt(--i);\n    }\n\n    return hash >>> 0;\n  }\n\n  function containsSlotChild(el) {\n    if (el.type === 1) {\n      if (el.tag === 'slot') {\n        return true;\n      }\n\n      return el.children.some(containsSlotChild);\n    }\n\n    return false;\n  }\n\n  function genScopedSlot(el, state) {\n    var isLegacySyntax = el.attrsMap['slot-scope'];\n\n    if (el[\"if\"] && !el.ifProcessed && !isLegacySyntax) {\n      return genIf(el, state, genScopedSlot, \"null\");\n    }\n\n    if (el[\"for\"] && !el.forProcessed) {\n      return genFor(el, state, genScopedSlot);\n    }\n\n    var slotScope = el.slotScope === emptySlotScopeToken ? \"\" : String(el.slotScope);\n    var fn = \"function(\" + slotScope + \"){\" + \"return \" + (el.tag === 'template' ? el[\"if\"] && isLegacySyntax ? \"(\" + el[\"if\"] + \")?\" + (genChildren(el, state) || 'undefined') + \":undefined\" : genChildren(el, state) || 'undefined' : genElement(el, state)) + \"}\"; // reverse proxy v-slot without scope on this.$slots\n\n    var reverseProxy = slotScope ? \"\" : \",proxy:true\";\n    return \"{key:\" + (el.slotTarget || \"\\\"default\\\"\") + \",fn:\" + fn + reverseProxy + \"}\";\n  }\n\n  function genChildren(el, state, checkSkip, altGenElement, altGenNode) {\n    var children = el.children;\n\n    if (children.length) {\n      var el$1 = children[0]; // optimize single v-for\n\n      if (children.length === 1 && el$1[\"for\"] && el$1.tag !== 'template' && el$1.tag !== 'slot') {\n        var normalizationType = checkSkip ? state.maybeComponent(el$1) ? \",1\" : \",0\" : \"\";\n        return \"\" + (altGenElement || genElement)(el$1, state) + normalizationType;\n      }\n\n      var normalizationType$1 = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;\n      var gen = altGenNode || genNode;\n      return \"[\" + children.map(function (c) {\n        return gen(c, state);\n      }).join(',') + \"]\" + (normalizationType$1 ? \",\" + normalizationType$1 : '');\n    }\n  } // determine the normalization needed for the children array.\n  // 0: no normalization needed\n  // 1: simple normalization needed (possible 1-level deep nested array)\n  // 2: full normalization needed\n\n\n  function getNormalizationType(children, maybeComponent) {\n    var res = 0;\n\n    for (var i = 0; i < children.length; i++) {\n      var el = children[i];\n\n      if (el.type !== 1) {\n        continue;\n      }\n\n      if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {\n        return needsNormalization(c.block);\n      })) {\n        res = 2;\n        break;\n      }\n\n      if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {\n        return maybeComponent(c.block);\n      })) {\n        res = 1;\n      }\n    }\n\n    return res;\n  }\n\n  function needsNormalization(el) {\n    return el[\"for\"] !== undefined || el.tag === 'template' || el.tag === 'slot';\n  }\n\n  function genNode(node, state) {\n    if (node.type === 1) {\n      return genElement(node, state);\n    } else if (node.type === 3 && node.isComment) {\n      return genComment(node);\n    } else {\n      return genText(node);\n    }\n  }\n\n  function genText(text) {\n    return \"_v(\" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\";\n  }\n\n  function genComment(comment) {\n    return \"_e(\" + JSON.stringify(comment.text) + \")\";\n  }\n\n  function genSlot(el, state) {\n    var slotName = el.slotName || '\"default\"';\n    var children = genChildren(el, state);\n    var res = \"_t(\" + slotName + (children ? \",\" + children : '');\n    var attrs = el.attrs || el.dynamicAttrs ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) {\n      return {\n        // slot props are camelized\n        name: camelize(attr.name),\n        value: attr.value,\n        dynamic: attr.dynamic\n      };\n    })) : null;\n    var bind$$1 = el.attrsMap['v-bind'];\n\n    if ((attrs || bind$$1) && !children) {\n      res += \",null\";\n    }\n\n    if (attrs) {\n      res += \",\" + attrs;\n    }\n\n    if (bind$$1) {\n      res += (attrs ? '' : ',null') + \",\" + bind$$1;\n    }\n\n    return res + ')';\n  } // componentName is el.component, take it as argument to shun flow's pessimistic refinement\n\n\n  function genComponent(componentName, el, state) {\n    var children = el.inlineTemplate ? null : genChildren(el, state, true);\n    return \"_c(\" + componentName + \",\" + genData$2(el, state) + (children ? \",\" + children : '') + \")\";\n  }\n\n  function genProps(props) {\n    var staticProps = \"\";\n    var dynamicProps = \"\";\n\n    for (var i = 0; i < props.length; i++) {\n      var prop = props[i];\n      var value = transformSpecialNewlines(prop.value);\n\n      if (prop.dynamic) {\n        dynamicProps += prop.name + \",\" + value + \",\";\n      } else {\n        staticProps += \"\\\"\" + prop.name + \"\\\":\" + value + \",\";\n      }\n    }\n\n    staticProps = \"{\" + staticProps.slice(0, -1) + \"}\";\n\n    if (dynamicProps) {\n      return \"_d(\" + staticProps + \",[\" + dynamicProps.slice(0, -1) + \"])\";\n    } else {\n      return staticProps;\n    }\n  } // #3895, #4268\n\n\n  function transformSpecialNewlines(text) {\n    return text.replace(/\\u2028/g, \"\\\\u2028\").replace(/\\u2029/g, \"\\\\u2029\");\n  }\n  /*  */\n  // these keywords should not appear inside expressions, but operators like\n  // typeof, instanceof and in are allowed\n\n\n  var prohibitedKeywordRE = new RegExp('\\\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\\\b|\\\\b') + '\\\\b'); // these unary operators should not be used as property/method names\n\n  var unaryOperatorsRE = new RegExp('\\\\b' + 'delete,typeof,void'.split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)'); // strip strings in expressions\n\n  var stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g; // detect problematic expressions in a template\n\n  function detectErrors(ast, warn) {\n    if (ast) {\n      checkNode(ast, warn);\n    }\n  }\n\n  function checkNode(node, warn) {\n    if (node.type === 1) {\n      for (var name in node.attrsMap) {\n        if (dirRE.test(name)) {\n          var value = node.attrsMap[name];\n\n          if (value) {\n            var range = node.rawAttrsMap[name];\n\n            if (name === 'v-for') {\n              checkFor(node, \"v-for=\\\"\" + value + \"\\\"\", warn, range);\n            } else if (onRE.test(name)) {\n              checkEvent(value, name + \"=\\\"\" + value + \"\\\"\", warn, range);\n            } else {\n              checkExpression(value, name + \"=\\\"\" + value + \"\\\"\", warn, range);\n            }\n          }\n        }\n      }\n\n      if (node.children) {\n        for (var i = 0; i < node.children.length; i++) {\n          checkNode(node.children[i], warn);\n        }\n      }\n    } else if (node.type === 2) {\n      checkExpression(node.expression, node.text, warn, node);\n    }\n  }\n\n  function checkEvent(exp, text, warn, range) {\n    var stipped = exp.replace(stripStringRE, '');\n    var keywordMatch = stipped.match(unaryOperatorsRE);\n\n    if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n      warn(\"avoid using JavaScript unary operator as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\" in expression \" + text.trim(), range);\n    }\n\n    checkExpression(exp, text, warn, range);\n  }\n\n  function checkFor(node, text, warn, range) {\n    checkExpression(node[\"for\"] || '', text, warn, range);\n    checkIdentifier(node.alias, 'v-for alias', text, warn, range);\n    checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);\n    checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);\n  }\n\n  function checkIdentifier(ident, type, text, warn, range) {\n    if (typeof ident === 'string') {\n      try {\n        new Function(\"var \" + ident + \"=_\");\n      } catch (e) {\n        warn(\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + text.trim(), range);\n      }\n    }\n  }\n\n  function checkExpression(exp, text, warn, range) {\n    try {\n      new Function(\"return \" + exp);\n    } catch (e) {\n      var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n\n      if (keywordMatch) {\n        warn(\"avoid using JavaScript keyword as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\"\\n  Raw expression: \" + text.trim(), range);\n      } else {\n        warn(\"invalid expression: \" + e.message + \" in\\n\\n\" + \"    \" + exp + \"\\n\\n\" + \"  Raw expression: \" + text.trim() + \"\\n\", range);\n      }\n    }\n  }\n  /*  */\n\n\n  var range = 2;\n\n  function generateCodeFrame(source, start, end) {\n    if (start === void 0) start = 0;\n    if (end === void 0) end = source.length;\n    var lines = source.split(/\\r?\\n/);\n    var count = 0;\n    var res = [];\n\n    for (var i = 0; i < lines.length; i++) {\n      count += lines[i].length + 1;\n\n      if (count >= start) {\n        for (var j = i - range; j <= i + range || end > count; j++) {\n          if (j < 0 || j >= lines.length) {\n            continue;\n          }\n\n          res.push(\"\" + (j + 1) + repeat$1(\" \", 3 - String(j + 1).length) + \"|  \" + lines[j]);\n          var lineLength = lines[j].length;\n\n          if (j === i) {\n            // push underline\n            var pad = start - (count - lineLength) + 1;\n            var length = end > count ? lineLength - pad : end - start;\n            res.push(\"   |  \" + repeat$1(\" \", pad) + repeat$1(\"^\", length));\n          } else if (j > i) {\n            if (end > count) {\n              var length$1 = Math.min(end - count, lineLength);\n              res.push(\"   |  \" + repeat$1(\"^\", length$1));\n            }\n\n            count += lineLength + 1;\n          }\n        }\n\n        break;\n      }\n    }\n\n    return res.join('\\n');\n  }\n\n  function repeat$1(str, n) {\n    var result = '';\n\n    if (n > 0) {\n      while (true) {\n        // eslint-disable-line\n        if (n & 1) {\n          result += str;\n        }\n\n        n >>>= 1;\n\n        if (n <= 0) {\n          break;\n        }\n\n        str += str;\n      }\n    }\n\n    return result;\n  }\n  /*  */\n\n\n  function createFunction(code, errors) {\n    try {\n      return new Function(code);\n    } catch (err) {\n      errors.push({\n        err: err,\n        code: code\n      });\n      return noop;\n    }\n  }\n\n  function createCompileToFunctionFn(compile) {\n    var cache = Object.create(null);\n    return function compileToFunctions(template, options, vm) {\n      options = extend({}, options);\n      var warn$$1 = options.warn || warn;\n      delete options.warn;\n      /* istanbul ignore if */\n\n      {\n        // detect possible CSP restriction\n        try {\n          new Function('return 1');\n        } catch (e) {\n          if (e.toString().match(/unsafe-eval|CSP/)) {\n            warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');\n          }\n        }\n      } // check cache\n\n      var key = options.delimiters ? String(options.delimiters) + template : template;\n\n      if (cache[key]) {\n        return cache[key];\n      } // compile\n\n\n      var compiled = compile(template, options); // check compilation errors/tips\n\n      {\n        if (compiled.errors && compiled.errors.length) {\n          if (options.outputSourceRange) {\n            compiled.errors.forEach(function (e) {\n              warn$$1(\"Error compiling template:\\n\\n\" + e.msg + \"\\n\\n\" + generateCodeFrame(template, e.start, e.end), vm);\n            });\n          } else {\n            warn$$1(\"Error compiling template:\\n\\n\" + template + \"\\n\\n\" + compiled.errors.map(function (e) {\n              return \"- \" + e;\n            }).join('\\n') + '\\n', vm);\n          }\n        }\n\n        if (compiled.tips && compiled.tips.length) {\n          if (options.outputSourceRange) {\n            compiled.tips.forEach(function (e) {\n              return tip(e.msg, vm);\n            });\n          } else {\n            compiled.tips.forEach(function (msg) {\n              return tip(msg, vm);\n            });\n          }\n        }\n      } // turn code into functions\n\n      var res = {};\n      var fnGenErrors = [];\n      res.render = createFunction(compiled.render, fnGenErrors);\n      res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n        return createFunction(code, fnGenErrors);\n      }); // check function generation errors.\n      // this should only happen if there is a bug in the compiler itself.\n      // mostly for codegen development use\n\n      /* istanbul ignore if */\n\n      {\n        if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n          warn$$1(\"Failed to generate render function:\\n\\n\" + fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n            return err.toString() + \" in\\n\\n\" + code + \"\\n\";\n          }).join('\\n'), vm);\n        }\n      }\n      return cache[key] = res;\n    };\n  }\n  /*  */\n\n\n  function createCompilerCreator(baseCompile) {\n    return function createCompiler(baseOptions) {\n      function compile(template, options) {\n        var finalOptions = Object.create(baseOptions);\n        var errors = [];\n        var tips = [];\n\n        var warn = function warn(msg, range, tip) {\n          (tip ? tips : errors).push(msg);\n        };\n\n        if (options) {\n          if (options.outputSourceRange) {\n            // $flow-disable-line\n            var leadingSpaceLength = template.match(/^\\s*/)[0].length;\n\n            warn = function warn(msg, range, tip) {\n              var data = {\n                msg: msg\n              };\n\n              if (range) {\n                if (range.start != null) {\n                  data.start = range.start + leadingSpaceLength;\n                }\n\n                if (range.end != null) {\n                  data.end = range.end + leadingSpaceLength;\n                }\n              }\n\n              (tip ? tips : errors).push(data);\n            };\n          } // merge custom modules\n\n\n          if (options.modules) {\n            finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n          } // merge custom directives\n\n\n          if (options.directives) {\n            finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);\n          } // copy other options\n\n\n          for (var key in options) {\n            if (key !== 'modules' && key !== 'directives') {\n              finalOptions[key] = options[key];\n            }\n          }\n        }\n\n        finalOptions.warn = warn;\n        var compiled = baseCompile(template.trim(), finalOptions);\n        {\n          detectErrors(compiled.ast, warn);\n        }\n        compiled.errors = errors;\n        compiled.tips = tips;\n        return compiled;\n      }\n\n      return {\n        compile: compile,\n        compileToFunctions: createCompileToFunctionFn(compile)\n      };\n    };\n  }\n  /*  */\n  // `createCompilerCreator` allows creating compilers that use alternative\n  // parser/optimizer/codegen, e.g the SSR optimizing compiler.\n  // Here we just export a default compiler using the default parts.\n\n\n  var createCompiler = createCompilerCreator(function baseCompile(template, options) {\n    var ast = parse(template.trim(), options);\n\n    if (options.optimize !== false) {\n      optimize(ast, options);\n    }\n\n    var code = generate(ast, options);\n    return {\n      ast: ast,\n      render: code.render,\n      staticRenderFns: code.staticRenderFns\n    };\n  });\n  /*  */\n\n  var ref$1 = createCompiler(baseOptions);\n  var compile = ref$1.compile;\n  var compileToFunctions = ref$1.compileToFunctions;\n  /*  */\n  // check whether current browser encodes a char inside attribute values\n\n  var div;\n\n  function getShouldDecode(href) {\n    div = div || document.createElement('div');\n    div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n    return div.innerHTML.indexOf('&#10;') > 0;\n  } // #3663: IE encodes newlines inside attribute values while other browsers don't\n\n\n  var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false; // #6828: chrome encodes content in a[href]\n\n  var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n  /*  */\n\n  var idToTemplate = cached(function (id) {\n    var el = query(id);\n    return el && el.innerHTML;\n  });\n  var mount = Vue.prototype.$mount;\n\n  Vue.prototype.$mount = function (el, hydrating) {\n    el = el && query(el);\n    /* istanbul ignore if */\n\n    if (el === document.body || el === document.documentElement) {\n      warn(\"Do not mount Vue to <html> or <body> - mount to normal elements instead.\");\n      return this;\n    }\n\n    var options = this.$options; // resolve template/el and convert to render function\n\n    if (!options.render) {\n      var template = options.template;\n\n      if (template) {\n        if (typeof template === 'string') {\n          if (template.charAt(0) === '#') {\n            template = idToTemplate(template);\n            /* istanbul ignore if */\n\n            if (!template) {\n              warn(\"Template element not found or is empty: \" + options.template, this);\n            }\n          }\n        } else if (template.nodeType) {\n          template = template.innerHTML;\n        } else {\n          {\n            warn('invalid template option:' + template, this);\n          }\n          return this;\n        }\n      } else if (el) {\n        template = getOuterHTML(el);\n      }\n\n      if (template) {\n        /* istanbul ignore if */\n        if (config.performance && mark) {\n          mark('compile');\n        }\n\n        var ref = compileToFunctions(template, {\n          outputSourceRange: \"development\" !== 'production',\n          shouldDecodeNewlines: shouldDecodeNewlines,\n          shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n          delimiters: options.delimiters,\n          comments: options.comments\n        }, this);\n        var render = ref.render;\n        var staticRenderFns = ref.staticRenderFns;\n        options.render = render;\n        options.staticRenderFns = staticRenderFns;\n        /* istanbul ignore if */\n\n        if (config.performance && mark) {\n          mark('compile end');\n          measure(\"vue \" + this._name + \" compile\", 'compile', 'compile end');\n        }\n      }\n    }\n\n    return mount.call(this, el, hydrating);\n  };\n  /**\n   * Get outerHTML of elements, taking care\n   * of SVG elements in IE as well.\n   */\n\n\n  function getOuterHTML(el) {\n    if (el.outerHTML) {\n      return el.outerHTML;\n    } else {\n      var container = document.createElement('div');\n      container.appendChild(el.cloneNode(true));\n      return container.innerHTML;\n    }\n  }\n\n  Vue.compile = compileToFunctions;\n  return Vue;\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack-stream/node_modules/webpack/buildin/global.js */ \"./node_modules/webpack-stream/node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))\n\n//# sourceURL=webpack:///./node_modules/vue/dist/vue.js?");

/***/ }),

/***/ "./node_modules/webpack-stream/node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar g; // This works in non-strict mode\n\ng = function () {\n  return this;\n}();\n\ntry {\n  // This works if eval is allowed (see CSP)\n  g = g || new Function(\"return this\")();\n} catch (e) {\n  // This works if the window reference is available\n  if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n} // g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\n\nmodule.exports = g;\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./node_modules/webpack-stream/node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function (module) {\n  if (!module.webpackPolyfill) {\n    module.deprecate = function () {};\n\n    module.paths = []; // module.parent = undefined by default\n\n    if (!module.children) module.children = [];\n    Object.defineProperty(module, \"loaded\", {\n      enumerable: true,\n      get: function get() {\n        return module.l;\n      }\n    });\n    Object.defineProperty(module, \"id\", {\n      enumerable: true,\n      get: function get() {\n        return module.i;\n      }\n    });\n    module.webpackPolyfill = 1;\n  }\n\n  return module;\n};\n\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ }),

/***/ "./src/js/components/inputs.vue":
/*!**************************************!*\
  !*** ./src/js/components/inputs.vue ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _inputs_vue_vue_type_template_id_028ecd15___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./inputs.vue?vue&type=template&id=028ecd15& */ \"./src/js/components/inputs.vue?vue&type=template&id=028ecd15&\");\n/* harmony import */ var _inputs_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./inputs.vue?vue&type=script&lang=js& */ \"./src/js/components/inputs.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ \"./node_modules/vue-loader/lib/runtime/componentNormalizer.js\");\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  _inputs_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _inputs_vue_vue_type_template_id_028ecd15___WEBPACK_IMPORTED_MODULE_0__[\"render\"],\n  _inputs_vue_vue_type_template_id_028ecd15___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"],\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"src/js/components/inputs.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);\n\n//# sourceURL=webpack:///./src/js/components/inputs.vue?");

/***/ }),

/***/ "./src/js/components/inputs.vue?vue&type=script&lang=js&":
/*!***************************************************************!*\
  !*** ./src/js/components/inputs.vue?vue&type=script&lang=js& ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_ref_1_node_modules_ify_loader_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_inputs_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib??ref--1!../../../node_modules/ify-loader!../../../node_modules/vue-loader/lib??vue-loader-options!./inputs.vue?vue&type=script&lang=js& */ \"./node_modules/babel-loader/lib/index.js?!./node_modules/ify-loader/index.js!./node_modules/vue-loader/lib/index.js?!./src/js/components/inputs.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_babel_loader_lib_index_js_ref_1_node_modules_ify_loader_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_inputs_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); \n\n//# sourceURL=webpack:///./src/js/components/inputs.vue?");

/***/ }),

/***/ "./src/js/components/inputs.vue?vue&type=template&id=028ecd15&":
/*!*********************************************************************!*\
  !*** ./src/js/components/inputs.vue?vue&type=template&id=028ecd15& ***!
  \*********************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_inputs_vue_vue_type_template_id_028ecd15___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib??vue-loader-options!./inputs.vue?vue&type=template&id=028ecd15& */ \"./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/inputs.vue?vue&type=template&id=028ecd15&\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_inputs_vue_vue_type_template_id_028ecd15___WEBPACK_IMPORTED_MODULE_0__[\"render\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_inputs_vue_vue_type_template_id_028ecd15___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"]; });\n\n\n\n//# sourceURL=webpack:///./src/js/components/inputs.vue?");

/***/ }),

/***/ "./src/js/components/plotly.vue":
/*!**************************************!*\
  !*** ./src/js/components/plotly.vue ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _plotly_vue_vue_type_template_id_4423324c___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plotly.vue?vue&type=template&id=4423324c& */ \"./src/js/components/plotly.vue?vue&type=template&id=4423324c&\");\n/* harmony import */ var _plotly_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plotly.vue?vue&type=script&lang=js& */ \"./src/js/components/plotly.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ \"./node_modules/vue-loader/lib/runtime/componentNormalizer.js\");\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  _plotly_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _plotly_vue_vue_type_template_id_4423324c___WEBPACK_IMPORTED_MODULE_0__[\"render\"],\n  _plotly_vue_vue_type_template_id_4423324c___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"],\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"src/js/components/plotly.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);\n\n//# sourceURL=webpack:///./src/js/components/plotly.vue?");

/***/ }),

/***/ "./src/js/components/plotly.vue?vue&type=script&lang=js&":
/*!***************************************************************!*\
  !*** ./src/js/components/plotly.vue?vue&type=script&lang=js& ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_ref_1_node_modules_ify_loader_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_plotly_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib??ref--1!../../../node_modules/ify-loader!../../../node_modules/vue-loader/lib??vue-loader-options!./plotly.vue?vue&type=script&lang=js& */ \"./node_modules/babel-loader/lib/index.js?!./node_modules/ify-loader/index.js!./node_modules/vue-loader/lib/index.js?!./src/js/components/plotly.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_babel_loader_lib_index_js_ref_1_node_modules_ify_loader_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_plotly_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); \n\n//# sourceURL=webpack:///./src/js/components/plotly.vue?");

/***/ }),

/***/ "./src/js/components/plotly.vue?vue&type=template&id=4423324c&":
/*!*********************************************************************!*\
  !*** ./src/js/components/plotly.vue?vue&type=template&id=4423324c& ***!
  \*********************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_plotly_vue_vue_type_template_id_4423324c___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib??vue-loader-options!./plotly.vue?vue&type=template&id=4423324c& */ \"./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/plotly.vue?vue&type=template&id=4423324c&\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_plotly_vue_vue_type_template_id_4423324c___WEBPACK_IMPORTED_MODULE_0__[\"render\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_plotly_vue_vue_type_template_id_4423324c___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"]; });\n\n\n\n//# sourceURL=webpack:///./src/js/components/plotly.vue?");

/***/ }),

/***/ "./src/js/components/polling.js":
/*!**************************************!*\
  !*** ./src/js/components/polling.js ***!
  \**************************************/
/*! exports provided: stop, start */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stop\", function() { return stop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"start\", function() { return start; });\nvar stop = function stop(id) {\n  clearInterval(id);\n};\nvar start = function start(func) {\n  return setInterval(func, 1000);\n};\n\n//# sourceURL=webpack:///./src/js/components/polling.js?");

/***/ }),

/***/ "./src/js/components/results.vue":
/*!***************************************!*\
  !*** ./src/js/components/results.vue ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _results_vue_vue_type_template_id_0fbc10fa___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./results.vue?vue&type=template&id=0fbc10fa& */ \"./src/js/components/results.vue?vue&type=template&id=0fbc10fa&\");\n/* harmony import */ var _results_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./results.vue?vue&type=script&lang=js& */ \"./src/js/components/results.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ \"./node_modules/vue-loader/lib/runtime/componentNormalizer.js\");\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  _results_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _results_vue_vue_type_template_id_0fbc10fa___WEBPACK_IMPORTED_MODULE_0__[\"render\"],\n  _results_vue_vue_type_template_id_0fbc10fa___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"],\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"src/js/components/results.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);\n\n//# sourceURL=webpack:///./src/js/components/results.vue?");

/***/ }),

/***/ "./src/js/components/results.vue?vue&type=script&lang=js&":
/*!****************************************************************!*\
  !*** ./src/js/components/results.vue?vue&type=script&lang=js& ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_ref_1_node_modules_ify_loader_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_results_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib??ref--1!../../../node_modules/ify-loader!../../../node_modules/vue-loader/lib??vue-loader-options!./results.vue?vue&type=script&lang=js& */ \"./node_modules/babel-loader/lib/index.js?!./node_modules/ify-loader/index.js!./node_modules/vue-loader/lib/index.js?!./src/js/components/results.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_babel_loader_lib_index_js_ref_1_node_modules_ify_loader_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_results_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); \n\n//# sourceURL=webpack:///./src/js/components/results.vue?");

/***/ }),

/***/ "./src/js/components/results.vue?vue&type=template&id=0fbc10fa&":
/*!**********************************************************************!*\
  !*** ./src/js/components/results.vue?vue&type=template&id=0fbc10fa& ***!
  \**********************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_results_vue_vue_type_template_id_0fbc10fa___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib??vue-loader-options!./results.vue?vue&type=template&id=0fbc10fa& */ \"./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/results.vue?vue&type=template&id=0fbc10fa&\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_results_vue_vue_type_template_id_0fbc10fa___WEBPACK_IMPORTED_MODULE_0__[\"render\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_results_vue_vue_type_template_id_0fbc10fa___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"]; });\n\n\n\n//# sourceURL=webpack:///./src/js/components/results.vue?");

/***/ }),

/***/ "./src/js/components/runner.vue":
/*!**************************************!*\
  !*** ./src/js/components/runner.vue ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _runner_vue_vue_type_template_id_4b4e0edc___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./runner.vue?vue&type=template&id=4b4e0edc& */ \"./src/js/components/runner.vue?vue&type=template&id=4b4e0edc&\");\n/* harmony import */ var _runner_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./runner.vue?vue&type=script&lang=js& */ \"./src/js/components/runner.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ \"./node_modules/vue-loader/lib/runtime/componentNormalizer.js\");\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  _runner_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _runner_vue_vue_type_template_id_4b4e0edc___WEBPACK_IMPORTED_MODULE_0__[\"render\"],\n  _runner_vue_vue_type_template_id_4b4e0edc___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"],\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"src/js/components/runner.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);\n\n//# sourceURL=webpack:///./src/js/components/runner.vue?");

/***/ }),

/***/ "./src/js/components/runner.vue?vue&type=script&lang=js&":
/*!***************************************************************!*\
  !*** ./src/js/components/runner.vue?vue&type=script&lang=js& ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_ref_1_node_modules_ify_loader_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_runner_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib??ref--1!../../../node_modules/ify-loader!../../../node_modules/vue-loader/lib??vue-loader-options!./runner.vue?vue&type=script&lang=js& */ \"./node_modules/babel-loader/lib/index.js?!./node_modules/ify-loader/index.js!./node_modules/vue-loader/lib/index.js?!./src/js/components/runner.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_babel_loader_lib_index_js_ref_1_node_modules_ify_loader_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_runner_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); \n\n//# sourceURL=webpack:///./src/js/components/runner.vue?");

/***/ }),

/***/ "./src/js/components/runner.vue?vue&type=template&id=4b4e0edc&":
/*!*********************************************************************!*\
  !*** ./src/js/components/runner.vue?vue&type=template&id=4b4e0edc& ***!
  \*********************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_runner_vue_vue_type_template_id_4b4e0edc___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib??vue-loader-options!./runner.vue?vue&type=template&id=4b4e0edc& */ \"./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/runner.vue?vue&type=template&id=4b4e0edc&\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_runner_vue_vue_type_template_id_4b4e0edc___WEBPACK_IMPORTED_MODULE_0__[\"render\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_runner_vue_vue_type_template_id_4b4e0edc___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"]; });\n\n\n\n//# sourceURL=webpack:///./src/js/components/runner.vue?");

/***/ }),

/***/ "./src/js/components/status.vue":
/*!**************************************!*\
  !*** ./src/js/components/status.vue ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _status_vue_vue_type_template_id_84b662c4___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./status.vue?vue&type=template&id=84b662c4& */ \"./src/js/components/status.vue?vue&type=template&id=84b662c4&\");\n/* harmony import */ var _status_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./status.vue?vue&type=script&lang=js& */ \"./src/js/components/status.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ \"./node_modules/vue-loader/lib/runtime/componentNormalizer.js\");\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  _status_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _status_vue_vue_type_template_id_84b662c4___WEBPACK_IMPORTED_MODULE_0__[\"render\"],\n  _status_vue_vue_type_template_id_84b662c4___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"],\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"src/js/components/status.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);\n\n//# sourceURL=webpack:///./src/js/components/status.vue?");

/***/ }),

/***/ "./src/js/components/status.vue?vue&type=script&lang=js&":
/*!***************************************************************!*\
  !*** ./src/js/components/status.vue?vue&type=script&lang=js& ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_ref_1_node_modules_ify_loader_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_status_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib??ref--1!../../../node_modules/ify-loader!../../../node_modules/vue-loader/lib??vue-loader-options!./status.vue?vue&type=script&lang=js& */ \"./node_modules/babel-loader/lib/index.js?!./node_modules/ify-loader/index.js!./node_modules/vue-loader/lib/index.js?!./src/js/components/status.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_babel_loader_lib_index_js_ref_1_node_modules_ify_loader_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_status_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); \n\n//# sourceURL=webpack:///./src/js/components/status.vue?");

/***/ }),

/***/ "./src/js/components/status.vue?vue&type=template&id=84b662c4&":
/*!*********************************************************************!*\
  !*** ./src/js/components/status.vue?vue&type=template&id=84b662c4& ***!
  \*********************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_status_vue_vue_type_template_id_84b662c4___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib??vue-loader-options!./status.vue?vue&type=template&id=84b662c4& */ \"./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/status.vue?vue&type=template&id=84b662c4&\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_status_vue_vue_type_template_id_84b662c4___WEBPACK_IMPORTED_MODULE_0__[\"render\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_status_vue_vue_type_template_id_84b662c4___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"]; });\n\n\n\n//# sourceURL=webpack:///./src/js/components/status.vue?");

/***/ }),

/***/ "./src/js/index.js":
/*!*************************!*\
  !*** ./src/js/index.js ***!
  \*************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.js\");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_runner_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/runner.vue */ \"./src/js/components/runner.vue\");\n/* harmony import */ var _components_inputs_vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/inputs.vue */ \"./src/js/components/inputs.vue\");\n/* harmony import */ var _components_status_vue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/status.vue */ \"./src/js/components/status.vue\");\n/* harmony import */ var _components_results_vue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/results.vue */ \"./src/js/components/results.vue\");\n__webpack_require__(/*! bootstrap/js/dist/tab */ \"./node_modules/bootstrap/js/dist/tab.js\");\n\n\n\n\n\n\nvar data = {\n  runId: null,\n  inputs: null,\n  finished: false,\n  success: false\n};\nvar app = new vue__WEBPACK_IMPORTED_MODULE_0___default.a({\n  el: '#app',\n  data: data,\n  components: {\n    modelInputs: _components_inputs_vue__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n    runner: _components_runner_vue__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n    status: _components_status_vue__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n    results: _components_results_vue__WEBPACK_IMPORTED_MODULE_4__[\"default\"]\n  },\n  methods: {\n    handleRun: function handleRun(id) {\n      this.runId = id;\n    },\n    handleValidated: function handleValidated(validatedInput) {\n      this.inputs = validatedInput;\n    },\n    handleFinished: function handleFinished(success) {\n      this.finished = true;\n      this.success = success;\n    }\n  }\n});\n\n//# sourceURL=webpack:///./src/js/index.js?");

/***/ }),

/***/ 0:
/*!*******************************!*\
  !*** multi ./src/js/index.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! /home/alex/Documents/dev/modelserver/app/static/src/js/index.js */\"./src/js/index.js\");\n\n\n//# sourceURL=webpack:///multi_./src/js/index.js?");

/***/ })

/******/ });